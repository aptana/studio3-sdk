<?xml version="1.0"?>
<javascript>
  <class type="dijit">
    <methods>
      <method name="unregisterWin" scope="instance">
        <parameters>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
      <method name="unregisterIframe" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required">
            <description>Handle returned by registerIframe()</description>
          </parameter>
        </parameters>
      </method>
      <method name="showTooltip" scope="instance">
        <parameters>
          <parameter name="innerHTML" type="String" usage="required">
            <description>Contents of the tooltip</description>
          </parameter>
          <parameter name="aroundNode" type="dijit.__Rectangle" usage="required">
            <description>Specifies that tooltip should be next to this node / area</description>
          </parameter>
          <parameter name="position" type="Array&lt;String&gt;" usage="optional">
            <description>List of positions to try to position tooltip (ex: [&amp;quot;right&amp;quot;, &amp;quot;above&amp;quot;])</description>
          </parameter>
          <parameter name="rtl" type="Boolean" usage="optional">
            <description>Corresponds to `WidgetBase.dir` attribute, where false means &amp;quot;ltr&amp;quot; and true
	means &amp;quot;rtl&amp;quot;; specifies GUI direction, not text direction.</description>
          </parameter>
          <parameter name="textDir" type="String" usage="optional">
            <description>Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setWaiState" scope="instance">
        <description>Sets an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setWaiRole" scope="instance">
        <description>Replace existing role attribute with new role.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="selectInputText" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="removeWaiState" scope="instance">
        <description>Sets an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeWaiRole" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="registerWin" scope="instance">
        <description>Users should call registerIframe() instead of this method.</description>
        <parameters>
          <parameter name="targetWindow" type="Window" usage="optional">
            <description>If specified this is the window associated with the iframe,
	i.e. iframe.contentWindow.</description>
          </parameter>
          <parameter name="effectiveNode" type="DomNode" usage="optional">
            <description>If specified, report any focus events inside targetWindow as
	an event on effectiveNode, rather than on evt.target.</description>
          </parameter>
        </parameters>
        <return-description>Handle to pass to unregisterWin()</return-description>
      </method>
      <method name="registerIframe" scope="instance">
        <description>Currently only used by editor.</description>
        <parameters>
          <parameter name="iframe" type="DomNode" usage="required"/>
        </parameters>
        <return-description>Handle to pass to unregisterIframe()</return-description>
      </method>
      <method name="placeOnScreenAroundRectangle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="aroundRect" type="Object" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeOnScreenAroundNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="aroundNode" type="Object" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeOnScreenAroundElement" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="aroundElement" type="Object" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Object" usage="required"/>
          <parameter name="aroundNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeOnScreen" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="corners" type="Object" usage="required"/>
          <parameter name="padding" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveToBookmark" scope="instance">
        <parameters>
          <parameter name="bookmark" type="Object" usage="required">
            <description>This should be a returned object from dijit.getBookmark()</description>
          </parameter>
        </parameters>
      </method>
      <method name="isTabNavigable" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isCollapsed" scope="instance"/>
      <method name="hideTooltip" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasWaiState" scope="instance">
        <description>Checks for an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
        <return-description>true if elem has a value for the given state and
	false if it does not.</return-description>
      </method>
      <method name="hasWaiRole" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="optional"/>
        </parameters>
        <return-description>True if elem has the specific role attribute and false if not.
	For backwards compatibility if role parameter not provided,
	returns true if has a role</return-description>
      </method>
      <method name="hasDefaultTabStop" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
      </method>
      <method name="getWaiState" scope="instance">
        <description>Checks for an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
        <return-description>The value of the requested state on elem
	or an empty string if elem has no value for state.</return-description>
      </method>
      <method name="getWaiRole" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
        <return-description>The role of elem or an empty string if elem
	does not have a role.</return-description>
      </method>
      <method name="getViewport" scope="instance"/>
      <method name="getUniqueId" scope="instance">
        <parameters>
          <parameter name="widgetType" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getPopupAroundAlignment" scope="instance">
        <parameters>
          <parameter name="position" type="Array" usage="required">
            <description>String[] This variable controls the position of the drop down.
	It's an array of strings with the following values:
	
	* before: places drop down to the left of the target node/widget, or to the right in
	the case of RTL scripts like Hebrew and Arabic
	* after: places drop down to the right of the target node/widget, or to the left in
	the case of RTL scripts like Hebrew and Arabic
	* above: drop down goes above target node
	* below: drop down goes below target node
	
	The list is positions is tried, in order, until a position is found where the drop down fits
	within the viewport.</description>
          </parameter>
          <parameter name="leftToRight" type="Boolean" usage="required">
            <description>Whether the popup will be displaying in leftToRight mode.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLastInTabbingOrder" scope="instance">
        <parameters>
          <parameter name="root" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="getFocus" scope="instance">
        <parameters>
          <parameter name="menu" type="Widget" usage="optional">
            <description>dijit._Widget or {domNode: DomNode} structure
	The button that was just pressed.  If focus has disappeared or moved
	to this button, returns the previous focus.  In this case the bookmark
	information is already lost, and null is returned.</description>
          </parameter>
          <parameter name="openedForWindow" type="Window" usage="optional">
            <description>iframe in which menu was opened</description>
          </parameter>
        </parameters>
        <return-description>A handle to restore focus/selection, to be passed to `dijit.focus`</return-description>
      </method>
      <method name="getFirstInTabbingOrder" scope="instance">
        <parameters>
          <parameter name="root" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="getEnclosingWidget" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="getDocumentWindow" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getBookmark" scope="instance">
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findWidgets" scope="instance">
        <parameters>
          <parameter name="root" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="byNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="id" type="String|dijit._Widget" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="_underlay" scope="instance">
        <description>A shared instance of a `dijit.DialogUnderlay` created and
	used by `dijit.Dialog`, though never created until some Dialog
	or subclass thereof is shown.</description>
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectionRange" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="_isElementShown" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
      </method>
      <method name="_getTabNavigable" scope="instance">
        <description>Finds the following descendants of the specified root node:
	* the first tab-navigable element in document order
	without a tabIndex or with tabIndex="0"
	* the last tab-navigable element in document order
	without a tabIndex or with tabIndex="0"
	* the first element in document order with the lowest
	positive tabIndex value
	* the last element in document order with the highest
	positive tabIndex value</description>
        <parameters>
          <parameter name="root" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyAll" scope="instance"/>
      <method name="_WidgetsInTemplateMixin" scope="instance"/>
      <method name="_WidgetBase" scope="instance">
        <description>Future base class for all Dijit widgets.
	_Widget extends this class adding support for various features needed by desktop.
	
	Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
	postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
	
	Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
	For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
	
	_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
	
	- DOM node attribute
			_setFocusAttr: {node: "focusNode", type: "attribute"}
			_setFocusAttr: "focusNode"	(shorthand)
			_setFocusAttr: ""		(shorthand, maps to this.domNode)
	Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
	
	- DOM node innerHTML
			_setTitleAttr: { node: "titleNode", type: "innerHTML" }
	Maps this.title to this.titleNode.innerHTML
	
	- DOM node innerText
			_setTitleAttr: { node: "titleNode", type: "innerText" }
	Maps this.title to this.titleNode.innerText
	
	- DOM node CSS class
			_setMyClassAttr: { node: "domNode", type: "class" }
	Maps this.myClass to this.domNode.className
	
	If the value of _setXXXAttr is an array, then each element in the array matches one of the
	formats of the above list.
	
	If the custom setter is null, no action is performed other than saving the new value
	in the widget (in this).
	
	If no custom setter is defined for an attribute, then it will be copied
	to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
	That's only done though for attributes that match DOMNode attributes (title,
	alt, aria-labelledby, etc.)</description>
        <parameters>
          <parameter name="params" type="Object" usage="optional"/>
          <parameter name="srcNodeRef" type="DomNode|String" usage="required"/>
        </parameters>
      </method>
      <method name="_Widget" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_TreeNode" scope="instance"/>
      <method name="_TimePicker" scope="instance"/>
      <method name="_TemplatedMixin" scope="instance"/>
      <method name="_Templated" scope="instance"/>
      <method name="_PaletteMixin" scope="instance">
        <description>A mixin for a grid showing various entities, so the user can pick a certain entity.</description>
      </method>
      <method name="_OnDijitClickMixin" scope="instance"/>
      <method name="_MenuBase" scope="instance"/>
      <method name="_MenuBarItemMixin" scope="instance"/>
      <method name="_MasterTooltip" scope="instance"/>
      <method name="_KeyNavContainer" scope="instance">
        <description>To use this mixin, call connectKeyNavHandlers() in
	postCreate().
	It provides normalized keyboard and focusing code for Container
	widgets.</description>
      </method>
      <method name="_InlineEditor" scope="instance"/>
      <method name="_HasDropDown" scope="instance"/>
      <method name="_FocusMixin" scope="instance"/>
      <method name="_DialogMixin" scope="instance"/>
      <method name="_DialogBase" scope="instance">
        <description>Pops up a modal dialog window, blocking access to the screen
	and also graying out the screen Dialog is extended from
	ContentPane so it supports all the same parameters (href, etc.)</description>
        <examples>
          <example>	&lt;div data-dojo-type="dijit.Dialog" data-dojo-props="href: 'test.html'"&gt;&lt;/div&gt;</example>
          <example>	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		dojo.body().appendChild(foo.domNode);
		foo.startup();</example>
        </examples>
      </method>
      <method name="_CssStateMixin" scope="instance">
        <description>By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
	maintain CSS classes on the widget root node (this.domNode) depending on hover,
	active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
	dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
	
	It also sets CSS like dijitButtonDisabled based on widget semantic state.
	
	By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
	within the widget).</description>
      </method>
      <method name="_Container" scope="instance">
        <description>Use this mixin for widgets that needs to know about and
	keep track of their widget children. Suitable for widgets like BorderContainer
	and TabContainer which contain (only) a set of child widgets.
	
	It's not suitable for widgets like ContentPane
	which contains mixed HTML (plain DOM nodes in addition to widgets),
	and where contained widgets are not necessarily directly below
	this.containerNode.   In that case calls like addChild(node, position)
	wouldn't make sense.</description>
      </method>
      <method name="_Contained" scope="instance">
        <examples>
          <example> 	// make a basic custom widget that knows about it's parents
		declare("my.customClass",[dijit._Widget,dijit._Contained],{});</example>
        </examples>
      </method>
      <method name="_Color" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
          <parameter name="row" type="Number" usage="required"/>
          <parameter name="col" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="WidgetSet" scope="instance">
        <examples>
          <example>Create a small list of widgets:
		var ws = new dijit.WidgetSet();
		ws.add(dijit.byId("one"));
	 	ws.add(dijit.byId("two"));
		// destroy both:
		ws.forEach(function(w){ w.destroy(); });</example>
          <example>Using dijit.registry:
		dijit.registry.forEach(function(w){ /* do something */ });</example>
        </examples>
      </method>
      <method name="Tree" scope="instance"/>
      <method name="TooltipDialog" scope="instance"/>
      <method name="Tooltip" scope="instance"/>
      <method name="ToolbarSeparator" scope="instance"/>
      <method name="Toolbar" scope="instance"/>
      <method name="TitlePane" scope="instance">
        <description>An accessible container with a title Heading, and a content
	section that slides open and closed. TitlePane is an extension to
	`dijit.layout.ContentPane`, providing all the useful content-control aspects from it.</description>
        <examples>
          <example> 	// load a TitlePane from remote file:
		var foo = new dijit.TitlePane({ href: "foobar.html", title:"Title" });
		foo.startup();</example>
          <example>	&lt;!-- markup href example: --&gt;
		&lt;div data-dojo-type="dijit.TitlePane" data-dojo-props="href: 'foobar.html', title: 'Title'"&gt;&lt;/div&gt;</example>
          <example>	&lt;!-- markup with inline data --&gt;
	 	&lt;div data-dojo-type="dijit.TitlePane" title="Title"&gt;
			&lt;p&gt;I am content&lt;/p&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="ProgressBar" scope="instance">
        <examples>
          <example>	&lt;div data-dojo-type="ProgressBar"
			 places="0"
			 value="..." maximum="..."&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="PopupMenuItem" scope="instance"/>
      <method name="PopupMenuBarItem" scope="instance"/>
      <method name="MenuSeparator" scope="instance"/>
      <method name="MenuItem" scope="instance"/>
      <method name="MenuBarItem" scope="instance"/>
      <method name="MenuBar" scope="instance"/>
      <method name="Menu" scope="instance"/>
      <method name="InlineEditBox" scope="instance">
        <description>Behavior for an existing node (`&lt;p&gt;`, `&lt;div&gt;`, `&lt;span&gt;`, etc.) so that
	when you click it, an editor shows up in place of the original
	text.  Optionally, Save and Cancel button are displayed below the edit widget.
	When Save is clicked, the text is pulled from the edit
	widget and redisplayed and the edit widget is again hidden.
	By default a plain Textarea widget is used as the editor (or for
	inline values a TextBox), but you can specify an editor such as
	dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	An edit widget must support the following API to be used:
	- displayedValue or value as initialization parameter,
	and available through set('displayedValue') / set('value')
	- void focus()
	- DOM-node focusNode = node containing editable text</description>
      </method>
      <method name="Editor" scope="instance">
        <description>This widget provides basic WYSIWYG editing features, based on the browser's
	underlying rich text editing capability, accompanied by a toolbar (`dijit.Toolbar`).
	A plugin model is available to extend the editor's capabilities as well as the
	the options available in the toolbar.  Content generation may vary across
	browsers, and clipboard operations may have different results, to name
	a few limitations.  Note: this widget should not be used with the HTML
	&amp;lt;TEXTAREA&amp;gt; tag -- see dijit._editor.RichText for details.</description>
      </method>
      <method name="Dye" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="col" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DropDownMenu" scope="instance"/>
      <method name="DialogUnderlay" scope="instance">
        <description>A component used to block input behind a `dijit.Dialog`. Only a single
	instance of this widget is created by `dijit.Dialog`, and saved as
	a reference to be shared between all Dialogs as `dijit._underlay`
	
	The underlay itself can be styled based on and id:
		#myDialog_underlay { background-color:red; }
	
	In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
	suffixed with _underlay.</description>
      </method>
      <method name="Dialog" scope="instance"/>
      <method name="Declaration" scope="instance"/>
      <method name="ColorPalette" scope="instance">
        <description>Grid showing various colors, so the user can pick a certain color.
	Can be used standalone, or as a popup.</description>
        <examples>
          <example>	&lt;div data-dojo-type="dijit.ColorPalette"&gt;&lt;/div&gt;</example>
          <example>	var picker = new dijit.ColorPalette({ },srcNode);
		picker.startup();</example>
        </examples>
      </method>
      <method name="CheckedMenuItem" scope="instance"/>
      <method name="CalendarLite" scope="instance">
        <description>A simple GUI for choosing a date in the context of a monthly calendar.
	This widget can't be used in a form because it doesn't serialize the date to an
	`&lt;input&gt;` field.  For a form element, use dijit.form.DateTextBox instead.
	
	Note that the parser takes all dates attributes passed in the
	[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
	so that they are serializable and locale-independent.
	
	Also note that this widget isn't keyboard accessible; use dijit.Calendar for that</description>
        <examples>
          <example>	var calendar = new dijit.CalendarLite({}, dojo.byId("calendarNode"));</example>
          <example>	&lt;div data-dojo-type="dijit.CalendarLite"&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Calendar" scope="instance">
        <description>See CalendarLite for general description.   Calendar extends CalendarLite, adding:
	- month drop down list
	- keyboard navigation
	- CSS classes for hover/mousepress on date, month, and year nodes
	- support of deprecated methods (will be removed in 2.0)</description>
      </method>
      <method name="BackgroundIframe" scope="instance">
        <description>new dijit.BackgroundIframe(node)
	Makes a background iframe as a child of node, that fills
	area (and position) of node</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="typematic" scope="instance" type="Object">
        <description>These functions are used to repetitively call a user specified callback
	method when a specific key or mouse click over a specific DOM node is
	held down for a specific amount of time.
	Only 1 such event is allowed to occur on the browser page at 1 time.</description>
      </property>
      <property name="tree" scope="instance" type="Object"/>
      <property name="range" scope="instance" type="Object"/>
      <property name="popup" scope="instance" type="Object">
        <description>Used to show drop downs (ex: the select list of a ComboBox)
	or popups (ex: right-click context menus).
	
	Access via require([&amp;quot;dijit/popup&amp;quot;], function(popup){ ... }).</description>
      </property>
      <property name="place" scope="instance" type="Object">
        <description>Code to place a DOMNode relative to another DOMNode.
	Load using require([&amp;quot;dijit/place&amp;quot;], function(place){ ... }).</description>
      </property>
      <property name="layout" scope="instance" type="Object">
        <description>Layout related widgets</description>
      </property>
      <property name="form" scope="instance" type="Object">
        <description>Form and input related widgets</description>
      </property>
      <property name="_tree" scope="instance" type="Object"/>
      <property name="_editor" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.BackgroundIframe">
    <description>new dijit.BackgroundIframe(node)
	Makes a background iframe as a child of node, that fills
	area (and position) of node</description>
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.BackgroundIframe.destroy">
    <methods/>
  </class>
  <class type="dijit.Calendar" superclass="dijit.CalendarLite">
    <description>See CalendarLite for general description.   Calendar extends CalendarLite, adding:
	- month drop down list
	- keyboard navigation
	- CSS classes for hover/mousepress on date, month, and year nodes
	- support of deprecated methods (will be removed in 2.0)</description>
    <methods>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="instance">
        <description>Formerly used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.DateTextBox`)
	to get notification when the user has clicked a date.  Now onExecute() (above) is used.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleKey" scope="instance">
        <description>Called from _onKeyPress() to handle keypress on a stand alone Calendar,
	and also from `dijit.form._DateTimeTextBox` to pass a keypress event
	from the `dijit.form.DateTextBox` to be handled in this widget</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-description>False if the key was recognized as a navigation key,
	to indicate that the event was handled by Calendar and shouldn't be propogated</return-description>
      </method>
      <method name="getClassForDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_onMonthSelect" scope="instance">
        <parameters>
          <parameter name="newMonth" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOver" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOut" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_createMonthWidget" scope="instance"/>
      <method name="_MonthDropDownButton" scope="instance"/>
      <method name="_MonthDropDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.CalendarLite" scope="instance"/>
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="cssStateNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Calendar.cssStateNodes"/>
  <class type="dijit.Calendar._MonthDropDownButton" superclass="dijit.form.DropDownButton">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onMonthSelect" scope="instance"/>
      <method name="_setMonthAttr" scope="instance">
        <parameters>
          <parameter name="month" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.DropDownButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Calendar._MonthDropDownButton.containerNode"/>
  <class type="dijit.Calendar._MonthDropDown" superclass="dijit._Widget">
    <methods>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setMonthsAttr" scope="instance">
        <parameters>
          <parameter name="months" type="Array&lt;String&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="_onMenuHover" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Calendar._MonthDropDown.domNode"/>
  <class type="dijit.CalendarLite" superclass="dijit._WidgetBase">
    <description>A simple GUI for choosing a date in the context of a monthly calendar.
	This widget can't be used in a form because it doesn't serialize the date to an
	`&lt;input&gt;` field.  For a form element, use dijit.form.DateTextBox instead.
	
	Note that the parser takes all dates attributes passed in the
	[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
	so that they are serializable and locale-independent.
	
	Also note that this widget isn't keyboard accessible; use dijit.Calendar for that</description>
    <methods>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="goToToday" scope="instance"/>
      <method name="getClassForDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="focus" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Set the current date and update the UI.  If the date is disabled, the value will
	not change, but the display will change to the corresponding month.</description>
        <parameters>
          <parameter name="value" type="Date|Number" usage="required">
            <description>Either a Date or the number of seconds since 1970.</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setCurrentFocusAttr" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="forceFocus" type="Boolean" usage="required">
            <description>If true, will focus() the cell even if calendar itself doesn't have focus</description>
          </parameter>
        </parameters>
      </method>
      <method name="_populateGrid" scope="instance"/>
      <method name="_onDayClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_isValidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_isSelectedDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_createMonthWidget" scope="instance"/>
      <method name="_MonthWidget" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._CssStateMixin">
    <description>By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
	maintain CSS classes on the widget root node (this.domNode) depending on hover,
	active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
	dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
	
	It also sets CSS like dijitButtonDisabled based on widget semantic state.
	
	By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
	within the widget).</description>
    <methods>
      <method name="_trackMouseState" scope="instance">
        <description>Given class=foo, will set the following CSS class on the node
	- fooActive: if the user is currently pressing down the mouse button while over the node
	- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
	- fooFocus: if the node is focused
	
	Note that it won't set any classes if the widget is disabled.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>Should be a sub-node of the widget, not the top node (this.domNode), since the top node
	is handled specially and automatically just by mixing in this class.</description>
          </parameter>
          <parameter name="clazz" type="String" usage="required">
            <description>CSS class name (ex: dijitSliderUpArrow).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setStateClass" scope="instance">
        <description>In the case where a widget has multiple
	states, it sets the class based on all possible
	combinations.  For example, an invalid form widget that is being hovered
	will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
	
	The widget may have one or more of the following states, determined
	by this.state, this.checked, this.valid, and this.selected:
	- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
	- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
	- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
	- Selected - ex: currently selected tab will have this.selected==true
	
	In addition, it may have one or more of the following states,
	based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
	- Disabled	- if the widget is disabled
	- Active		- if the mouse (or space/enter key?) is being pressed down
	- Focused		- if the widget has focus
	- Hover		- if the mouse is over the widget</description>
      </method>
      <method name="_cssMouseEvent" scope="instance">
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_applyAttributes" scope="instance"/>
    </methods>
    <properties>
      <property name="stateNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Widget" superclass="dijit._WidgetBase">
    <methods>
      <method name="setAttribute" scope="instance">
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onShow" scope="instance"/>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseLeave" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseEnter" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="event" type="key" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="event" type="key" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="key" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHide" scope="instance"/>
      <method name="onDblClick" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onClose" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="on" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="func" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="getDescendants" scope="instance">
        <return-types>
          <return-type type="Array&lt;dijit._Widget&gt;"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="instance">
        <description>This method is deprecated, use get() or set() directly.</description>
        <parameters>
          <parameter name="name" type="String|Object" usage="required">
            <description>The property to get or set. If an object is passed here and not
	a string, its keys are used as names of attributes to be set
	and the value of the object as values to set in the widget.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. If provided, attr() operates as a setter. If omitted,
	the current value of the named property is returned.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setFocusedAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._OnDijitClickMixin.prototype" scope="instance"/>
      <mixin type="dijit._FocusMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._OnDijitClickMixin" scope="instance"/>
      <mixin type="dijit._FocusMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._TemplatedMixin">
    <methods>
      <method name="destroyRendering" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_stringRepl" scope="instance">
        <parameters>
          <parameter name="tmpl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_beforeFillContent" scope="instance"/>
      <method name="_attachTemplateNodes" scope="instance">
        <description>Map widget properties and functions to the handlers specified in
	the dom node and it's descendants. This function iterates over all
	nodes and looks for these properties:
	* dojoAttachPoint/data-dojo-attach-point
	* dojoAttachEvent/data-dojo-attach-event</description>
        <parameters>
          <parameter name="rootNode" type="DomNode|Array&lt;Widget&gt;" usage="required">
            <description>the node to search for properties. All children will be searched.</description>
          </parameter>
          <parameter name="getAttrFunc" type="Function" usage="required">
            <description>a function which will be used to obtain property for a given
	DomNode/Widget</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.form">
    <methods>
      <method name="__SelectOption" scope="instance"/>
      <method name="_ToggleButtonMixin" scope="instance"/>
      <method name="_TextBoxMixin" scope="instance"/>
      <method name="_Spinner" scope="instance">
        <description>This class basically (conceptually) extends `dijit.form.ValidationTextBox`.
	It modifies the template to have up/down arrows, and provides related handling code.</description>
      </method>
      <method name="_SliderMoverMax" scope="instance"/>
      <method name="_SliderMover" scope="instance"/>
      <method name="_SliderBarMover" scope="instance"/>
      <method name="_SelectMenu" scope="instance"/>
      <method name="_RadioButtonMixin" scope="instance"/>
      <method name="_ListMouseMixin" scope="instance"/>
      <method name="_ListBase" scope="instance"/>
      <method name="_FormWidgetMixin" scope="instance">
        <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	
	They also share some common methods.</description>
      </method>
      <method name="_FormWidget" scope="instance">
        <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	
	They also share some common methods.</description>
      </method>
      <method name="_FormValueWidget" scope="instance">
        <description>Each _FormValueWidget represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
      </method>
      <method name="_FormValueMixin" scope="instance">
        <description>Each _FormValueMixin represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
      </method>
      <method name="_FormSelectWidget" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_FormMixin" scope="instance">
        <description>Can extract all the form widgets
	values and combine them into a single javascript object, or alternately
	take such an object and set the values for all the contained
	form widgets</description>
      </method>
      <method name="_ExpandingTextAreaMixin" scope="instance"/>
      <method name="_DateTimeTextBox" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ComboBoxMenuMixin" scope="instance"/>
      <method name="_ComboBoxMenu" scope="instance"/>
      <method name="_CheckBoxMixin" scope="instance">
        <description>User interacts with real html inputs.
	On onclick (which occurs by mouse click, space-bar, or
	using the arrow keys to switch the selected radio button),
	we update the state of the checkbox/radio.</description>
      </method>
      <method name="_ButtonMixin" scope="instance">
        <description>A label should always be specified (through innerHTML) or the label attribute.
	Attach points:
	focusNode (required): this node receives focus
	valueNode (optional): this node's value gets submitted with FORM elements
	containerNode (optional): this node gets the innerHTML assignment for label</description>
        <examples>
          <example>	&lt;button data-dojo-type="dijit.form.Button" onClick="..."&gt;Hello world&lt;/button&gt;</example>
          <example>	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
		dojo.body().appendChild(button1.domNode);</example>
        </examples>
      </method>
      <method name="_AutoCompleterMixin" scope="instance">
        <description>All widgets that mix in dijit.form._AutoCompleterMixin must extend `dijit.form._FormValueWidget`.</description>
      </method>
      <method name="VerticalSlider" scope="instance"/>
      <method name="VerticalRuleLabels" scope="instance"/>
      <method name="VerticalRule" scope="instance"/>
      <method name="ValidationTextBox" scope="instance"/>
      <method name="ToggleButton" scope="instance"/>
      <method name="TimeTextBox" scope="instance"/>
      <method name="Textarea" scope="instance">
        <description>A textarea that dynamically expands/contracts (changing it's height) as
	the user types, to display all the text without requiring a scroll bar.
	
	Takes nearly all the parameters (name, value, etc.) that a vanilla textarea takes.
	Rows is not supported since this widget adjusts the height.</description>
        <examples>
          <example>	&lt;textarea data-dojo-type="dijit.form.TextArea"&gt;...&lt;/textarea&gt;</example>
        </examples>
      </method>
      <method name="TextBox" scope="instance"/>
      <method name="SimpleTextarea" scope="instance">
        <examples>
          <example>	&lt;textarea data-dojo-type="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40&gt;&lt;/textarea&gt;</example>
          <example>	new dijit.form.SimpleTextarea({ rows:20, cols:30 }, "foo");</example>
        </examples>
      </method>
      <method name="Select" scope="instance"/>
      <method name="RangeBoundTextBox" scope="instance"/>
      <method name="RadioButton" scope="instance"/>
      <method name="NumberTextBoxMixin" scope="instance"/>
      <method name="NumberTextBox" scope="instance">
        <description>NumberTextBox is a textbox for entering and displaying numbers, supporting
	the following main features:
	
	1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
	a number rather than a random string)
	2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
	depending on locale).
	3. Separate modes for editing the value and displaying it, specifically that
	the thousands separator character (typically comma) disappears when editing
	but reappears after the field is blurred.
	4. Formatting and constraints regarding the number of places (digits after the decimal point)
	allowed on input, and number of places displayed when blurred (see `constraints` parameter).</description>
      </method>
      <method name="NumberSpinner" scope="instance">
        <description>A `dijit.form.NumberTextBox` extension to provide keyboard accessible value selection
	as well as icons for spinning direction. When using the keyboard, the typematic rules
	apply, meaning holding the key will gradually increase or decrease the value and
	accelerate.</description>
        <examples>
          <example> new dijit.form.NumberSpinner({ constraints:{ max:300, min:100 }}, "someInput");</example>
        </examples>
      </method>
      <method name="MultiSelect" scope="instance"/>
      <method name="MappedTextBox" scope="instance">
        <description>The visible display may
	be locale-dependent and interactive.  The value sent to the server is stored in a hidden
	input field which uses the `name` attribute declared by the original widget.  That value sent
	to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
	locale-neutral.</description>
      </method>
      <method name="HorizontalSlider" scope="instance"/>
      <method name="HorizontalRuleLabels" scope="instance"/>
      <method name="HorizontalRule" scope="instance"/>
      <method name="Form" scope="instance">
        <examples>
          <example>	&lt;form data-dojo-type="dijit.form.Form" id="myForm"&gt;
			Name: &lt;input type="text" name="name" /&gt;
		&lt;/form&gt;
		myObj = {name: "John Doe"};
		dijit.byId('myForm').set('value', myObj);
	
		myObj=dijit.byId('myForm').get('value');</example>
        </examples>
      </method>
      <method name="FilteringSelect" scope="instance">
        <description>An enhanced version of the HTML SELECT tag, populated dynamically. It works
	very nicely with very large data sets because it can load and page data as needed.
	It also resembles ComboBox, but does not allow values outside of the provided ones.
	If OPTION tags are used as the data provider via markup, then the
	OPTION tag's child text node is used as the displayed value when selected
	while the OPTION tag's value attribute is used as the widget value on form submit.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	
	Similar features:
	- There is a drop down list of possible values.
	- You can only enter a value from the drop down list.  (You can't
	enter an arbitrary value.)
	- The value submitted with the form is the hidden value (ex: CA),
	not the displayed value a.k.a. label (ex: California)
	
	Enhancements over plain HTML version:
	- If you type in some text then it will filter down the list of
	possible values in the drop down list.
	- List can be specified either as a static list or via a javascript
	function (that can get the list from a server)</description>
      </method>
      <method name="DropDownButton" scope="instance">
        <examples>
          <example>	&lt;button data-dojo-type="dijit.form.DropDownButton"&gt;
			Hello world
			&lt;div data-dojo-type="dijit.Menu"&gt;...&lt;/div&gt;
		&lt;/button&gt;</example>
          <example>	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
		win.body().appendChild(button1);</example>
        </examples>
      </method>
      <method name="DateTextBox" scope="instance"/>
      <method name="DataList" scope="instance">
        <description>Provides a store for inlined data like:
	
		&lt;datalist&gt;
			&lt;option value="AL"&gt;Alabama&lt;/option&gt;
			...</description>
        <parameters>
          <parameter name="params" type="Object" usage="optional"/>
          <parameter name="srcNodeRef" type="DomNode|String" usage="required"/>
        </parameters>
      </method>
      <method name="CurrencyTextBox" scope="instance">
        <description>CurrencyTextBox is similar to `dijit.form.NumberTextBox` but has a few
	extra features related to currency:
	
	1. After specifying the currency type (american dollars, euros, etc.) it automatically
	sets parse/format options such as how many decimal places to show.
	2. The currency mark (dollar sign, euro mark, etc.) is displayed when the field is blurred
	but erased during editing, so that the user can just enter a plain number.</description>
      </method>
      <method name="ComboButton" scope="instance">
        <examples>
          <example>	&lt;button data-dojo-type="dijit.form.ComboButton" onClick="..."&gt;
			&lt;span&gt;Hello world&lt;/span&gt;
			&lt;div data-dojo-type="dijit.Menu"&gt;...&lt;/div&gt;
		&lt;/button&gt;</example>
          <example>	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
		dojo.body().appendChild(button1.domNode);</example>
        </examples>
      </method>
      <method name="ComboBoxMixin" scope="instance"/>
      <method name="ComboBox" scope="instance">
        <description>The drop down box's values are populated from an class called
	a data provider, which returns a list of values based on the characters
	that the user has typed into the input box.
	If OPTION tags are used as the data provider via markup,
	then the OPTION tag's child text node is used as the widget value
	when selected.  The OPTION tag's value attribute is ignored.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	
	Some of the options to the ComboBox are actually arguments to the data
	provider.</description>
      </method>
      <method name="CheckBox" scope="instance">
        <description>User interacts with real html inputs.
	On onclick (which occurs by mouse click, space-bar, or
	using the arrow keys to switch the selected radio button),
	we update the state of the checkbox/radio.
	
	There are two modes:
	1. High contrast mode
	2. Normal mode
	
	In case 1, the regular html inputs are shown and used by the user.
	In case 2, the regular html inputs are invisible but still used by
	the user. They are turned quasi-invisible and overlay the background-image.</description>
      </method>
      <method name="Button" scope="instance">
        <description>Buttons can display a label, an icon, or both.
	A label should always be specified (through innerHTML) or the label
	attribute.  It can be hidden via showLabel=false.</description>
        <examples>
          <example>	&lt;button data-dojo-type="dijit.form.Button" onClick="..."&gt;Hello world&lt;/button&gt;</example>
          <example>	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
		dojo.body().appendChild(button1.domNode);</example>
        </examples>
      </method>
    </methods>
  </class>
  <class type="dijit.form.DropDownButton" superclass="dijit.form.Button">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="isLoaded" scope="instance"/>
      <method name="isFocusable" scope="instance"/>
      <method name="_fillContent" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.CalendarLite._MonthWidget" superclass="dijit._WidgetBase">
    <methods>
      <method name="_setMonthAttr" scope="instance">
        <parameters>
          <parameter name="month" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.CalendarLite._MonthWidget.domNode"/>
  <class type="dijit._WidgetBase" superclass="dojo.Stateful">
    <description>Future base class for all Dijit widgets.
	_Widget extends this class adding support for various features needed by desktop.
	
	Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
	postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
	
	Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
	For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
	
	_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
	
	- DOM node attribute
			_setFocusAttr: {node: "focusNode", type: "attribute"}
			_setFocusAttr: "focusNode"	(shorthand)
			_setFocusAttr: ""		(shorthand, maps to this.domNode)
	Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
	
	- DOM node innerHTML
			_setTitleAttr: { node: "titleNode", type: "innerHTML" }
	Maps this.title to this.titleNode.innerHTML
	
	- DOM node innerText
			_setTitleAttr: { node: "titleNode", type: "innerText" }
	Maps this.title to this.titleNode.innerText
	
	- DOM node CSS class
			_setMyClassAttr: { node: "domNode", type: "class" }
	Maps this.myClass to this.domNode.className
	
	If the value of _setXXXAttr is an array, then each element in the array matches one of the
	formats of the above list.
	
	If the custom setter is null, no action is performed other than saving the new value
	in the widget (in this).
	
	If no custom setter is defined for an attribute, then it will be copied
	to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
	That's only done though for attributes that match DOMNode attributes (title,
	alt, aria-labelledby, etc.)</description>
    <methods>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance"/>
      <method name="toString" scope="instance">
        <description>When a widget is cast to a string, this method will be used to generate the
	output. Currently, it does not implement any sort of reversible
	serialization.</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="subscribe" scope="instance">
        <description>Provide widget-specific analog to dojo.subscribe, except with the
	implicit use of this widget as the target object.</description>
        <examples>
          <example>	var btn = new dijit.form.Button();
		// when /my/topic is published, this button changes its label to
		 // be the parameter of the topic.
		btn.subscribe("/my/topic", function(v){
			this.set("label", v);
		});</example>
        </examples>
        <parameters>
          <parameter name="t" type="String" usage="required">
            <description>The topic</description>
          </parameter>
          <parameter name="method" type="Function" usage="required">
            <description>The callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="_Widget.Handle"/>
        </return-types>
      </method>
      <method name="startup" scope="instance">
        <description>Called after a widget and its children have been created and added to the page,
	and all related widgets have finished their create() cycle, up through postCreate().
	This is useful for composite widgets that need to control or layout sub-widgets.
	Many layout widgets can use this as a wiring phase.</description>
      </method>
      <method name="set" scope="instance">
        <description>Sets named properties on a widget which may potentially be handled by a
	setter in the widget.
	
	For example, if the widget has properties `foo` and `bar`
	and a method named `_setFooAttr()`, calling
	`myWidget.set("foo", "Howdy!")` would be equivalent to calling
	`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
	would be equivalent to the statement `widget.bar = 3;`
	
	set() may also be called with a hash of name/value pairs, ex:
	
		myWidget.set({
			foo: "Howdy",
			bar: 3
		});
	
	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`</description>
        <parameters>
          <parameter name="name" type="The" usage="required">
            <description>property to set.</description>
          </parameter>
          <parameter name="value" type="The" usage="required">
            <description>value to set in the property.</description>
          </parameter>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance">
        <description>Called after the DOM fragment has been created, but not necessarily
	added to the document.  Do not include any operations which rely on
	node dimensions or placement.</description>
      </method>
      <method name="placeAt" scope="instance">
        <description>A convenience function provided in all _Widgets, providing a simple
	shorthand mechanism to put an existing (or newly created) Widget
	somewhere in the dom, and allow chaining.</description>
        <examples>
          <example> 	// create a Button with no srcNodeRef, and place it in the body:
	 	var button = new dijit.form.Button({ label:"click" }).placeAt(win.body());
	 	// now, 'button' is still the widget reference to the newly created button
	 	button.on("click", function(e){ console.log('click'); }));</example>
          <example>	// create a button out of a node with id="src" and append it to id="wrapper":
	 	var button = new dijit.form.Button({},"src").placeAt("wrapper");</example>
          <example>	// place a new button as the first element of some div
		var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");</example>
          <example>	// create a contentpane and add it to a TabContainer
		var tc = dijit.byId("myTabs");
		new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)</example>
        </examples>
        <parameters>
          <parameter name="reference" type="String|DomNode|_Widget" usage="required">
            <description>The String id of a domNode, a domNode reference, or a reference to a Widget possessing
	an addChild method.</description>
          </parameter>
          <parameter name="position" type="String|Int" usage="optional">
            <description>If passed a string or domNode reference, the position argument
	accepts a string just as domConstruct.place does, one of: &amp;quot;first&amp;quot;, &amp;quot;last&amp;quot;,
	&amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;.
	
	If passed a _Widget reference, and that widget reference has an &amp;quot;.addChild&amp;quot; method,
	it will be called passing this widget instance into that method, supplying the optional
	position index passed.</description>
          </parameter>
        </parameters>
        <return-description>dijit._Widget
	Provides a useful return of the newly created dijit._Widget instance so you
	can "chain" this function by instantiating, placing, then saving the return value
	to a variable.</return-description>
      </method>
      <method name="onFocus" scope="instance"/>
      <method name="onBlur" scope="instance"/>
      <method name="on" scope="instance">
        <description>Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
	Note that the function is not run in any particular scope, so if (for example) you want it to run in the
	widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.</description>
        <parameters>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="func" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="isLeftToRight" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isFocusable" scope="instance"/>
      <method name="getTextDir" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="originalDir" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getParent" scope="instance"/>
      <method name="getChildren" scope="instance">
        <return-types>
          <return-type type="Array&lt;dijit._Widget&gt;"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <description>Get a named property from a widget. The property may
	potentially be retrieved via a getter method. If no getter is defined, this
	just retrieves the object's property.
	
	For example, if the widget has properties `foo` and `bar`
	and a method named `_getFooAttr()`, calling:
	`myWidget.get("foo")` would be equivalent to calling
	`widget._getFooAttr()` and `myWidget.get("bar")`
	would be equivalent to the expression
	`widget.bar2`</description>
        <parameters>
          <parameter name="name" type="The" usage="required">
            <description>property to get.</description>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyRendering" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <description>If true, this method will leave the original DOM structure alone
	during tear-down. Note: this will not work with _Templated
	widgets yet.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroyRecursive" scope="instance">
        <description>This is the generic "destructor" function that all widget users
	should call to cleanly discard with a widget. Once a widget is
	destroyed, it is removed from the manager object.</description>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <description>If true, this method will leave the original DOM structure
	alone of descendant Widgets. Note: This will NOT work with
	dijit._Templated widgets.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <description>If true, the preserveDom attribute is passed to all descendant
	widget's .destroy() method. Not for use with _Templated
	widgets.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required">
            <description>If true, this method will leave the original DOM structure alone.
	Note: This will not yet work with _Templated widgets</description>
          </parameter>
        </parameters>
      </method>
      <method name="create" scope="instance">
        <description>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
	etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
	for a discussion of the widget creation lifecycle.
	
	Of course, adventurous developers could override create entirely, but this should
	only be done as a last resort.</description>
        <parameters>
          <parameter name="params" type="Object" usage="optional">
            <description>Hash of initialization parameters for widget, including
	scalar values (like title, duration etc.) and functions,
	typically callbacks like onClick.</description>
          </parameter>
          <parameter name="srcNodeRef" type="DomNode|String" usage="optional">
            <description>If a srcNodeRef (DOM node) is specified:
	- use srcNodeRef.innerHTML as my contents
	- if this is a behavioral widget then apply behavior
	to that srcNodeRef
	- otherwise, replace srcNodeRef with my generated DOM
	tree</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <description>Provide widget-specific analog to dojo.connect, except with the
	implicit use of this widget as the target object.
	Events connected with `this.connect` are disconnected upon
	destruction.</description>
        <examples>
          <example>	var btn = new dijit.form.Button();
		// when foo.bar() is called, call the listener we're going to
		// provide in the scope of btn
		btn.connect(foo, "bar", function(){
			console.debug(this.toString());
		});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String|Function" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
        <return-description>A handle that can be passed to `disconnect` in order to disconnect before
	the widget is destroyed.</return-description>
        <return-types>
          <return-type type="_Widget.Handle"/>
        </return-types>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="applyTextDir" scope="instance">
        <parameters>
          <parameter name="element" type="DOMNode" usage="required"/>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setStyleAttr" scope="instance">
        <description>Determines which node to set the style on based on style setting
	in attributeMap.</description>
        <parameters>
          <parameter name="value" type="String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_onMap" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_onFocus" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="_getAttrNames" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cv" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_attrToDom" scope="instance">
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="commands" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_applyAttributes" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.Stateful" scope="instance"/>
    </mixins>
    <properties>
      <property name="prototype" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
      <property name="_setClassAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.CheckedMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.MenuItem" superclass="dijit._Widget">
    <methods>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setSelected" scope="instance">
        <parameters>
          <parameter name="selected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setAccelKeyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnhover" scope="instance"/>
      <method name="_onHover" scope="instance"/>
      <method name="_onFocus" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="accelKeyNode" scope="instance" type="Object"/>
      <property name="_setLabelAttr" scope="instance" type="Object"/>
      <property name="_setIconClassAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette" superclass="dijit._Widget">
    <description>Grid showing various colors, so the user can pick a certain color.
	Can be used standalone, or as a popup.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_dyeFactory" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="col" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_palettes" scope="instance" type="Map">
        <description>This represents the value of the colors.
	The first level is a hashmap of the different palettes available.
	The next two dimensions represent the columns and rows of colors.</description>
      </property>
    </properties>
  </class>
  <class type="dijit.ColorPalette._palettes"/>
  <class type="dijit._Color" superclass="Color">
    <methods>
      <method name="getValue" scope="instance"/>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
          <parameter name="blankGif" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
          <parameter name="row" type="Number" usage="required"/>
          <parameter name="col" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Color" scope="instance"/>
    </mixins>
    <properties>
      <property name="_imagePaths" scope="instance" type="Map">
        <description>This is stores the path to the palette images used for high-contrast mode display</description>
      </property>
    </properties>
  </class>
  <class type="dijit._Color._imagePaths"/>
  <class type="dijit._PaletteMixin" superclass="dijit._CssStateMixin">
    <description>A mixin for a grid showing various entities, so the user can pick a certain entity.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>Value corresponding to cell.</description>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>value of the cell to select</description>
          </parameter>
          <parameter name="priorityChange" type="Optional" usage="required">
            <description>parameter used to tell the select whether or not to fire
	onChange event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setCurrent" scope="instance">
        <description>At any point in time there's exactly one
	cell with tabIndex != -1.   If focus is inside the palette then
	focus is on that cell.
	
	After calling this method, arrow key handlers and mouse click handlers
	should focus the cell in a setTimeout().</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_preparePalette" scope="instance">
        <parameters>
          <parameter name="choices" type="Array&lt;Array&lt;String&gt;&gt;" usage="required">
            <description>id's for each cell of the palette, used to create Dye JS object for each cell</description>
          </parameter>
          <parameter name="titles" type="Array&lt;String&gt;" usage="required">
            <description>Localized tooltip for each cell</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_navigateByKey" scope="instance">
        <parameters>
          <parameter name="increment" type="How" usage="required">
            <description>much the key is navigated.</description>
          </parameter>
          <parameter name="typeCount" type="How" usage="required">
            <description>many times typematic has fired.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getDye" scope="instance">
        <parameters>
          <parameter name="cell" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_dyeFactory" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="col" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.Declaration" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaults" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Declaration.defaults"/>
  <class type="dijit._WidgetsInTemplateMixin">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_beforeFillContent" scope="instance"/>
    </methods>
  </class>
  <class type="dijit._DialogBase" superclass="dijit._TemplatedMixin">
    <description>Pops up a modal dialog window, blocking access to the screen
	and also graying out the screen Dialog is extended from
	ContentPane so it supports all the same parameters (href, etc.)</description>
    <methods>
      <method name="show" scope="instance">
        <return-description>dojo.Deferred
	Deferred object that resolves when the display animation is complete</return-description>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onLoad" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="hide" scope="instance">
        <return-description>dojo.Deferred
	Deferred object that resolves when the hide animation is complete</return-description>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_size" scope="instance"/>
      <method name="_setup" scope="instance"/>
      <method name="_position" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="just let it go"/>
        </return-types>
      </method>
      <method name="_endDrag" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormMixin.prototype" scope="instance"/>
      <mixin type="dijit._DialogMixin.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit._DialogMixin" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="cssStateNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._DialogBase.cssStateNodes"/>
  <class type="dijit._DialogBase._singleChild.domNode.style"/>
  <class type="dijit.Dialog" superclass="ContentPane">
    <methods/>
    <mixins scope="instance">
      <mixin type="_DialogBase.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="ContentPane" scope="instance"/>
      <mixin type="_DialogBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._FormMixin">
    <description>Can extract all the form widgets
	values and combine them into a single javascript object, or alternately
	take such an object and set the values for all the contained
	form widgets</description>
    <methods>
      <method name="validate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="onValidStateChange" scope="instance">
        <parameters>
          <parameter name="isValid" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance"/>
      <method name="getValues" scope="instance"/>
      <method name="disconnectChildren" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="connectChildren" scope="instance">
        <parameters>
          <parameter name="inStartup" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_getState" scope="instance"/>
      <method name="_getDescendantFormWidgets" scope="instance">
        <parameters>
          <parameter name="children" type="Array&lt;dijit._WidgetBase&gt;" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._DialogMixin">
    <methods>
      <method name="onExecute" scope="instance">
        <description>Developer shouldn't override or connect to this method;
	it's a private communication device between the TooltipDialog
	and the thing that opened it (ex: `dijit.form.DropDownButton`)
	type:
	protected</description>
      </method>
      <method name="onCancel" scope="instance">
        <description>Developer shouldn't override or connect to this method;
	it's a private communication device between the TooltipDialog
	and the thing that opened it (ex: `dijit.form.DropDownButton`)
	type:
	protected</description>
      </method>
      <method name="execute" scope="instance">
        <description>After the user has pressed the submit button, the Dialog
	first calls onExecute() to notify the container to hide the
	dialog and restore focus to wherever it used to be.
	
	*Then* this method is called.
	type:
	callback</description>
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSubmit" scope="instance"/>
      <method name="_getFocusItems" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.DialogUnderlay" superclass="dijit._Widget">
    <description>A component used to block input behind a `dijit.Dialog`. Only a single
	instance of this widget is created by `dijit.Dialog`, and saved as
	a reference to be shared between all Dialogs as `dijit._underlay`
	
	The underlay itself can be styled based on and id:
		#myDialog_underlay { background-color:red; }
	
	In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
	suffixed with _underlay.</description>
    <methods>
      <method name="show" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="layout" scope="instance">
        <description>Sets the background to the size of the viewport (rather than the size
	of the document) since we need to cover the whole browser window, even
	if the document is only a few lines long.</description>
      </method>
      <method name="hide" scope="instance"/>
      <method name="_setDialogIdAttr" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setClassAttr" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.node">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.domNode.style"/>
  <class type="dijit.DialogUnderlay.node.style"/>
  <class type="dijit.DropDownMenu" superclass="dijit._MenuBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._OnDijitClickMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._MenuBase" scope="instance"/>
      <mixin type="dijit._OnDijitClickMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._MenuBase" superclass="dijit._Widget">
    <methods>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onItemUnhover" scope="instance">
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="onItemHover" scope="instance">
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onExecute" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="closeAll" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_stopPopupTimer" scope="instance"/>
      <method name="_stopPendingCloseTimer" scope="instance">
        <parameters>
          <parameter name="popup" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_stopFocusTimer" scope="instance"/>
      <method name="_openPopup" scope="instance">
        <return-types>
          <return-type type="the focused child lost focus since the timer was started"/>
        </return-types>
      </method>
      <method name="_onPopupHover" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemFocus" scope="instance">
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_moveToPopup" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_markInactive" scope="instance"/>
      <method name="_markActive" scope="instance"/>
      <method name="_getTopMenu" scope="instance"/>
      <method name="_closeChild" scope="instance"/>
      <method name="_cleanUp" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._KeyNavContainer.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._KeyNavContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="focusedChild" scope="instance" type="Object"/>
      <property name="currentPopup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._OnDijitClickMixin">
    <methods>
      <method name="connect" scope="instance">
        <description>Provide widget-specific analog to connect.connect, except with the
	implicit use of this widget as the target object.
	This version of connect also provides a special "ondijitclick"
	event which triggers on a click or space or enter keyup.
	Events connected with `this.connect` are disconnected upon
	destruction.</description>
        <examples>
          <example>	var btn = new dijit.form.Button();
		// when foo.bar() is called, call the listener we're going to
		// provide in the scope of btn
		btn.connect(foo, "bar", function(){
			console.debug(this.toString());
		});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String|Function" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
        <return-description>A handle that can be passed to `disconnect` in order to disconnect before
	the widget is destroyed.</return-description>
      </method>
    </methods>
  </class>
  <class type="_Plugin.registry">
    <methods>
      <method name="|" scope="instance"/>
      <method name="LocalImage" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.Editor" superclass="RichText">
    <description>This widget provides basic WYSIWYG editing features, based on the browser's
	underlying rich text editing capability, accompanied by a toolbar (`dijit.Toolbar`).
	A plugin model is available to extend the editor's capabilities as well as the
	the options available in the toolbar.  Content generation may vary across
	browsers, and clipboard operations may have different results, to name
	a few limitations.  Note: this widget should not be used with the HTML
	&amp;lt;TEXTAREA&amp;gt; tag -- see dijit._editor.RichText for details.</description>
    <methods>
      <method name="undo" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="replaceValue" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="redo" scope="instance"/>
      <method name="queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance"/>
      <method name="onBeforeDeactivate" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeActivate" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="execCommand" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endEditing" scope="instance">
        <parameters>
          <parameter name="ignore_caret" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="beginEditing" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addPlugin" scope="instance">
        <parameters>
          <parameter name="plugin" type="String|Object|Function" usage="required">
            <description>String, args object, plugin instance, or plugin constructor
	
	args:
	This object will be passed to the plugin constructor</description>
          </parameter>
          <parameter name="index" type="Integer" usage="optional">
            <description>Used when creating an instance from
	something already in this.plugins. Ensures that the new
	instance is assigned to this.plugins at that index.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setStateClass" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_saveSelection" scope="instance"/>
      <method name="_restoreSelection" scope="instance"/>
      <method name="_pasteImpl" scope="instance"/>
      <method name="_onIEMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_moveToBookmark" scope="instance">
        <parameters>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBookmark" scope="instance"/>
      <method name="_endEditing" scope="instance"/>
      <method name="_cutImpl" scope="instance"/>
      <method name="_copyImpl" scope="instance"/>
      <method name="_clipboardCommand" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_changeToStep" scope="instance">
        <parameters>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_beginEditing" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="RichText" scope="instance"/>
    </mixins>
    <properties>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Editor.editingArea.style"/>
  <class type="dijit.Editor.iframe.style"/>
  <class type="dijit.Editor.document">
    <properties>
      <property name="body" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Editor.document.body"/>
  <class type="dijit._InlineEditor" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="getValue" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="enableSave" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <description>For autoSave widgets, if Esc/Enter, call cancel/save.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onIntermediateChange" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChange" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="inlineEditBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor.inlineEditBox"/>
  <class type="dijit._InlineEditor.domNode.style"/>
  <class type="dijit.InlineEditBox" superclass="dijit._Widget">
    <description>Behavior for an existing node (`&lt;p&gt;`, `&lt;div&gt;`, `&lt;span&gt;`, etc.) so that
	when you click it, an editor shows up in place of the original
	text.  Optionally, Save and Cancel button are displayed below the edit widget.
	When Save is clicked, the text is pulled from the edit
	widget and redisplayed and the edit widget is again hidden.
	By default a plain Textarea widget is used as the editor (or for
	inline values a TextBox), but you can specify an editor such as
	dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	An edit widget must support the following API to be used:
	- displayedValue or value as initialization parameter,
	and available through set('displayedValue') / set('value')
	- void focus()
	- DOM-node focusNode = node containing editable text</description>
    <methods>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required">
            <description>Focus on the display mode text</description>
          </parameter>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="getValue" scope="instance"/>
      <method name="edit" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_showText" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setTextDirAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('textDir', value)</description>
        <parameters>
          <parameter name="textDir" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="instance"/>
      <method name="_onMouseOut" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="wrapperWidget" scope="instance" type="Object"/>
      <property name="displayNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox.displayNode"/>
  <class type="dijit.InlineEditBox.wrapperWidget"/>
  <class type="dijit._Container">
    <description>Use this mixin for widgets that needs to know about and
	keep track of their widget children. Suitable for widgets like BorderContainer
	and TabContainer which contain (only) a set of child widgets.
	
	It's not suitable for widgets like ContentPane
	which contains mixed HTML (plain DOM nodes in addition to widgets),
	and where contained widgets are not necessarily directly below
	this.containerNode.   In that case calls like addChild(node, position)
	wouldn't make sense.</description>
    <methods>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget|int" usage="required"/>
        </parameters>
      </method>
      <method name="hasChildren" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getIndexOfChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <description>Inserts specified child widget's dom node as a child of this widget's
	container node, and possibly does other processing (such as layout).</description>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_getSiblingOfChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="dir" type="int" usage="required">
            <description>if 1, get the next sibling
	if -1, get the previous sibling</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dijit.form.Button" superclass="dijit.form._FormWidget">
    <description>Buttons can display a label, an icon, or both.
	A label should always be specified (through innerHTML) or the label
	attribute.  It can be hidden via showLabel=false.</description>
    <methods>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setShowLabelAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <description>Set the label (text) of the button; takes an HTML string.
	If the label is hidden (showLabel=false) then and no title has
	been specified, then label is also set as title attribute of icon.</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._ButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
      <mixin type="dijit.form._ButtonMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="titleNode" scope="instance" type="Object"/>
      <property name="_setIconClassAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="setDisplayedValue" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="getDisplayedValue" scope="instance"/>
      <method name="_updatePlaceHolder" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_setPlaceHolderAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="by" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="MozMixin" scope="instance"/>
      <method name="IEMixin" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._TextBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
      <mixin type="dijit.form._TextBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_phspan" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Menu" superclass="dijit.DropDownMenu">
    <methods>
      <method name="uninitialize" scope="instance"/>
      <method name="unBindDomNode" scope="instance">
        <parameters>
          <parameter name="nodeName" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="getPlaceholders" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="optional">
            <description>Label to search for - if not specified, then all placeholders
	are returned</description>
          </parameter>
        </parameters>
        <return-description>An array of placeholders that match the given label</return-description>
        <return-types>
          <return-type type="Array&lt;dojox.widget.PlaceholderMenuItem&gt;"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="bindDomNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_scheduleOpen" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="optional"/>
          <parameter name="iframe" type="DomNode" usage="optional"/>
          <parameter name="coords" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_openMyself" scope="instance">
        <parameters>
          <parameter name="args" type="This" usage="required">
            <description>is an Object containing:
	* target:
	The node that is being clicked
	* iframe:
	If an &amp;lt;iframe&amp;gt; is being clicked, iframe points to that iframe
	* coords:
	Put menu at specified x/y position in viewport, or if iframe is
	specified, then relative to iframe.
	
	_openMyself() formerly took the event object, and since various code references
	evt.target (after connecting to _openMyself()), using an Object for parameters
	(so that old code still works).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_iframeContentWindow" scope="instance">
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeContentDocument" scope="instance">
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="W3"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.DropDownMenu" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.MenuBar" superclass="dijit._MenuBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focusChild" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._MenuBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._MenuBarItemMixin">
    <methods/>
  </class>
  <class type="dijit.MenuBarItem" superclass="dijit.MenuItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="_MenuBarItemMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
      <mixin type="_MenuBarItemMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.MenuItem._setLabelAttr"/>
  <class type="dijit.MenuItem._setIconClassAttr"/>
  <class type="dijit.MenuItem.accelKeyNode.style"/>
  <class type="dijit.MenuItem.accelKeyNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Contained">
    <methods>
      <method name="getPreviousSibling" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getNextSibling" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getIndexInParent" scope="instance">
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="_getSibling" scope="instance">
        <parameters>
          <parameter name="which" type="String" usage="required">
            <description>Either &amp;quot;next&amp;quot; or &amp;quot;previous&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dijit.MenuSeparator" superclass="dijit._WidgetBase">
    <methods>
      <method name="isFocusable" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.PopupMenuBarItem" superclass="dijit.PopupMenuItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._MenuBarItemMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.PopupMenuItem" scope="instance"/>
      <mixin type="dijit._MenuBarItemMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.PopupMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_fillContent" scope="instance">
        <description>srcNodeRefinnerHTML contains both the menu item text and a popup widget
	The first part holds the menu item text and the second part is the popup</description>
        <examples>
          <example>	&lt;div data-dojo-type="dijit.PopupMenuItem"&gt;
			&lt;span&gt;pick me&lt;/span&gt;
			&lt;popup&gt; ... &lt;/popup&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.PopupMenuItem.popup.domNode.style"/>
  <class type="dijit.ProgressBar" superclass="dijit._Widget">
    <methods>
      <method name="update" scope="instance">
        <examples>
          <example>	myProgressBar.update({'indeterminate': true});
		myProgressBar.update({'progress': 80});
		myProgressBar.update({'indeterminate': true, label:"Loading ..." })</example>
        </examples>
        <parameters>
          <parameter name="attributes" type="Object" usage="optional">
            <description>May provide progress and/or maximum properties on this parameter;
	see attribute specs for details.</description>
          </parameter>
        </parameters>
      </method>
      <method name="report" scope="instance">
        <parameters>
          <parameter name="percent" type="float" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onChange" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setIndeterminateAttr" scope="instance">
        <parameters>
          <parameter name="indeterminate" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="labelNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ProgressBar.labelNode"/>
  <class type="dijit.ProgressBar.internalProgress.style"/>
  <class type="dijit.TitlePane" superclass="dijit.layout.ContentPane">
    <description>An accessible container with a title Heading, and a content
	section that slides open and closed. TitlePane is an extension to
	`dijit.layout.ContentPane`, providing all the useful content-control aspects from it.</description>
    <methods>
      <method name="toggle" scope="instance"/>
      <method name="setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setToggleableAttr" scope="instance">
        <parameters>
          <parameter name="canToggle" type="Boolean" usage="required">
            <description>True to allow user to open/close pane by clicking title bar.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setOpenAttr" scope="instance">
        <parameters>
          <parameter name="open" type="Boolean" usage="required">
            <description>True if you want to open the pane, false if you want to close it.</description>
          </parameter>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setCss" scope="instance"/>
      <method name="_setContentAttr" scope="instance">
        <parameters>
          <parameter name="content" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="_onTitleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTitleClick" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="arrowNodeInner" scope="instance" type="Object"/>
      <property name="_setTooltipAttr" scope="instance" type="Object"/>
      <property name="_setTitleAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TitlePane._setTitleAttr"/>
  <class type="dijit.TitlePane._setTooltipAttr"/>
  <class type="dijit.TitlePane.hideNode.style"/>
  <class type="dijit.TitlePane.wipeNode.style"/>
  <class type="dijit.TitlePane.arrowNodeInner"/>
  <class type="dijit.layout">
    <methods>
      <method name="marginBox2contentBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="mb" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layoutChildren" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required">
            <description>parent node</description>
          </parameter>
          <parameter name="dim" type="Object" usage="required">
            <description>{l, t, w, h} object specifying dimensions of container into which to place children</description>
          </parameter>
          <parameter name="children" type="Array&lt;Widget&gt;" usage="required">
            <description>an array of Widgets or at least objects containing:
	* domNode: pointer to DOM node to position
	* region or layoutAlign: position to place DOM node
	* resize(): (optional) method to set size of node
	* id: (optional) Id of widgets, referenced from resize object, below.</description>
          </parameter>
          <parameter name="changedRegionId" type="String" usage="optional">
            <description>If specified, the slider for the region with the specified id has been dragged, and thus
	the region's height or width should be adjusted according to changedRegionSize</description>
          </parameter>
          <parameter name="changedRegionSize" type="Number" usage="optional">
            <description>See changedRegionId.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_TabContainerBase" scope="instance">
        <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
      </method>
      <method name="_TabButton" scope="instance">
        <description>Contains the title of the pane, and optionally a close-button to destroy the pane.
	This is an internal widget and should not be instantiated directly.</description>
      </method>
      <method name="_StackButton" scope="instance">
        <description>The button-like or tab-like object you click to select or delete a page</description>
      </method>
      <method name="_Splitter" scope="instance">
        <description>This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	create it directly.</description>
      </method>
      <method name="_ScrollingTabControllerMenuButton" scope="instance"/>
      <method name="_ScrollingTabControllerButtonMixin" scope="instance"/>
      <method name="_ScrollingTabControllerButton" scope="instance"/>
      <method name="_LayoutWidget" scope="instance"/>
      <method name="_Gutter" scope="instance">
        <description>Instantiated by `dijit.layout.BorderContainer`.  Users should not
	create directly.</description>
      </method>
      <method name="_ContentPaneResizeMixin" scope="instance"/>
      <method name="_AccordionInnerContainer" scope="instance"/>
      <method name="_AccordionButton" scope="instance"/>
      <method name="TabController" scope="instance">
        <description>Lets the user select the currently shown pane in a TabContainer or StackContainer.
	TabController also monitors the TabContainer, and whenever a pane is
	added or deleted updates itself accordingly.</description>
      </method>
      <method name="TabContainer" scope="instance">
        <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
      </method>
      <method name="StackController" scope="instance">
        <description>Monitors the specified StackContainer, and whenever a page is
	added, deleted, or selected, updates itself accordingly.</description>
      </method>
      <method name="StackContainer" scope="instance">
        <description>A container for widgets (ContentPanes, for example) That displays
	only one Widget at a time.
	
	Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	
	Can be base class for container, Wizard, Show, etc.</description>
      </method>
      <method name="SplitContainer" scope="instance">
        <description>A Container widget with sizing handles in-between each child.
	Contains multiple children widgets, all of which are displayed side by side
	(either horizontally or vertically); there's a bar between each of the children,
	and you can adjust the relative size of each child by dragging the bars.
	
	You must specify a size (width and height) for the SplitContainer.</description>
      </method>
      <method name="ScrollingTabController" scope="instance"/>
      <method name="LinkPane" scope="instance">
        <description>LinkPane is just a ContentPane that is declared in markup similarly
	to an anchor.  The anchor's body (the words between `&lt;a&gt;` and `&lt;/a&gt;`)
	become the title of the widget (used for TabContainer, AccordionContainer, etc.)</description>
        <examples>
          <example> &lt;a href="foo.html"&gt;my title&lt;/a&gt;</example>
        </examples>
      </method>
      <method name="LayoutContainer" scope="instance">
        <description>Provides Delphi-style panel layout semantics.
	
	A LayoutContainer is a box with a specified size (like style="width: 500px; height: 500px;"),
	that contains children widgets marked with "layoutAlign" of "left", "right", "bottom", "top", and "client".
	It takes it's children marked as left/top/bottom/right, and lays them out along the edges of the box,
	and then it takes the child marked "client" and puts it into the remaining space in the middle.
	
	Left/right positioning is similar to CSS's "float: left" and "float: right",
	and top/bottom positioning would be similar to "float: top" and "float: bottom", if there were such
	CSS.
	
	Note that there can only be one client element, but there can be multiple left, right, top,
	or bottom elements.</description>
        <examples>
          <example>	&lt;style&gt;
			html, body{ height: 100%; width: 100%; }
		&lt;/style&gt;
		&lt;div data-dojo-type="dijit.layout.LayoutContainer" style="width: 100%; height: 100%"&gt;
			&lt;div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="layoutAlign: 'top'"&gt;header text&lt;/div&gt;
			&lt;div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="layoutAlign: 'left'" style="width: 200px;"&gt;table of contents&lt;/div&gt;
			&lt;div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="layoutAlign: 'client'"&gt;client area&lt;/div&gt;
		&lt;/div&gt;
	
	Lays out each child in the natural order the children occur in.
	Basically each child is laid out into the "remaining space", where "remaining space" is initially
	the content area of this widget, but is reduced to a smaller rectangle each time a child is added.</example>
        </examples>
      </method>
      <method name="ContentPane" scope="instance">
        <description>This widget embeds a document fragment in the page, specified
	either by uri, javascript generated markup or DOM reference.
	Any widgets within this content are instantiated and managed,
	but laid out according to the HTML structure.  Unlike IFRAME,
	ContentPane embeds a document fragment as would be found
	inside the BODY tag of a full HTML document.  It should not
	contain the HTML, HEAD, or BODY tags.
	For more advanced functionality with scripts and
	stylesheets, see dojox.layout.ContentPane.  This widget may be
	used stand alone or as a base class for other widgets.
	ContentPane is useful as a child of other layout containers
	such as BorderContainer or TabContainer, but note that those
	widgets can contain any widget as a child.</description>
        <examples>
          <example>Some quick samples:
	To change the innerHTML: cp.set('content', '&lt;b&gt;new content&lt;/b&gt;')
	
	Or you can send it a NodeList: cp.set('content', dojo.query('div [class=selected]', userSelection))
	
	To do an ajax update: cp.set('href', url)</example>
        </examples>
      </method>
      <method name="BorderContainer" scope="instance">
        <description>A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	that contains a child widget marked region="center" and optionally children widgets marked
	region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	Children along the edges will be laid out according to width or height dimensions and may
	include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	space is designated for the center region.
	
	The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	"left" and "right" except that they will be reversed in right-to-left environments.
	
	For complex layouts, multiple children can be specified for a single region.   In this case, the
	layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
	and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
	instead of the design attribute to control layout precedence of horizontal vs. vertical panes.</description>
        <examples>
          <example>	&lt;div data-dojo-type="dijit.layout.BorderContainer" data-dojo-props="design: 'sidebar', gutters: false"
							style="width: 400px; height: 300px;"&gt;
			&lt;div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="region: 'top'"&gt;header text&lt;/div&gt;
			&lt;div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="region: 'right', splitter: true" style="width: 200px;"&gt;table of contents&lt;/div&gt;
			&lt;div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="region: 'center'"&gt;client area&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="AccordionPane" scope="instance"/>
      <method name="AccordionContainer" scope="instance">
        <examples>
          <example> 	&lt;div data-dojo-type="dijit.layout.AccordionContainer"&gt;
			&lt;div data-dojo-type="dijit.layout.ContentPane" title="pane 1"&gt;
			&lt;/div&gt;
			&lt;div data-dojo-type="dijit.layout.ContentPane" title="pane 2"&gt;
				&lt;p&gt;This is some text&lt;/p&gt;
			&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
    </methods>
  </class>
  <class type="dijit.layout.ContentPane" superclass="dijit._Widget">
    <description>This widget embeds a document fragment in the page, specified
	either by uri, javascript generated markup or DOM reference.
	Any widgets within this content are instantiated and managed,
	but laid out according to the HTML structure.  Unlike IFRAME,
	ContentPane embeds a document fragment as would be found
	inside the BODY tag of a full HTML document.  It should not
	contain the HTML, HEAD, or BODY tags.
	For more advanced functionality with scripts and
	stylesheets, see dojox.layout.ContentPane.  This widget may be
	used stand alone or as a base class for other widgets.
	ContentPane is useful as a child of other layout containers
	such as BorderContainer or TabContainer, but note that those
	widgets can contain any widget as a child.</description>
    <methods>
      <method name="uninitialize" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="setHref" scope="instance">
        <parameters>
          <parameter name="href" type="String|Uri" usage="required"/>
        </parameters>
      </method>
      <method name="setContent" scope="instance">
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance">
        <description>1. cancels any currently in-flight requests
	2. posts "loading..." message
	3. sends XHR to download new data</description>
        <return-types>
          <return-type type="If child has an href, promise that fires when refresh is complete"/>
        </return-types>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onUnload" scope="instance"/>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadStart" scope="instance">
        <description>The string returned by this function will be the html
	that tells the user we are loading something.
	Override with your own function if you want to change text.</description>
      </method>
      <method name="onDownloadError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadEnd" scope="instance"/>
      <method name="onContentError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="destroyRecursive" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="srcNodeRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancel" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setHrefAttr" scope="instance">
        <description>Reset the (external defined) content of this pane and replace with new url
	Note: It delays the download until widget is shown if preload is false.</description>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required">
            <description>url to the page you want to get, must be within the same domain as your mainpage</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Deferred"/>
        </return-types>
      </method>
      <method name="_setContentAttr" scope="instance">
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required">
            <description>the new Content may be String, DomNode or NodeList
	
	if data is a NodeList (or an array of nodes) nodes are copied
	so you can import nodes from another document implicitly</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Deferred"/>
        </return-types>
      </method>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DocumentFragment" usage="required"/>
          <parameter name="isFakeContent" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnloadHandler" scope="instance"/>
      <method name="_onShow" scope="instance">
        <description>For a plain ContentPane, this is called on initialization, from startup().
	If the ContentPane is a hidden pane of a TabContainer etc., then it's
	called whenever the pane is made visible.
	
	Does necessary processing, including href download and layout/resize of
	child widget(s)</description>
        <return-types>
          <return-type type="If child has an href, promise that fires when the load is complete"/>
        </return-types>
      </method>
      <method name="_onLoadHandler" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onError" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="consoleText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_load" scope="instance"/>
      <method name="_getContentAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._ContentPaneResizeMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit.layout._ContentPaneResizeMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Toolbar" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._KeyNavContainer.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._KeyNavContainer" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._KeyNavContainer" superclass="dijit._FocusMixin">
    <description>To use this mixin, call connectKeyNavHandlers() in
	postCreate().
	It provides normalized keyboard and focusing code for Container
	widgets.</description>
    <methods>
      <method name="startupKeyNavChildren" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="focusPrev" scope="instance"/>
      <method name="focusNext" scope="instance"/>
      <method name="focusLastChild" scope="instance"/>
      <method name="focusFirstChild" scope="instance"/>
      <method name="focusChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required">
            <description>Reference to container's child widget</description>
          </parameter>
          <parameter name="last" type="Boolean" usage="required">
            <description>If true and if widget has multiple focusable nodes, focus the
	last one instead of the first one</description>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="connectKeyNavHandlers" scope="instance">
        <parameters>
          <parameter name="prevKeyCodes" type="Array&lt;keys&gt;" usage="required"/>
          <parameter name="nextKeyCodes" type="Array&lt;keys&gt;" usage="required">
            <description>Key codes for navigating to the next child.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_startupChild" scope="instance">
        <description>Sets tabIndex=-1 on each child, so that the tab key will
	leave the container rather than visiting each child.</description>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerKeypress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerFocus" scope="instance">
        <description>Initially the container itself has a tabIndex, but when it gets
	focus, switch focus to first child...</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextFocusableChild" scope="instance">
        <parameters>
          <parameter name="child" type="Widget" usage="required">
            <description>The current widget</description>
          </parameter>
          <parameter name="dir" type="Integer" usage="required">
            <description>* 1 = after
	* -1 = before</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="_getLastFocusableChild" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="_getFirstFocusableChild" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._FocusMixin" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.ToolbarSeparator" superclass="dijit._Widget">
    <methods>
      <method name="isFocusable" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._MasterTooltip" superclass="dijit._Widget">
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="innerHTML" type="String" usage="required">
            <description>Contents of the tooltip</description>
          </parameter>
          <parameter name="aroundNode" type="DomNode" usage="required">
            <description>|| dijit.__Rectangle
	Specifies that tooltip should be next to this node / area</description>
          </parameter>
          <parameter name="position" type="Array&lt;String&gt;" usage="optional">
            <description>List of positions to try to position tooltip (ex: [&amp;quot;right&amp;quot;, &amp;quot;above&amp;quot;])</description>
          </parameter>
          <parameter name="rtl" type="Boolean" usage="optional">
            <description>Corresponds to `WidgetBase.dir` attribute, where false means &amp;quot;ltr&amp;quot; and true
	means &amp;quot;rtl&amp;quot;; specifies GUI direction, not text direction.</description>
          </parameter>
          <parameter name="textDir" type="String" usage="optional">
            <description>Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.</description>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="orient" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="tooltipCorner" type="String" usage="required"/>
          <parameter name="spaceAvailable" type="Object" usage="required"/>
          <parameter name="aroundNodeCoords" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setTextDirAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('textDir', value)</description>
        <parameters>
          <parameter name="textDir" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setAutoTextDir" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="instance"/>
      <method name="_onHide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="connectorNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.containerNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.connectorNode.style"/>
  <class type="dijit._MasterTooltip.domNode.style"/>
  <class type="dijit._MasterTooltip.containerNode.style"/>
  <class type="dijit._MasterTooltip.connectorNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Tooltip" superclass="dijit._Widget">
    <methods>
      <method name="uninitialize" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="removeTarget" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
      </method>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onShow" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="position" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHide" scope="instance"/>
      <method name="close" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="addTarget" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNODE" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setConnectIdAttr" scope="instance">
        <parameters>
          <parameter name="newId" type="String|Array&lt;String&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnHover" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHover" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.TooltipDialog" superclass="dijit.layout.ContentPane">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="orient" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="corner" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_setTitleAttr" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <description>Keep keyboard focus in dialog; close dialog on escape key</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit.form._FormMixin.prototype" scope="instance"/>
      <mixin type="dijit._DialogMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit._DialogMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TooltipDialog.containerNode"/>
  <class type="dijit._TreeNode" superclass="dijit._Widget">
    <methods>
      <method name="unmarkProcessing" scope="instance"/>
      <method name="setSelected" scope="instance">
        <description>In particular, setting a node as selected involves setting tabIndex
	so that when user tabs to the tree, focus will go to that node (only).</description>
        <parameters>
          <parameter name="selected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusable" scope="instance">
        <description>In particular, setting a node as selected involves setting tabIndex
	so that when user tabs to the tree, focus will go to that node (only).</description>
        <parameters>
          <parameter name="selected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setChildItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array&lt;Object&gt;" usage="required"/>
        </parameters>
        <return-description>Deferred object that fires after all previously opened children
	have been expanded again (or fires instantly if there are no such children).</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="node" type="treeNode" usage="required"/>
        </parameters>
      </method>
      <method name="markProcessing" scope="instance"/>
      <method name="makeExpandable" scope="instance"/>
      <method name="getTreePath" scope="instance"/>
      <method name="getIdentity" scope="instance"/>
      <method name="expand" scope="instance">
        <return-description>Deferred that fires when expansion is complete</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="collapse" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_updateLayout" scope="instance"/>
      <method name="_updateItemClasses" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setTextDirAttr" scope="instance">
        <parameters>
          <parameter name="textDir" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setIndentAttr" scope="instance">
        <description>0 for top level nodes, 1 for their children, 2 for their
	grandchildren, etc.</description>
        <parameters>
          <parameter name="indent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setExpando" scope="instance">
        <parameters>
          <parameter name="processing" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseLeave" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEnter" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLabelFocus" scope="instance"/>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyClassAndStyle" scope="instance">
        <parameters>
          <parameter name="item" type="The" usage="required">
            <description>data item.</description>
          </parameter>
          <parameter name="lower" type="The" usage="required">
            <description>lower case attribute to use, e.g. 'icon', 'label' or 'row'.</description>
          </parameter>
          <parameter name="upper" type="The" usage="required">
            <description>upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="tree" scope="instance" type="Object"/>
      <property name="expandoNodeText" scope="instance" type="Object"/>
      <property name="cssStateNodes" scope="instance" type="Object"/>
      <property name="_setTooltipAttr" scope="instance" type="Object"/>
      <property name="_setLabelAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode._setLabelAttr"/>
  <class type="dijit._TreeNode.cssStateNodes"/>
  <class type="dijit._TreeNode._setTooltipAttr"/>
  <class type="dijit._TreeNode.tree"/>
  <class type="dijit._TreeNode.expandoNodeText"/>
  <class type="dijit.Tree" superclass="dijit._Widget">
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <description>If persist == true the loading may encompass many levels of fetches
	from the data store, each asynchronous.   Waits for all to finish.</description>
      </method>
      <method name="onDndDrop" scope="instance"/>
      <method name="onDndCancel" scope="instance"/>
      <method name="onDblClick" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="itemCreator" scope="instance">
        <description>For each node in nodes[], which came from source, create a hash of name/value
	pairs to be passed to Tree.model.newItem().  Returns array of those hashes.</description>
        <parameters>
          <parameter name="nodes" type="Array&lt;DomNode&gt;" usage="required">
            <description>The DOMNodes dragged from the source container</description>
          </parameter>
          <parameter name="target" type="DomNode" usage="required">
            <description>The target TreeNode.rowNode</description>
          </parameter>
          <parameter name="source" type="dojo.dnd.Source" usage="required">
            <description>The source container the nodes were dragged from, perhaps another Tree or a plain dojo.dnd.Source</description>
          </parameter>
        </parameters>
        <return-description>Object[]
	Array of name/value hashes for each new item to be added to the Tree, like:
		[
			{ id: 123, label: "apple", foo: "bar" },
			{ id: 456, label: "pear", zaz: "bam" }
		]</return-description>
      </method>
      <method name="isExpandoNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTooltip" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getRowStyle" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Object suitable for input to dojo.style() like {background-color: "#bbb"}</return-description>
      </method>
      <method name="getRowClass" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>String
	CSS class name</return-description>
      </method>
      <method name="getNodesByItem" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required">
            <description>or id</description>
          </parameter>
        </parameters>
        <return-description>Array of tree nodes that refer to passed item</return-description>
      </method>
      <method name="getLabelStyle" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Object suitable for input to dojo.style() like {color: "red", background: "green"}</return-description>
      </method>
      <method name="getLabelClass" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>String
	CSS class name</return-description>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getItemChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="Object" usage="required"/>
          <parameter name="onComplete" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIconStyle" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Object
	Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}</return-description>
      </method>
      <method name="getIconClass" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="focusNode" scope="instance">
        <parameters>
          <parameter name="node" type="_tree.Node" usage="required"/>
        </parameters>
      </method>
      <method name="destroyRecursive" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="checkItemAcceptance" scope="instance">
        <description>In the base case, this is called to check if target can become a child of source.
	When betweenThreshold is set, position="before" or "after" means that we
	are asking if the source node can be dropped before/after the target node.</description>
        <parameters>
          <parameter name="target" type="DOMNode" usage="required">
            <description>The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
	Use dijit.getEnclosingWidget(target) to get the TreeNode.</description>
          </parameter>
          <parameter name="source" type="dijit.tree.dndSource" usage="required">
            <description>The (set of) nodes we are dropping</description>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <description>&amp;quot;over&amp;quot;, &amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="dijit.tree._dndSource" usage="required">
            <description>The source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array&lt;DOMNode&gt;" usage="required">
            <description>Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
	source is a dijit.Tree.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_store2model" scope="instance"/>
      <method name="_state" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="expanded" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setTextDirAttr" scope="instance">
        <parameters>
          <parameter name="textDir" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedNodesAttr" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedNodeAttr" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedItemsAttr" scope="instance">
        <parameters>
          <parameter name="items" type="Items" usage="required">
            <description>or ids</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setSelectedItemAttr" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required">
            <description>or id</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setPathsAttr" scope="instance">
        <parameters>
          <parameter name="paths" type="Array&lt;Array&lt;Item&gt;&gt;" usage="required">
            <description>Array of arrays of items or item id's</description>
          </parameter>
        </parameters>
        <return-description>Deferred to indicate when the set is complete</return-description>
      </method>
      <method name="_setPathAttr" scope="instance">
        <parameters>
          <parameter name="path" type="Array&lt;Item&gt;" usage="required">
            <description>|| String[]</description>
          </parameter>
        </parameters>
      </method>
      <method name="_publish" scope="instance">
        <parameters>
          <parameter name="topicName" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRightArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeMouseLeave" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeMouseEnter" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeFocus" scope="instance">
        <description>It marks that the current node is the selected one, and the previously
	selected node no longer is.</description>
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onLetterKeyNav" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required">
            <description>Like { node: TreeNode, key: 'a' } where key is the key the user pressed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onLeftArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChildrenChange" scope="instance">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="Array&lt;dojo.data.Item&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChange" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_onHomeKey" scope="instance"/>
      <method name="_onExpandoClick" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEnterKey" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEndKey" scope="instance"/>
      <method name="_onDownArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="nodeWidget" type="TreeNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="nodeWidget" type="TreeNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_load" scope="instance"/>
      <method name="_initState" scope="instance"/>
      <method name="_getRootOrFirstNode" scope="instance"/>
      <method name="_getNextNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_TreeNode"/>
        </return-types>
      </method>
      <method name="_expandNode" scope="instance">
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
          <parameter name="recursive" type="Boolean" usage="optional">
            <description>Internal flag used when _expandNode() calls itself, don't set.</description>
          </parameter>
        </parameters>
        <return-description>Deferred that fires when the node is loaded and opened and (if persist=true) all it's descendants
	that were previously opened too</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_createTreeNode" scope="instance">
        <description>Developers can override this method to define their own TreeNode class;
	However it will probably be removed in a future release in favor of a way
	of just specifying a widget for the label, rather than one that contains
	the children too.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_collapseNode" scope="instance">
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.WidgetSet">
    <methods>
      <method name="toArray" scope="instance">
        <examples>
          <example>Work with the widget .domNodes in a real Array
		array.map(dijit.registry.toArray(), function(w){ return w.domNode; });</example>
        </examples>
        <return-types>
          <return-type type="Array&lt;dijit._Widget&gt;"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <description>A callback function run for every widget in this list. Exits loop
	when the first true return is encountered.</description>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <description>Optional scope parameter to use for the callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="map" scope="instance">
        <examples>
          <example>	var nodes = dijit.registry.map(function(w){ return w.domNode; });</example>
        </examples>
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="thisObj" type="Object" usage="optional"/>
        </parameters>
        <return-description>A new array of the returned values.</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <examples>
          <example>Using the default `dijit.registry` instance:
		dijit.registry.forEach(function(widget){
			console.log(widget.declaredClass);
		});</example>
        </examples>
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <description>A callback function to run for each item. Is passed the widget, the index
	in the iteration, and the full hash, similar to `array.forEach`.</description>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <description>An optional scope parameter</description>
          </parameter>
        </parameters>
        <return-description>Returns self, in order to allow for further chaining.</return-description>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <examples>
          <example>Arbitrary: select the odd widgets in this list
		dijit.registry.filter(function(w, i){
			return i % 2 == 0;
		}).forEach(function(w){ /* odd ones */ });</example>
        </examples>
        <parameters>
          <parameter name="filter" type="Function" usage="required">
            <description>Callback function to test truthiness. Is passed the widget
	reference and the pseudo-index in the object.</description>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <description>Option scope to use for the filter function.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <description>A callback function run for every widget in this list. Exits loop
	when the first false return is encountered.</description>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <description>Optional scope parameter to use for the callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="byId" scope="instance">
        <examples>
          <example>Test if an id is in a particular WidgetSet
	 var ws = new dijit.WidgetSet();
	 ws.add(dijit.byId("bar"));
	 var t = ws.byId("bar") // returns a widget
	 var x = ws.byId("foo"); // returns undefined</example>
        </examples>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="byClass" scope="instance">
        <examples>
          <example>Find all `dijit.TitlePane`s in a page:
		dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });</example>
        </examples>
        <parameters>
          <parameter name="cls" type="String" usage="required">
            <description>The Class to scan for. Full dot-notated string.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required">
            <description>Any dijit._Widget subclass.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._CssStateMixin.stateNode"/>
  <class type="dijit._FocusMixin">
    <methods/>
  </class>
  <class type="dijit._HasDropDown" superclass="dijit._FocusMixin">
    <methods>
      <method name="toggleDropDown" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="openDropDown" scope="instance">
        <return-description>return value of dijit.popup.open()</return-description>
      </method>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="loadAndOpenDropDown" scope="instance">
        <return-description>Deferred
	Deferred for the drop down widget that
	fires when drop down is created and loaded</return-description>
      </method>
      <method name="isLoaded" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="closeDropDown" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required">
            <description>If true, refocuses the button widget</description>
          </parameter>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_onKeyUp" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDropDownMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._FocusMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="dropDownPosition" scope="instance" type="Array&lt;String&gt;">
        <description>This variable controls the position of the drop down.
	It's an array of strings with the following values:
	
	* before: places drop down to the left of the target node/widget, or to the right in
	the case of RTL scripts like Hebrew and Arabic
	* after: places drop down to the right of the target node/widget, or to the left in
	the case of RTL scripts like Hebrew and Arabic
	* above: drop down goes above target node
	* below: drop down goes below target node
	
	The list is positions is tried, in order, until a position is found where the drop down fits
	within the viewport.</description>
      </property>
      <property name="dropDown" scope="instance" type="Widget">
        <description>The widget to display as a popup.  This widget *must* be
	defined before the startup function is called.</description>
      </property>
    </properties>
  </class>
  <class type="dijit._HasDropDown.dropDownPosition"/>
  <class type="dijit._HasDropDown.dropDown"/>
  <class type="dijit._MenuBase.currentPopup">
    <properties>
      <property name="parentMenu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MenuBase.currentPopup.parentMenu"/>
  <class type="dijit._MenuBase.focusedChild">
    <properties>
      <property name="popup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MenuBase.focusedChild.popup"/>
  <class type="dijit.Dye">
    <methods>
      <method name="getValue" scope="instance">
        <description>For example color hex value, emoticon ascii value etc, entity hex value.</description>
      </method>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DomNode" usage="required">
            <description>The surrounding cell</description>
          </parameter>
          <parameter name="blankGif" type="String" usage="required">
            <description>URL for blank cell image</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="col" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._Templated" superclass="dijit._TemplatedMixin">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_attachTemplateNodes" scope="instance">
        <parameters>
          <parameter name="rootNode" type="Object" usage="required"/>
          <parameter name="getAttrFunc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._TimePicker" superclass="dijit._Widget">
    <methods>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="val" type="Date" usage="required">
            <description>The current value</description>
          </parameter>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onmouseover" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onmouseout" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="time" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional">
            <description>type:
	extension</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="true means don't call stopEvent()"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_showText" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Set the value of the TimePicker.
	Redraws the TimePicker around the new date.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setFilterStringAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onOptionSelected" scope="instance">
        <parameters>
          <parameter name="tgt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onArrowUp" scope="instance">
        <description>Removes the bottom time and add one to the top</description>
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="typematic end"/>
        </return-types>
      </method>
      <method name="_onArrowDown" scope="instance">
        <description>Remove the top time and add one to the bottom</description>
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="typematic end"/>
        </return-types>
      </method>
      <method name="_mouseWheeled" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightOption" scope="instance">
        <parameters>
          <parameter name="node" type="node" usage="required"/>
          <parameter name="highlight" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getFilteredNodes" scope="instance">
        <parameters>
          <parameter name="start" type="number" usage="required"/>
          <parameter name="maxNum" type="number" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="lastNode" type="DOMnode" usage="required"/>
        </parameters>
      </method>
      <method name="_createOption" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_buttonMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="__Constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="timeMenu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TimePicker.__Constraints" superclass="locale.__FormatOptions">
    <methods/>
    <mixins scope="instance">
      <mixin type="locale.__FormatOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._TimePicker.timeMenu"/>
  <class type="dijit._TimePicker.timeMenu.childNodes.0"/>
  <class type="dijit.form._FormValueWidget" superclass="dijit.form._FormWidget">
    <description>Each _FormValueWidget represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
    <methods>
      <method name="_layoutHackIE7" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
      <mixin type="dijit.form._FormValueMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._WidgetBase._setClassAttr"/>
  <class type="dijit._WidgetBase.constructor"/>
  <class type="dijit._WidgetBase.domNode.style"/>
  <class type="dojo">
    <methods>
      <method name="xhrPut" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrPost" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrGet" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrDelete" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhr" scope="instance">
        <description>Sends an HTTP request with the given method.
	See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
	for those HTTP methods. There are also methods for "raw" PUT and POST methods
	via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.</description>
          </parameter>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
          <parameter name="hasBody" type="Boolean" usage="optional">
            <description>If the request has an HTTP body, then pass true for hasBody.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="withGlobal" scope="instance">
        <description>Invoke callback with globalObject as dojo.global and
	globalObject.document as dojo.doc. If provided, globalObject
	will be executed in the context of object thisObject
	When callback() returns or throws an error, the dojo.global
	and dojo.doc will be restored to its previous state.</description>
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="withDoc" scope="instance">
        <description>Invoke callback with documentObject as dojo.doc. If provided,
	callback will be executed in the context of object thisObject
	When callback() returns or throws an error, the dojo.doc will
	be restored to its previous state.</description>
        <parameters>
          <parameter name="documentObject" type="DocumentElement" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="windowUnloaded" scope="instance"/>
      <method name="when" scope="instance">
        <examples>
          <example>	function printFirstAndLast(items){
			dojo.when(findFirst(items), console.log);
			dojo.when(findLast(items), console.log);
		}
		function findFirst(items){
			return dojo.when(items, function(items){
				return items[0];
			});
		}
		function findLast(items){
			return dojo.when(items, function(items){
				return items[items.length - 1];
			});
		}
	And now all three of his functions can be used sync or async.
		printFirstAndLast([1,2,3,4]) will work just as well as
		printFirstAndLast(dojo.xhrGet(...));</example>
        </examples>
        <parameters>
          <parameter name="promiseOrValue" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="optional"/>
          <parameter name="errback" type="Function" usage="optional"/>
          <parameter name="progressHandler" type="Function" usage="optional"/>
        </parameters>
        <return-description>Returns a new promise that represents the result of the execution of callback
	when parameter "promiseOrValue" is promise.
	Returns the execution result of callback when parameter "promiseOrValue" is value.</return-description>
        <return-types>
          <return-type type="Promise"/>
        </return-types>
      </method>
      <method name="trim" scope="instance">
        <description>This version of trim() was selected for inclusion into the base due
	to its compact size and relatively good performance
	(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
	Uses String.prototype.trim instead, if available.
	The fastest but longest version of this function is located at
	dojo.string.trim()</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>String to be trimmed</description>
          </parameter>
        </parameters>
        <return-description>String
	Returns the trimmed string</return-description>
      </method>
      <method name="toggleClass" scope="instance">
        <examples>
          <example>	dojo.toggleClass("someNode", "hovered");</example>
          <example>Forcefully add a class
		dojo.toggleClass("someNode", "hovered", true);</example>
          <example>Available in `dojo.NodeList()` for multiple toggles
		dojo.query(".toggleMe").toggleClass("toggleMe");</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DOMNode" usage="required">
            <description>String ID or DomNode reference to toggle a class string</description>
          </parameter>
          <parameter name="classStr" type="String|Array" usage="required">
            <description>A String class name to toggle, or several space-separated class names,
	or an array of class names.</description>
          </parameter>
          <parameter name="condition" type="If" usage="required">
            <description>passed, true means to add the class, false means to remove.
	Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toPixelValue" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="toJson" scope="instance">
        <description>Returns a [JSON](http://json.org) serialization of an object.
	Note that this doesn't check for infinite recursion, so don't do that!
	It is recommend that you use dojo/json's stringify function for an lighter
	and faster implementation that matches the native JSON API and uses the
	native JSON serializer when available.</description>
        <examples>
          <example>simple serialization of a trivial object
		var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);</example>
          <example>a custom serializer for an objects of a particular class:
		dojo.declare("Furby", null, {
			furbies: "are strange",
			furbyCount: 10,
			__json__: function(){
			},
		});</example>
        </examples>
        <parameters>
          <parameter name="it" type="Object" usage="required">
            <description>an object to be serialized. Objects may define their own
	serialization via a special &amp;quot;__json__&amp;quot; or &amp;quot;json&amp;quot; function
	property. If a specialized serializer has been defined, it will
	be used as a fallback.
	Note that in 1.6, toJson would serialize undefined, but this no longer supported
	since it is not supported by native JSON serializer.</description>
          </parameter>
          <parameter name="prettyPrint" type="Boolean" usage="optional">
            <description>if true, we indent objects and arrays to make the output prettier.
	The variable `dojo.toJsonIndentStr` is used as the indent string --
	to use something other than the default (tab), change that variable
	before calling dojo.toJson().
	Note that if native JSON support is available, it will be used for serialization,
	and native implementations vary on the exact spacing used in pretty printing.</description>
          </parameter>
        </parameters>
        <return-description>A JSON string serialization of the passed-in object.</return-description>
      </method>
      <method name="toDom" scope="instance">
        <examples>
          <example>Create a table row:
		var tr = dojo.toDom("&lt;tr&gt;&lt;td&gt;First!&lt;/td&gt;&lt;/tr&gt;");</example>
        </examples>
        <parameters>
          <parameter name="frag" type="String" usage="required">
            <description>the HTML fragment</description>
          </parameter>
          <parameter name="doc" type="DocumentNode" usage="optional">
            <description>optional document to use when creating DOM nodes, defaults to
	dojo.doc if not specified.</description>
          </parameter>
        </parameters>
        <return-description>DocumentFragment</return-description>
      </method>
      <method name="style" scope="instance">
        <description>Getting the style value uses the computed style for the node, so the value
	will be a calculated value, not just the immediate node.style value.
	Also when getting values, use specific style names,
	like "borderBottomWidth" instead of "border" since compound values like
	"border" are not necessarily reflected as expected.
	If you want to get node dimensions, use `dojo.marginBox()`,
	`dojo.contentBox()` or `dojo.position()`.</description>
        <examples>
          <example>Passing only an ID or node returns the computed style object of
	the node:
		dojo.style("thinger");</example>
          <example>Passing a node and a style property returns the current
	normalized, computed value for that property:
		dojo.style("thinger", "opacity"); // 1 by default</example>
          <example>Passing a node, a style property, and a value changes the
	current display of the node and returns the new computed value
		dojo.style("thinger", "opacity", 0.5); // == 0.5</example>
          <example>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		dojo.style("thinger", {
			"opacity": 0.5,
			"border": "3px solid black",
			"height": "300px"
		});</example>
          <example>When the CSS style property is hyphenated, the JavaScript property is camelCased.
	font-size becomes fontSize, and so on.
		dojo.style("thinger",{
			fontSize:"14pt",
			letterSpacing:"1.2em"
		});</example>
          <example>dojo.NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
	dojo.style() on every element of the list. See: `dojo.query()` and `dojo.NodeList()`
		dojo.query(".someClassName").style("visibility","hidden");
		// or
		dojo.query("#baz &gt; div").style({
			opacity:0.75,
			fontSize:"13pt"
		});</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to node to get/set style for</description>
          </parameter>
          <parameter name="name" type="String|Object" usage="optional">
            <description>the style property to set in DOM-accessor format
	(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
	pairs suitable for setting each property.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>If passed, sets value on the node for style, handling
	cross-browser concerns.  When setting a pixel value,
	be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
	Otherwise, in some cases, some browsers will not apply the style.</description>
          </parameter>
        </parameters>
        <return-description>when used as a getter, return the computed style of the node if passing in an ID or node,
	or return the normalized, computed value for the property when passing in a node and a style property</return-description>
      </method>
      <method name="stopEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event object. If omitted, window.event is used on IE.</description>
          </parameter>
        </parameters>
      </method>
      <method name="some" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
	run over sparse arrays, this implementation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some</description>
        <examples>
          <example> // is true
	 dojo.some([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
          <example> // is false
	 dojo.some([1, 2, 3, 4], function(item){ return item&lt;1; });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate over. If a string, operates on individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments: item, index,
	and array and returns true if the condition is met.</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-description>Boolean</return-description>
      </method>
      <method name="setStyle" scope="instance">
        <examples>
          <example>Passing a node, a style property, and a value changes the
	current display of the node and returns the new computed value
		dojo.setStyle("thinger", "opacity", 0.5); // == 0.5</example>
          <example>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		dojo.setStyle("thinger", {
			"opacity": 0.5,
			"border": "3px solid black",
			"height": "300px"
		});</example>
          <example>When the CSS style property is hyphenated, the JavaScript property is camelCased.
	font-size becomes fontSize, and so on.
		dojo.setStyle("thinger",{
			fontSize:"14pt",
			letterSpacing:"1.2em"
		});</example>
          <example>dojo.NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
	dojo.style() on every element of the list. See: `dojo.query()` and `dojo.NodeList()`
		dojo.query(".someClassName").style("visibility","hidden");
		// or
		dojo.query("#baz &gt; div").style({
			opacity:0.75,
			fontSize:"13pt"
		});</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to node to set style for</description>
          </parameter>
          <parameter name="name" type="String|Object" usage="required">
            <description>the style property to set in DOM-accessor format
	(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
	pairs suitable for setting each property.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>If passed, sets value on the node for style, handling
	cross-browser concerns.  When setting a pixel value,
	be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
	Otherwise, in some cases, some browsers will not apply the style.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setObject" scope="instance">
        <description>Useful for longer api chains where you have to test each object in
	the chain, or when you have an object reference in string format.
	Objects are created as needed along `path`. Returns the passed
	value if setting is successful or `undefined` if not.</description>
        <examples>
          <example>set the value of `foo.bar.baz`, regardless of whether
	intermediate objects already exist:
	 lang.setObject("foo.bar.baz", value);</example>
          <example>without `lang.setObject`, we often see code like this:
	 // ensure that intermediate objects are available
	 if(!obj["parent"]){ obj.parent = {}; }
	 if(!obj.parent["child"]){ obj.parent.child = {}; }
	 // now we can safely set the property
	 obj.parent.child.prop = "some value";
	whereas with `lang.setObject`, we can shorten that to:
	 lang.setObject("parent.child.prop", "some value", obj);</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Path to a property, in the form &amp;quot;A.B.C&amp;quot;.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>value or object to place at location given by name</description>
          </parameter>
          <parameter name="context" type="Object" usage="optional">
            <description>Optional. Object to use as root of path. Defaults to
	`dojo.global`.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setMarginBox" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="box" type="Object" usage="required">
            <description>hash with optional &amp;quot;l&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
	respectively. All specified properties should have numeric values in whole pixels.</description>
          </parameter>
          <parameter name="computedStyle" type="Object" usage="optional">
            <description>This parameter accepts computed styles object.
	If this parameter is omitted, the functions will call
	dojo.getComputedStyle to get one. It is a better way, calling
	dojo.computedStyle once, and then pass the reference to this
	computedStyle parameter. Wherever possible, reuse the returned
	object of dojo.getComputedStyle.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContext" scope="instance">
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="globalDocument" type="DocumentElement" usage="required"/>
        </parameters>
      </method>
      <method name="setContentSize" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="box" type="Object" usage="required">
            <description>hash with optional &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
	respectively. All specified properties should have numeric values in whole pixels.</description>
          </parameter>
          <parameter name="computedStyle" type="Object" usage="optional">
            <description>This parameter accepts computed styles object.
	If this parameter is omitted, the functions will call
	dojo.getComputedStyle to get one. It is a better way, calling
	dojo.computedStyle once, and then pass the reference to this
	computedStyle parameter. Wherever possible, reuse the returned
	object of dojo.getComputedStyle.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAttr" scope="instance">
        <description>Handles normalized setting of attributes on DOM Nodes.
	
	When passing functions as values, note that they will not be
	directly assigned to slots on the node, but rather the default
	behavior will be removed and the new behavior will be added
	using `dojo.connect()`, meaning that event handler properties
	will be normalized and that some caveats with regards to
	non-standard behaviors for onsubmit apply. Namely that you
	should cancel form submission using `dojo.stopEvent()` on the
	passed event object instead of returning a boolean value from
	the handler itself.</description>
        <examples>
          <example>	// use attr() to set the tab index
		dojo.setAttr("nodeId", "tabIndex", 3);</example>
          <example>Set multiple values at once, including event handlers:
		dojo.setAttr("formId", {
			"foo": "bar",
			"tabIndex": -1,
			"method": "POST",
			"onsubmit": function(e){
				// stop submitting the form. Note that the IE behavior
				// of returning true or false will have no effect here
				// since our handler is connect()ed to the built-in
				// onsubmit behavior and so we need to use
				// dojo.stopEvent() to ensure that the submission
				// doesn't proceed.
				dojo.stopEvent(e);
	
				// submit the form with Ajax
				dojo.xhrPost({ form: "formId" });
			}
		});</example>
          <example>Style is s special case: Only set with an object hash of styles
		dojo.setAttr("someNode",{
			id:"bar",
			style:{
				width:"200px", height:"100px", color:"#000"
			}
		});</example>
          <example>Again, only set style as an object hash of styles:
		var obj = { color:"#fff", backgroundColor:"#000" };
		dojo.setAttr("someNode", "style", obj);
	
		// though shorter to use `dojo.style()` in this case:
		dojo.setStyle("someNode", obj);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to the element to set the attribute on</description>
          </parameter>
          <parameter name="name" type="String|Object" usage="required">
            <description>the name of the attribute to set, or a hash of key-value pairs to set.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>the value to set for the attribute, if the name is a string.</description>
          </parameter>
        </parameters>
        <return-description>the DOM node</return-description>
      </method>
      <method name="safeMixin" scope="instance">
        <description>This function is used to mix in properties like lang.mixin does,
	but it skips a constructor property and decorates functions like
	dojo.declare does.
	
	It is meant to be used with classes and objects produced with
	dojo.declare. Functions mixed in with dojo.safeMixin can use
	this.inherited() like normal methods.
	
	This function is used to implement extend() method of a constructor
	produced with dojo.declare().</description>
        <examples>
          <example>	var A = dojo.declare(null, {
			m1: function(){
				console.log("A.m1");
			},
			m2: function(){
				console.log("A.m2");
			}
		});
		var B = dojo.declare(A, {
			m1: function(){
				this.inherited(arguments);
				console.log("B.m1");
			}
		});
		B.extend({
			m2: function(){
				this.inherited(arguments);
				console.log("B.m2");
			}
		});
		var x = new B();
		dojo.safeMixin(x, {
			m1: function(){
				this.inherited(arguments);
				console.log("X.m1");
			},
			m2: function(){
				this.inherited(arguments);
				console.log("X.m2");
			}
		});
		x.m2();
		// prints:
		// A.m1
		// B.m1
		// X.m1</example>
        </examples>
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>Target object to accept new properties.</description>
          </parameter>
          <parameter name="source" type="Object" usage="required">
            <description>Source object for new properties.</description>
          </parameter>
        </parameters>
      </method>
      <method name="requireLocalization" scope="instance">
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="requireIf" scope="instance"/>
      <method name="requireAfterIf" scope="instance">
        <examples>
          <example>	dojo.requireIf(dojo.isBrowser, "my.special.Module");</example>
        </examples>
        <parameters>
          <parameter name="condition" type="Boolean" usage="required"/>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="omitModuleCheck" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="require" scope="instance">
        <description>Modules are loaded via dojo.require by using one of two loaders: the normal loader
	and the xdomain loader. The xdomain loader is used when dojo was built with a
	custom build that specified loader=xdomain and the module lives on a modulePath
	that is a whole URL, with protocol and a domain. The versions of Dojo that are on
	the Google and AOL CDNs use the xdomain loader.
	
	If the module is loaded via the xdomain loader, it is an asynchronous load, since
	the module is added via a dynamically created script tag. This
	means that dojo.require() can return before the module has loaded. However, this
	should only happen in the case where you do dojo.require calls in the top-level
	HTML page, or if you purposely avoid the loader checking for dojo.require
	dependencies in your module by using a syntax like dojo["require"] to load the module.
	
	Sometimes it is useful to not have the loader detect the dojo.require calls in the
	module so that you can dynamically load the modules as a result of an action on the
	page, instead of right at module load time.
	
	Also, for script blocks in an HTML page, the loader does not pre-process them, so
	it does not know to download the modules before the dojo.require calls occur.
	
	So, in those two cases, when you want on-the-fly module loading or for script blocks
	in the HTML page, special care must be taken if the dojo.required code is loaded
	asynchronously. To make sure you can execute code that depends on the dojo.required
	modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
	callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
	executing.
	
	This type of syntax works with both xdomain and normal loaders, so it is good
	practice to always use this idiom for on-the-fly code loading and in HTML script
	blocks. If at some point you change loaders and where the code is loaded from,
	it will all still work.
	
	More on how dojo.require
	`dojo.require("A.B")` first checks to see if symbol A.B is
	defined. If it is, it is simply returned (nothing to do).
	
	If it is not defined, it will look for `A/B.js` in the script root
	directory.
	
	`dojo.require` throws an exception if it cannot find a file
	to load, or if the symbol `A.B` is not defined after loading.
	
	It returns the object `A.B`, but note the caveats above about on-the-fly loading and
	HTML script blocks when the xdomain loader is loading a module.
	
	`dojo.require()` does nothing about importing symbols into
	the current namespace.  It is presumed that the caller will
	take care of that.</description>
        <examples>
          <example>To use dojo.require in conjunction with dojo.ready:
	
		dojo.require("foo");
		dojo.require("bar");
		dojo.addOnLoad(function(){
			//you can now safely do something with foo and bar
		});</example>
          <example>For example, to import all symbols into a local block, you might write:
	
		with (dojo.require("A.B")) {
			...
		}
	
	And to import just the leaf symbol to a local variable:
	
		var B = dojo.require("A.B");
		...</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <description>module name to load, using periods for separators,
	e.g. &amp;quot;dojo.date.locale&amp;quot;.  Module paths are de-referenced by dojo's
	internal mapping of locations to names and are disambiguated by
	longest prefix. See `dojo.registerModulePath()` for details on
	registering new modules.</description>
          </parameter>
          <parameter name="omitModuleCheck" type="Boolean" usage="optional">
            <description>if `true`, omitModuleCheck skips the step of ensuring that the
	loaded file actually defines the symbol it is referenced by.
	For example if it called as `dojo.require(&amp;quot;a.b.c&amp;quot;)` and the
	file located at `a/b/c.js` does not define an object `a.b.c`,
	and exception will be throws whereas no exception is raised
	when called as `dojo.require(&amp;quot;a.b.c&amp;quot;, true)`</description>
          </parameter>
        </parameters>
        <return-description>the required namespace object</return-description>
      </method>
      <method name="replaceClass" scope="instance">
        <examples>
          <example>	dojo.replaceClass("someNode", "add1 add2", "remove1 remove2");</example>
          <example>Replace all classes with addMe
		dojo.replaceClass("someNode", "addMe");</example>
          <example>Available in `dojo.NodeList()` for multiple toggles
		dojo.query(".findMe").replaceClass("addMe", "removeMe");</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DOMNode" usage="required">
            <description>String ID or DomNode reference to remove the class from.</description>
          </parameter>
          <parameter name="addClassStr" type="String|Array" usage="required">
            <description>A String class name to add, or several space-separated class names,
	or an array of class names.</description>
          </parameter>
          <parameter name="removeClassStr" type="String|Array" usage="optional">
            <description>A String class name to remove, or several space-separated class names,
	or an array of class names.</description>
          </parameter>
        </parameters>
      </method>
      <method name="replace" scope="instance">
        <examples>
          <example>	// uses a dictionary for substitutions:
		dojo.replace("Hello, {name.first} {name.last} AKA {nick}!",
			{
				nick: "Bob",
				name: {
					first:	"Robert",
					middle: "X",
					last:		"Cringely"
				}
			});
		// returns: Hello, Robert Cringely AKA Bob!</example>
          <example>	// uses an array for substitutions:
		dojo.replace("Hello, {0} {2}!",
			["Robert", "X", "Cringely"]);
		// returns: Hello, Robert Cringely!</example>
          <example>	// uses a function for substitutions:
		function sum(a){
			var t = 0;
			dojo.forEach(a, function(x){ t += x; });
			return t;
		}
		dojo.replace(
			"{count} payments averaging {avg} USD per payment.",
			dojo.hitch(
				{ payments: [11, 16, 12] },
				function(_, key){
					switch(key){
						case "count": return this.payments.length;
						case "min":		return Math.min.apply(Math, this.payments);
						case "max":		return Math.max.apply(Math, this.payments);
						case "sum":		return sum(this.payments);
						case "avg":		return sum(this.payments) / this.payments.length;
					}
				}
			)
		);
		// prints: 3 payments averaging 13 USD per payment.</example>
          <example>	// uses an alternative PHP-like pattern for substitutions:
		dojo.replace("Hello, ${0} ${2}!",
			["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
		// returns: Hello, Robert Cringely!</example>
        </examples>
        <parameters>
          <parameter name="tmpl" type="String" usage="required">
            <description>String to be used as a template.</description>
          </parameter>
          <parameter name="map" type="Object|Function" usage="required">
            <description>If an object, it is used as a dictionary to look up substitutions.
	If a function, it is called for every substitution with following
	parameters: a whole match, a name, an offset, and the whole template
	string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
	for more details).</description>
          </parameter>
          <parameter name="pattern" type="RegEx" usage="optional">
            <description>Optional regular expression objects that overrides the default pattern.
	Must be global and match one item. The default is: /\{([^\}]+)\}/g,
	which matches patterns like that: &amp;quot;{xxx}&amp;quot;, where &amp;quot;xxx&amp;quot; is any sequence
	of characters, which doesn't include &amp;quot;}&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-description>String
	Returns the substituted string.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="removeClass" scope="instance">
        <examples>
          <example>Remove a class from some node:
		dojo.removeClass("someNode", "firstClass");</example>
          <example>Remove two classes from some node:
		dojo.removeClass("someNode", "firstClass secondClass");</example>
          <example>Remove two classes from some node (using array):
		dojo.removeClass("someNode", ["firstClass", "secondClass"]);</example>
          <example>Remove all classes from some node:
		dojo.removeClass("someNode");</example>
          <example>Available in `dojo.NodeList()` for multiple removal
		dojo.query(".foo").removeClass("foo");</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DOMNode" usage="required">
            <description>String ID or DomNode reference to remove the class from.</description>
          </parameter>
          <parameter name="classStr" type="String|Array" usage="required">
            <description>An optional String class name to remove, or several space-separated
	class names, or an array of class names. If omitted, all class names
	will be deleted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeAttr" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to the element to remove the attribute from</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the attribute to remove</description>
          </parameter>
        </parameters>
      </method>
      <method name="registerModulePath" scope="instance">
        <description>An unregistered module is given the default path of ../[module],
	relative to Dojo root. For example, module acme is mapped to
	../acme.  If you want to use a different module name, use
	dojo.registerModulePath.</description>
        <examples>
          <example>If your dojo.js is located at this location in the web root:
		/myapp/js/dojo/dojo/dojo.js
	and your modules are located at:
		/myapp/js/foo/bar.js
		/myapp/js/foo/baz.js
		/myapp/js/foo/thud/xyzzy.js
	Your application can tell Dojo to locate the "foo" namespace by calling:
		dojo.registerModulePath("foo", "../../foo");
	At which point you can then use dojo.require() to load the
	modules (assuming they provide() the same things which are
	required). The full code might be:
		&lt;script type="text/javascript"
			src="/myapp/js/dojo/dojo/dojo.js"&gt;&lt;/script&gt;
		&lt;script type="text/javascript"&gt;
			dojo.registerModulePath("foo", "../../foo");
			dojo.require("foo.bar");
			dojo.require("foo.baz");
			dojo.require("foo.thud.xyzzy");
		&lt;/script&gt;</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="prefix" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="ready" scope="instance"/>
      <method name="rawXhrPut" scope="instance"/>
      <method name="rawXhrPost" scope="instance"/>
      <method name="query" scope="instance">
        <description>dojo/query is responsible for loading the appropriate query engine and wrapping
	its results with a `dojo.NodeList`. You can use dojo/query with a specific selector engine
	by using it as a plugin. For example, if you installed the sizzle package, you could
	use it as the selector engine with:
		define("dojo/query!sizzle", function(query){
			query("div")...
	
	The id after the ! can be a module id of the selector engine or one of the following values:
		+ acme: This is the default engine used by Dojo base, and will ensure that the full
		Acme engine is always loaded.
	
		+ css2: If the browser has a native selector engine, this will be used, otherwise a
		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (&gt;)
		operators) and nothing more.
	
		+ css2.1: If the browser has a native selector engine, this will be used, otherwise the
		full Acme engine will be loaded.
	
		+ css3: If the browser has a native selector engine with support for CSS3 pseudo
		selectors (most modern browsers except IE8), this will be used, otherwise the
		full Acme engine will be loaded.
	
		+ Or the module id of a selector engine can be used to explicitly choose the selector engine
	
	For example, if you are using CSS3 pseudo selectors in module, you can specify that
	you will need support them with:
		define("dojo/query!css3", function(query){
			query('#t &gt; h3:nth-child(odd)')...
	
	You can also choose the selector engine/load configuration by setting the &lt;FIXME:what is the configuration setting?&gt;.
	For example:
		&lt;script data-dojo-config="query-selector:'css3'" src="dojo.js"&gt;&lt;/script&gt;</description>
        <examples>
          <example>add an onclick handler to every submit button in the document
	which causes the form to be sent via Ajax instead:
		define(["dojo/query"], function(query){
		query("input[type='submit']").on("click", function(e){
			dojo.stopEvent(e); // prevent sending the form
			var btn = e.target;
			dojo.xhrPost({
				form: btn.form,
				load: function(data){
					// replace the form with the response
					var div = dojo.doc.createElement("div");
					dojo.place(div, btn.form, "after");
					div.innerHTML = data;
					dojo.style(btn.form, "display", "none");
				}
			});
		});</example>
        </examples>
        <parameters>
          <parameter name="selector" type="String" usage="required">
            <description>A CSS selector to search for.</description>
          </parameter>
          <parameter name="context" type="String|DomNode" usage="optional">
            <description>An optional context to limit the searching scope. Only nodes under `context` will be
	scanned.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="pushContext" scope="instance">
        <description>dojo.pushContext treats contexts as a stack. The
	auto-detected contexts which are initially provided using
	dojo.setContext() require authors to keep state in order to
	"return" to a previous context, whereas the
	dojo.pushContext and dojo.popContext methods provide a more
	natural way to augment blocks of code to ensure that they
	execute in a different window or frame without issue. If
	called without any arguments, the default context (the
	context when Dojo is first loaded) is instead pushed into
	the stack. If only a single string is passed, a node in the
	intitial context's document is looked up and its
	contextWindow and contextDocument properties are used as
	the context to push. This means that iframes can be given
	an ID and code can be executed in the scope of the iframe's
	document in subsequent calls easily.</description>
        <parameters>
          <parameter name="g" type="Object|String" usage="optional">
            <description>The global context. If a string, the id of the frame to
	search for a context and document.</description>
          </parameter>
          <parameter name="d" type="MDocumentElement" usage="optional">
            <description>The document element to execute subsequent code with.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="provide" scope="instance">
        <parameters>
          <parameter name="mid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="prop" scope="instance">
        <description>Handles normalized getting and setting of properties on DOM
	Nodes. If 2 arguments are passed, and a the second argument is a
	string, acts as a getter.
	
	If a third argument is passed, or if the second argument is a
	map of attributes, acts as a setter.
	
	When passing functions as values, note that they will not be
	directly assigned to slots on the node, but rather the default
	behavior will be removed and the new behavior will be added
	using `dojo.connect()`, meaning that event handler properties
	will be normalized and that some caveats with regards to
	non-standard behaviors for onsubmit apply. Namely that you
	should cancel form submission using `dojo.stopEvent()` on the
	passed event object instead of returning a boolean value from
	the handler itself.</description>
        <examples>
          <example>	// get the current value of the "foo" property on a node
		dojo.prop(dojo.byId("nodeId"), "foo");
		// or we can just pass the id:
		dojo.prop("nodeId", "foo");</example>
          <example>	// use prop() to set the tab index
		dojo.prop("nodeId", "tabIndex", 3);</example>
          <example>Set multiple values at once, including event handlers:
		dojo.prop("formId", {
			"foo": "bar",
			"tabIndex": -1,
			"method": "POST",
			"onsubmit": function(e){
				// stop submitting the form. Note that the IE behavior
				// of returning true or false will have no effect here
				// since our handler is connect()ed to the built-in
				// onsubmit behavior and so we need to use
				// dojo.stopEvent() to ensure that the submission
				// doesn't proceed.
				dojo.stopEvent(e);
	
				// submit the form with Ajax
				dojo.xhrPost({ form: "formId" });
			}
		});</example>
          <example>Style is s special case: Only set with an object hash of styles
		dojo.prop("someNode",{
			id:"bar",
			style:{
				width:"200px", height:"100px", color:"#000"
			}
		});</example>
          <example>Again, only set style as an object hash of styles:
		var obj = { color:"#fff", backgroundColor:"#000" };
		dojo.prop("someNode", "style", obj);
	
		// though shorter to use `dojo.style()` in this case:
		dojo.style("someNode", obj);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to the element to get or set the property on</description>
          </parameter>
          <parameter name="name" type="String|Object" usage="required">
            <description>the name of the property to get or set.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>The value to set for the property</description>
          </parameter>
        </parameters>
        <return-description>when used as a getter, the value of the requested property
	or null if that attribute does not have a specified or
	default value;
	
	when used as a setter, the DOM node</return-description>
      </method>
      <method name="position" scope="instance">
        <description>Returns an object of the form:
	{ x: 100, y: 300, w: 20, h: 15 }
	If includeScroll==true, the x and y values will include any
	document offsets that may affect the position relative to the
	viewport.
	Uses the border-box model (inclusive of border and padding but
	not margin).  Does not act as a setter.</description>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>Object</return-description>
      </method>
      <method name="popContext" scope="instance"/>
      <method name="platformRequire" scope="instance">
        <description>This method takes a "map" of arrays which one can use to
	optionally load dojo modules. The map is indexed by the
	possible dojo.name_ values, with two additional values:
	"default" and "common". The items in the "default" array will
	be loaded if none of the other items have been choosen based on
	dojo.name_, set by your host environment. The items in the
	"common" array will *always* be loaded, regardless of which
	list is chosen.</description>
        <examples>
          <example>	dojo.platformRequire({
			browser: [
				"foo.sample", // simple module
				"foo.test",
				["foo.bar.baz", true] // skip object check in _loadModule (dojo.require)
			],
			default: [ "foo.sample._base" ],
			common: [ "important.module.common" ]
		});</example>
        </examples>
        <parameters>
          <parameter name="modMap" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="place" scope="instance">
        <examples>
          <example>Place a node by string id as the last child of another node by string id:
		dojo.place("someNode", "anotherNode");</example>
          <example>Place a node by string id before another node by string id
		dojo.place("someNode", "anotherNode", "before");</example>
          <example>Create a Node, and place it in the body element (last child):
		dojo.place("&lt;div&gt;&lt;/div&gt;", dojo.body());</example>
          <example>Put a new LI as the first child of a list by id:
		dojo.place("&lt;li&gt;&lt;/li&gt;", "someUl", "first");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or node reference, or HTML fragment starting with &amp;quot;&amp;lt;&amp;quot; to place relative to refNode</description>
          </parameter>
          <parameter name="refNode" type="DOMNode|String" usage="required">
            <description>id or node reference to use as basis for placement</description>
          </parameter>
          <parameter name="position" type="String|Number" usage="optional">
            <description>string noting the position of node relative to refNode or a
	number indicating the location in the childNodes collection of refNode.
	Accepted string values are:
		* before
		* after
		* replace
		* only
		* first
		* last
	&amp;quot;first&amp;quot; and &amp;quot;last&amp;quot; indicate positions as children of refNode, &amp;quot;replace&amp;quot; replaces refNode,
	&amp;quot;only&amp;quot; replaces all children.  position defaults to &amp;quot;last&amp;quot; if not specified</description>
          </parameter>
        </parameters>
        <return-description>DOMNode
	Returned values is the first argument resolved to a DOM node.
	
	.place() is also a method of `dojo.NodeList`, allowing `dojo.query` node lookups.</return-description>
      </method>
      <method name="partial" scope="instance">
        <description>Calling dojo.partial is the functional equivalent of calling:
		dojo.hitch(null, funcName, ...);</description>
        <parameters>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
      </method>
      <method name="mixin" scope="instance">
        <description>All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
	found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
	The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
	executes a so-called "shallow copy" and aggregate types are copied/added by reference.</description>
        <examples>
          <example>make a shallow copy of an object
	 var copy = lang.mixin({}, source);</example>
          <example>many class constructors often take an object which specifies
	values to be configured on the object. In this case, it is
	often simplest to call `lang.mixin` on the `this` object:
	 dojo.declare("acme.Base", null, {
			constructor: function(properties){
				// property configuration:
				lang.mixin(this, properties);
	
				console.log(this.quip);
				//	...
			},
			quip: "I wasn't born yesterday, you know - I've seen movies.",
			// ...
	 });
	
	 // create an instance of the class and configure it
	 var b = new acme.Base({quip: "That's what it does!" });</example>
          <example>copy in properties from multiple objects
	 var flattened = lang.mixin(
			{
				name: "Frylock",
				braces: true
			},
			{
				name: "Carl Brutanananadilewski"
			}
	 );
	
	 // will print "Carl Brutanananadilewski"
	 console.log(flattened.name);
	 // will print "true"
	 console.log(flattened.braces);</example>
        </examples>
        <parameters>
          <parameter name="dest" type="Object" usage="required">
            <description>The object to which to copy/add all properties contained in source. If dest is falsy, then
	a new object is manufactured before copying/adding properties begins.</description>
          </parameter>
          <parameter name="sources" type="Object" usage="one-or-more">
            <description>One of more objects from which to draw all properties to copy into dest. sources are processed
	left-to-right and if more than one of these objects contain the same property name, the right-most
	value &amp;quot;wins&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-description>Object
	dest, as modified</return-description>
      </method>
      <method name="marginBox" scope="instance">
        <description>Getter/setter for the margin-box of node.
	Returns an object in the expected format of box (regardless
	if box is passed). The object might look like:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	for a node offset from its parent 50px to the left, 200px from
	the top with a margin width of 300px and a margin-height of
	150px.</description>
        <examples>
          <example>Retrieve the margin box of a passed node
		var box = dojo.marginBox("someNodeId");
		console.dir(box);</example>
          <example>Set a node's margin box to the size of another node
		var box = dojo.marginBox("someNodeId");
		dojo.marginBox("someOtherNode", box);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to DOM Node to get/set box for</description>
          </parameter>
          <parameter name="box" type="Object" usage="optional">
            <description>If passed, denotes that dojo.marginBox() should
	update/set the margin box for node. Box is an object in the
	above format. All properties are optional if passed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
	run over sparse arrays, this implementation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</description>
        <examples>
          <example> // returns [2, 3, 4, 5]
	 dojo.map([1, 2, 3, 4], function(item){ return item+1 });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate on. If a string, operates on
	individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments, (item, index,
	array),	 and returns a value</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-description>Array</return-description>
      </method>
      <method name="loadInit" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="lastIndexOf" scope="instance">
        <description>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when
	run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
	1.6's lastIndexOf skips the holes in the sparse array.
	For details on this method, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf</description>
        <parameters>
          <parameter name="arr" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="isString" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required">
            <description>Item to test.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isObject" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required">
            <description>Item to test.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isFunction" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required">
            <description>Item to test.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isCopyKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
        </parameters>
      </method>
      <method name="isBodyLtr" scope="instance">
        <return-description>Boolean</return-description>
      </method>
      <method name="isArrayLike" scope="instance">
        <description>Doesn't strongly test for "arrayness".  Instead, settles for "isn't
	a string or number and has a length property". Arguments objects
	and DOM collections will return true when passed to
	dojo.isArrayLike(), but will return false when passed to
	dojo.isArray().</description>
        <parameters>
          <parameter name="it" type="anything" usage="required">
            <description>Item to test.</description>
          </parameter>
        </parameters>
        <return-description>If it walks like a duck and quacks like a duck, return `true`</return-description>
      </method>
      <method name="isArray" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required">
            <description>Item to test.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isAlien" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="indexOf" scope="instance">
        <description>This method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when
	run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
	1.6's indexOf skips the holes in the sparse array.
	For details on this method, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf</description>
        <parameters>
          <parameter name="arr" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
          <parameter name="findLast" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="hitch" scope="instance">
        <examples>
          <example>	dojo.hitch(foo, "bar")();
	runs foo.bar() in the scope of foo</example>
          <example>	dojo.hitch(foo, myFunction);
	returns a function that runs myFunction in the scope of foo</example>
          <example>Expansion on the default positional arguments passed along from
	hitch. Passed args are mixed first, additional args after.
		var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
		var fn = dojo.hitch(foo, "bar", 1, 2);
		fn(3); // logs "1, 2, 3"</example>
          <example>	var foo = { bar: 2 };
		dojo.hitch(foo, function(){ this.bar = 10; })();
	execute an anonymous function in scope of foo</example>
        </examples>
        <parameters>
          <parameter name="scope" type="Object" usage="required">
            <description>The scope to use when method executes. If method is a string,
	scope is also the object containing method.</description>
          </parameter>
          <parameter name="method" type="Function|String" usage="one-or-more">
            <description>A function to be hitched to scope, or the name of the method in
	scope to be hitched.</description>
          </parameter>
        </parameters>
      </method>
      <method name="hash" scope="instance">
        <description>Handles getting and setting of location.hash.
	- If no arguments are passed, acts as a getter.
	- If a string is passed, acts as a setter.</description>
        <parameters>
          <parameter name="hash" type="String" usage="optional">
            <description>the hash is set - #string.</description>
          </parameter>
          <parameter name="replace" type="Boolean" usage="optional">
            <description>If true, updates the hash value in the current history
	state instead of creating a new history state.</description>
          </parameter>
        </parameters>
        <return-description>when used as a getter, returns the current hash string.
	when used as a setter, returns the new hash string.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="hasClass" scope="instance">
        <examples>
          <example>Do something if a node with id="someNode" has class="aSillyClassName" present
		if(dojo.hasClass("someNode","aSillyClassName")){ ... }</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DOMNode" usage="required">
            <description>String ID or DomNode reference to check the class for.</description>
          </parameter>
          <parameter name="classStr" type="String" usage="required">
            <description>A string class name to look for.</description>
          </parameter>
        </parameters>
        <return-description>Boolean</return-description>
      </method>
      <method name="hasAttr" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to the element to check</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the attribute</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true if the requested attribute is specified on the
	given element, and false otherwise</return-description>
      </method>
      <method name="has" scope="instance">
        <description>Returns the value of the feature named by name. The feature must have been
	previously added to the cache by has.add.</description>
        <parameters>
          <parameter name="name" type="String|Integer" usage="required">
            <description>The name (if a string) or identifier (if an integer) of the feature to test.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getStyle" scope="instance">
        <description>Getting the style value uses the computed style for the node, so the value
	will be a calculated value, not just the immediate node.style value.
	Also when getting values, use specific style names,
	like "borderBottomWidth" instead of "border" since compound values like
	"border" are not necessarily reflected as expected.
	If you want to get node dimensions, use `dojo.marginBox()`,
	`dojo.contentBox()` or `dojo.position()`.</description>
        <examples>
          <example>Passing only an ID or node returns the computed style object of
	the node:
		dojo.getStyle("thinger");</example>
          <example>Passing a node and a style property returns the current
	normalized, computed value for that property:
		dojo.getStyle("thinger", "opacity"); // 1 by default</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to node to get style for</description>
          </parameter>
          <parameter name="name" type="String" usage="optional">
            <description>the style property to get</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPadExtents" scope="instance">
        <description>Returns an object with `w`, `h`, `l`, `t` properties:
			l/t/r/b = left/top/right/bottom padding (respectively)
			w = the total of the left and right padding
			h = the total of the top and bottom padding
	If 'node' has position, l/t forms the origin for child nodes.
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="optional">
            <description>This parameter accepts computed styles object.
	If this parameter is omitted, the functions will call
	dojo.getComputedStyle to get one. It is a better way, calling
	dojo.computedStyle once, and then pass the reference to this
	computedStyle parameter. Wherever possible, reuse the returned
	object of dojo.getComputedStyle.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPadBorderExtents" scope="instance">
        <description>* l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
	* w = the sum of the left and right padding and border
	* h = the sum of the top and bottom padding and border
	
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="optional">
            <description>This parameter accepts computed styles object.
	If this parameter is omitted, the functions will call
	dojo.getComputedStyle to get one. It is a better way, calling
	dojo.computedStyle once, and then pass the reference to this
	computedStyle parameter. Wherever possible, reuse the returned
	object of dojo.getComputedStyle.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getObject" scope="instance">
        <description>Useful for longer api chains where you have to test each object in
	the chain, or when you have an object reference in string format.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Path to an property, in the form &amp;quot;A.B.C&amp;quot;.</description>
          </parameter>
          <parameter name="create" type="Boolean" usage="optional">
            <description>Optional. Defaults to `false`. If `true`, Objects will be
	created at any point along the 'path' that is undefined.</description>
          </parameter>
          <parameter name="context" type="Object" usage="optional">
            <description>Optional. Object to use as root of path. Defaults to
	'dojo.global'. Null may be passed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getNodeProp" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to the element to remove the attribute from</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the attribute</description>
          </parameter>
        </parameters>
        <return-description>the value of the attribute</return-description>
      </method>
      <method name="getMarginSize" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="optional">
            <description>This parameter accepts computed styles object.
	If this parameter is omitted, the functions will call
	dojo.getComputedStyle to get one. It is a better way, calling
	dojo.computedStyle once, and then pass the reference to this
	computedStyle parameter. Wherever possible, reuse the returned
	object of dojo.getComputedStyle.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getMarginExtents" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="optional">
            <description>This parameter accepts computed styles object.
	If this parameter is omitted, the functions will call
	dojo.getComputedStyle to get one. It is a better way, calling
	dojo.computedStyle once, and then pass the reference to this
	computedStyle parameter. Wherever possible, reuse the returned
	object of dojo.getComputedStyle.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getMarginBox" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="optional">
            <description>This parameter accepts computed styles object.
	If this parameter is omitted, the functions will call
	dojo.getComputedStyle to get one. It is a better way, calling
	dojo.computedStyle once, and then pass the reference to this
	computedStyle parameter. Wherever possible, reuse the returned
	object of dojo.getComputedStyle.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getL10nName" scope="instance">
        <parameters>
          <parameter name="moduleName" type="Object" usage="required"/>
          <parameter name="bundleName" type="Object" usage="required"/>
          <parameter name="locale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIeDocumentElementOffset" scope="instance">
        <description>The following values in IE contain an offset:
			event.clientX
			event.clientY
			node.getBoundingClientRect().left
			node.getBoundingClientRect().top
	But other position related values do not contain this offset,
	such as node.offsetLeft, node.offsetTop, node.style.left and
	node.style.top. The offset is always (2, 2) in LTR direction.
	When the body is in RTL direction, the offset counts the width
	of left scroll bar's width.  This function computes the actual
	offset.</description>
      </method>
      <method name="getContentBox" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="optional">
            <description>This parameter accepts computed styles object.
	If this parameter is omitted, the functions will call
	dojo.getComputedStyle to get one. It is a better way, calling
	dojo.computedStyle once, and then pass the reference to this
	computedStyle parameter. Wherever possible, reuse the returned
	object of dojo.getComputedStyle.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getComputedStyle" scope="instance">
        <description>Gets a "computed style" object which can be used to gather
	information about the current state of the rendered node.
	
	Note that this may behave differently on different browsers.
	Values may have different formats and value encodings across
	browsers.
	
	Note also that this method is expensive.  Wherever possible,
	reuse the returned object.
	
	Use the dojo.style() method for more consistent (pixelized)
	return values.</description>
        <examples>
          <example>	dojo.getComputedStyle(dojo.byId('foo')).borderWidth;</example>
          <example>Reusing the returned object, avoiding multiple lookups:
		var cs = dojo.getComputedStyle(dojo.byId("someNode"));
		var w = cs.width, h = cs.height;</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>A reference to a DOM node. Does NOT support taking an
	ID string for speed reasons.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="CSS2Properties"/>
        </return-types>
      </method>
      <method name="getBorderExtents" scope="instance">
        <description>* l/t/r/b = the sum of left/top/right/bottom border (respectively)
	* w = the sum of the left and right border
	* h = the sum of the top and bottom border
	
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="optional">
            <description>This parameter accepts computed styles object.
	If this parameter is omitted, the functions will call
	dojo.getComputedStyle to get one. It is a better way, calling
	dojo.computedStyle once, and then pass the reference to this
	computedStyle parameter. Wherever possible, reuse the returned
	object of dojo.getComputedStyle.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAttr" scope="instance">
        <description>Handles normalized getting of attributes on DOM Nodes.</description>
        <examples>
          <example>	// get the current value of the "foo" attribute on a node
		dojo.getAttr(dojo.byId("nodeId"), "foo");
		// or we can just pass the id:
		dojo.getAttr("nodeId", "foo");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to the element to get the attribute on</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the attribute to get.</description>
          </parameter>
        </parameters>
        <return-description>the value of the requested attribute or null if that attribute does not have a specified or
	default value;</return-description>
      </method>
      <method name="fromJson" scope="instance">
        <description>Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
	always delegates to eval(). The content passed to this method must therefore come
	from a trusted source.
	It is recommend that you use dojo/json's parse function for an
	implementation uses the (faster) native JSON parse when available.</description>
        <parameters>
          <parameter name="js" type="String" usage="required">
            <description>a string literal of a JavaScript expression, for instance:
	`'{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }'`</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formToQuery" scope="instance">
        <parameters>
          <parameter name="formNode" type="DOMNode|String" usage="required"/>
        </parameters>
        <return-description>String</return-description>
      </method>
      <method name="formToObject" scope="instance">
        <description>Returns the values encoded in an HTML form as
	string properties in an object which it then returns. Disabled form
	elements, buttons, and other non-value form elements are skipped.
	Multi-select elements are returned as an array of string values.</description>
        <examples>
          <example>This form:
		&lt;form id="test_form"&gt;
			&lt;input type="text" name="blah" value="blah"&gt;
			&lt;input type="text" name="no_value" value="blah" disabled&gt;
			&lt;input type="button" name="no_value2" value="blah"&gt;
			&lt;select type="select" multiple name="multi" size="5"&gt;
				&lt;option value="blah"&gt;blah&lt;/option&gt;
				&lt;option value="thud" selected&gt;thud&lt;/option&gt;
				&lt;option value="thonk" selected&gt;thonk&lt;/option&gt;
			&lt;/select&gt;
		&lt;/form&gt;
	
	yields this object structure as the result of a call to
	formToObject():
	
		{
			blah: "blah",
			multi: [
				"thud",
				"thonk"
			]
		};</example>
        </examples>
        <parameters>
          <parameter name="formNode" type="DOMNode|String" usage="required"/>
        </parameters>
        <return-description>Object</return-description>
      </method>
      <method name="formToJson" scope="instance">
        <parameters>
          <parameter name="formNode" type="DOMNode|String" usage="required"/>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
        </parameters>
        <return-description>String</return-description>
      </method>
      <method name="forEach" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
	run over sparse arrays, this implementation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</description>
        <examples>
          <example> // log out all members of the array:
	 dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			function(item){
				console.log(item);
			}
	 );</example>
          <example> // log out the members and their indexes
	 dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			function(item, idx, arr){
				console.log(item, "at index:", idx);
			}
	 );</example>
          <example> // use a scoped object member as the callback
	
	 var obj = {
			prefix: "logged via obj.callback:",
			callback: function(item){
				console.log(this.prefix, item);
			}
	 };
	
	 // specifying the scope function executes the callback in that scope
	 dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			obj.callback,
			obj
	 );
	
	 // alternately, we can accomplish the same thing with dojo.hitch()
	 dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			dojo.hitch(obj, "callback")
	 );</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required"/>
          <parameter name="callback" type="Function|String" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="fixIeBiDiScrollLeft" scope="instance">
        <parameters>
          <parameter name="scrollLeft" type="NUmber" usage="required"/>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="fixEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>native event object</description>
          </parameter>
          <parameter name="sender" type="DOMNode" usage="required">
            <description>node to treat as &amp;quot;currentTarget&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Event"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
	run over sparse arrays, this implementation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</description>
        <examples>
          <example> // returns [2, 3, 4]
	 dojo.filter([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array" usage="required">
            <description>the array to iterate over.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function that is invoked with three arguments (item,
	index, array). The return of this function is expected to
	be a boolean which determines whether the passed-in item
	will be included in the returned array.</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-description>Array</return-description>
      </method>
      <method name="fieldToObject" scope="instance">
        <description>Returns the value encoded in a form field as
	as a string or an array of strings. Disabled form elements
	and unchecked radio and checkboxes are skipped.	Multi-select
	elements are returned as an array of string values.</description>
        <parameters>
          <parameter name="inputNode" type="DOMNode|String" usage="required"/>
        </parameters>
        <return-description>Object</return-description>
      </method>
      <method name="fadeOut" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="extend" scope="instance">
        <parameters>
          <parameter name="constructor" type="Object" usage="required">
            <description>Target constructor to extend.</description>
          </parameter>
          <parameter name="props" type="Object" usage="one-or-more">
            <description>One or more objects to mix into constructor.prototype</description>
          </parameter>
        </parameters>
      </method>
      <method name="exit" scope="instance">
        <parameters>
          <parameter name="exitcode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="exists" scope="instance">
        <description>useful for longer api chains where you have to test each object in
	the chain. Useful for object and method detection.</description>
        <examples>
          <example> // define an object
	 var foo = {
			bar: { }
	 };
	
	 // search the global scope
	 lang.exists("foo.bar"); // true
	 lang.exists("foo.bar.baz"); // false
	
	 // search from a particular scope
	 lang.exists("bar", foo); // true
	 lang.exists("bar.baz", foo); // false</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Path to an object, in the form &amp;quot;A.B.C&amp;quot;.</description>
          </parameter>
          <parameter name="obj" type="Object" usage="optional">
            <description>Object to use as root of path. Defaults to
	'dojo.global'. Null may be passed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="every" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
	run over sparse arrays, this implementation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every</description>
        <examples>
          <example> // returns false
	 dojo.every([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
          <example> // returns true
	 dojo.every([1, 2, 3, 4], function(item){ return item&gt;0; });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate on. If a string, operates on individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments: item, index,
	and array and returns true if the condition is met.</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-description>Boolean</return-description>
      </method>
      <method name="empty" scope="instance">
        <examples>
          <example>Destroy node's children byId:
		dojo.empty("someId");</example>
          <example>Destroy all nodes' children in a list by reference:
		dojo.query(".someNode").forEach(dojo.empty);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>a reference to a DOM node or an id.</description>
          </parameter>
        </parameters>
      </method>
      <method name="docScroll" scope="instance">
        <return-description>Object</return-description>
      </method>
      <method name="disconnect" scope="instance">
        <description>Removes the connection between event and the method referenced by handle.</description>
        <parameters>
          <parameter name="handle" type="Handle" usage="required">
            <description>the return value of the dojo.connect call that created the connection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <description>Removes a node from its parent, clobbering it and all of its
	children. Function only works with DomNodes, and returns nothing.</description>
        <examples>
          <example>Destroy a node byId:
		dojo.destroy("someId");</example>
          <example>Destroy all nodes in a list by reference:
		dojo.query(".someNode").forEach(dojo.destroy);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>A String ID or DomNode reference of the element to be destroyed</description>
          </parameter>
        </parameters>
      </method>
      <method name="delegate" scope="instance">
        <description>This is a small implementaton of the Boodman/Crockford delegation
	pattern in JavaScript. An intermediate object constructor mediates
	the prototype chain for the returned object, using it to delegate
	down to obj for property lookup when object-local lookup fails.
	This can be thought of similarly to ES4's "wrap", save that it does
	not act on types but rather on pure objects.</description>
        <examples>
          <example>	var foo = { bar: "baz" };
		var thinger = dojo.delegate(foo, { thud: "xyzzy"});
		thinger.bar == "baz"; // delegated to foo
		foo.thud == undefined; // by definition
		thinger.thud == "xyzzy"; // mixed in from props
		foo.bar = "thonk";
		thinger.bar == "thonk"; // still delegated to foo's bar</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>The object to delegate to for properties not found directly on the
	return object or in props.</description>
          </parameter>
          <parameter name="props" type="Object" usage="one-or-more">
            <description>an object containing properties to assign to the returned object</description>
          </parameter>
        </parameters>
        <return-description>an Object of anonymous type</return-description>
      </method>
      <method name="declare" scope="instance">
        <description>Create a constructor using a compact notation for inheritance and
	prototype extension.
	
	Mixin ancestors provide a type of multiple inheritance.
	Prototypes of mixin ancestors are copied to the new class:
	changes to mixin prototypes will not affect classes to which
	they have been mixed in.
	
	Ancestors can be compound classes created by this version of
	dojo.declare. In complex cases all base classes are going to be
	linearized according to C3 MRO algorithm
	(see http://www.python.org/download/releases/2.3/mro/ for more
	details).
	
	"className" is cached in "declaredClass" property of the new class,
	if it was supplied. The immediate super class will be cached in
	"superclass" property of the new class.
	
	Methods in "props" will be copied and modified: "nom" property
	(the declared name of the method) will be added to all copied
	functions to help identify them for the internal machinery. Be
	very careful, while reusing methods: if you use the same
	function under different names, it can produce errors in some
	cases.
	
	It is possible to use constructors created "manually" (without
	dojo.declare) as bases. They will be called as usual during the
	creation of an instance, their methods will be chained, and even
	called by "this.inherited()".
	
	Special property "-chains-" governs how to chain methods. It is
	a dictionary, which uses method names as keys, and hint strings
	as values. If a hint string is "after", this method will be
	called after methods of its base classes. If a hint string is
	"before", this method will be called before methods of its base
	classes.
	
	If "constructor" is not mentioned in "-chains-" property, it will
	be chained using the legacy mode: using "after" chaining,
	calling preamble() method before each constructor, if available,
	and calling postscript() after all constructors were executed.
	If the hint is "after", it is chained as a regular method, but
	postscript() will be called after the chain of constructors.
	"constructor" cannot be chained "before", but it allows
	a special hint string: "manual", which means that constructors
	are not going to be chained in any way, and programmer will call
	them manually using this.inherited(). In the latter case
	postscript() will be called after the construction.
	
	All chaining hints are "inherited" from base classes and
	potentially can be overridden. Be very careful when overriding
	hints! Make sure that all chained methods can work in a proposed
	manner of chaining.
	
	Once a method was chained, it is impossible to unchain it. The
	only exception is "constructor". You don't need to define a
	method in order to supply a chaining hint.
	
	If a method is chained, it cannot use this.inherited() because
	all other methods in the hierarchy will be called automatically.
	
	Usually constructors and initializers of any kind are chained
	using "after" and destructors of any kind are chained as
	"before". Note that chaining assumes that chained methods do not
	return any value: any returned value will be discarded.</description>
        <examples>
          <example>	dojo.declare("my.classes.bar", my.classes.foo, {
			// properties to be added to the class prototype
			someValue: 2,
			// initialization function
			constructor: function(){
				this.myComplicatedObject = new ReallyComplicatedObject();
			},
			// other functions
			someMethod: function(){
				doStuff();
			}
		});</example>
          <example>	var MyBase = dojo.declare(null, {
			// constructor, properties, and methods go here
			// ...
		});
		var MyClass1 = dojo.declare(MyBase, {
			// constructor, properties, and methods go here
			// ...
		});
		var MyClass2 = dojo.declare(MyBase, {
			// constructor, properties, and methods go here
			// ...
		});
		var MyDiamond = dojo.declare([MyClass1, MyClass2], {
			// constructor, properties, and methods go here
			// ...
		});</example>
          <example>	var F = function(){ console.log("raw constructor"); };
		F.prototype.method = function(){
			console.log("raw method");
		};
		var A = dojo.declare(F, {
			constructor: function(){
				console.log("A.constructor");
			},
			method: function(){
				console.log("before calling F.method...");
				this.inherited(arguments);
				console.log("...back in A");
			}
		});
		new A().method();
		// will print:
		// raw constructor
		// A.constructor
		// before calling F.method...
		// raw method
		// ...back in A</example>
          <example>	var A = dojo.declare(null, {
			"-chains-": {
				destroy: "before"
			}
		});
		var B = dojo.declare(A, {
			constructor: function(){
				console.log("B.constructor");
			},
			destroy: function(){
				console.log("B.destroy");
			}
		});
		var C = dojo.declare(B, {
			constructor: function(){
				console.log("C.constructor");
			},
			destroy: function(){
				console.log("C.destroy");
			}
		});
		new C().destroy();
		// prints:
		// B.constructor
		// C.constructor
		// C.destroy
		// B.destroy</example>
          <example>	var A = dojo.declare(null, {
			"-chains-": {
				constructor: "manual"
			}
		});
		var B = dojo.declare(A, {
			constructor: function(){
				// ...
				// call the base constructor with new parameters
				this.inherited(arguments, [1, 2, 3]);
				// ...
			}
		});</example>
          <example>	var A = dojo.declare(null, {
			"-chains-": {
				m1: "before"
			},
			m1: function(){
				console.log("A.m1");
			},
			m2: function(){
				console.log("A.m2");
			}
		});
		var B = dojo.declare(A, {
			"-chains-": {
				m2: "after"
			},
			m1: function(){
				console.log("B.m1");
			},
			m2: function(){
				console.log("B.m2");
			}
		});
		var x = new B();
		x.m1();
		// prints:
		// B.m1
		// A.m1
		x.m2();
		// prints:
		// A.m2
		// B.m2</example>
        </examples>
        <parameters>
          <parameter name="className" type="String" usage="optional">
            <description>The optional name of the constructor (loosely, a &amp;quot;class&amp;quot;)
	stored in the &amp;quot;declaredClass&amp;quot; property in the created prototype.
	It will be used as a global name for a created constructor.</description>
          </parameter>
          <parameter name="superclass" type="Function|Array&lt;Function&gt;" usage="required">
            <description>May be null, a Function, or an Array of Functions. This argument
	specifies a list of bases (the left-most one is the most deepest
	base).</description>
          </parameter>
          <parameter name="props" type="Object" usage="required">
            <description>An object whose properties are copied to the created prototype.
	Add an instance-initialization function by making it a property
	named &amp;quot;constructor&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-description>New constructor function.</return-description>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <description>A DOM Element creation function. A shorthand method for creating a node or
	a fragment, and allowing for a convenient optional attribute setting step,
	as well as an optional DOM placement reference.
	
	Attributes are set by passing the optional object through `dojo.setAttr`.
	See `dojo.setAttr` for noted caveats and nuances, and API if applicable.
	
	Placement is done via `dojo.place`, assuming the new node to be the action
	node, passing along the optional reference node and position.</description>
        <examples>
          <example>Create a DIV:
		var n = dojo.create("div");</example>
          <example>Create a DIV with content:
		var n = dojo.create("div", { innerHTML:"&lt;p&gt;hi&lt;/p&gt;" });</example>
          <example>Place a new DIV in the BODY, with no attributes set
		var n = dojo.create("div", null, dojo.body());</example>
          <example>Create an UL, and populate it with LI's. Place the list as the first-child of a
	node with id="someId":
		var ul = dojo.create("ul", null, "someId", "first");
		var items = ["one", "two", "three", "four"];
		dojo.forEach(items, function(data){
			dojo.create("li", { innerHTML: data }, ul);
		});</example>
          <example>Create an anchor, with an href. Place in BODY:
		dojo.create("a", { href:"foo.html", title:"Goto FOO!" }, dojo.body());</example>
          <example>Create a `dojo.NodeList()` from a new element (for syntatic sugar):
		dojo.query(dojo.create('div'))
			.addClass("newDiv")
			.onclick(function(e){ console.log('clicked', e.target) })
			.place("#someNode"); // redundant, but cleaner.</example>
        </examples>
        <parameters>
          <parameter name="tag" type="DOMNode|String" usage="required">
            <description>A string of the element to create (eg: &amp;quot;div&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;li&amp;quot;, &amp;quot;script&amp;quot;, &amp;quot;br&amp;quot;),
	or an existing DOM node to process.</description>
          </parameter>
          <parameter name="attrs" type="Object" usage="required">
            <description>An object-hash of attributes to set on the newly created node.
	Can be null, if you don't want to set any attributes/styles.
	See: `dojo.setAttr` for a description of available attributes.</description>
          </parameter>
          <parameter name="refNode" type="DOMNode|String" usage="optional">
            <description>Optional reference node. Used by `dojo.place` to place the newly created
	node somewhere in the dom relative to refNode. Can be a DomNode reference
	or String ID of a node.</description>
          </parameter>
          <parameter name="pos" type="String" usage="optional">
            <description>Optional positional reference. Defaults to &amp;quot;last&amp;quot; by way of `dojo.place`,
	though can be set to &amp;quot;first&amp;quot;,&amp;quot;after&amp;quot;,&amp;quot;before&amp;quot;,&amp;quot;last&amp;quot;, &amp;quot;replace&amp;quot; or &amp;quot;only&amp;quot;
	to further control the placement of the new node relative to the refNode.
	'refNode' is required if a 'pos' is specified.</description>
          </parameter>
        </parameters>
        <return-description>DOMNode</return-description>
      </method>
      <method name="coords" scope="instance">
        <description>Returns an object that measures margin-box (w)idth/(h)eight
	and absolute position x/y of the border-box. Also returned
	is computed (l)eft and (t)op values in pixels from the
	node's offsetParent as returned from marginBox().
	Return value will be in the form:
				{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
	Does not act as a setter. If includeScroll is passed, the x and
	y params are affected as one would expect in dojo.position().</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="cookie" scope="instance">
        <description>If one argument is passed, returns the value of the cookie
	For two or more arguments, acts as a setter.</description>
        <examples>
          <example>set a cookie with the JSON-serialized contents of an object which
	will expire 5 days from now:
		dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });</example>
          <example>de-serialize a cookie back into a JavaScript object:
		var config = dojo.fromJson(dojo.cookie("configObj"));</example>
          <example>delete a cookie:
		dojo.cookie("configObj", null, {expires: -1});</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Name of the cookie</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>Value for the cookie</description>
          </parameter>
          <parameter name="props" type="dojo.__cookieProps" usage="optional">
            <description>Properties for the cookie</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="contentBox" scope="instance">
        <description>Returns an object in the expected format of box (regardless if box is passed).
	The object might look like:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	for a node offset from its parent 50px to the left, 200px from
	the top with a content width of 300px and a content-height of
	150px. Note that the content box may have a much larger border
	or margin box, depending on the box model currently in use and
	CSS values set/inherited for node.
	While the getter will return top and left values, the
	setter only accepts setting the width and height.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to DOM Node to get/set box for</description>
          </parameter>
          <parameter name="box" type="Object" usage="optional">
            <description>If passed, denotes that dojo.contentBox() should
	update/set the content box for node. Box is an object in the
	above format, but only w (width) and h (height) are supported.
	All properties are optional if passed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="connectPublisher" scope="instance">
        <examples>
          <example>	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");</example>
        </examples>
        <parameters>
          <parameter name="topic" type="String" usage="required">
            <description>The name of the topic to publish.</description>
          </parameter>
          <parameter name="obj" type="Object|null" usage="required">
            <description>The source object for the event function. Defaults to kernel.global
	if null.</description>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <description>The name of the event function in obj.
	I.e. identifies a property obj[event].</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <description>Connects listeners to actions, so that after event fires, a
	listener is called with the same arguments passed to the original
	function.
	
	Since `dojo.connect` allows the source of events to be either a
	"regular" JavaScript function or a DOM event, it provides a uniform
	interface for listening to all the types of events that an
	application is likely to deal with though a single, unified
	interface. DOM programmers may want to think of it as
	"addEventListener for everything and anything".
	
	When setting up a connection, the `event` parameter must be a
	string that is the name of the method/event to be listened for. If
	`obj` is null, `kernel.global` is assumed, meaning that connections
	to global methods are supported but also that you may inadvertently
	connect to a global by passing an incorrect object name or invalid
	reference.
	
	`dojo.connect` generally is forgiving. If you pass the name of a
	function or method that does not yet exist on `obj`, connect will
	not fail, but will instead set up a stub method. Similarly, null
	arguments may simply be omitted such that fewer than 4 arguments
	may be required to set up a connection See the examples for details.
	
	The return value is a handle that is needed to
	remove this connection with `dojo.disconnect`.</description>
        <examples>
          <example>When obj.onchange(), do ui.update():
		dojo.connect(obj, "onchange", ui, "update");
		dojo.connect(obj, "onchange", ui, ui.update); // same</example>
          <example>Using return value for disconnect:
		var link = dojo.connect(obj, "onchange", ui, "update");
		...
		dojo.disconnect(link);</example>
          <example>When onglobalevent executes, watcher.handler is invoked:
		dojo.connect(null, "onglobalevent", watcher, "handler");</example>
          <example>When ob.onCustomEvent executes, customEventHandler is invoked:
		dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same</example>
          <example>When ob.onCustomEvent executes, customEventHandler is invoked
	with the same scope (this):
		dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		dojo.connect(ob, "onCustomEvent", customEventHandler); // same</example>
          <example>When globalEvent executes, globalHandler is invoked
	with the same scope (this):
		dojo.connect(null, "globalEvent", null, globalHandler);
		dojo.connect("globalEvent", globalHandler); // same</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required">
            <description>The source object for the event function.
	Defaults to `kernel.global` if null.
	If obj is a DOM node, the connection is delegated
	to the DOM event manager (unless dontFix is true).</description>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <description>String name of the event function in obj.
	I.e. identifies a property `obj[event]`.</description>
          </parameter>
          <parameter name="context" type="Object|null" usage="required">
            <description>The object that method will receive as &amp;quot;this&amp;quot;.
	
	If context is null and method is a function, then method
	inherits the context of event.
	
	If method is a string then context must be the source
	object object for method (context[method]). If context is null,
	kernel.global is used.</description>
          </parameter>
          <parameter name="method" type="String|Function" usage="required">
            <description>A function reference, or name of a function in context.
	The function identified by method fires after event does.
	method receives the same arguments as the event.
	See context argument comments for information on method's scope.</description>
          </parameter>
          <parameter name="dontFix" type="Boolean" usage="optional">
            <description>If obj is a DOM node, set dontFix to true to prevent delegation
	of this connection to the DOM event manager.</description>
          </parameter>
        </parameters>
      </method>
      <method name="colorFromString" scope="instance">
        <description>Acceptable input values for str may include arrays of any form
	accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
	rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
	10, 50)"</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromRgb" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromHex" scope="instance">
        <examples>
          <example> var thing = dojo.colorFromHex("#ededed"); // grey, longhand</example>
          <example> var thing = dojo.colorFromHex("#000"); // black, shorthand</example>
        </examples>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromArray" scope="instance">
        <examples>
          <example> var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha</example>
        </examples>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="src" type="The" usage="required">
            <description>object to clone</description>
          </parameter>
        </parameters>
      </method>
      <method name="cache" scope="instance">
        <description>If module is a string that contains slashes, then it is interpretted as a fully
	resolved path (typically a result returned by require.toUrl), and url should not be
	provided. This is the preferred signature. If module is a string that does not
	contain slashes, then url must also be provided and module and url are used to
	call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
	If value is specified, the cache value for the moduleUrl will be set to
	that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
	in its internal cache and return that cached value for the URL. To clear
	a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
	the URL contents, only modules on the same domain of the page can use this capability.
	The build system can inline the cache values though, to allow for xdomain hosting.</description>
        <examples>
          <example>To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
	of call is used to avoid an issue with the build system erroneously trying to intern
	this example. To get the build system to intern your dojo.cache calls, use the
	"dojo.cache" style of call):
	 //If template.html contains "&lt;h1&gt;Hello&lt;/h1&gt;" that will be
	 //the value for the text variable.
	 var text = dojo["cache"]("my.module", "template.html");</example>
          <example>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
	(the dojo["cache"] style of call is used to avoid an issue with the build system
	erroneously trying to intern this example. To get the build system to intern your
	dojo.cache calls, use the "dojo.cache" style of call):
	 //If template.html contains "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;", the
	 //text variable will contain just "&lt;h1&gt;Hello&lt;/h1&gt;".
	 var text = dojo["cache"]("my.module", "template.html", {sanitize: true});</example>
          <example>Same example as previous, but demostrates how an object can be passed in as
	the first argument, then the value argument can then be the second argument.
	 //If template.html contains "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;", the
	 //text variable will contain just "&lt;h1&gt;Hello&lt;/h1&gt;".
	 var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});</example>
        </examples>
        <parameters>
          <parameter name="module" type="String|Object" usage="required">
            <description>If a String with slashes, a fully resolved path; if a String without slashes, the
	module name to use for the base part of the URL, similar to module argument
	to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
	generates a valid path for the cache item. For example, a dojo._Url object.</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>The rest of the path to append to the path derived from the module argument. If
	module is an object, then this second argument should be the &amp;quot;value&amp;quot; argument instead.</description>
          </parameter>
          <parameter name="value" type="String|Object" usage="optional">
            <description>If a String, the value to use in the cache for the module/url combination.
	If an Object, it can have two properties: value and sanitize. The value property
	should be the value to use in the cache, and sanitize can be set to true or false,
	to indicate if XML declarations should be removed from the value and if the HTML
	inside a body tag in the value should be extracted as the real value. The value argument
	or the value property on the value argument are usually only used by the build system
	as it inlines cache content.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="byId" scope="instance">
        <examples>
          <example>Look up a node by ID:
		var n = dojo.byId("foo");</example>
          <example>Check if a node exists, and use it.
		var n = dojo.byId("bar");
		if(n){ doStuff() ... }</example>
          <example>Allow string or DomNode references to be passed to a custom function:
		var foo = function(nodeOrId){
			nodeOrId = dojo.byId(nodeOrId);
			// ... more stuff
		}</example>
        </examples>
        <parameters>
          <parameter name="id" type="String|DOMNode" usage="required">
            <description>A string to match an HTML id attribute or a reference to a DOM Node</description>
          </parameter>
          <parameter name="doc" type="Document" usage="optional">
            <description>Document to work in. Defaults to the current value of
	dojo.doc.  Can be used to retrieve
	node references from other documents.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="body" scope="instance">
        <examples>
          <example>	dojo.body().appendChild(dojo.doc.createElement('div'));</example>
        </examples>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="blendColors" scope="instance">
        <parameters>
          <parameter name="start" type="dojo.Color" usage="required"/>
          <parameter name="end" type="dojo.Color" usage="required"/>
          <parameter name="weight" type="Number" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="behavior" scope="instance">
        <description>A very simple, lightweight mechanism for applying code to
	existing documents, based around `dojo.query` (CSS3 selectors) for node selection,
	and a simple two-command API: `dojo.behavior.add()` and `dojo.behavior.apply()`;
	
	Behaviors apply to a given page, and are registered following the syntax
	options described by `dojo.behavior.add` to match nodes to actions, or "behaviors".
	
	Added behaviors are applied to the current DOM when .apply() is called,
	matching only new nodes found since .apply() was last called.</description>
      </method>
      <method name="attr" scope="instance">
        <description>Handles normalized getting and setting of attributes on DOM
	Nodes. If 2 arguments are passed, and a the second argument is a
	string, acts as a getter.
	
	If a third argument is passed, or if the second argument is a
	map of attributes, acts as a setter.
	
	When passing functions as values, note that they will not be
	directly assigned to slots on the node, but rather the default
	behavior will be removed and the new behavior will be added
	using `dojo.connect()`, meaning that event handler properties
	will be normalized and that some caveats with regards to
	non-standard behaviors for onsubmit apply. Namely that you
	should cancel form submission using `dojo.stopEvent()` on the
	passed event object instead of returning a boolean value from
	the handler itself.</description>
        <examples>
          <example>	// get the current value of the "foo" attribute on a node
		dojo.attr(dojo.byId("nodeId"), "foo");
		// or we can just pass the id:
		dojo.attr("nodeId", "foo");</example>
          <example>	// use attr() to set the tab index
		dojo.attr("nodeId", "tabIndex", 3);</example>
          <example>Set multiple values at once, including event handlers:
		dojo.attr("formId", {
			"foo": "bar",
			"tabIndex": -1,
			"method": "POST",
			"onsubmit": function(e){
				// stop submitting the form. Note that the IE behavior
				// of returning true or false will have no effect here
				// since our handler is connect()ed to the built-in
				// onsubmit behavior and so we need to use
				// dojo.stopEvent() to ensure that the submission
				// doesn't proceed.
				dojo.stopEvent(e);
	
				// submit the form with Ajax
				dojo.xhrPost({ form: "formId" });
			}
		});</example>
          <example>Style is s special case: Only set with an object hash of styles
		dojo.attr("someNode",{
			id:"bar",
			style:{
				width:"200px", height:"100px", color:"#000"
			}
		});</example>
          <example>Again, only set style as an object hash of styles:
		var obj = { color:"#fff", backgroundColor:"#000" };
		dojo.attr("someNode", "style", obj);
	
		// though shorter to use `dojo.style()` in this case:
		dojo.style("someNode", obj);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to the element to get or set the attribute on</description>
          </parameter>
          <parameter name="name" type="String|Object" usage="required">
            <description>the name of the attribute to get or set.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>The value to set for the attribute</description>
          </parameter>
        </parameters>
        <return-description>when used as a getter, the value of the requested attribute
	or null if that attribute does not have a specified or
	default value;
	
	when used as a setter, the DOM node</return-description>
      </method>
      <method name="animateProperty" scope="instance">
        <description>`dojo.animateProperty` is the foundation of most `dojo.fx`
	animations. It takes an object of "properties" corresponding to
	style properties, and animates them in parallel over a set
	duration.</description>
        <examples>
          <example>A simple animation that changes the width of the specified node.
		dojo.animateProperty({
			node: "nodeId",
			properties: { width: 400 },
		}).play();
	Dojo figures out the start value for the width and converts the
	integer specified for the width to the more expressive but
	verbose form `{ width: { end: '400', units: 'px' } }` which you
	can also specify directly. Defaults to 'px' if ommitted.</example>
          <example>Animate width, height, and padding over 2 seconds... the
	pedantic way:
		dojo.animateProperty({ node: node, duration:2000,
			properties: {
				width: { start: '200', end: '400', units:"px" },
				height: { start:'200', end: '400', units:"px" },
				paddingTop: { start:'5', end:'50', units:"px" }
			}
		}).play();
	Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
	are written using "mixed case", as the hyphen is illegal as an object key.</example>
          <example>Plug in a different easing function and register a callback for
	when the animation ends. Easing functions accept values between
	zero and one and return a value on that basis. In this case, an
	exponential-in curve.
		dojo.animateProperty({
			node: "nodeId",
			// dojo figures out the start value
			properties: { width: { end: 400 } },
			easing: function(n){
				return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
			},
			onEnd: function(node){
				// called when the animation finishes. The animation
				// target is passed to this function
			}
		}).play(500); // delay playing half a second</example>
          <example>Like all `dojo.Animation`s, animateProperty returns a handle to the
	Animation instance, which fires the events common to Dojo FX. Use `dojo.connect`
	to access these events outside of the Animation definiton:
		var anim = dojo.animateProperty({
			node:"someId",
			properties:{
				width:400, height:500
			}
		});
		dojo.connect(anim,"onEnd", function(){
			console.log("animation ended");
		});
		// play the animation now:
		anim.play();</example>
          <example>Each property can be a function whose return value is substituted along.
	Additionally, each measurement (eg: start, end) can be a function. The node
	reference is passed direcly to callbacks.
		dojo.animateProperty({
			node:"mine",
			properties:{
				height:function(node){
					// shrink this node by 50%
					return dojo.position(node).h / 2
				},
				width:{
					start:function(node){ return 100; },
					end:function(node){ return 200; }
				}
			}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="dojo.__AnimArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="anim" scope="instance">
        <description>`dojo.anim` is a simpler (but somewhat less powerful) version
	of `dojo.animateProperty`.  It uses defaults for many basic properties
	and allows for positional parameters to be used in place of the
	packed "property bag" which is used for other Dojo animation
	methods.
	
	The `dojo.Animation` object returned from `dojo.anim` will be
	already playing when it is returned from this function, so
	calling play() on it again is (usually) a no-op.</description>
        <examples>
          <example>Fade out a node
		dojo.anim("id", { opacity: 0 });</example>
          <example>Fade out a node over a full second
		dojo.anim("id", { opacity: 0 }, 1000);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>a DOM node or the id of a node to animate CSS properties on</description>
          </parameter>
          <parameter name="properties" type="Object" usage="required"/>
          <parameter name="duration" type="Integer" usage="optional">
            <description>The number of milliseconds over which the animation
	should run. Defaults to the global animation default duration
	(350ms).</description>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <description>An easing function over which to calculate acceleration
	and deceleration of the animation through its duration.
	A default easing algorithm is provided, but you may
	plug in any you wish. A large selection of easing algorithms
	are available in `dojo.fx.easing`.</description>
          </parameter>
          <parameter name="onEnd" type="Function" usage="optional">
            <description>A function to be called when the animation finishes
	running.</description>
          </parameter>
          <parameter name="delay" type="Integer" usage="optional">
            <description>The number of milliseconds to delay beginning the
	animation by. The default is 0.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="addOnWindowUnload" scope="instance">
        <description>The first time that addOnWindowUnload is called Dojo
	will register a page listener to trigger your unload
	handler with. Note that registering these handlers may
	destory "fastback" page caching in browsers that support
	it. Be careful trying to modify the DOM or access
	JavaScript properties during this phase of page unloading:
	they may not always be available. Consider
	dojo.addOnUnload() if you need to modify the DOM or do
	heavy JavaScript work since it fires at the eqivalent of
	the page's "onbeforeunload" event.</description>
        <examples>
          <example>	dojo.addOnWindowUnload(functionPointer)
		dojo.addOnWindowUnload(object, "functionName")
		dojo.addOnWindowUnload(object, function(){ /* ... */});</example>
          <example> dojo.addOnWindowUnload(functionPointer)
	 dojo.addOnWindowUnload(object, "functionName");
	 dojo.addOnWindowUnload(object, function(){ /* ... */});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="optional"/>
          <parameter name="functionName" type="String|Function" usage="optional"/>
        </parameters>
      </method>
      <method name="addOnUnload" scope="instance">
        <description>The first time that addOnUnload is called Dojo will
	register a page listener to trigger your unload handler
	with.
	
	In a browser enviroment, the functions will be triggered
	during the window.onbeforeunload event. Be careful of doing
	too much work in an unload handler. onbeforeunload can be
	triggered if a link to download a file is clicked, or if
	the link is a javascript: link. In these cases, the
	onbeforeunload event fires, but the document is not
	actually destroyed. So be careful about doing destructive
	operations in a dojo.addOnUnload callback.
	
	Further note that calling dojo.addOnUnload will prevent
	browsers from using a "fast back" cache to make page
	loading via back button instantaneous.</description>
        <examples>
          <example> dojo.addOnUnload(functionPointer)
	 dojo.addOnUnload(object, "functionName")
	 dojo.addOnUnload(object, function(){ /* ... */});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|Function" usage="optional"/>
          <parameter name="functionName" type="String|Function" usage="optional"/>
        </parameters>
      </method>
      <method name="addOnLoad" scope="instance">
        <examples>
          <example>Simple DOM and Modules ready syntax
		dojo.ready(function(){ alert("Dom ready!"); });</example>
          <example>Using a priority
		dojo.ready(2, function(){ alert("low priority ready!"); })</example>
          <example>Using context
		dojo.ready(foo, function(){
			// in here, this == foo
		})</example>
          <example>Using dojo.hitch style args:
		var foo = { dojoReady: function(){ console.warn(this, "dojo dom and modules ready."); } };
		dojo.ready(foo, "dojoReady");</example>
        </examples>
        <parameters>
          <parameter name="priority" type="Integer" usage="optional">
            <description>The order in which to exec this callback relative to other callbacks, defaults to 1000</description>
          </parameter>
          <parameter name="context" type="Object|Function" usage="optional">
            <description>The context in which to run execute callback, or a callback if not using context</description>
          </parameter>
          <parameter name="callback" type="Function" usage="optional">
            <description>The function to execute.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addClass" scope="instance">
        <examples>
          <example>Add a class to some node:
		dojo.addClass("someNode", "anewClass");</example>
          <example>Add two classes at once:
		dojo.addClass("someNode", "firstClass secondClass");</example>
          <example>Add two classes at once (using array):
		dojo.addClass("someNode", ["firstClass", "secondClass"]);</example>
          <example>Available in `dojo.NodeList` for multiple additions
		dojo.query("ul &gt; li").addClass("firstLevel");</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DOMNode" usage="required">
            <description>String ID or DomNode reference to add a class string too</description>
          </parameter>
          <parameter name="classStr" type="String|Array" usage="required">
            <description>A String class name to add, or several space-separated class names,
	or an array of class names.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_xhrObj" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toPixelValue" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toDom" scope="instance">
        <parameters>
          <parameter name="frag" type="Object" usage="required"/>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toArray" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>the object to &amp;quot;arrayify&amp;quot;. We expect the object to have, at a
	minimum, a length property which corresponds to integer-indexed
	properties.</description>
          </parameter>
          <parameter name="offset" type="Number" usage="optional">
            <description>the location in obj to start iterating from. Defaults to 0.
	Optional.</description>
          </parameter>
          <parameter name="startWith" type="Array" usage="optional">
            <description>An array to pack with the properties of obj. If provided,
	properties in obj are appended at the end of startWith and
	startWith is the returned array.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_spidermonkeyCurrentFile" scope="instance">
        <parameters>
          <parameter name="depth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeNodeData" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>The node reference to remove data from</description>
          </parameter>
          <parameter name="key" type="String" usage="optional">
            <description>If omitted, remove all data in this dataset.
	If passed, remove only the passed `key` in the associated dataset</description>
          </parameter>
        </parameters>
      </method>
      <method name="_nodeData" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>The node to associate data with</description>
          </parameter>
          <parameter name="key" type="Object|String" usage="optional">
            <description>If an object, act as a setter and iterate over said object setting data items as defined.
	If a string, and `value` present, set the data for defined `key` to `value`
	If a string, and `value` absent, act as a getter, returning the data associated with said `key`</description>
          </parameter>
          <parameter name="value" type="Anything" usage="optional">
            <description>The value to set for said `key`, provided `key` is a string (and not an object)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Anything"/>
          <return-type type="Nothing"/>
        </return-types>
      </method>
      <method name="_mixin" scope="instance">
        <description>All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
	found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
	delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
	Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.</description>
        <parameters>
          <parameter name="dest" type="Object" usage="required">
            <description>The object to which to copy/add all properties contained in source.</description>
          </parameter>
          <parameter name="source" type="Object" usage="required">
            <description>The object from which to draw all properties to copy into dest.</description>
          </parameter>
          <parameter name="copyFunc" type="Function" usage="optional">
            <description>The process used to copy/add a property in source; defaults to the Javascript assignment operator.</description>
          </parameter>
        </parameters>
        <return-description>dest, as modified</return-description>
      </method>
      <method name="_loadUri" scope="instance">
        <parameters>
          <parameter name="uri" type="Object" usage="required"/>
          <parameter name="cb" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadInit" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isDocumentOk" scope="instance">
        <parameters>
          <parameter name="http" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_isBodyLtr" scope="instance"/>
      <method name="_ioWatch" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required">
            <description>The Deferred object to watch.</description>
          </parameter>
          <parameter name="validCheck" type="Function" usage="required">
            <description>Function used to check if the IO request is still valid. Gets the dfd
	object as its only argument.</description>
          </parameter>
          <parameter name="ioCheck" type="Function" usage="required">
            <description>Function used to check if basic IO call worked. Gets the dfd
	object as its only argument.</description>
          </parameter>
          <parameter name="resHandle" type="Function" usage="required">
            <description>Function used to process response. Gets the dfd
	object as its only argument.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_ioSetArgs" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__IoArgs" usage="required">
            <description>The args object passed into the public io call. Recognized properties on
	the args object are:</description>
          </parameter>
          <parameter name="canceller" type="Function" usage="required">
            <description>The canceller function used for the Deferred object. The function
	will receive one argument, the Deferred object that is related to the
	canceller.</description>
          </parameter>
          <parameter name="okHandler" type="Function" usage="required">
            <description>The first OK callback to be registered with Deferred. It has the opportunity
	to transform the OK response. It will receive one argument -- the Deferred
	object returned from this function.</description>
          </parameter>
          <parameter name="errHandler" type="Function" usage="required">
            <description>The first error callback to be registered with Deferred. It has the opportunity
	to do cleanup on an error. It will receive two arguments: error (the
	Error object) and dfd, the Deferred object returned from this function.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_ioNotifyStart" scope="instance">
        <description>Used by IO transports. An IO transport should
	call this method before making the network connection.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioCancelAll" scope="instance"/>
      <method name="_ioAddQueryToUrl" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_inContext" scope="instance">
        <parameters>
          <parameter name="g" type="Object" usage="required"/>
          <parameter name="d" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getText" scope="instance">
        <parameters>
          <parameter name="uri" type="URI" usage="required">
            <description>A relative or absolute uri. If absolute, it still must be in
	the same &amp;quot;domain&amp;quot; as we are.</description>
          </parameter>
          <parameter name="fail_ok" type="Boolean" usage="required">
            <description>Default false. If fail_ok and loading fails, return null
	instead of throwing.</description>
          </parameter>
        </parameters>
        <return-description>The response text. null is returned when there is a
	failure and failure is okay (an exception otherwise)</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getPadExtents" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPadBorderExtents" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginSize" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginExtents" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginBox" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getIeDocumentElementOffset" scope="instance"/>
      <method name="_getContentBox" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderExtents" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_gcNodeData" scope="instance">
        <description>super expensive: GC all data in the data for nodes that no longer exist in the dom.
	MUCH safer to do this yourself, manually, on a per-node basis (via `NodeList.removeData()`)
	provided as a stop-gap for exceptionally large/complex applications with constantly changing
	content regions (eg: a dijit.layout.ContentPane with replacing data)
	There is NO automatic GC going on. If you dojo.destroy() a node, you should _removeNodeData
	prior to destruction.</description>
      </method>
      <method name="_fixIeBiDiScrollLeft" scope="instance">
        <parameters>
          <parameter name="scrollLeft" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_filterQueryResult" scope="instance"/>
      <method name="_fade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_escapeString" scope="instance"/>
      <method name="_docScroll" scope="instance"/>
      <method name="_destroyElement" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultEasing" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
      <method name="_connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="dontFix" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__cookieProps" scope="instance"/>
      <method name="__backArgs" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__XhrArgs" scope="instance"/>
      <method name="__IoPublish" scope="instance"/>
      <method name="__IoCallbackArgs" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>the original object argument to the IO call.</description>
          </parameter>
          <parameter name="xhr" type="XMLHttpRequest" usage="required">
            <description>For XMLHttpRequest calls only, the
	XMLHttpRequest object that was used for the
	request.</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>The final URL used for the call. Many times it
	will be different than the original args.url
	value.</description>
          </parameter>
          <parameter name="query" type="String" usage="required">
            <description>For non-GET requests, the
	name1=value1&amp;amp;name2=value2 parameters sent up in
	the request.</description>
          </parameter>
          <parameter name="handleAs" type="String" usage="required">
            <description>The final indicator on how the response will be
	handled.</description>
          </parameter>
          <parameter name="id" type="String" usage="required">
            <description>For dojo.io.script calls only, the internal
	script ID used for the request.</description>
          </parameter>
          <parameter name="canDelete" type="Boolean" usage="required">
            <description>For dojo.io.script calls only, indicates
	whether the script tag that represents the
	request can be deleted after callbacks have
	been called. Used internally to know when
	cleanup can happen on JSONP-type requests.</description>
          </parameter>
          <parameter name="json" type="Object" usage="required">
            <description>For dojo.io.script calls only: holds the JSON
	response for JSONP-type requests. Used
	internally to hold on to the JSON responses.
	You should not need to access it directly --
	the same object should be passed to the success
	callbacks directly.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__IoArgs" scope="instance"/>
      <method name="__FadeArgs" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>The node referenced in the animation</description>
          </parameter>
          <parameter name="duration" type="Integer" usage="optional">
            <description>Duration of the animation in milliseconds.</description>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <description>An easing function.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__AnimArgs" scope="instance"/>
      <method name="_Line" scope="instance">
        <parameters>
          <parameter name="start" type="int" usage="required">
            <description>Beginning value for range</description>
          </parameter>
          <parameter name="end" type="int" usage="required">
            <description>Ending value for range</description>
          </parameter>
        </parameters>
      </method>
      <method name="Stateful" scope="instance">
        <examples>
          <example>	var obj = new dojo.Stateful();
		obj.watch("foo", function(){
			console.log("foo changed to " + this.get("foo"));
		});
		obj.set("foo","bar");</example>
        </examples>
        <parameters>
          <parameter name="mixin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Nodelist" scope="instance"/>
      <method name="NodeList" scope="instance">
        <description>dojo.NodeList instances provide many utilities that reflect
	core Dojo APIs for Array iteration and manipulation, DOM
	manipulation, and event handling. Instead of needing to dig up
	functions in the dojo.* namespace, NodeLists generally make the
	full power of Dojo available for DOM manipulation tasks in a
	simple, chainable way.</description>
        <examples>
          <example>create a node list from a node
		new dojo.NodeList(dojo.byId("foo"));</example>
          <example>get a NodeList from a CSS query and iterate on it
		var l = dojo.query(".thinger");
		l.forEach(function(node, index, nodeList){
			console.log(index, node.innerHTML);
		});</example>
          <example>use native and Dojo-provided array methods to manipulate a
	NodeList without needing to use dojo.* functions explicitly:
		var l = dojo.query(".thinger");
		// since NodeLists are real arrays, they have a length
		// property that is both readable and writable and
		// push/pop/shift/unshift methods
		console.log(l.length);
		l.push(dojo.create("span"));
	
		// dojo's normalized array methods work too:
		console.log( l.indexOf(dojo.byId("foo")) );
		// ...including the special "function as string" shorthand
		console.log( l.every("item.nodeType == 1") );
	
		// NodeLists can be [..] indexed, or you can use the at()
		// function to get specific items wrapped in a new NodeList:
		var node = l[3]; // the 4th element
		var newList = l.at(1, 3); // the 2nd and 4th elements</example>
          <example>the style functions you expect are all there too:
		// style() as a getter...
		var borders = dojo.query(".thinger").style("border");
		// ...and as a setter:
		dojo.query(".thinger").style("border", "1px solid black");
		// class manipulation
		dojo.query("li:nth-child(even)").addClass("even");
		// even getting the coordinates of all the items
		var coords = dojo.query(".thinger").coords();</example>
          <example>DOM manipulation functions from the dojo.* namespace area also
	available:
		// remove all of the elements in the list from their
		// parents (akin to "deleting" them from the document)
		dojo.query(".thinger").orphan();
		// place all elements in the list at the front of #foo
		dojo.query(".thinger").place("foo", "first");</example>
          <example>Event handling couldn't be easier. `dojo.connect` is mapped in,
	and shortcut handlers are provided for most DOM events:
		// like dojo.connect(), but with implicit scope
		dojo.query("li").connect("onclick", console, "log");
	
		// many common event handlers are already available directly:
		dojo.query("li").onclick(console, "log");
		var toggleHovered = dojo.hitch(dojo, "toggleClass", "hovered");
		dojo.query("p")
			.onmouseenter(toggleHovered)
			.onmouseleave(toggleHovered);</example>
          <example>chainability is a key advantage of NodeLists:
		dojo.query(".thinger")
			.onclick(function(e){ /* ... */ })
			.at(1, 3, 8) // get a subset
				.style("padding", "5px")
				.forEach(console.log);</example>
        </examples>
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DeferredList" scope="instance">
        <description>DeferredList takes an array of existing deferreds and returns a new deferred of its own
	this new deferred will typically have its callback fired when all of the deferreds in
	the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	fireOnOneErrback, will fire before all the deferreds as appropriate</description>
        <parameters>
          <parameter name="list" type="Array" usage="required">
            <description>The list of deferreds to be synchronizied with this DeferredList</description>
          </parameter>
          <parameter name="fireOnOneCallback" type="Boolean" usage="optional">
            <description>Will cause the DeferredLists callback to be fired as soon as any
	of the deferreds in its list have been fired instead of waiting until
	the entire list has finished
	fireonOneErrback:
	Will cause the errback to fire upon any of the deferreds errback</description>
          </parameter>
          <parameter name="fireOnOneErrback" type="Boolean" usage="optional"/>
          <parameter name="consumeErrors" type="Boolean" usage="optional"/>
          <parameter name="canceller" type="Function" usage="optional">
            <description>A deferred canceller function, see dojo.Deferred</description>
          </parameter>
        </parameters>
      </method>
      <method name="Deferred" scope="instance">
        <description>The dojo.Deferred API is based on the concept of promises that provide a
	generic interface into the eventual completion of an asynchronous action.
	The motivation for promises fundamentally is about creating a
	separation of concerns that allows one to achieve the same type of
	call patterns and logical data flow in asynchronous code as can be
	achieved in synchronous code. Promises allows one
	to be able to call a function purely with arguments needed for
	execution, without conflating the call with concerns of whether it is
	sync or async. One shouldn't need to alter a call's arguments if the
	implementation switches from sync to async (or vice versa). By having
	async functions return promises, the concerns of making the call are
	separated from the concerns of asynchronous interaction (which are
	handled by the promise).
	
	The dojo.Deferred is a type of promise that provides methods for fulfilling the
	promise with a successful result or an error. The most important method for
	working with Dojo's promises is the then() method, which follows the
	CommonJS proposed promise API. An example of using a Dojo promise:
	
		var resultingPromise = someAsyncOperation.then(function(result){
			... handle result ...
		},
		function(error){
			... handle error ...
		});
	
	The .then() call returns a new promise that represents the result of the
	execution of the callback. The callbacks will never affect the original promises value.
	
	The dojo.Deferred instances also provide the following functions for backwards compatibility:
	
	* addCallback(handler)
	* addErrback(handler)
	* callback(result)
	* errback(result)
	
	Callbacks are allowed to return promises themselves, so
	you can build complicated sequences of events with ease.
	
	The creator of the Deferred may specify a canceller.  The canceller
	is a function that will be called if Deferred.cancel is called
	before the Deferred fires. You can use this to implement clean
	aborting of an XMLHttpRequest, etc. Note that cancel will fire the
	deferred with a CancelledError (unless your canceller returns
	another kind of error), so the errbacks should be prepared to
	handle that error for cancellable Deferreds.</description>
        <examples>
          <example>	var deferred = new dojo.Deferred();
		setTimeout(function(){ deferred.callback({success: true}); }, 1000);
		return deferred;</example>
          <example>Deferred objects are often used when making code asynchronous. It
	may be easiest to write functions in a synchronous manner and then
	split code using a deferred to trigger a response to a long-lived
	operation. For example, instead of register a callback function to
	denote when a rendering operation completes, the function can
	simply return a deferred:
	
		// callback style:
		function renderLotsOfData(data, callback){
			var success = false
			try{
				for(var x in data){
					renderDataitem(data[x]);
				}
				success = true;
			}catch(e){ }
			if(callback){
				callback(success);
			}
		}
	
		// using callback style
		renderLotsOfData(someDataObj, function(success){
			// handles success or failure
			if(!success){
				promptUserToRecover();
			}
		});
		// NOTE: no way to add another callback here!!</example>
          <example>Using a Deferred doesn't simplify the sending code any, but it
	provides a standard interface for callers and senders alike,
	providing both with a simple way to service multiple callbacks for
	an operation and freeing both sides from worrying about details
	such as "did this get called already?". With Deferreds, new
	callbacks can be added at any time.
	
		// Deferred style:
		function renderLotsOfData(data){
			var d = new dojo.Deferred();
			try{
				for(var x in data){
					renderDataitem(data[x]);
				}
				d.callback(true);
			}catch(e){
				d.errback(new Error("rendering failed"));
			}
			return d;
		}
	
		// using Deferred style
		renderLotsOfData(someDataObj).then(null, function(){
			promptUserToRecover();
		});
		// NOTE: addErrback and addCallback both return the Deferred
		// again, so we could chain adding callbacks or save the
		// deferred for later should we need to be notified again.</example>
          <example>In this example, renderLotsOfData is synchronous and so both
	versions are pretty artificial. Putting the data display on a
	timeout helps show why Deferreds rock:
	
		// Deferred style and async func
		function renderLotsOfData(data){
			var d = new dojo.Deferred();
			setTimeout(function(){
				try{
					for(var x in data){
						renderDataitem(data[x]);
					}
					d.callback(true);
				}catch(e){
					d.errback(new Error("rendering failed"));
				}
			}, 100);
			return d;
		}
	
		// using Deferred style
		renderLotsOfData(someDataObj).then(null, function(){
			promptUserToRecover();
		});
	
	Note that the caller doesn't have to change his code at all to
	handle the asynchronous case.</example>
        </examples>
        <parameters>
          <parameter name="canceller" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="Color" scope="instance">
        <examples>
          <example>Work with a Color instance:
	 var c = new dojo.Color();
	 c.setColor([0,0,0]); // black
	 var hex = c.toHex(); // #000000</example>
          <example>Work with a node's color:
	 var color = dojo.style("someNode", "backgroundColor");
	 var n = new dojo.Color(color);
	 // adjust the color some
	 n.r *= .5;
	 console.log(n.toString()); // rgb(128, 255, 255);</example>
        </examples>
        <parameters>
          <parameter name="color" type="Array|String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="Animation" scope="instance">
        <description>A generic animation class that fires callbacks into its handlers
	object at various states. Nearly all dojo animation functions
	return an instance of this method, usually without calling the
	.play() method beforehand. Therefore, you will likely need to
	call .play() on instances of `dojo.Animation` when one is
	returned.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>The 'magic argument', mixing all the properties into this
	animation instance.</description>
          </parameter>
        </parameters>
      </method>
      <method name="AdapterRegistry" scope="instance">
        <description>Objects of this class keep list of arrays in the form [name, check,
	wrap, directReturn] that are used to determine what the contextual
	result of a set of checked arguments is. All check/wrap functions
	in this registry should be of the same arity.</description>
        <examples>
          <example>	// create a new registry
		var reg = new dojo.AdapterRegistry();
		reg.register("handleString",
			dojo.isString,
			function(str){
				// do something with the string here
			}
		);
		reg.register("handleArr",
			dojo.isArray,
			function(arr){
				// do something with the array here
			}
		);
	
		// now we can pass reg.match() *either* an array or a string and
		// the value we pass will get handled by the right function
		reg.match("someValue"); // will call the first function
		reg.match(["someValue"]); // will call the second</example>
        </examples>
        <parameters>
          <parameter name="returnWrappers" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="array" scope="instance"/>
    </mixins>
    <properties>
      <property name="window" scope="instance" type="Object">
        <description>TODO</description>
      </property>
      <property name="touch" scope="instance" type="Object">
        <description>This module provides unified touch event handlers by exporting
	press, move, release and cancel which can also run well on desktop.
	Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html</description>
      </property>
      <property name="string" scope="instance" type="Object">
        <description>String utilities for Dojo</description>
      </property>
      <property name="store" scope="instance" type="Object"/>
      <property name="selector" scope="instance" type="Object"/>
      <property name="rpc" scope="instance" type="Object">
        <description>Dojo remote-procedure-call resources</description>
      </property>
      <property name="regexp" scope="instance" type="Object">
        <description>Regular expressions and Builder resources</description>
      </property>
      <property name="number" scope="instance" type="Object">
        <description>localized formatting and parsing routines for Number</description>
      </property>
      <property name="mouseButtons" scope="instance" type="Object"/>
      <property name="keys" scope="instance" type="Object">
        <description>Definitions for common key values
	
	
	the apple key on macs
	
	
	virtual key mapping</description>
      </property>
      <property name="io" scope="instance" type="Object">
        <description>Additional I/O transports (Ajax)</description>
      </property>
      <property name="html" scope="instance" type="Object"/>
      <property name="global" scope="instance" type="Object"/>
      <property name="gears" scope="instance" type="Object"/>
      <property name="fx" scope="instance" type="Object">
        <description>Effects library on top of Base animations</description>
      </property>
      <property name="dnd" scope="instance" type="Object">
        <description>Drag and Drop resources</description>
      </property>
      <property name="date" scope="instance" type="Object">
        <description>Date manipulation utilities</description>
      </property>
      <property name="data" scope="instance" type="Object">
        <description>A uniform data access layer</description>
      </property>
      <property name="currency" scope="instance" type="Object">
        <description>localized formatting and parsing routines for currencies</description>
      </property>
      <property name="contentHandlers" scope="instance" type="Object">
        <description>A map of availble XHR transport handle types. Name matches the
	`handleAs` attribute passed to XHR calls.</description>
      </property>
      <property name="config" scope="instance" type="Object"/>
      <property name="cldr" scope="instance" type="Object">
        <description>transformation of relevant pieces of the Unicode.org Common Locale Data Repository
	(see http://unicode.org/cldr) to JSON from the original XML with associated utility classes</description>
      </property>
      <property name="back" scope="instance" type="Object">
        <description>Browser history management resources</description>
      </property>
      <property name="aspect" scope="instance" type="Object">
        <description>provides aspect oriented programming functionality, allowing for
	one to add before, around, or after advice on existing methods.</description>
      </property>
      <property name="_firebug" scope="instance" type="Object"/>
      <property name="_extraNames" scope="instance" type="Object"/>
      <property name="_contentHandlers" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Stateful">
    <methods>
      <method name="watch" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <description>Indicates the property to watch. This is optional (the callback may be the
	only parameter), and if omitted, all the properties will be watched</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>The function to execute when the property changes. This will be called after
	the property has been changed. The callback will be called with the |this|
	set to the instance, the first argument as the name of the property, the
	second argument as the old value and the third argument as the new value.</description>
          </parameter>
        </parameters>
        <return-description>An object handle for the watch. The unwatch method of this object
	can be used to discontinue watching this property:
		var watchHandle = obj.watch("foo", callback);
		watchHandle.unwatch(); // callback won't be called now</return-description>
      </method>
      <method name="set" scope="instance">
        <description>Sets named properties on a stateful object and notifies any watchers of
	the property. A programmatic setter may be defined in subclasses.
	For example:
		stateful = new dojo.Stateful();
		stateful.watch(function(name, oldValue, value){
			// this will be called on the set below
		}
		stateful.set(foo, 5);
	
	set() may also be called with a hash of name/value pairs, ex:
		myObj.set({
			foo: "Howdy",
			bar: 3
		})
	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The property to set.</description>
          </parameter>
          <parameter name="value" type="Object" usage="required">
            <description>The value to set in the property.</description>
          </parameter>
        </parameters>
        <return-description>The function returns this dojo.Stateful instance.</return-description>
        <return-types>
          <return-type type="dojo.Stateful"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <description>Get a named property on a Stateful object. The property may
	potentially be retrieved via a getter method in subclasses. In the base class
	this just retrieves the object's property.
	For example:
		stateful = new dojo.Stateful({foo: 3});
		stateful.get("foo") // returns 3
		stateful.foo // returns 3</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The property to get.</description>
          </parameter>
        </parameters>
        <return-description>The property value on this Stateful instance.</return-description>
        <return-types>
          <return-type type="Any"/>
        </return-types>
      </method>
      <method name="_watchCallbacks" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="ignoreCatchall" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="focus">
    <methods>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required">
            <description>object returned by get(), or a DomNode</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._base"/>
  <class type="popup">
    <methods>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="args" type="dijit.popup.__OpenArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_createWrapper" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._editor">
    <methods>
      <method name="getNodeHtml" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getChildrenHtml" scope="instance">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="escapeXml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_Plugin" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="RichText" scope="instance">
        <description>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features. It also encapsulates the differences
	of different js engines for various browsers.  Do not use this widget
	with an HTML &amp;lt;TEXTAREA&amp;gt; tag, since the browser unescapes XML escape characters,
	like &amp;lt;.  This can have unexpected behavior and lead to security issues
	such as scripting attacks.</description>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="selection" scope="instance" type="Object"/>
      <property name="plugins" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText" superclass="dijit._Widget">
    <description>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features. It also encapsulates the differences
	of different js engines for various browsers.  Do not use this widget
	with an HTML &amp;lt;TEXTAREA&amp;gt; tag, since the browser unescapes XML escape characters,
	like &amp;lt;.  This can have unexpected behavior and lead to security issues
	such as scripting attacks.</description>
    <methods>
      <method name="setupDefaultShortcuts" scope="instance">
        <description>Overwrite this to setup your own handlers. The default
	implementation does not use Editor commands, but directly
	executes the builtin commands within the underlying browser
	support.</description>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="replaceValue" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeStyleSheet" scope="instance">
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandValue" scope="instance">
        <parameters>
          <parameter name="command" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandState" scope="instance">
        <parameters>
          <parameter name="command" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required">
            <description>The command to execute</description>
          </parameter>
        </parameters>
      </method>
      <method name="queryCommandAvailable" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required">
            <description>The command to test for</description>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="placeCursorAtStart" scope="instance"/>
      <method name="placeCursorAtEnd" scope="instance"/>
      <method name="open" scope="instance">
        <description>Sets up the editing area asynchronously. This will result in
	the creation and replacement with an iframe.</description>
        <parameters>
          <parameter name="element" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="onNormalizedDisplayChanged" scope="instance">
        <description>If something needs to happen immediately after a
	user change, please use onDisplayChanged instead.</description>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>Editor contents should be set to this value</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPressed" scope="instance"/>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onDisplayChanged" scope="instance">
        <description>If you don't want to have update too often,
	onNormalizedDisplayChanged should be used instead</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newContent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="nonDestructive" type="Boolean" usage="optional">
            <description>defaults to false. Should the post-filtering be run over a copy
	of the live DOM? Most users should pass &amp;quot;true&amp;quot; here unless they
	*really* know that none of the installed filters are going to
	mess up the editing session.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getNodeHtml" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getNodeChildrenHtml" scope="instance">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getHeaderHeight" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getFooterHeight" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="focus" scope="instance"/>
      <method name="execCommand" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required">
            <description>The command to execute</description>
          </parameter>
          <parameter name="argument" type="An" usage="required">
            <description>optional argument to the command</description>
          </parameter>
        </parameters>
      </method>
      <method name="escapeXml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="save" type="Boolean" usage="optional">
            <description>Whether or not to save the changes. If false, the changes are discarded.</description>
          </parameter>
        </parameters>
      </method>
      <method name="blur" scope="instance"/>
      <method name="addStyleSheet" scope="instance">
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required">
            <description>A dojo.uri.Uri pointing to the url of the external css file</description>
          </parameter>
        </parameters>
      </method>
      <method name="addKeyHandler" scope="instance">
        <description>The key argument should be in lowercase if it is a letter character</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="ctrl" type="Boolean" usage="required"/>
          <parameter name="shift" type="Boolean" usage="required"/>
          <parameter name="handler" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_unlinkImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_unlinkEnabledImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_underlineImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_tagNamesForCommand" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required">
            <description>The command to return tags for.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_superscriptImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_subscriptImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_stripBreakerNodes" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_strikethroughImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="this method requires init to be complete"/>
          <return-type type="! _disabledOK"/>
        </return-types>
      </method>
      <method name="_setDisableSpellCheckAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_saveContent" scope="instance"/>
      <method name="_sCall" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeWebkitBogus" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_removeStartingRangeFromRange" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to remove from the starting range.</description>
          </parameter>
          <parameter name="range" type="The" usage="required">
            <description>range to adapt.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeMozBogus" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_queryCommandAvailable" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFixUrlAttributes" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFilterContent" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preDomFilterContent" scope="instance">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_postFilterContent" scope="instance">
        <description>post-filtering allows plug-ins and users to specify any number
	of transforms over the editor's content, enabling many common
	use-cases such as transforming absolute to relative URLs (and
	vice-versa), ensuring conformance with a particular DTD, etc.
	The filters are registered in the contentDomPostFilters and
	contentPostFilters arrays. Each item in the
	contentDomPostFilters array is a function which takes a DOM
	Node or array of nodes as its only argument and returns the
	same. It is then passed down the chain for further filtering.
	The contentPostFilters array behaves the same way, except each
	member operates on strings. Together, the DOM and string-based
	filtering allow the full range of post-processing that should
	be necessaray to enable even the most agressive of post-editing
	conversions to take place.
	
	If nonDestructive is set to "true", the nodes are cloned before
	filtering proceeds to avoid potentially destructive transforms
	to the content which may still needed to be edited further.
	Once DOM filtering has taken place, the serialized version of
	the DOM which is passed is run through each of the
	contentPostFilters functions.</description>
        <parameters>
          <parameter name="dom" type="DomNode|Array&lt;DomNode&gt;|String" usage="optional">
            <description>a node, set of nodes, which to filter using each of the current
	members of the contentDomPostFilters and contentPostFilters arrays.</description>
          </parameter>
          <parameter name="nonDestructive" type="Boolean" usage="optional">
            <description>defaults to &amp;quot;false&amp;quot;. If true, ensures that filtering happens on
	a clone of the passed-in content and not the actual node
	itself.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_pasteEnabledImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onIEMouseDown" scope="instance"/>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeFontStyle" scope="instance">
        <description>Moz can not handle strong/em tags correctly, so to help
	mozilla and also to normalize output, convert them to 'b' and 'i'.
	
	Note the IE generates 'strong' and 'em' rather than 'b' and 'i'</description>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeCommand" scope="instance">
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
          <parameter name="argument" type="Anything" usage="optional"/>
        </parameters>
      </method>
      <method name="_localizeEditorCommands" scope="instance"/>
      <method name="_italicImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isNodeEmpty" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
          <parameter name="startOffset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_insertunorderedlistImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_inserttableEnabledImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_insertorderedlistImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_inserthtmlImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="The" usage="required">
            <description>content to insert, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_inserthorizontalruleImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hilitecolorImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleTextColorOrProperties" scope="instance">
        <parameters>
          <parameter name="command" type="The" usage="required">
            <description>command.</description>
          </parameter>
          <parameter name="argument" type="Any" usage="required">
            <description>additional arguments.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_getNodeChildrenHeight" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to process the children of;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getIframeDocTxt" scope="instance"/>
      <method name="_forecolorImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fontsizeImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fontnameImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_cutEnabledImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createlinkEnabledImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_copyEnabledImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_browserQueryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="command" type="The" usage="required">
            <description>command to check.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_boldImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_backcolorImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_applyEditingAreaStyleSheets" scope="instance"/>
      <method name="_adjustNodeAndOffset" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to check.</description>
          </parameter>
          <parameter name="offset" type="Int" usage="required">
            <description>The position to find within the text node</description>
          </parameter>
        </parameters>
      </method>
      <method name="_adaptIESelection" scope="instance"/>
      <method name="_adaptIEList" scope="instance">
        <parameters>
          <parameter name="command" type="The" usage="required">
            <description>list command to execute.</description>
          </parameter>
          <parameter name="argument" type="Any" usage="required">
            <description>additional argument.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_adaptIEFormatAreaAndExec" scope="instance">
        <parameters>
          <parameter name="command" type="The" usage="required">
            <description>format command, needed to check if the desired
	command is true or not.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="window" scope="instance" type="Object"/>
      <property name="textarea" scope="instance" type="Object"/>
      <property name="iframe" scope="instance" type="Object"/>
      <property name="editNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="document" scope="instance" type="Object"/>
      <property name="_mozSettingProps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText._mozSettingProps"/>
  <class type="dijit._editor.RichText.editNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.document"/>
  <class type="dijit._editor.RichText.window"/>
  <class type="dijit._editor.RichText.iframe"/>
  <class type="dijit._editor.RichText.editNode.style"/>
  <class type="dijit._editor.RichText.textarea">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.textarea.style"/>
  <class type="dijit._editor.RichText.domNode"/>
  <class type="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance">
        <description>This is called on meaningful events in the editor, such as change of selection
	or caret position (but not simple typing of alphanumeric keys).   It gives the
	plugin a chance to update the CSS of its button.
	
	For example, the "bold" plugin will highlight/unhighlight the bold button depending on whether the
	characters next to the caret are bold or not.
	
	Only makes sense when `useDefaultCommand` is true, as it calls Editor.queryCommandEnabled(`command`).</description>
      </method>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="dijit.Toolbar" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>Sets named properties on a plugin which may potentially be handled by a
	setter in the plugin.
	For example, if the plugin has a properties "foo"
	and "bar" and a method named "_setFooAttr", calling:
		plugin.set("foo", "Howdy!");
	would be equivalent to writing:
		plugin._setFooAttr("Howdy!");
	and:
		plugin.set("bar", 3);
	would be equivalent to writing:
		plugin.bar = 3;
	
	set() may also be called with a hash of name/value pairs, ex:
		plugin.set({
			foo: "Howdy",
			bar: 3
		})
	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)</description>
        <parameters>
          <parameter name="name" type="attribute" usage="required">
            <description>The property to set.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to set in the property.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <description>Get a named property from a plugin. The property may
	potentially be retrieved via a getter method. If no getter is defined, this
	just retrieves the object's property.
	For example, if the plugin has a properties "foo"
	and "bar" and a method named "_getFooAttr", calling:
		plugin.get("foo");
	would be equivalent to writing:
		plugin._getFooAttr();
	and:
		plugin.get("bar");
	would be equivalent to writing:
		plugin.bar;</description>
        <parameters>
          <parameter name="name" type="The" usage="required">
            <description>property to get.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="tf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_getAttrNames" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="registry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor._Plugin.button.domNode.style"/>
  <class type="dijit._editor.plugins">
    <methods>
      <method name="_FormatBlockDropDown" scope="instance"/>
      <method name="_FontSizeDropDown" scope="instance"/>
      <method name="_FontNameDropDown" scope="instance"/>
      <method name="_FontDropDown" scope="instance"/>
      <method name="ViewSource" scope="instance"/>
      <method name="ToggleDir" scope="instance"/>
      <method name="TextColor" scope="instance">
        <description>The commands provided by this plugin are:
	* foreColor - sets the text color
	* hiliteColor - sets the background color</description>
      </method>
      <method name="TabIndent" scope="instance"/>
      <method name="Print" scope="instance"/>
      <method name="NewPage" scope="instance"/>
      <method name="LinkDialog" scope="instance">
        <description>The command provided by this plugin is:
	* createLink</description>
      </method>
      <method name="ImgLinkDialog" scope="instance">
        <description>The command provided by this plugin is:
	* insertImage</description>
      </method>
      <method name="FullScreen" scope="instance"/>
      <method name="FontChoice" scope="instance">
        <description>The commands provided by this plugin are:
	
	* fontName
			Provides a drop down to select from a list of font names
	* fontSize
			Provides a drop down to select from a list of font sizes
	* formatBlock
			Provides a drop down to select from a list of block styles
	
	
	which can easily be added to an editor by including one or more of the above commands
	in the `plugins` attribute as follows:
	
		plugins="['fontName','fontSize',...]"
	
	It is possible to override the default dropdown list by providing an Array for the `custom` property when
	instantiating this plugin, e.g.
	
		plugins="[{name:'dijit._editor.plugins.FontChoice', command:'fontName', custom:['Verdana','Myriad','Garamond']},...]"
	
	Alternatively, for `fontName` only, `generic:true` may be specified to provide a dropdown with
	[CSS generic font families](http://www.w3.org/TR/REC-CSS2/fonts.html#generic-font-families)
	
	Note that the editor is often unable to properly handle font styling information defined outside
	the context of the current editor instance, such as pre-populated HTML.</description>
      </method>
      <method name="EnterKeyHandling" scope="instance">
        <description>This plugin has three modes:
	
	* blockNodeForEnter=BR
	* blockNodeForEnter=DIV
	* blockNodeForEnter=P
	
	In blockNodeForEnter=P, the ENTER key starts a new
	paragraph, and shift-ENTER starts a new line in the current paragraph.
	For example, the input:
	
		first paragraph &lt;shift-ENTER&gt;
		second line of first paragraph &lt;ENTER&gt;
		second paragraph
	
	will generate:
	
		&lt;p&gt;
			first paragraph
			&lt;br/&gt;
			second line of first paragraph
		&lt;/p&gt;
		&lt;p&gt;
			second paragraph
		&lt;/p&gt;
	
	In BR and DIV mode, the ENTER key conceptually goes to a new line in the
	current paragraph, and users conceptually create a new paragraph by pressing ENTER twice.
	For example, if the user enters text into an editor like this:
	
			one &lt;ENTER&gt;
			two &lt;ENTER&gt;
			three &lt;ENTER&gt;
			&lt;ENTER&gt;
			four &lt;ENTER&gt;
			five &lt;ENTER&gt;
			six &lt;ENTER&gt;
	
	It will appear on the screen as two 'paragraphs' of three lines each.  Markupwise, this generates:
	
	BR:
			one&lt;br/&gt;
			two&lt;br/&gt;
			three&lt;br/&gt;
			&lt;br/&gt;
			four&lt;br/&gt;
			five&lt;br/&gt;
			six&lt;br/&gt;
	
	DIV:
			&lt;div&gt;one&lt;/div&gt;
			&lt;div&gt;two&lt;/div&gt;
			&lt;div&gt;three&lt;/div&gt;
			&lt;div&gt;&amp;nbsp;&lt;/div&gt;
			&lt;div&gt;four&lt;/div&gt;
			&lt;div&gt;five&lt;/div&gt;
			&lt;div&gt;six&lt;/div&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="AlwaysShowToolbar" scope="instance">
        <description>Specify this in extraPlugins (or plugins) parameter and also set
	height to "".</description>
        <examples>
          <example>	&lt;div data-dojo-type="dijit.Editor" height=""
		data-dojo-props="extraPlugins: [dijit._editor.plugins.AlwaysShowToolbar]"&gt;</example>
        </examples>
      </method>
    </methods>
  </class>
  <class type="dijit._editor.plugins.AlwaysShowToolbar" superclass="dijit._editor._Plugin">
    <description>Specify this in extraPlugins (or plugins) parameter and also set
	height to "".</description>
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="globalOnScrollHandler" scope="instance"/>
      <method name="enable" scope="instance">
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_updateHeight" scope="instance">
        <return-types>
          <return-type type="prevent setting height to 0"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor">
    <properties>
      <property name="header" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.header">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.iframe.style"/>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.header.style"/>
  <class type="dijit._editor.plugins.EnterKeyHandling" superclass="dijit._editor._Plugin">
    <description>This plugin has three modes:
	
	* blockNodeForEnter=BR
	* blockNodeForEnter=DIV
	* blockNodeForEnter=P
	
	In blockNodeForEnter=P, the ENTER key starts a new
	paragraph, and shift-ENTER starts a new line in the current paragraph.
	For example, the input:
	
		first paragraph &lt;shift-ENTER&gt;
		second line of first paragraph &lt;ENTER&gt;
		second paragraph
	
	will generate:
	
		&lt;p&gt;
			first paragraph
			&lt;br/&gt;
			second line of first paragraph
		&lt;/p&gt;
		&lt;p&gt;
			second paragraph
		&lt;/p&gt;
	
	In BR and DIV mode, the ENTER key conceptually goes to a new line in the
	current paragraph, and users conceptually create a new paragraph by pressing ENTER twice.
	For example, if the user enters text into an editor like this:
	
			one &lt;ENTER&gt;
			two &lt;ENTER&gt;
			three &lt;ENTER&gt;
			&lt;ENTER&gt;
			four &lt;ENTER&gt;
			five &lt;ENTER&gt;
			six &lt;ENTER&gt;
	
	It will appear on the screen as two 'paragraphs' of three lines each.  Markupwise, this generates:
	
	BR:
			one&lt;br/&gt;
			two&lt;br/&gt;
			three&lt;br/&gt;
			&lt;br/&gt;
			four&lt;br/&gt;
			five&lt;br/&gt;
			six&lt;br/&gt;
	
	DIV:
			&lt;div&gt;one&lt;/div&gt;
			&lt;div&gt;two&lt;/div&gt;
			&lt;div&gt;three&lt;/div&gt;
			&lt;div&gt;&amp;nbsp;&lt;/div&gt;
			&lt;div&gt;four&lt;/div&gt;
			&lt;div&gt;five&lt;/div&gt;
			&lt;div&gt;six&lt;/div&gt;</description>
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeTrailingBr" scope="instance">
        <parameters>
          <parameter name="container" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPressed" scope="instance"/>
      <method name="handleEnterKey" scope="instance">
        <description>Manually handle enter key event to make the behavior consistent across
	all supported browsers. See class description for details.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="let browser handle"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustNodeAndOffset" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to check.</description>
          </parameter>
          <parameter name="offset" type="Int" usage="required">
            <description>The position to find within the text node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.EnterKeyHandling.editor"/>
  <class type="dijit._editor.plugins._FontDropDown" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object|String" usage="required">
            <description>The value to set in the select.</description>
          </parameter>
          <parameter name="priorityChange" type="Optional" usage="required">
            <description>parameter used to tell the select whether or not to fire
	onChange event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="select" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FontDropDown.select"/>
  <class type="dijit._editor.plugins._FontNameDropDown" superclass="_FontDropDown">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The 'insert value' associated with a name</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The text name of the value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_FontDropDown" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._editor.plugins._FontSizeDropDown" superclass="_FontDropDown">
    <methods>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The 'insert value' associated with a name</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The text name of the value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_FontDropDown" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._editor.plugins._FormatBlockDropDown" superclass="_FontDropDown">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The 'insert value' associated with a name</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The text name of the value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeFormat" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
          <parameter name="node" type="The" usage="required">
            <description>block format node to remove (and leave the contents behind)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_execCommand" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
          <parameter name="command" type="Object" usage="required"/>
          <parameter name="choice" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_FontDropDown" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._editor.plugins.FontChoice" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	
	* fontName
			Provides a drop down to select from a list of font names
	* fontSize
			Provides a drop down to select from a list of font sizes
	* formatBlock
			Provides a drop down to select from a list of block styles
	
	
	which can easily be added to an editor by including one or more of the above commands
	in the `plugins` attribute as follows:
	
		plugins="['fontName','fontSize',...]"
	
	It is possible to override the default dropdown list by providing an Array for the `custom` property when
	instantiating this plugin, e.g.
	
		plugins="[{name:'dijit._editor.plugins.FontChoice', command:'fontName', custom:['Verdana','Myriad','Garamond']},...]"
	
	Alternatively, for `fontName` only, `generic:true` may be specified to provide a dropdown with
	[CSS generic font families](http://www.w3.org/TR/REC-CSS2/fonts.html#generic-font-families)
	
	Note that the editor is often unable to properly handle font styling information defined outside
	the context of the current editor instance, such as pre-populated HTML.</description>
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="params" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FontChoice.params"/>
  <class type="dijit.form.FilteringSelect" superclass="dijit.form.MappedTextBox">
    <description>An enhanced version of the HTML SELECT tag, populated dynamically. It works
	very nicely with very large data sets because it can load and page data as needed.
	It also resembles ComboBox, but does not allow values outside of the provided ones.
	If OPTION tags are used as the data provider via markup, then the
	OPTION tag's child text node is used as the displayed value when selected
	while the OPTION tag's value attribute is used as the widget value on form submit.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	
	Similar features:
	- There is a drop down list of possible values.
	- You can only enter a value from the drop down list.  (You can't
	enter an arbitrary value.)
	- The value submitted with the form is the hidden value (ex: CA),
	not the displayed value a.k.a. label (ex: California)
	
	Enhancements over plain HTML version:
	- If you type in some text then it will filter down the list of
	possible values in the drop down list.
	- List can be specified either as a static list or via a javascript
	function (that can get the list from a server)</description>
    <methods>
      <method name="undo" scope="instance"/>
      <method name="isValid" scope="instance">
        <return-types>
          <return-type type="#5974"/>
        </return-types>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the select.
	Also sets the label to the corresponding value by reverse lookup.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
      </method>
      <method name="_setItemAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('item', value)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="instance">
        <description>Sets textbox to display label. Also performs reverse lookup
	to set the hidden value.  label should corresponding to item.searchAttr.</description>
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="_openResultList" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isValidSubset" scope="instance"/>
      <method name="_getValueField" scope="instance"/>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_getDisplayQueryString" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_callbackSetLabel" scope="instance">
        <parameters>
          <parameter name="result" type="Array" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.MappedTextBox" scope="instance"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="valueNode" scope="instance" type="Object"/>
      <property name="textbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FullScreen" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="toggle" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_setFullScreen" scope="instance">
        <parameters>
          <parameter name="full" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resizeEditor" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_getAltViewNode" scope="instance"/>
      <method name="_containFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The key event.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FullScreen.editor">
    <methods>
      <method name="resize" scope="instance"/>
    </methods>
    <properties>
      <property name="toolbar" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FullScreen.editor.toolbar"/>
  <class type="dijit._editor._Plugin.registry">
    <methods>
      <method name="viewsource" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="viewSource" scope="instance"/>
      <method name="toggleDir" scope="instance"/>
      <method name="tabIndent" scope="instance"/>
      <method name="print" scope="instance"/>
      <method name="newpage" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="newPage" scope="instance"/>
      <method name="insertImage" scope="instance"/>
      <method name="hiliteColor" scope="instance"/>
      <method name="fullscreen" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fullScreen" scope="instance"/>
      <method name="foreColor" scope="instance"/>
      <method name="createLink" scope="instance"/>
    </methods>
  </class>
  <class type="dijit._editor.plugins.LinkDialog" superclass="dijit._editor._Plugin">
    <description>The command provided by this plugin is:
	* createLink</description>
    <methods>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="staticPanel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onOpenDialog" scope="instance"/>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The double-click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onCloseDialog" scope="instance"/>
      <method name="_loadDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isValid" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_getCurrentValues" scope="instance">
        <parameters>
          <parameter name="a" type="The" usage="required">
            <description>anchor/link to process for data for the dropdown.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_connectTagEvents" scope="instance"/>
      <method name="_checkValues" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Content being set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkAndFixInput" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="button" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.LinkDialog.button"/>
  <class type="dijit._editor.plugins.ImgLinkDialog" superclass="LinkDialog">
    <description>The command provided by this plugin is:
	* insertImage</description>
    <methods>
      <method name="_selectTag" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The mousedown event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The double-click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isValid" scope="instance"/>
      <method name="_getCurrentValues" scope="instance">
        <parameters>
          <parameter name="img" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_connectTagEvents" scope="instance"/>
      <method name="_checkValues" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Content being set.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="LinkDialog" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._editor.plugins.NewPage" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <description>Object The editor object to attach the newPage capability to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_newPage" scope="instance"/>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._editor.plugins.Print" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <description>Object The editor object to attach the print capability to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_print" scope="instance"/>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.Print.editor"/>
  <class type="dijit._editor.plugins.TabIndent" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._editor.plugins.TextColor" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* foreColor - sets the text color
	* hiliteColor - sets the background color</description>
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="button" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.TextColor.button">
    <methods>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._editor.plugins.ToggleDir" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="_setRtl" scope="instance">
        <parameters>
          <parameter name="rtl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._editor.plugins.ViewSource" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="toggle" scope="instance"/>
      <method name="setSourceAreaCaret" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <description>Object The editor object to attach the print capability to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_stripScripts" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The HTML to filter</description>
          </parameter>
        </parameters>
      </method>
      <method name="_stripIFrames" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The HTML to filter</description>
          </parameter>
        </parameters>
      </method>
      <method name="_stripComments" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The HTML to filter</description>
          </parameter>
        </parameters>
      </method>
      <method name="_showSource" scope="instance">
        <parameters>
          <parameter name="source" type="boolean" usage="required">
            <description>Boolean value indicating if it should be in source mode or not.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_resize" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_filter" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The HTML to filter</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createSourceView" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="sourceArea" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="_fsPlugin" scope="instance" type="Object">
        <description>Reference to a registered fullscreen plugin so that viewSource knows
	how to scale.</description>
      </property>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource.editor">
    <methods>
      <method name="queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
    </methods>
  </class>
  <class type="dijit._editor.plugins.ViewSource._fsPlugin">
    <methods>
      <method name="_getAltViewNode" scope="instance"/>
    </methods>
  </class>
  <class type="dijit._editor.plugins.ViewSource.sourceArea">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource.sourceArea.style"/>
  <class type="dijit.range">
    <methods>
      <method name="getSelection" scope="instance">
        <parameters>
          <parameter name="win" type="Window" usage="required"/>
          <parameter name="ignoreUpdate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="index" type="Array" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="terminate array.every"/>
          <return-type type="carry on the every loop"/>
        </return-types>
      </method>
      <method name="getIndex" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getCommonAncestor" scope="instance">
        <parameters>
          <parameter name="n1" type="Object" usage="required"/>
          <parameter name="n2" type="Object" usage="required"/>
          <parameter name="root" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getBlockAncestor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="getAncestor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="window" type="Window" usage="optional"/>
        </parameters>
      </method>
      <method name="atEndOfContainer" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="atBeginningOfContainer" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="adjacentNoneTextNode" scope="instance">
        <parameters>
          <parameter name="startnode" type="Object" usage="required"/>
          <parameter name="next" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="W3CRange" scope="instance"/>
    </methods>
    <properties>
      <property name="ie" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.W3CRange">
    <methods>
      <method name="setStartBefore" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartAfter" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStart" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndBefore" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndAfter" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEnd" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getBookmark" scope="instance"/>
      <method name="detach" scope="instance"/>
      <method name="deleteContents" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="cloneRange" scope="instance"/>
      <method name="_updateInternal" scope="instance"/>
      <method name="_setPoint" scope="instance">
        <parameters>
          <parameter name="what" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="ext" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_select" scope="instance"/>
      <method name="_getIERange" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.range.ie">
    <methods>
      <method name="setRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="startContainer" type="Object" usage="required"/>
          <parameter name="startOffset" type="Object" usage="required"/>
          <parameter name="endContainer" type="Object" usage="required"/>
          <parameter name="endOffset" type="Object" usage="required"/>
          <parameter name="collapsed" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndPoint" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="container" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selection" scope="instance">
        <parameters>
          <parameter name="win" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getEndPoint" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decomposeTextRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decomposeControlRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.range.ie.selection">
    <methods>
      <method name="removeAllRanges" scope="instance"/>
      <method name="getRangeAt" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="internal" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentSelection" scope="instance"/>
    </methods>
  </class>
  <class type="dijit._editor.selection">
    <methods>
      <method name="selectElementChildren" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required">
            <description>DOMNode The element you wish to select the children content of.</description>
          </parameter>
          <parameter name="nochangefocus" type="Boolean" usage="optional">
            <description>Boolean to indicate if the foxus should change or not.</description>
          </parameter>
        </parameters>
      </method>
      <method name="selectElement" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required">
            <description>DOMNode The element to select.</description>
          </parameter>
          <parameter name="nochangefocus" type="Boolean" usage="optional">
            <description>Boolean indicating if the focus should be changed.  IE only.</description>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <return-types>
          <return-type type="Selection"/>
        </return-types>
      </method>
      <method name="isTag" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to inspect.</description>
          </parameter>
          <parameter name="tags" type="Array&lt;String&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="inSelection" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="hasAncestorElement" scope="instance">
        <parameters>
          <parameter name="tagName" type="String" usage="required">
            <description>The tag name to determine if it has an ancestor of.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getType" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedText" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedHtml" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedElement" scope="instance"/>
      <method name="getParentOfType" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to inspect.</description>
          </parameter>
          <parameter name="tags" type="Array&lt;String&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="getParentElement" scope="instance"/>
      <method name="getAncestorElement" scope="instance">
        <parameters>
          <parameter name="tagName" type="String" usage="required">
            <description>The tag name to determine if it has an ancestor of.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="collapse" scope="instance">
        <parameters>
          <parameter name="beginning" type="Boolean" usage="required">
            <description>Boolean to indicate whether to collapse the cursor to the beginning of the selection or end.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._tree"/>
  <class type="dijit.focus">
    <methods>
      <method name="registerWin" scope="instance">
        <description>Users should call registerIframe() instead of this method.</description>
        <parameters>
          <parameter name="targetWindow" type="Window" usage="optional">
            <description>If specified this is the window associated with the iframe,
	i.e. iframe.contentWindow.</description>
          </parameter>
          <parameter name="effectiveNode" type="DOMNode" usage="optional">
            <description>If specified, report any focus events inside targetWindow as
	an event on effectiveNode, rather than on evt.target.</description>
          </parameter>
        </parameters>
        <return-description>Handle with remove() method to deregister.</return-description>
      </method>
      <method name="registerIframe" scope="instance">
        <description>Currently only used by editor.</description>
        <parameters>
          <parameter name="iframe" type="Object" usage="required"/>
        </parameters>
        <return-description>Handle with remove() method to deregister.</return-description>
      </method>
    </methods>
  </class>
  <class type="dijit.form.Button._setIconClassAttr"/>
  <class type="dijit.form.Button.titleNode"/>
  <class type="dijit.form._FormWidget" superclass="dijit._Widget">
    <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	
	They also share some common methods.</description>
    <methods>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="getValue" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
      <mixin type="dijit.form._FormWidgetMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
      <mixin type="dijit.form._FormWidgetMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._ButtonMixin">
    <description>A label should always be specified (through innerHTML) or the label attribute.
	Attach points:
	focusNode (required): this node receives focus
	valueNode (optional): this node's value gets submitted with FORM elements
	containerNode (optional): this node gets the innerHTML assignment for label</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <description>Set the label (text) of the button; takes an HTML string.</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.form.CheckBox" superclass="dijit.form.ToggleButton">
    <description>User interacts with real html inputs.
	On onclick (which occurs by mouse click, space-bar, or
	using the arrow keys to switch the selected radio button),
	we update the state of the checkbox/radio.
	
	There are two modes:
	1. High contrast mode
	2. Normal mode
	
	In case 1, the regular html inputs are shown and used by the user.
	In case 2, the regular html inputs are invisible but still used by
	the user. They are turned quasi-invisible and overlay the background-image.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>During initialization, just saves as attribute to the &lt;input type=checkbox&gt;.
	
	After initialization,
	when passed a boolean, controls whether or not the CheckBox is checked.
	If passed a string, changes the value attribute of the CheckBox (the one
	specified as "value" when the CheckBox was constructed (ex: &lt;input
	data-dojo-type="dijit.CheckBox" value="chicken"&gt;)
	widget.set('value', string) will check the checkbox and change the value to the
	specified string
	widget.set('value', boolean) will change the checked state.</description>
        <parameters>
          <parameter name="newValue" type="String|Boolean" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="_getValueAttr" scope="instance">
        <description>If the CheckBox is checked, returns the value attribute.
	Otherwise returns false.</description>
      </method>
      <method name="_fillContent" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._CheckBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ToggleButton" scope="instance"/>
      <mixin type="dijit.form._CheckBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.ToggleButton" superclass="dijit.form.Button">
    <methods>
      <method name="setChecked" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._ToggleButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dijit.form._ToggleButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._CheckBoxMixin">
    <description>User interacts with real html inputs.
	On onclick (which occurs by mouse click, space-bar, or
	using the arrow keys to switch the selected radio button),
	we update the state of the checkbox/radio.</description>
    <methods>
      <method name="reset" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.form.ComboBox" superclass="dijit.form.ValidationTextBox">
    <description>The drop down box's values are populated from an class called
	a data provider, which returns a list of values based on the characters
	that the user has typed into the input box.
	If OPTION tags are used as the data provider via markup,
	then the OPTION tag's child text node is used as the widget value
	when selected.  The OPTION tag's value attribute is ignored.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	
	Some of the options to the ComboBox are actually arguments to the data
	provider.</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.ValidationTextBox" superclass="dijit.form.TextBox">
    <methods>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="validate" scope="instance">
        <description>Show missing or invalid messages if appropriate, and highlight textbox field.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="regExpGen" scope="instance">
        <parameters>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getPromptMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getErrorMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="displayMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_setValueAttr" scope="instance"/>
      <method name="_setRequiredAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setMessageAttr" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="_isValidSubset" scope="instance"/>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_computePartialRE" scope="instance"/>
      <method name="__Constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.TextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.ComboBoxMixin" superclass="dijit._HasDropDown">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="dropDownClass" scope="instance"/>
      <method name="_showResultList" scope="instance"/>
      <method name="_setStoreAttr" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setHasDownArrowAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._AutoCompleterMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown" scope="instance"/>
      <mixin type="dijit.form._AutoCompleterMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="cssStateNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin.cssStateNodes"/>
  <class type="dijit.form.ComboBoxMixin._buttonNode.style"/>
  <class type="dijit.form._AutoCompleterMixin">
    <description>All widgets that mix in dijit.form._AutoCompleterMixin must extend `dijit.form._FormValueWidget`.</description>
    <methods>
      <method name="reset" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="labelFunc" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="store" type="dojo.store.api.Store" usage="required"/>
        </parameters>
        <return-description>The label that the ComboBox should display</return-description>
      </method>
      <method name="isLoaded" scope="instance"/>
      <method name="doHighlight" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="find" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="closeDropDown" scope="instance"/>
      <method name="_startSearchFromInput" scope="instance"/>
      <method name="_startSearchAll" scope="instance"/>
      <method name="_startSearch" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_showResultList" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the select.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
      </method>
      <method name="_setTextDirAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('textDir', value)</description>
        <parameters>
          <parameter name="textDir" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setItemAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('item', value)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setCaretPos" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="location" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_selectOption" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_openResultList" scope="instance">
        <description>1. generates drop-down list and calls _showResultList() to display it
	2. if this result list is from user pressing "more choices"/"previous choices"
	then tell screen reader to announce new option</description>
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="throw out weird key combinations and spurious events"/>
        </return-types>
      </method>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueField" scope="instance"/>
      <method name="_getQueryString" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenuLabelFromItem" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_getCaretPos" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_escapeHtml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_autoCompleteText" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_announceOption" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_abortQuery" scope="instance"/>
    </methods>
    <properties>
      <property name="focusNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu" superclass="dijit._WidgetBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onUnhover" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onHover" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselect" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="handleKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_page" scope="instance">
        <parameters>
          <parameter name="up" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_createMenuItem" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit.form._ListMouseMixin.prototype" scope="instance"/>
      <mixin type="dijit.form._ComboBoxMenuMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit.form._ListMouseMixin" scope="instance"/>
      <mixin type="dijit.form._ComboBoxMenuMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboButton" superclass="dijit.form.DropDownButton">
    <methods>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="position" type="String" usage="required">
            <description>&amp;quot;start&amp;quot; or &amp;quot;end&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onButtonKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onArrowKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.DropDownButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="cssStateNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboButton.cssStateNodes"/>
  <class type="dijit.form.CurrencyTextBox" superclass="dijit.form.NumberTextBox">
    <description>CurrencyTextBox is similar to `dijit.form.NumberTextBox` but has a few
	extra features related to currency:
	
	1. After specifying the currency type (american dollars, euros, etc.) it automatically
	sets parse/format options such as how many decimal places to show.
	2. The currency mark (dollar sign, euro mark, etc.) is displayed when the field is blurred
	but erased during editing, so that the user can just enter a plain number.</description>
    <methods>
      <method name="regExpGen" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__Constraints" scope="instance">
        <description>Follows the pattern of `dijit.form.NumberTextBox.constraints`.
	In general developers won't need to set this parameter</description>
        <examples>
          <example>To ensure that the user types in the cents (for example, 1.00 instead of just 1):
			{fractional:true}</example>
        </examples>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.CurrencyTextBox.__Constraints" superclass="dijit.form.NumberTextBox.__Constraints">
    <description>Follows the pattern of `dijit.form.NumberTextBox.constraints`.
	In general developers won't need to set this parameter</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="currency.__FormatOptions.prototype" scope="instance"/>
      <mixin type="currency.__ParseOptions.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBox.__Constraints" scope="instance"/>
      <mixin type="currency.__FormatOptions" scope="instance"/>
      <mixin type="currency.__ParseOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.NumberTextBox" superclass="dijit.form.RangeBoundTextBox">
    <description>NumberTextBox is a textbox for entering and displaying numbers, supporting
	the following main features:
	
	1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
	a number rather than a random string)
	2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
	depending on locale).
	3. Separate modes for editing the value and displaying it, specifically that
	the thousands separator character (typically comma) disappears when editing
	but reappears after the field is blurred.
	4. Formatting and constraints regarding the number of places (digits after the decimal point)
	allowed on input, and number of places displayed when blurred (see `constraints` parameter).</description>
    <methods>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="__Constraints" scope="instance">
        <examples>
          <example>Minimum/maximum:
	To specify a field between 0 and 120:
			{min:0,max:120}
	To specify a field that must be an integer:
			{fractional:false}
	To specify a field where 0 to 3 decimal places are allowed on input:
			{places:'0,3'}</example>
        </examples>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox" scope="instance"/>
      <mixin type="dijit.form.NumberTextBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.DataList" superclass="MemoryStore">
    <description>Provides a store for inlined data like:
	
		&lt;datalist&gt;
			&lt;option value="AL"&gt;Alabama&lt;/option&gt;
			...</description>
    <methods>
      <method name="fetchSelectedItem" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="optional"/>
          <parameter name="srcNodeRef" type="DomNode|String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="MemoryStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.DataList.domNode.style"/>
  <class type="dijit.form.DateTextBox" superclass="dijit.form._DateTimeTextBox">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._DateTimeTextBox" superclass="dijit.form.RangeBoundTextBox">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="val" type="anything" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="openDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="Date" usage="required"/>
          <parameter name="val2" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Date|String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_setDropDownDefaultValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="attr" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isInvalidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance"/>
      <method name="__Constraints" scope="instance">
        <examples>
          <example>To restrict to dates within 2004, displayed in a long format like "December 25, 2005":
			{min:'2004-01-01',max:'2004-12-31', formatLength:'long'}</example>
        </examples>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.FilteringSelect.valueNode"/>
  <class type="dijit.form.FilteringSelect.textbox"/>
  <class type="dijit.form.MappedTextBox" superclass="dijit.form.ValidationTextBox">
    <description>The visible display may
	be locale-dependent and interactive.  The value sent to the server is stored in a hidden
	input field which uses the `name` attribute declared by the original widget.  That value sent
	to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
	locale-neutral.</description>
    <methods>
      <method name="validate" scope="instance"/>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="val" type="anything" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="reset" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="valueNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Form" superclass="dijit._Widget">
    <methods>
      <method name="submit" scope="instance"/>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onSubmit" scope="instance">
        <description>This method is intended to be over-ridden, but by default it checks and
	returns the validity of form elements. When the `submit`
	method is called programmatically, the return value from
	`onSubmit` is used to compute whether or not submission
	should proceed</description>
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onReset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onExecute" scope="instance"/>
      <method name="execute" scope="instance">
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setEncTypeAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onSubmit" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onReset" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit.form._FormMixin.prototype" scope="instance"/>
      <mixin type="dijit.layout._ContentPaneResizeMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit.layout._ContentPaneResizeMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Form.domNode"/>
  <class type="dijit.form.Form.constructor"/>
  <class type="dijit.layout._ContentPaneResizeMixin">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scheduleLayout" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="instance">
        <description>For a plain ContentPane, this is called on initialization, from startup().
	If the ContentPane is a hidden pane of a TabContainer etc., then it's
	called whenever the pane is made visible.
	
	Does layout/resize of child widget(s)</description>
      </method>
      <method name="_layoutChildren" scope="instance"/>
      <method name="_layout" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isShown" scope="instance">
        <description>If I am a child of a layout widget then it actually returns true if I've ever been visible,
	not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
	tree every call, and at least solves the performance problem on page load by deferring loading
	hidden ContentPanes until they are first shown</description>
        <return-types>
          <return-type type="for TitlePane, etc"/>
        </return-types>
      </method>
      <method name="_checkIfSingleChild" scope="instance">
        <return-types>
          <return-type type="or a regexp for hidden elements like script"/>
          <return-type type="area"/>
          <return-type type="map"/>
          <return-type type="etc"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRule" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_genHTML" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRule.domNode"/>
  <class type="dijit.form.HorizontalRuleLabels" superclass="dijit.form.HorizontalRule">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="getLabels" scope="instance"/>
      <method name="_genHTML" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="ndx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcPosition" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalRule" scope="instance"/>
    </mixins>
    <properties>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="constraints" scope="instance" type="Object">
        <description>pattern, places, lang, et al (see dojo.number) for generated numeric labels when labels[] are not specified</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels.constraints"/>
  <class type="dijit.form.HorizontalRuleLabels.srcNodeRef"/>
  <class type="dijit.form._SliderMover" superclass="Mover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Mover" scope="instance"/>
    </mixins>
    <properties>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SliderMover.widget"/>
  <class type="dijit.form.HorizontalSlider" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="increment" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="decrement" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_typematicCallback" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="button" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="instance">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_onKeyUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="instance"/>
      <method name="_onClkDecBumper" scope="instance"/>
      <method name="_onClkBumper" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBarClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_isReversed" scope="instance"/>
      <method name="_bumpValue" scope="instance">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="valueNode" scope="instance" type="Object"/>
      <property name="cssStateNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.cssStateNodes"/>
  <class type="dijit.form.HorizontalSlider.valueNode"/>
  <class type="dijit.form.HorizontalSlider.incrementButton.style"/>
  <class type="dijit.form.HorizontalSlider.decrementButton.style"/>
  <class type="dijit.form.MappedTextBox.valueNode"/>
  <class type="dijit.form.MultiSelect" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="invertSelection" scope="instance">
        <parameters>
          <parameter name="onChange" type="Boolean" usage="optional">
            <description>If false, onChange is not fired.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSelected" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="addSelected" scope="instance">
        <examples>
          <example>	// move all the selected values from "bar" to "foo"
	 	dijit.byId("foo").addSelected(dijit.byId("bar"));</example>
        </examples>
        <parameters>
          <parameter name="select" type="dijit.form.MultiSelect" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Set the value(s) of this Select based on passed values</description>
        <parameters>
          <parameter name="values" type="Array" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_onChange" scope="instance"/>
      <method name="_getValueAttr" scope="instance">
        <description>Returns an array of the selected options' values.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.NumberSpinner" superclass="dijit.form._Spinner">
    <description>A `dijit.form.NumberTextBox` extension to provide keyboard accessible value selection
	as well as icons for spinning direction. When using the keyboard, the typematic rules
	apply, meaning holding the key will gradually increase or decrease the value and
	accelerate.</description>
    <methods>
      <method name="adjust" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBox.Mixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._Spinner" scope="instance"/>
      <mixin type="dijit.form.NumberTextBox.Mixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="constraints" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.NumberSpinner.constraints"/>
  <class type="dijit.form._Spinner" superclass="dijit.form.RangeBoundTextBox">
    <description>This class basically (conceptually) extends `dijit.form.ValidationTextBox`.
	It modifies the template to have up/down arrows, and provides related handling code.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="adjust" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_typematicCallback" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowReleased" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowPressed" scope="instance">
        <parameters>
          <parameter name="nodePressed" type="Node" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="increment" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="cssStateNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBox.__Constraints" superclass="dijit.form.RangeBoundTextBox.__Constraints">
    <methods/>
    <mixins scope="instance">
      <mixin type="number.__FormatOptions.prototype" scope="instance"/>
      <mixin type="number.__ParseOptions.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox.__Constraints" scope="instance"/>
      <mixin type="number.__FormatOptions" scope="instance"/>
      <mixin type="number.__ParseOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.NumberTextBoxMixin">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="number.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="valid exponential number in range"/>
        </return-types>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="constraints" type="dojo.number.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="set('value', null"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="undefined) should fire onChange(NaN)"/>
        </return-types>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_parser" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>String representing a number</description>
          </parameter>
          <parameter name="constraints" type="dojo.number.__ParseOptions" usage="required">
            <description>Formatting options</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_onFocus" scope="instance"/>
      <method name="_getValueAttr" scope="instance">
        <return-types>
          <return-type type="return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)"/>
          <return-type type="gibberish"/>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance"/>
      <method name="_formatter" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The number to be converted into a string.</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional">
            <description>Formatting options</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="textbox" scope="instance" type="Object"/>
      <property name="editOptions" scope="instance" type="Object">
        <description>Properties to mix into constraints when the value is being edited.
	This is here because we edit the number in the format &amp;quot;12345&amp;quot;, which is
	different than the display value (ex: &amp;quot;12,345&amp;quot;)</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBoxMixin.editOptions"/>
  <class type="dijit.form.NumberTextBoxMixin.textbox"/>
  <class type="dijit.form.RangeBoundTextBox" superclass="dijit.form.MappedTextBox">
    <methods>
      <method name="rangeCheck" scope="instance">
        <parameters>
          <parameter name="primitive" type="Number" usage="required"/>
          <parameter name="constraints" type="dijit.form.RangeBoundTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="isInRange" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getErrorMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="applyTextDir" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isValidSubset" scope="instance"/>
      <method name="_isDefinitelyOutOfRange" scope="instance"/>
      <method name="__Constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.MappedTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.RadioButton" superclass="dijit.form.CheckBox">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form._RadioButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.CheckBox" scope="instance"/>
      <mixin type="dijit.form._RadioButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._RadioButtonMixin">
    <methods>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getRelatedWidgets" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.form.RangeBoundTextBox.__Constraints">
    <methods/>
  </class>
  <class type="dijit.form._SelectMenu" superclass="dijit.Menu">
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="mb" type="Object" usage="required">
            <description>The margin box to set this dropdown to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Menu" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._SelectMenu.menuTableNode.style"/>
  <class type="dijit.form.Select" superclass="dijit._FormSelectWidget">
    <methods>
      <method name="validate" scope="instance">
        <description>Show missing or invalid messages if appropriate, and highlight textbox field.
	Used when a select is initially set to no value and the user is required to
	set the value.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="handle value is null or undefined"/>
        </return-types>
      </method>
      <method name="isLoaded" scope="instance"/>
      <method name="closeDropDown" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStyleAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplay" scope="instance">
        <parameters>
          <parameter name="newDisplay" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="_loadChildren" scope="instance">
        <parameters>
          <parameter name="loadMenuItems" type="Boolean" usage="required">
            <description>actually loads the child menu items - we only do this when we are
	populating for showing the dropdown.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getMenuItemForOption" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildren" scope="instance"/>
      <method name="_fillContent" scope="instance"/>
      <method name="_addOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._FormSelectWidget" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Select.srcNodeRef"/>
  <class type="dijit.form.Select.containerNode"/>
  <class type="dijit.form.Select.dropDown.menuTableNode.style"/>
  <class type="dijit.form.SimpleTextarea" superclass="dijit.form.TextBox">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.TextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="textbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.SimpleTextarea.textbox"/>
  <class type="dijit.form.TextBox._phspan">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox._phspan.style"/>
  <class type="dijit.form.TextBox.IEMixin" superclass="TextBox">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_isTextSelected" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="TextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.TextBox.MozMixin" superclass="TextBox">
    <methods>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="TextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="textbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox.MozMixin.textbox"/>
  <class type="dijit.form._TextBoxMixin">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance">
        <return-types>
          <return-type type="keydown for A-Z can be processed with keypress"/>
          <return-type type="if preventDefault was called"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="onInput" scope="instance">
        <parameters>
          <parameter name="event" type="keydown" usage="required">
            <description>| keypress | cut | paste | input</description>
          </parameter>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <description>For MappedTextBox subclasses, this is called twice
	- once with the display value
	- once the value as set/returned by set('value', ...)
	and get('value'), ex: a Number for NumberTextBox.
	
	In the latter case it does corrections like converting null to NaN.  In
	the former case the NumberTextBox.filter() method calls this.inherited()
	to execute standard trimming code in TextBox.filter().
	
	TODO: break this into two methods in 2.0</description>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget to "value" which can be of
	any type as determined by the widget.</description>
        <parameters>
          <parameter name="value" type="The" usage="required">
            <description>visual element value is also set to a corresponding,
	but not necessarily the same, value.</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <description>If true, an onChange event is fired immediately instead of
	waiting for the next blur event.</description>
          </parameter>
          <parameter name="formattedValue" type="String" usage="optional">
            <description>If specified, used to set the visual element value,
	otherwise a computed visual value is used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTextDirAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('textDir', value)</description>
        <parameters>
          <parameter name="textDir" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectionRange" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="instance">
        <description>Sets the value of the visual element to the string "value".
	The widget value is also set to a corresponding,
	but not necessarily the same, value.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_refreshState" scope="instance"/>
      <method name="_onInput" scope="instance"/>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="by" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isTextSelected" scope="instance"/>
      <method name="_getValueAttr" scope="instance">
        <description>For `dijit.form.TextBox` this basically returns the value of the &lt;input&gt;.
	
	For `dijit.form.MappedTextBox` subclasses, which have both
	a "displayed value" and a separate "submit value",
	This treats the "displayed value" as the master value, computing the
	submit value from it via this.parse().</description>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance">
        <description>Returns the displayed value (what the user sees on the screen),
	after filtering (ie, trimming spaces etc.).
	
	For some subclasses of TextBox (like ComboBox), the displayed value
	is different from the serialized value that's actually
	sent to the server (see dijit.form.ValidationTextBox.serialize)</description>
      </method>
    </methods>
    <properties>
      <property name="textbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea" superclass="dijit.form.SimpleTextarea">
    <description>A textarea that dynamically expands/contracts (changing it's height) as
	the user types, to display all the text without requiring a scroll bar.
	
	Takes nearly all the parameters (name, value, etc.) that a vanilla textarea takes.
	Rows is not supported since this widget adjusts the height.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._ExpandingTextAreaMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.SimpleTextarea" scope="instance"/>
      <mixin type="dijit.form._ExpandingTextAreaMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._ExpandingTextAreaMixin">
    <methods>
      <method name="resize" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setValueAttr" scope="instance"/>
      <method name="_resizeLater" scope="instance"/>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_estimateHeight" scope="instance"/>
    </methods>
    <properties>
      <property name="textbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TimeTextBox" superclass="dijit.form._DateTimeTextBox">
    <methods>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__Constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.TimeTextBox.__Constraints" superclass="dijit.form._DateTimeTextBox.__Constraints">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._TimePicker.__Constraints.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox.__Constraints" scope="instance"/>
      <mixin type="dijit._TimePicker.__Constraints" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._ToggleButtonMixin">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.form.ValidationTextBox.__Constraints">
    <methods/>
  </class>
  <class type="dijit.form.VerticalRule" superclass="dijit.form.HorizontalRule">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalRule" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.VerticalRuleLabels" superclass="dijit.form.HorizontalRuleLabels">
    <methods>
      <method name="_calcPosition" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalRuleLabels" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.VerticalSlider" superclass="dijit.form.HorizontalSlider">
    <methods>
      <method name="_isReversed" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalSlider" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._AutoCompleterMixin.focusNode"/>
  <class type="dijit.form._ComboBoxMenu.domNode"/>
  <class type="dijit.form._ComboBoxMenuMixin">
    <methods>
      <method name="selectLastNode" scope="instance"/>
      <method name="selectFirstNode" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onPage" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="highlightLastOption" scope="instance"/>
      <method name="highlightFirstOption" scope="instance"/>
      <method name="getHighlightedOption" scope="instance"/>
      <method name="createOptions" scope="instance">
        <parameters>
          <parameter name="results" type="Array" usage="required">
            <description>of items</description>
          </parameter>
          <parameter name="options" type="The" usage="required">
            <description>options to the query function of the store</description>
          </parameter>
          <parameter name="labelFunc" type="Function" usage="required">
            <description>to produce a label in the drop down list from a dojo.data item</description>
          </parameter>
        </parameters>
      </method>
      <method name="clearResultList" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createOption" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="labelFunc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="previousButton" scope="instance" type="Object"/>
      <property name="nextButton" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ListMouseMixin" superclass="dijit.form._ListBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_onMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOut" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._ListBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._ComboBoxMenuMixin.previousButton">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenuMixin.nextButton">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenuMixin.previousButton.style"/>
  <class type="dijit.form._ComboBoxMenuMixin.nextButton.style"/>
  <class type="dijit.form._DateTimeTextBox.__Constraints" superclass="dijit.form.RangeBoundTextBox.__Constraints">
    <methods/>
    <mixins scope="instance">
      <mixin type="locale.__FormatOptions.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox.__Constraints" scope="instance"/>
      <mixin type="locale.__FormatOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._DateTimeTextBox._buttonNode.style"/>
  <class type="dijit.form._ExpandingTextAreaMixin.textbox.style"/>
  <class type="dijit.form._ExpandingTextAreaMixin.textbox">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormSelectWidget" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="updateOption" scope="instance">
        <parameters>
          <parameter name="newOption" type="dijit.form.__SelectOption|Array&lt;dijit.form.__SelectOption&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="dojo.data.api.Identity" usage="required">
            <description>The store you would like to use - it MUST implement dojo.data.api.Identity,
	and MAY implement dojo.data.api.Notification.</description>
          </parameter>
          <parameter name="selectedValue" type="anything" usage="optional">
            <description>The value that this widget should set itself to *after* the store
	has been loaded</description>
          </parameter>
          <parameter name="fetchArgs" type="Object" usage="optional">
            <description>The arguments that will be passed to the store's fetch() function</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.data.api.Identity"/>
        </return-types>
      </method>
      <method name="removeOption" scope="instance">
        <parameters>
          <parameter name="valueOrIdx" type="String|dijit.form.__SelectOption|Number|Array" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onSetStore" scope="instance"/>
      <method name="onFetch" scope="instance"/>
      <method name="getOptions" scope="instance">
        <parameters>
          <parameter name="valueOrIdx" type="anything" usage="required">
            <description>If passed in as a string, that string is used to look up the option
	in the array of options - based on the value property.
	(See dijit.form.__SelectOption).
	
	If passed in a number, then the option with the given index (0-based)
	within this select will be returned.
	
	If passed in a dijit.form.__SelectOption, the same option will be
	returned if and only if it exists within this select.
	
	If passed an array, then an array will be returned with each element
	in the array being looked up.
	
	If not passed a value, then all options will be returned</description>
          </parameter>
        </parameters>
        <return-description>The option corresponding with the given value or index.  null
	is returned if any of the following are true:
	- A string value is passed in which doesn't exist
	- An index is passed in which is outside the bounds of the array of options
	- A dijit.form.__SelectOption is passed in which is not a part of the select</return-description>
        <return-types>
          <return-type type="Array&lt;dijit.form.__SelectOption&gt;"/>
          <return-type type="dijit.form.__SelectOption"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="addOption" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption|Array&lt;dijit.form.__SelectOption&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelection" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setDisplay" scope="instance">
        <parameters>
          <parameter name="newDisplay" type="String" usage="required">
            <description>or String[]</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_pseudoLoadChildren" scope="instance">
        <parameters>
          <parameter name="items" type="Array&lt;item&gt;" usage="required">
            <description>An array of items that will be loaded, when needed</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onSetItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onNewItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_loadChildren" scope="instance"/>
      <method name="_getValueFromOpts" scope="instance"/>
      <method name="_getSelectedOptionsAttr" scope="instance"/>
      <method name="_getOptionObjForItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.form.__SelectOption"/>
        </return-types>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance"/>
      <method name="_getChildren" scope="instance"/>
      <method name="_fillContent" scope="instance"/>
      <method name="_addOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_addOptionForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="options" scope="instance" type="Array&lt;dijit.form.__SelectOption&gt;">
        <description>The set of options for our select item.  Roughly corresponds to
	the html &amp;lt;option&amp;gt; tag.</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form._FormSelectWidget.options"/>
  <class type="dijit.form.__SelectOption">
    <methods/>
  </class>
  <class type="dijit.form._FormValueMixin" superclass="dijit.form._FormWidgetMixin">
    <description>Each _FormValueMixin represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
    <methods>
      <method name="undo" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidgetMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._FormWidgetMixin">
    <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	
	They also share some common methods.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="anything" usage="required"/>
          <parameter name="val2" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required">
            <description>the new value</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <description>For a slider, for example, dragging the slider is priorityChange==false,
	but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
	onChange is only called form priorityChange=true events.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.form._FormValueWidget.domNode"/>
  <class type="dijit.form._FormValueWidget.domNode.firstChild.style"/>
  <class type="dijit.form._ListBase">
    <methods>
      <method name="selectPreviousNode" scope="instance"/>
      <method name="selectNextNode" scope="instance"/>
      <method name="selectLastNode" scope="instance"/>
      <method name="selectFirstNode" scope="instance"/>
      <method name="_setSelectedAttr" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getTarget" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getSelectedAttr" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.form._Spinner.cssStateNodes"/>
  <class type="dijit.form._TextBoxMixin.textbox"/>
  <class type="dijit.layout._AccordionButton" superclass="dijit._Widget">
    <methods>
      <method name="getTitleHeight" scope="instance">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getParent" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setSelectedAttr" scope="instance">
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onTitleKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTitleClick" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_setTitleAttr" scope="instance" type="Object"/>
      <property name="_setLabelAttr" scope="instance" type="Object"/>
      <property name="_setIconClassAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._AccordionButton._setLabelAttr"/>
  <class type="dijit.layout._AccordionButton._setTitleAttr"/>
  <class type="dijit.layout._AccordionButton._setIconClassAttr"/>
  <class type="dijit.layout._AccordionInnerContainer" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="buttonWidget" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setSelectedAttr" scope="instance">
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="contentWidget" scope="instance" type="dijit._Widget">
        <description>Pointer to the real child widget</description>
      </property>
    </properties>
  </class>
  <class type="dijit.layout._AccordionInnerContainer.contentWidget"/>
  <class type="dijit.layout.AccordionContainer" superclass="dijit.layout.StackContainer">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="getChildren" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="optional"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="optional"/>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="If child has an href, promise that fires when the widget has finished loading"/>
        </return-types>
      </method>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <description>This is called from a handler on AccordionContainer.domNode
	(setup in StackContainer), and is also called directly from
	the click handler for accordion labels</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="fromTitle" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="_animation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer.domNode.style"/>
  <class type="dijit.layout.AccordionContainer.selectedChildWidget.containerNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer.selectedChildWidget.containerNode.style"/>
  <class type="dijit.layout.AccordionContainer.selectedChildWidget._wrapperWidget"/>
  <class type="dijit.layout.AccordionContainer._animation"/>
  <class type="dijit.layout.StackContainer" superclass="dijit.layout._LayoutWidget">
    <description>A container for widgets (ContentPanes, for example) That displays
	only one Widget at a time.
	
	Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	
	Can be base class for container, Wizard, Show, etc.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="selectChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget|String" usage="required">
            <description>Reference to child widget or id of child widget</description>
          </parameter>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="If child has an href, promise that fires when the child's href finishes loading"/>
        </return-types>
      </method>
      <method name="resize" scope="instance"/>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="forward" scope="instance"/>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="closeChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="back" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="required">
            <description>The newly selected widget.</description>
          </parameter>
          <parameter name="oldWidget" type="dijit._Widget" usage="required">
            <description>The previously selected widget.</description>
          </parameter>
          <parameter name="animate" type="Boolean" usage="required">
            <description>Used by AccordionContainer to turn on/off slide effect.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="If child has an href, promise that fires when the child's href finishes loading"/>
        </return-types>
      </method>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
        <return-description>Promise that fires when page has finished showing, or true if there's no href</return-description>
      </method>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_adjacent" scope="instance">
        <parameters>
          <parameter name="forward" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout.AccordionPane" superclass="dijit.layout.ContentPane">
    <methods>
      <method name="onSelected" scope="instance"/>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._WidgetBase.prototype"/>
  <class type="dijit.layout._Splitter" superclass="dijit._Widget">
    <description>This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	create it directly.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_stopDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_startDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_drag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="forceResize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_computeMaxSize" scope="instance"/>
      <method name="_cleanupHandlers" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="child" scope="instance" type="dijit.layout._LayoutWidget">
        <description>Pointer to the pane associated with this splitter</description>
      </property>
    </properties>
  </class>
  <class type="dijit.layout._Splitter.domNode"/>
  <class type="dijit.layout._Splitter.child"/>
  <class type="dijit.layout._Gutter" superclass="dijit._Widget">
    <description>Instantiated by `dijit.layout.BorderContainer`.  Users should not
	create directly.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout.BorderContainer" superclass="dijit.layout._LayoutWidget">
    <description>A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	that contains a child widget marked region="center" and optionally children widgets marked
	region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	Children along the edges will be laid out according to width or height dimensions and may
	include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	space is designated for the center region.
	
	The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	"left" and "right" except that they will be reversed in right-to-left environments.
	
	For complex layouts, multiple children can be specified for a single region.   In this case, the
	layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
	and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
	instead of the design attribute to control layout precedence of horizontal vs. vertical panes.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="newSize" type="Object" usage="required"/>
          <parameter name="currentSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="getSplitter" scope="instance">
        <parameters>
          <parameter name="region" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance"/>
      <method name="destroyRecursive" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutChildren" scope="instance">
        <description>With no arguments, measures the height of top/bottom panes, the width
	of left/right panes, and then sizes all panes accordingly.
	
	With changedRegion specified (as "left", "top", "bottom", or "right"),
	it changes that region's width/height to changedRegionSize and
	then resizes other regions that were affected.</description>
        <parameters>
          <parameter name="changedChildId" type="String" usage="optional">
            <description>Id of the child which should be resized because splitter was dragged.</description>
          </parameter>
          <parameter name="changedChildSize" type="Number" usage="optional">
            <description>The new width/height (in pixels) to make specified child</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="pe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.BorderContainer.pe"/>
  <class type="dijit.layout._LayoutWidget" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <description>Change size mode:
	When changeSize is specified, changes the marginBox of this widget
	and forces it to relayout its contents accordingly.
	changeSize may specify height, width, or both.
	
	If resultSize is specified it indicates the size the widget will
	become after changeSize has been applied.
	
	Notification mode:
	When changeSize is null, indicates that the caller has already changed
	the size of the widget, or perhaps it changed because the browser
	window was resized.  Tells widget to relayout its contents accordingly.
	
	If resultSize is also specified it indicates the size the widget has
	become.
	
	In either mode, this method also:
	1. Sets this._borderBox and this._contentBox to the new size of
	the widget.  Queries the current domNode size if necessary.
	2. Calls layout() to resize contents (and maybe adjust child widgets).</description>
        <parameters>
          <parameter name="changeSize" type="Object" usage="optional">
            <description>Sets the widget to this margin-box size and position.
	May include any/all of the following properties:
		{w: int, h: int, l: int, t: int}</description>
          </parameter>
          <parameter name="resultSize" type="Object" usage="optional">
            <description>The margin-box size of this widget after applying changeSize (if
	changeSize is specified).  If caller knows this size and
	passes it in, we don't need to query the browser to get the size.
		{w: int, h: int}</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout.ContentPane.domNode"/>
  <class type="dijit.layout.LayoutContainer" superclass="dijit.layout._LayoutWidget">
    <description>Provides Delphi-style panel layout semantics.
	
	A LayoutContainer is a box with a specified size (like style="width: 500px; height: 500px;"),
	that contains children widgets marked with "layoutAlign" of "left", "right", "bottom", "top", and "client".
	It takes it's children marked as left/top/bottom/right, and lays them out along the edges of the box,
	and then it takes the child marked "client" and puts it into the remaining space in the middle.
	
	Left/right positioning is similar to CSS's "float: left" and "float: right",
	and top/bottom positioning would be similar to "float: top" and "float: bottom", if there were such
	CSS.
	
	Note that there can only be one client element, but there can be multiple left, right, top,
	or bottom elements.</description>
    <methods>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout.LinkPane" superclass="dijit.layout.ContentPane">
    <description>LinkPane is just a ContentPane that is declared in markup similarly
	to an anchor.  The anchor's body (the words between `&lt;a&gt;` and `&lt;/a&gt;`)
	become the title of the widget (used for TabContainer, AccordionContainer, etc.)</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_fillContent" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout.ScrollingTabController" superclass="dijit.layout.TabController">
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStartup" scope="instance"/>
      <method name="onSelectChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAddChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doSlideRight" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The mouse click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="doSlideLeft" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The mouse click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="doSlide" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required">
            <description>If the direction is 1, the widget scrolls to the right, if it is
	-1, it scrolls to the left.</description>
          </parameter>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="createSmoothScroll" scope="instance">
        <description>If an number argument is passed to the function, that horizontal
	pixel position is scrolled to.  Otherwise the currently selected
	tab is scrolled to.</description>
        <parameters>
          <parameter name="x" type="Integer" usage="optional">
            <description>An optional pixel value to scroll to, indicating distance from left.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setButtonClass" scope="instance">
        <parameters>
          <parameter name="scroll" type="Number" usage="required">
            <description>Integer amount of horizontal scroll</description>
          </parameter>
        </parameters>
      </method>
      <method name="_initButtons" scope="instance"/>
      <method name="_getTabsWidth" scope="instance"/>
      <method name="_getScrollForSelectedTab" scope="instance"/>
      <method name="_getScrollBounds" scope="instance"/>
      <method name="_getScroll" scope="instance"/>
      <method name="_getBtnNode" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The mouse click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_enableBtn" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_convertToScrollLeft" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.TabController" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="scrollNode" scope="instance" type="Object"/>
      <property name="_setClassAttr" scope="instance" type="Object"/>
      <property name="_rightBtn" scope="instance" type="Object"/>
      <property name="_menuBtn" scope="instance" type="Object"/>
      <property name="_leftBtn" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController._setClassAttr"/>
  <class type="dijit.layout.ScrollingTabController.scrollNode.style"/>
  <class type="dijit.layout.ScrollingTabController._leftBtn"/>
  <class type="dijit.layout.ScrollingTabController._rightBtn"/>
  <class type="dijit.layout.ScrollingTabController._menuBtn"/>
  <class type="dijit.layout.ScrollingTabController.scrollNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._ScrollingTabControllerButtonMixin">
    <methods>
      <method name="isFocusable" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.layout._ScrollingTabControllerButton" superclass="Button">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="Button" scope="instance"/>
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout._ScrollingTabControllerMenuButton" superclass="Button">
    <methods>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLoaded" scope="instance"/>
      <method name="closeDropDown" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="Button" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout.TabController" superclass="dijit.layout.StackController">
    <description>Lets the user select the currently shown pane in a TabContainer or StackContainer.
	TabController also monitors the TabContainer, and whenever a pane is
	added or deleted updates itself accordingly.</description>
    <methods>
      <method name="_rectifyRtlTabList" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackController" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout.SplitContainer" superclass="dijit.layout._LayoutWidget">
    <description>A Container widget with sizing handles in-between each child.
	Contains multiple children widgets, all of which are displayed side by side
	(either horizontally or vertically); there's a bar between each of the children,
	and you can adjust the relative size of each child by dragging the bars.
	
	You must specify a size (width and height) for the SplitContainer.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="movePoint" scope="instance"/>
      <method name="legaliseSplitPoint" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="endSizing" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="changeSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required">
            <description>a widget to add</description>
          </parameter>
          <parameter name="insertIndex" type="Integer" usage="optional">
            <description>postion in the &amp;quot;stack&amp;quot; to add the child widget</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateSize" scope="instance"/>
      <method name="_showSizingLine" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_saveState" scope="instance"/>
      <method name="_restoreState" scope="instance"/>
      <method name="_onSizerMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveSlider" scope="instance">
        <parameters>
          <parameter name="slider" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveSizingLine" scope="instance"/>
      <method name="_movePanel" scope="instance">
        <parameters>
          <parameter name="panel" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideSizingLine" scope="instance"/>
      <method name="_growPane" scope="instance">
        <parameters>
          <parameter name="growth" type="Object" usage="required"/>
          <parameter name="pane" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCookieName" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkSizes" scope="instance"/>
      <method name="_addSizer" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="paneBefore" scope="instance" type="Object"/>
      <property name="paneAfter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.domNode.style"/>
  <class type="dijit.layout.SplitContainer.cover.style"/>
  <class type="dijit.layout.SplitContainer.sizingSplitter.style"/>
  <class type="dijit.layout.SplitContainer.paneBefore"/>
  <class type="dijit.layout.SplitContainer.paneAfter"/>
  <class type="dijit.layout.SplitContainer.virtualSizer.style"/>
  <class type="dijit.layout.StackController" superclass="dijit._Widget">
    <description>Monitors the specified StackContainer, and whenever a page is
	added, deleted, or selected, updates itself accordingly.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onkeypress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onStartup" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onContainerKeyPress" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCloseButtonClick" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onButtonClick" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onAddChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="adjacent" scope="instance">
        <parameters>
          <parameter name="forward" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout._StackButton" superclass="dijit.form.ToggleButton">
    <description>The button-like or tab-like object you click to select or delete a page</description>
    <methods>
      <method name="onClickCloseButton" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ToggleButton" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout.TabContainer" superclass="dijit.layout._TabContainerBase">
    <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_makeController" scope="instance">
        <parameters>
          <parameter name="srcNode" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._TabContainerBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout._TabContainerBase" superclass="dijit.layout.StackContainer">
    <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="tab" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="tablist" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabButton" superclass="dijit.layout.StackController.StackButton">
    <description>Contains the title of the pane, and optionally a close-button to destroy the pane.
	This is an internal widget and should not be instantiated directly.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setLabelAttr" scope="instance">
        <description>takes an HTML string.
	Inherited ToggleButton implementation will Set the label (text) of the button;
	Need to set the alt attribute of icon on tab buttons if no label displayed</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setCloseButtonAttr" scope="instance">
        <parameters>
          <parameter name="disp" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackController.StackButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconNode" scope="instance" type="Object"/>
      <property name="cssStateNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabButton.cssStateNodes"/>
  <class type="dijit.layout._TabButton.closeNode.style"/>
  <class type="dijit.layout._TabButton.iconNode"/>
  <class type="dijit.layout._ContentPaneResizeMixin.domNode"/>
  <class type="dijit.layout._TabContainerBase.tablist">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabContainerBase.tablist.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabContainerBase.tablist.domNode.style"/>
  <class type="dijit.place">
    <methods>
      <method name="at" scope="instance">
        <description>NOTE: node is assumed to be absolutely or relatively positioned.</description>
        <examples>
          <example>Try to place node's top right corner at (10,20).
	If that makes node go (partially) off screen, then try placing
	bottom left corner at (10,20).
		place(node, {x: 10, y: 20}, ["TR", "BL"])</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node to position</description>
          </parameter>
          <parameter name="pos" type="dijit.place.__Position" usage="required">
            <description>Object like {x: 10, y: 20}</description>
          </parameter>
          <parameter name="corners" type="Array&lt;String&gt;" usage="required">
            <description>Array of Strings representing order to try corners in, like [&amp;quot;TR&amp;quot;, &amp;quot;BL&amp;quot;].
	Possible values are:
	* &amp;quot;BL&amp;quot; - bottom left
	* &amp;quot;BR&amp;quot; - bottom right
	* &amp;quot;TL&amp;quot; - top left
	* &amp;quot;TR&amp;quot; - top right</description>
          </parameter>
          <parameter name="padding" type="dijit.place.__Position" usage="optional">
            <description>optional param to set padding, to put some buffer around the element you want to position.</description>
          </parameter>
        </parameters>
      </method>
      <method name="around" scope="instance">
        <description>Place node such that corner of node touches a corner of
	aroundNode, and that node is fully visible.</description>
        <examples>
          <example>	placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
	This will try to position node such that node's top-left corner is at the same position
	as the bottom left corner of the aroundNode (ie, put node below
	aroundNode, with left edges aligned).	If that fails it will try to put
	the bottom-right corner of node where the top right corner of aroundNode is
	(ie, put node above aroundNode, with right edges aligned)</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="anchor" type="DomNode" usage="required">
            <description>Either a DOMNode or a __Rectangle (object with x, y, width, height).</description>
          </parameter>
          <parameter name="positions" type="Array&lt;String&gt;" usage="required">
            <description>Ordered list of positions to try matching up.
	* before: places drop down to the left of the anchor node/widget, or to the right in the case
	of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
	with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
	* after: places drop down to the right of the anchor node/widget, or to the left in the case
	of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
	with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
	* before-centered: centers drop down to the left of the anchor node/widget, or to the right
	in the case of RTL scripts like Hebrew and Arabic
	* after-centered: centers drop down to the right of the anchor node/widget, or to the left
	in the case of RTL scripts like Hebrew and Arabic
	* above-centered: drop down is centered above anchor node
	* above: drop down goes above anchor node, left sides aligned
	* above-alt: drop down goes above anchor node, right sides aligned
	* below-centered: drop down is centered above anchor node
	* below: drop down goes below anchor node
	* below-alt: drop down goes below anchor node, right sides aligned</description>
          </parameter>
          <parameter name="leftToRight" type="Boolean" usage="required">
            <description>True if widget is LTR, false if widget is RTL.   Affects the behavior of &amp;quot;above&amp;quot; and &amp;quot;below&amp;quot;
	positions slightly.</description>
          </parameter>
          <parameter name="layoutNode" type="Function" usage="optional">
            <description>Function(node, aroundNodeCorner, nodeCorner)
	For things like tooltip, they are displayed differently (and have different dimensions)
	based on their orientation relative to the parent.	 This adjusts the popup based on orientation.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__Rectangle" scope="instance"/>
      <method name="__Position" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.place.__Position">
    <methods/>
  </class>
  <class type="dijit.place.__Rectangle">
    <methods/>
  </class>
  <class type="dijit.popup">
    <methods>
      <method name="open" scope="instance">
        <examples>
          <example>opening at the mouse position
			popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});</example>
          <example>opening the widget as a dropdown
			popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
	
	Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
	(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.</example>
        </examples>
        <parameters>
          <parameter name="args" type="dijit.popup.__OpenArgs" usage="required">
            <description>Parameters</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object specifying which position was chosen"/>
        </return-types>
      </method>
      <method name="moveOffScreen" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._WidgetBase" usage="required">
            <description>The widget</description>
          </parameter>
        </parameters>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._WidgetBase" usage="required">
            <description>The widget</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="popup" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__OpenArgs" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.popup.__OpenArgs">
    <methods>
      <method name="onExecute" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="onCancel" scope="instance"/>
    </methods>
  </class>
  <class type="doh.robot">
    <methods>
      <method name="waitForPageToLoad" scope="instance">
        <description>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
	returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.
	Example:
	runTest:function(){
	return waitForPageLoad(function(){ doh.robot.keyPress(dojo.keys.ENTER, 500); });
	}</description>
        <parameters>
          <parameter name="submitActions" type="Function" usage="required">
            <description>The doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),
	expecting these actions to create a page change (like a form submit).
	After these actions execute and the resulting page loads, the next test will start.</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="String|DOMNode|Function" usage="required">
            <description>The id of the node, or the node itself, to move the mouse to.
	If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
	This is useful if you need to move the mouse to an node that is not yet present.</description>
          </parameter>
          <parameter name="delay" type="Number" usage="required">
            <description>Delay, in milliseconds, to wait before firing.
	The delay is a delta with respect to the previous automation call.</description>
          </parameter>
        </parameters>
      </method>
      <method name="mouseMoveAt" scope="instance">
        <description>Moves the mouse over the specified node at the specified relative x,y offset.
	If you do not specify an offset, mouseMove will default to move to the middle of the node.
	Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);</description>
        <parameters>
          <parameter name="node" type="String|DOMNode|Function" usage="required">
            <description>The id of the node, or the node itself, to move the mouse to.
	If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
	This is useful if you need to move the mouse to an node that is not yet present.</description>
          </parameter>
          <parameter name="delay" type="Integer" usage="required">
            <description>Delay, in milliseconds, to wait before firing.
	The delay is a delta with respect to the previous automation call.
	For example, the following code ends after 600ms:
	doh.robot.mouseClick({left:true}, 100) // first call; wait 100ms
	doh.robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all</description>
          </parameter>
          <parameter name="duration" type="Integer" usage="required">
            <description>Approximate time Robot will spend moving the mouse
	The default is 100ms.</description>
          </parameter>
          <parameter name="offsetX" type="Number" usage="required">
            <description>x offset relative to the node, in pixels, to move the mouse. The default is half the node's width.</description>
          </parameter>
          <parameter name="offsetY" type="Number" usage="required">
            <description>y offset relative to the node, in pixels, to move the mouse. The default is half the node's height.</description>
          </parameter>
        </parameters>
      </method>
      <method name="initRobot" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>URL to open. Any of the test's dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls (e.g. dijit.byId()) will point to elements and widgets inside this application.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateDocument" scope="instance"/>
      <method name="_scrollIntoView" scope="instance">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_run" scope="instance">
        <parameters>
          <parameter name="frame" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveNode" scope="instance">
        <parameters>
          <parameter name="n" type="String|DOMNode|Function" usage="required"/>
        </parameters>
      </method>
      <method name="_position" scope="instance">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_getWindowChain" scope="instance">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="options"/>
  <class type="dijit.tree">
    <methods>
      <method name="model" scope="instance">
        <description>Tree passes in values to the constructor to specify the callbacks.
	"item" is typically a dojo.data.Item but it's just a black box so
	it could be anything.
	
	This (like `dojo.data.api.Read`) is just documentation, and not meant to be used.</description>
      </method>
      <method name="dndSource" scope="instance">
        <parameters>
          <parameter name="tree" type="dijit.Tree" usage="required"/>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_dndSelector" scope="instance"/>
      <method name="_dndContainer" scope="instance">
        <parameters>
          <parameter name="tree" type="Node" usage="required">
            <description>Node or node's id to build the container on</description>
          </parameter>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required">
            <description>A dict of parameters, which gets mixed into the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="__SourceArgs" scope="instance"/>
      <method name="TreeStoreModel" scope="instance">
        <examples>
          <example>	{id:'ROOT'}</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ForestStoreModel" scope="instance">
        <examples>
          <example>	{type:'continent'}</example>
        </examples>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.tree.ForestStoreModel" superclass="dijit.tree.TreeStoreModel">
    <methods>
      <method name="pasteItem" scope="instance">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onSetItem" scope="instance">
        <description>Handles updates to an item's children by calling onChildrenChange(), and
	other updates to an item by calling onChange().
	
	Also, any change to any item re-executes the query for the tree's top-level items,
	since this modified item may have started/stopped matching the query for top level items.
	
	If possible, developers should override this function to only call _requeryTop() when
	the change to the item has caused it to stop/start being a top level item in the tree.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
        </parameters>
      </method>
      <method name="onNewRootItem" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onNewItem" scope="instance">
        <description>Note that the default implementation requeries the top level items every time
	a new item is created, since any new item could be a top level item (even in
	addition to being a child of another item, since items can have multiple parents).
	
	If developers can detect which items are possible top level items (based on the item and the
	parentInfo parameters), they should override this method to only call _requeryTop() for top
	level items.  Often all top level items have parentInfo==null, but
	that will depend on which store you use and what your data is like.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLeaveRoot" scope="instance">
        <examples>
          <example>	store.unsetAttribute(item, "root");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAddToRoot" scope="instance">
        <examples>
          <example>	store.setValue(item, "root", true);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="callback" type="Function(items))" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_requeryTop" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.tree.TreeStoreModel" scope="instance"/>
    </mixins>
    <properties>
      <property name="root" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree.ForestStoreModel.root"/>
  <class type="dijit.tree.TreeStoreModel">
    <methods>
      <method name="pasteItem" scope="instance">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onSetItem" scope="instance">
        <description>Handles updates to an item's children by calling onChildrenChange(), and
	other updates to an item by calling onChange().
	
	See `onNewItem` for more details on handling updates to an item's children.</description>
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
        </parameters>
      </method>
      <method name="onNewItem" scope="instance">
        <description>If the new item is a child of an existing item,
	calls onChildrenChange() with the new list of children
	for that existing item.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <description>Note that there will also be an onChildrenChange() callback for the parent
	of this item.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="instance">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="Array&lt;dojo.data.Item&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <description>Developers will need to override this method if new items get added
	to parents with multiple children attributes, in order to define which
	children attribute points to the new item.</description>
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getRoot" scope="instance">
        <parameters>
          <parameter name="onItem" type="Object" usage="required"/>
          <parameter name="onError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="Function(items))" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.tree._dndContainer">
    <methods>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="widget" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="widget" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tree" type="Node" usage="required">
            <description>Node or node's id to build the container on</description>
          </parameter>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required">
            <description>A dict of parameters, which gets mixed into the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>A variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="_changeState" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>A name of the state to change</description>
          </parameter>
          <parameter name="newState" type="String" usage="required">
            <description>new state</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>A variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.tree._dndSelector" superclass="_dndContainer">
    <methods>
      <method name="userSelect" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="multi" type="Boolean" usage="required">
            <description>Indicates whether this is meant to be a multi-select action (e.g. ctrl-click)</description>
          </parameter>
          <parameter name="range" type="Boolean" usage="required">
            <description>Indicates whether this is meant to be a ranged action (e.g. shift-click)</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSelection" scope="instance">
        <parameters>
          <parameter name="newSelection" type="Array&lt;dijit._treeNode&gt;" usage="required">
            <description>Node[] list of tree nodes to make selected</description>
          </parameter>
        </parameters>
      </method>
      <method name="selectNone" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="removeTreeNode" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._TreeNode" usage="required">
            <description>Node node to remove</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmouseup/ontouchend event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousemove/ontouchmove event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousedown/ontouchstart event</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="ignore right-click"/>
        </return-types>
      </method>
      <method name="isTreeNodeSelected" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._TreeNode" usage="required">
            <description>Node the node to check whether it's in the current selection</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSelectedTreeNodes" scope="instance"/>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="forInSelectedItems" scope="instance">
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="addTreeNode" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._TreeNode" usage="required">
            <description>Node node to add</description>
          </parameter>
          <parameter name="isAnchor" type="Boolean" usage="optional">
            <description>Whether the node should become anchor.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateSelectionProperties" scope="instance"/>
      <method name="_setDifference" scope="instance">
        <parameters>
          <parameter name="xs" type="Object" usage="required"/>
          <parameter name="ys" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_compareNodes" scope="instance">
        <parameters>
          <parameter name="n1" type="Object" usage="required"/>
          <parameter name="n2" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_dndContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="current" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree._dndSelector.current"/>
  <class type="dijit.tree.dndSource" superclass="_dndSelector">
    <methods>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmouseup/ontouchend event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance"/>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousemouse/ontouchmove event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousedown/ontouchend event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>The dijit.tree.dndSource / dojo.dnd.Source which is providing the items</description>
          </parameter>
          <parameter name="nodes" type="Array&lt;DomNode&gt;" usage="required">
            <description>The list of transferred items, dndTreeNode nodes if dragging from a Tree</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>Copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>The dijit.tree.dndSource / dojo.dnd.Source which has the mouse over it</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndDrop" scope="instance">
        <description>Updates data store items according to where node was dragged from and dropped
	to.   The tree will then respond to those data store updates and redraw itself.</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>The dijit.tree.dndSource / dojo.dnd.Source which is providing the items</description>
          </parameter>
          <parameter name="nodes" type="Array&lt;DomNode&gt;" usage="required">
            <description>The list of transferred items, dndTreeNode nodes if dragging from a Tree</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>Copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="itemCreator" scope="instance">
        <description>For each node in nodes[], which came from source, create a hash of name/value
	pairs to be passed to Tree.model.newItem().  Returns array of those hashes.</description>
        <parameters>
          <parameter name="nodes" type="Array&lt;DomNode&gt;" usage="required"/>
          <parameter name="target" type="DomNode" usage="required"/>
          <parameter name="source" type="dojo.dnd.Source" usage="required"/>
        </parameters>
        <return-description>Object[]
	Array of name/value hashes for each new item to be added to the Tree, like:
		[
			{ id: 123, label: "apple", foo: "bar" },
			{ id: 456, label: "pear", zaz: "bam" }
		]</return-description>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="copyState" scope="instance">
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <description>The &amp;quot;copy&amp;quot; control key was pressed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tree" type="dijit.Tree" usage="required"/>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required"/>
        </parameters>
      </method>
      <method name="checkItemAcceptance" scope="instance">
        <description>In the base case, this is called to check if target can become a child of source.
	When betweenThreshold is set, position="before" or "after" means that we
	are asking if the source node can be dropped before/after the target node.</description>
        <parameters>
          <parameter name="target" type="DOMNode" usage="required">
            <description>The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
	Use dijit.getEnclosingWidget(target) to get the TreeNode.</description>
          </parameter>
          <parameter name="source" type="dijit.tree.dndSource" usage="required">
            <description>The (set of) nodes we are dropping</description>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <description>&amp;quot;over&amp;quot;, &amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="dijit.tree.dndSource" usage="required">
            <description>The source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array&lt;DOMNode&gt;" usage="required">
            <description>Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
	source is a dijit.Tree.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_onDragMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_markDndStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isParentChildDrop" scope="instance">
        <parameters>
          <parameter name="source" type="The" usage="required">
            <description>DragSource object.</description>
          </parameter>
          <parameter name="targetRow" type="The" usage="required">
            <description>tree row onto which the dragged nodes are being dropped.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_dndSelector" scope="instance"/>
    </mixins>
    <properties>
      <property name="tree" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree.dndSource.tree"/>
  <class type="dijit.tree.__SourceArgs">
    <methods/>
  </class>
  <class type="dijit.tree.model">
    <description>Tree passes in values to the constructor to specify the callbacks.
	"item" is typically a dojo.data.Item but it's just a black box so
	it could be anything.
	
	This (like `dojo.data.api.Read`) is just documentation, and not meant to be used.</description>
    <methods>
      <method name="pasteItem" scope="instance">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="instance">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="Array&lt;dojo.data.Item&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRoot" scope="instance">
        <parameters>
          <parameter name="onItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="Function(items))" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.typematic">
    <methods>
      <method name="trigger" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>key or mouse event object</description>
          </parameter>
          <parameter name="_this" type="Object" usage="required">
            <description>pointer to the user's widget space.</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>the DOM node object passed in</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>function to call until the sequence is stopped called with 3 parameters:
	count:
	integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped</description>
          </parameter>
          <parameter name="obj" type="Object" usage="required">
            <description>user space object used to uniquely identify each typematic sequence
	subsequentDelay (optional):
	if &amp;gt; 1, the number of milliseconds until the 3-&amp;gt;n events occur
	or else the fractional time multiplier for the next event's delay, default=0.9
	initialDelay (optional):
	the number of milliseconds until the 2nd event occurs, default=500ms
	minDelay (optional):
	the maximum delay in milliseconds for event to fire, default=10ms</description>
          </parameter>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="stop" scope="instance"/>
      <method name="addMouseListener" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
        <return-description>a connection handle</return-description>
      </method>
      <method name="addListener" scope="instance">
        <parameters>
          <parameter name="mouseNode" type="Node" usage="required">
            <description>the DOM node object to listen on for mouse events.</description>
          </parameter>
          <parameter name="keyNode" type="Node" usage="required">
            <description>the DOM node object to listen on for key events.</description>
          </parameter>
          <parameter name="keyObject" type="Object" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
        <return-description>a connection handle</return-description>
      </method>
      <method name="addKeyListener" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="keyObject" type="Object" usage="required">
            <description>an object defining the key to listen for:
	charOrCode:
	the printable character (string) or keyCode (number) to listen for.
	keyCode:
	(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
	charCode:
	(deprecated - use charOrCode) the charCode (number) to listen for.
	ctrlKey:
	desired ctrl key state to initiate the callback sequence:
	- pressed (true)
	- released (false)
	- either (unspecified)
	altKey:
	same as ctrlKey but for the alt key
	shiftKey:
	same as ctrlKey but for the shift key</description>
          </parameter>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
        <return-description>a connection handle</return-description>
      </method>
      <method name="_fireEventAndReload" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.typematic._fireEventAndReload">
    <methods/>
  </class>
  <class type="dijit.typematic.trigger">
    <methods/>
  </class>
  <class type="dijit.typematic.stop">
    <methods/>
  </class>
  <class type="dojo.AdapterRegistry">
    <description>Objects of this class keep list of arrays in the form [name, check,
	wrap, directReturn] that are used to determine what the contextual
	result of a set of checked arguments is. All check/wrap functions
	in this registry should be of the same arity.</description>
    <methods>
      <method name="unregister" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the adapter.</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	Returns true if operation is successful.
	Returns false if operation fails.</return-description>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>a way to identify this matcher.</description>
          </parameter>
          <parameter name="check" type="Function" usage="required">
            <description>a function that arguments are passed to from the adapter's
	match() function.  The check function should return true if the
	given arguments are appropriate for the wrap function.</description>
          </parameter>
          <parameter name="wrap" type="Function" usage="required"/>
          <parameter name="directReturn" type="Boolean" usage="optional">
            <description>If directReturn is true, the value passed in for wrap will be
	returned instead of being called. Alternately, the
	AdapterRegistry can be set globally to &amp;quot;return not call&amp;quot; using
	the returnWrappers property. Either way, this behavior allows
	the registry to act as a &amp;quot;search&amp;quot; function instead of a
	function interception library.</description>
          </parameter>
          <parameter name="override" type="Boolean" usage="optional">
            <description>If override is given and true, the check function will be given
	highest priority. Otherwise, it will be the lowest priority
	adapter.</description>
          </parameter>
        </parameters>
      </method>
      <method name="match" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.DeferredList">
    <description>DeferredList takes an array of existing deferreds and returns a new deferred of its own
	this new deferred will typically have its callback fired when all of the deferreds in
	the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	fireOnOneErrback, will fire before all the deferreds as appropriate</description>
    <methods>
      <method name="gatherResults" scope="instance">
        <parameters>
          <parameter name="deferredList" type="dojo.DeferredList" usage="required">
            <description>The deferred list from which this function gathers results.</description>
          </parameter>
        </parameters>
        <return-description>dojo.DeferredList
	The newly created deferred list which packs results as
	parameters to its callback.</return-description>
      </method>
    </methods>
  </class>
  <class type="aspect"/>
  <class type="dojo.NodeList">
    <description>dojo.NodeList instances provide many utilities that reflect
	core Dojo APIs for Array iteration and manipulation, DOM
	manipulation, and event handling. Instead of needing to dig up
	functions in the dojo.* namespace, NodeLists generally make the
	full power of Dojo available for DOM manipulation tasks in a
	simple, chainable way.</description>
    <methods>
      <method name="wrapInner" scope="instance">
        <description>html will be cloned if the NodeList has more than one
	element. Only DOM nodes are cloned, not any attached
	event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").wrapInner('&lt;span class="special"&gt;&lt;/span&gt;');
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;&lt;span class="special"&gt;Red One&lt;/span&gt;&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;&lt;span class="special"&gt;Red Two&lt;/span&gt;&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="html" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrapAll" scope="instance">
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").wrapAll('&lt;div class="allRed"&gt;&lt;/div&gt;');
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="allRed"&gt;
				&lt;div class="red"&gt;Red One&lt;/div&gt;
				&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="html" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrap" scope="instance">
        <description>html will be cloned if the NodeList has more than one
	element. Only DOM nodes are cloned, not any attached
	event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;b&gt;one&lt;/b&gt;
		&lt;b&gt;two&lt;/b&gt;
	Running this code:
		dojo.query("b").wrap("&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;");
	Results in this DOM structure:
		&lt;div&gt;&lt;span&gt;&lt;b&gt;one&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;
		&lt;div&gt;&lt;span&gt;&lt;b&gt;two&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="html" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wipeOut" scope="instance">
        <examples>
          <example>Wipe out all tables with class "blah":
		dojo.query("table.blah").wipeOut().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an `auto` parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wipeIn" scope="instance">
        <examples>
          <example>Fade in all tables with class "blah":
		dojo.query("table.blah").wipeIn().play();</example>
          <example>Utilizing `auto` to get the NodeList back:
		dojo.query(".titles").wipeIn({ auto:true }).onclick(someFunction);</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an `auto` parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="val" scope="instance">
        <examples>
          <example>assume a DOM created by this markup:
		&lt;input type="text" value="foo"&gt;
		&lt;select multiple&gt;
			&lt;option value="red" selected&gt;Red&lt;/option&gt;
			&lt;option value="blue"&gt;Blue&lt;/option&gt;
			&lt;option value="yellow" selected&gt;Yellow&lt;/option&gt;
		&lt;/select&gt;
	This code gets and sets the values for the form fields above:
		dojo.query('[type="text"]').val(); //gets value foo
		dojo.query('[type="text"]').val("bar"); //sets the input's value to "bar"
		dojo.query("select").val() //gets array value ["red", "yellow"]
		dojo.query("select").val(["blue", "yellow"]) //Sets the blue and yellow options to selected.</example>
        </examples>
        <parameters>
          <parameter name="value" type="String|Array" usage="required"/>
        </parameters>
        <return-description>if no value is passed, the result is String or an Array, for the value of the
	first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="toString" scope="instance"/>
      <method name="text" scope="instance">
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;/div&gt;
	This code inserts "Hello World" into both divs:
		dojo.query("div").text("Hello World");</example>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars &lt;span&gt;today&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	This code returns "Hello Mars today":
		var message = dojo.query("div").text();</example>
        </examples>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-description>if no value is passed, the result is String, the text value of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="splice" scope="instance">
        <description>This method behaves exactly like the Array.splice method
	with the caveat that it returns a dojo.NodeList and not a
	raw Array. For more details, see Mozilla's (splice
	documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:splice]
	For backwards compatibility, calling .end() on the spliced NodeList
	does not return the original NodeList -- splice alters the NodeList in place.</description>
        <parameters>
          <parameter name="index" type="Integer" usage="required">
            <description>begin can be a positive or negative integer, with positive
	integers noting the offset to begin at, and negative
	integers denoting an offset from the end (i.e., to the left
	of the end)</description>
          </parameter>
          <parameter name="howmany" type="Integer" usage="optional">
            <description>Optional parameter to describe what position relative to
	the NodeList's zero index to end the slice at. Like begin,
	can be positive or negative.</description>
          </parameter>
          <parameter name="item" type="Object" usage="optional">
            <description>Any number of optional parameters may be passed in to be
	spliced into the NodeList</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
      </method>
      <method name="some" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>the callback</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>the context</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="slideTo" scope="instance">
        <examples>
          <example>	Move all tables with class "blah" to 300/300:
		dojo.query("table.blah").slideTo({
			left: 40,
			top: 50
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an `auto` parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="slice" scope="instance">
        <description>This method behaves exactly like the Array.slice method
	with the caveat that it returns a dojo.NodeList and not a
	raw Array. For more details, see Mozilla's (slice
	documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:slice]</description>
        <parameters>
          <parameter name="begin" type="Integer" usage="required">
            <description>Can be a positive or negative integer, with positive
	integers noting the offset to begin at, and negative
	integers denoting an offset from the end (i.e., to the left
	of the end)</description>
          </parameter>
          <parameter name="end" type="Integer" usage="optional">
            <description>Optional parameter to describe what position relative to
	the NodeList's zero index to end the slice at. Like begin,
	can be positive or negative.</description>
          </parameter>
        </parameters>
      </method>
      <method name="siblings" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").siblings();
	returns the two divs with class "red" and the other div
		with class "blue" that does not have "first".
	Running this code:
		dojo.query(".first").siblings(".red");
	returns the two div with class "red".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all sibling elements for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="replaceWith" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").replaceWith('&lt;div class="green"&gt;Green&lt;/div&gt;');
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="green"&gt;Green&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="green"&gt;Green&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|DOMNode|NodeList" usage="required"/>
        </parameters>
        <return-description>The nodes currently in this NodeList will be returned, not the replacing content.
	Note that the returned nodes have been removed from the DOM.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="replaceAll" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").replaceAll(".blue");
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>The nodes currently in this NodeList will be returned, not the matched nodes
	from the query. The nodes currently in this NodeLIst could have
	been cloned, so the returned NodeList will include the cloned nodes.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="removeData" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="optional">
            <description>If ommitted, clean all data for this node.
	If passed, remove the data item found at `key`</description>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="simpleFilter" type="String" usage="required">
            <description>single-expression CSS rule. For example, &amp;quot;.thinger&amp;quot; or
	&amp;quot;#someId[attrName='value']&amp;quot; but not &amp;quot;div &amp;gt; span&amp;quot;. In short,
	anything which does not invoke a descent to evaluate but
	can instead be used to test a single node is acceptable.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="prevAll" scope="instance">
        <description>The returned nodes will be in reverse DOM order -- the first node in the list will
	be the node closest to the original node/NodeList.
	.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red prev"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue prev"&gt;Blue One&lt;/div&gt;
			&lt;div class="red second"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".second").prevAll();
	returns the two divs with class of "prev".
	Running this code:
		dojo.query(".first").prevAll(".red");
	returns the one div with class "red prev" and innerHTML "Red One".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all sibling elements that come before the nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="prev" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").prev();
	returns the div with class "red" and has innerHTML of "Red One".
	Running this code:
		dojo.query(".first").prev(".blue");
	does not return any elements.</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, the previous element for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="prependTo" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;prepend&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").prependTo("p");
	Results in this DOM structure:
		&lt;p&gt;&lt;span&gt;prepend&lt;/span&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;&lt;span&gt;prepend&lt;/span&gt;Hello World&lt;/p&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="prepend" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="content" type="String|DOMNode|NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.
	assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").prepend("&lt;span&gt;prepend&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;span&gt;prepend&lt;/span&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;span&gt;prepend&lt;/span&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="parents" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;&lt;span class="text"&gt;Blue One&lt;/span&gt;&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;&lt;span class="text"&gt;Blue Two&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".text").parents();
	returns the two divs with class "blue", the div with class "container",
		the body element and the html element.
	Running this code:
		dojo.query(".text").parents(".container");
	returns the one div with class "container".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all parent elements for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="parent" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;&lt;span class="text"&gt;Blue One&lt;/span&gt;&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;&lt;span class="text"&gt;Blue Two&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".text").parent();
	returns the two divs with class "blue".
	Running this code:
		dojo.query(".text").parent(".first");
	returns the one div with class "blue" and "first".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, immediate parent elements for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="on" scope="instance">
        <parameters>
          <parameter name="eventName" type="Object" usage="required"/>
          <parameter name="listener" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="TODO: apply to the NodeList so the same selector engine is used for matches"/>
        </return-types>
      </method>
      <method name="odd" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="interior red"&gt;Red One&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="interior red"&gt;Red Two&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".interior").odd();
	returns the two divs with class "red"</example>
        </examples>
        <return-description>dojo.NodeList, with the odd nodes in this dojo.NodeList</return-description>
      </method>
      <method name="nextAll" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red next"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue next"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").nextAll();
	returns the two divs with class of "next".
	Running this code:
		dojo.query(".first").nextAll(".red");
	returns the one div with class "red" and innerHTML "Red Two".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all sibling elements that come after the nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="next" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue last"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").next();
	returns the div with class "red" and has innerHTML of "Red Two".
	Running this code:
		dojo.query(".last").next(".red");
	does not return any elements.</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, the next element for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="obj" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="lastIndexOf" scope="instance">
        <description>For more details on the behavior of lastIndexOf, see
	Mozilla's (lastIndexOf
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:lastIndexOf]</description>
        <parameters>
          <parameter name="value" type="Object" usage="required">
            <description>The value to search for.</description>
          </parameter>
          <parameter name="fromIndex" type="Integer" usage="optional">
            <description>The location to start searching from. Optional. Defaults to 0.</description>
          </parameter>
        </parameters>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="last" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue last"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".blue").last();
	returns the last div with class "blue",</example>
        </examples>
        <return-description>dojo.NodeList, with the last node in this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="instantiate" scope="instance">
        <examples>
          <example>Grabs all buttons in the page and converts them to diji.form.Buttons.
		var buttons = dojo.query("button").instantiate("dijit.form.Button", {showLabel: true});</example>
        </examples>
        <parameters>
          <parameter name="declaredClass" type="String|Object" usage="required"/>
          <parameter name="properties" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="insertBefore" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;before&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").insertBefore("p");
	Results in this DOM structure:
		&lt;span&gt;before&lt;/span&gt;&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;span&gt;before&lt;/span&gt;&lt;p&gt;Hello World&lt;/p&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="insertAfter" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;after&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").insertAfter("p");
	Results in this DOM structure:
		&lt;p&gt;Hello Mars&lt;/p&gt;&lt;span&gt;after&lt;/span&gt;
		&lt;p&gt;Hello World&lt;/p&gt;&lt;span&gt;after&lt;/span&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="innerHTML" scope="instance">
        <description>This method is simpler than the dojo.NodeList.html() method provided by
	`dojo.NodeList-html`. This method just does proper innerHTML insertion of HTML fragments,
	and it allows for the innerHTML to be read for the first node in the node list.
	Since dojo.NodeList-html already took the "html" name, this method is called
	"innerHTML". However, if dojo.NodeList-html has not been loaded yet, this
	module will define an "html" method that can be used instead. Be careful if you
	are working in an environment where it is possible that dojo.NodeList-html could
	have been loaded, since its definition of "html" will take precedence.
	The nodes represented by the value argument will be cloned if more than one
	node is in this NodeList. The nodes in this NodeList are returned in the "set"
	usage of this method, not the HTML that was inserted.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;/div&gt;
	This code inserts &lt;p&gt;Hello World&lt;/p&gt; into both divs:
		dojo.query("div").innerHTML("&lt;p&gt;Hello World&lt;/p&gt;");</example>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	This code returns "&lt;p&gt;Hello Mars&lt;/p&gt;":
		var message = dojo.query("div").innerHTML();</example>
        </examples>
        <parameters>
          <parameter name="value" type="String|DOMNode|NodeList" usage="optional"/>
        </parameters>
        <return-description>if no value is passed, the result is String, the innerHTML of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="indexOf" scope="instance">
        <description>For more details on the behavior of indexOf, see Mozilla's
	(indexOf
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:indexOf]</description>
        <parameters>
          <parameter name="value" type="Object" usage="required">
            <description>The value to search for.</description>
          </parameter>
          <parameter name="fromIndex" type="Integer" usage="optional">
            <description>The location to start searching from. Optional. Defaults to 0.</description>
          </parameter>
        </parameters>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="html" scope="instance">
        <description>An alias for the "innerHTML" method, but only defined if there is not an existing
	"html" method on dojo.NodeList. Be careful if you are working in an environment
	where it is possible that dojo.NodeList-html could have been loaded, since its
	definition of "html" will take precedence. If you are not sure if dojo.NodeList-html
	could be loaded, use the "innerHTML" method.</description>
        <examples>
          <example> dojo.query(".thingList").html("&lt;li dojoType='dojo.dnd.Moveable'&gt;1&lt;/li&gt;&lt;li dojoType='dojo.dnd.Moveable'&gt;2&lt;/li&gt;&lt;li dojoType='dojo.dnd.Moveable'&gt;3&lt;/li&gt;",
	 {
	 	parseContent: true,
	 	onBegin: function(){
	 		this.content = this.content.replace(/([0-9])/g, this.id + ": $1");
	 		this.inherited("onBegin", arguments);
	 	}
	 }).removeClass("notdone").addClass("done");</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|DomNode|NodeList" usage="optional">
            <description>An html string, node or enumerable list of nodes for insertion into the dom</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <description>Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter</description>
          </parameter>
        </parameters>
        <return-description>if no value is passed, the result is String, the innerHTML of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="thisObj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="first" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue last"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".blue").first();
	returns the div with class "blue" and "first".</example>
        </examples>
        <return-description>dojo.NodeList, with the first node in this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <examples>
          <example>"regular" JS filter syntax as exposed in dojo.filter:
		dojo.query("*").filter(function(item){
			// highlight every paragraph
			return (item.nodeName == "p");
		}).style("backgroundColor", "yellow");</example>
          <example>the same filtering using a CSS selector
		dojo.query("*").filter("p").styles("backgroundColor", "yellow");</example>
        </examples>
        <parameters>
          <parameter name="filter" type="String|Function" usage="required">
            <description>If a string, a CSS rule like &amp;quot;.thinger&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="fadeOut" scope="instance">
        <examples>
          <example>Fade out all elements with class "zork":
		dojo.query(".zork").fadeOut().play();</example>
          <example>Fade them on a delay and do something at the end:
		var fo = dojo.query(".zork").fadeOut();
		dojo.connect(fo, "onEnd", function(){ /*...*/ });
		fo.play();</example>
          <example>Using `auto`:
		dojo.query("li").fadeOut({ auto:true }).filter(filterFn).forEach(doit);</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an `auto` parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="instance">
        <examples>
          <example>Fade in all tables with class "blah":
		dojo.query("table.blah").fadeIn().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an `auto` parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>the callback</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>the context</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="even" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="interior red"&gt;Red One&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="interior red"&gt;Red Two&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".interior").even();
	returns the two divs with class "blue"</example>
        </examples>
        <return-description>dojo.NodeList, with the even nodes in this dojo.NodeList</return-description>
      </method>
      <method name="end" scope="instance">
        <description>Returns the `dojo.NodeList` that generated the current `dojo.NodeList`. If there
	is no parent dojo.NodeList, an empty dojo.NodeList is returned.</description>
        <examples>
          <example>	dojo.query("a")
			.filter(".disabled")
				// operate on the anchors that only have a disabled class
				.style("color", "grey")
			.end()
			// jump back to the list of anchors
			.style(...)</example>
        </examples>
      </method>
      <method name="delegate" scope="instance">
        <description>Sets up event handlers that can catch events on any subnodes matching a given selector,
	including nodes created after delegate() has been called.
	
	This allows an app to setup a single event handler on a high level node, rather than many
	event handlers on subnodes. For example, one onclick handler for a Tree widget, rather than separate
	handlers for each node in the tree.
	Since setting up many event handlers is expensive, this can increase performance.
	
	Note that delegate() will not work for events that don't bubble, like focus.
	onmouseenter/onmouseleave also don't currently work.</description>
        <examples>
          <example>	dojo.query("navbar").delegate("a", "onclick", function(evt){
				console.log("user clicked anchor ", this.node);
		});</example>
        </examples>
        <parameters>
          <parameter name="selector" type="String" usage="required">
            <description>CSS selector valid to `dojo.query`, like &amp;quot;.foo&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;.  The
	selector is relative to the nodes in this NodeList, not the document root.
	For example myNodeList.delegate(&amp;quot;&amp;gt; a&amp;quot;, &amp;quot;onclick&amp;quot;, ...) will catch events on
	anchor nodes which are (immediate) children of the nodes in myNodeList.</description>
          </parameter>
          <parameter name="eventName" type="String" usage="required">
            <description>Standard event name used as an argument to `dojo.connect`, like &amp;quot;onclick&amp;quot;.</description>
          </parameter>
          <parameter name="fn" type="Function" usage="required">
            <description>Callback function passed the event object, and where this == the node that matches the selector.
	That means that for example, after setting up a handler via
	dojo.query(&amp;quot;body&amp;quot;).delegate(&amp;quot;fieldset&amp;quot;, &amp;quot;onclick&amp;quot;, ...)
	clicking on a fieldset or *any nodes inside of a fieldset* will be reported
	as a click on the fieldset itself.</description>
          </parameter>
        </parameters>
      </method>
      <method name="data" scope="instance">
        <description>Stash or get some arbirtrary data on/from these nodes. This private _data function is
	exposed publicly on `dojo.NodeList`, eg: as the result of a `dojo.query` call.
	DIFFERS from jQuery.data in that when used as a getter, the entire list is ALWAYS
	returned. EVEN WHEN THE LIST IS length == 1.
	
	A single-node version of this function is provided as `dojo._nodeData`, which follows
	the same signature, though expects a String ID or DomNode reference in the first
	position, before key/value arguments.
	
	node: String|DomNode
	The node to associate data with</description>
        <examples>
          <example>Set a key `bar` to some data, then retrieve it.
		dojo.query(".foo").data("bar", "touched");
		var touched = dojo.query(".foo").data("bar");
		if(touched[0] == "touched"){ alert('win'); }</example>
          <example>Get all the data items for a given node.
		var list = dojo.query(".foo").data();
		var first = list[0];</example>
          <example>Set the data to a complex hash. Overwrites existing keys with new value
		dojo.query(".foo").data({ bar:"baz", foo:"bar" });
	Then get some random key:
		dojo.query(".foo").data("foo"); // returns [`bar`]</example>
        </examples>
        <parameters>
          <parameter name="key" type="Object|String" usage="optional">
            <description>If an object, act as a setter and iterate over said object setting data items as defined.
	If a string, and `value` present, set the data for defined `key` to `value`
	If a string, and `value` absent, act as a getter, returning the data associated with said `key`</description>
          </parameter>
          <parameter name="value" type="Anything" usage="optional">
            <description>The value to set for said `key`, provided `key` is a string (and not an object)</description>
          </parameter>
        </parameters>
        <return-description>Object|Anything|Nothing
	When used as a setter via `dojo.NodeList`, a NodeList instance is returned
	for further chaning. When used as a getter via `dojo.NodeList` an ARRAY
	of items is returned. The items in the array correspond to the elements
	in the original list. This is true even when the list length is 1, eg:
	when looking up a node by ID (#foo)</return-description>
      </method>
      <method name="coords" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <examples>
          <example>add an onclick handler to every button on the page
		dojo.query("div:nth-child(odd)").connect("onclick", function(e){
			console.log("clicked!");
		});</example>
          <example>attach foo.bar() to every odd div's onmouseover
		dojo.query("div:nth-child(odd)").connect("onmouseover", foo, "bar");</example>
        </examples>
        <parameters>
          <parameter name="methodName" type="String" usage="required">
            <description>the name of the method to attach to. For DOM events, this should be
	the lower-case name of the event</description>
          </parameter>
          <parameter name="objOrFunc" type="Object|Function|String" usage="required">
            <description>if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
	reference a function or be the name of the function in the global
	namespace to attach. If 3 arguments are provided
	(methodName, objOrFunc, funcName), objOrFunc must be the scope to
	locate the bound function in</description>
          </parameter>
          <parameter name="funcName" type="String" usage="optional">
            <description>optional. A string naming the function in objOrFunc to bind to the
	event. May also be a function reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="concat" scope="instance">
        <description>This method behaves exactly like the Array.concat method
	with the caveat that it returns a `dojo.NodeList` and not a
	raw Array. For more details, see the (Array.concat
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:concat]</description>
        <parameters>
          <parameter name="item" type="Object" usage="optional">
            <description>Any number of optional parameters may be passed in to be
	spliced into the NodeList</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="closest" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").closest(".container");
	returns the div with class "container".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <description>a CSS selector.</description>
          </parameter>
          <parameter name="root" type="String|DOMNode" usage="optional">
            <description>If specified, query is relative to &amp;quot;root&amp;quot; rather than document body.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, the closest parent that matches the query, including the current
	node in this dojo.NodeList if it matches the query.</return-description>
        <return-types>
          <return-type type="To make rhino strict checking happy"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <description>Only the DOM nodes are cloned, not any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").clone().appendTo(".container");
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <return-description>dojo.NodeList, a cloned set of the original nodes.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="children" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".container").children();
	returns the four divs that are children of the container div.
	Running this code:
		dojo.query(".container").children(".red");
	returns the two divs that have the class "red".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all immediate child elements for the nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="before" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").before("&lt;span&gt;before&lt;/span&gt;");
	Results in this DOM structure:
		&lt;span&gt;before&lt;/span&gt;&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;span&gt;before&lt;/span&gt;&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|DOMNode|NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="at" scope="instance">
        <examples>
          <example>Shorten the list to the first, second, and third elements
		dojo.query("a").at(0, 1, 2).forEach(fn);</example>
          <example>Retrieve the first and last elements of a unordered list:
		dojo.query("ul &gt; li").at(0, -1).forEach(cb);</example>
          <example>Do something for the first element only, but end() out back to
	the original list and continue chaining:
		dojo.query("a").at(0).onclick(fn).end().forEach(function(n){
			console.log(n); // all anchors on the page.
		})</example>
        </examples>
        <parameters>
          <parameter name="index" type="Integer" usage="one-or-more">
            <description>One or more 0-based indices of items in the current
	NodeList. A negative index will start at the end of the
	list and go backwards.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="appendTo" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;append&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").appendTo("p");
	Results in this DOM structure:
		&lt;p&gt;Hello Mars&lt;span&gt;append&lt;/span&gt;&lt;/p&gt;
		&lt;p&gt;Hello World&lt;span&gt;append&lt;/span&gt;&lt;/p&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="append" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").append("&lt;span&gt;append&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;span&gt;append&lt;/span&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;span&gt;append&lt;/span&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|DOMNode|NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="animateProperty" scope="instance">
        <examples>
          <example>	dojo.query(".zork").animateProperty({
			duration: 500,
			properties: {
				color:		{ start: "black", end: "white" },
				left:		{ end: 300 }
			}
		}).play();</example>
          <example>	dojo.query(".grue").animateProperty({
			auto:true,
			properties: {
				height:240
			}
		}).onclick(handler);</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an `auto` parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="anim" scope="instance">
        <examples>
          <example>Another way to fade out:
		dojo.query(".thinger").anim({ opacity: 0 });</example>
          <example>animate all elements with the "thigner" class to a width of 500
	pixels over half a second
		dojo.query(".thinger").anim({ width: 500 }, 700);</example>
        </examples>
        <parameters>
          <parameter name="properties" type="Object" usage="required">
            <description>the properties to animate. does NOT support the `auto` parameter like other
	NodeList-fx methods.</description>
          </parameter>
          <parameter name="duration" type="Integer" usage="optional">
            <description>Optional. The time to run the animations for</description>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <description>Optional. The easing function to use.</description>
          </parameter>
          <parameter name="onEnd" type="Function" usage="optional">
            <description>A function to be called when the animation ends</description>
          </parameter>
          <parameter name="delay" type="Integer" usage="optional">
            <description>how long to delay playing the returned animation</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="andSelf" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red prev"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue prev"&gt;Blue One&lt;/div&gt;
			&lt;div class="red second"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".second").prevAll().andSelf();
	returns the two divs with class of "prev", as well as the div with class "second".</example>
        </examples>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="after" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").after("&lt;span&gt;after&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;&lt;span&gt;after&lt;/span&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;&lt;span&gt;after&lt;/span&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|Element|NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_stash" scope="instance">
        <examples>
          <example>How to make a `dojo.NodeList` method that only returns the third node in
	the dojo.NodeList but allows access to the original NodeList by using this._stash:
		dojo.extend(dojo.NodeList, {
			third: function(){
				var newNodeList = dojo.NodeList(this[2]);
				return newNodeList._stash(this);
			}
		});
		// then see how _stash applies a sub-list, to be .end()'ed out of
		dojo.query(".foo")
			.third()
				.addClass("thirdFoo")
			.end()
			// access to the orig .foo list
			.removeClass("foo")</example>
        </examples>
        <parameters>
          <parameter name="parent" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_placeMultiple" scope="instance">
        <parameters>
          <parameter name="query" type="String|Node|NodeList" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_getUniqueNodeListWithParent" scope="instance">
        <parameters>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_getUniqueAsNodeList" scope="instance">
        <parameters>
          <parameter name="nodes" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_getRelatedUniqueNodes" scope="instance">
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_buildArrayFromCallback" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_anim" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="style" scope="instance" type="Object"/>
      <property name="prototype" scope="instance" type="Object"/>
      <property name="attr" scope="instance" type="Object"/>
      <property name="addContent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="query">
    <methods>
      <method name="NodeList" scope="instance"/>
    </methods>
  </class>
  <class type="query.NodeList">
    <methods>
      <method name="toggleClass" scope="instance">
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>the CSS class to add</description>
          </parameter>
          <parameter name="condition" type="Boolean" usage="optional">
            <description>If passed, true means to add the class, false means to remove.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="style" scope="instance">
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>the CSS property to get/set, in JavaScript notation
	(&amp;quot;lineHieght&amp;quot; instead of &amp;quot;line-height&amp;quot;)</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>optional. The value to set the property to</description>
          </parameter>
        </parameters>
        <return-description>if no value is passed, the result is an array of strings.
	If a value is passed, the return is this NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="removeClass" scope="instance">
        <parameters>
          <parameter name="className" type="String|Array" usage="optional">
            <description>An optional String class name to remove, or several space-separated
	class names, or an array of class names. If omitted, all class names
	will be deleted.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, this list</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="query" scope="instance">
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;
			&lt;p&gt;
				bacon is tasty, &lt;span&gt;dontcha think?&lt;/span&gt;
			&lt;/p&gt;
		&lt;/div&gt;
		&lt;div id="bar"&gt;
			&lt;p&gt;great comedians may not be funny &lt;span&gt;in person&lt;/span&gt;&lt;/p&gt;
		&lt;/div&gt;
	If we are presented with the following definition for a NodeList:
		var l = new dojo.NodeList(dojo.byId("foo"), dojo.byId("bar"));
	it's possible to find all span elements under paragraphs
	contained by these elements with this sub-query:
		var spans = l.query("p span");</example>
        </examples>
        <parameters>
          <parameter name="queryStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="position" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="queryOrNode" type="String|Node" usage="required">
            <description>may be a string representing any valid CSS3 selector or a DOM node.
	In the selector case, only the first matching element will be used
	for relative positioning.</description>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <description>can be one of:
		&amp;quot;last&amp;quot; (default)
		&amp;quot;first&amp;quot;
		&amp;quot;before&amp;quot;
		&amp;quot;after&amp;quot;
		&amp;quot;only&amp;quot;
		&amp;quot;replace&amp;quot;
	or an offset in the childNodes property</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="orphan" scope="instance">
        <parameters>
          <parameter name="filter" type="String" usage="optional">
            <description>CSS selector like &amp;quot;.foo&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;</description>
          </parameter>
        </parameters>
        <return-description>`dojo.NodeList` containing the orphaned elements</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <examples>
          <example>"regular" JS filter syntax as exposed in dojo.filter:
		dojo.query("*").filter(function(item){
			// highlight every paragraph
			return (item.nodeName == "p");
		}).style("backgroundColor", "yellow");</example>
          <example>the same filtering using a CSS selector
		dojo.query("*").filter("p").styles("backgroundColor", "yellow");</example>
        </examples>
        <parameters>
          <parameter name="filter" type="String|Function" usage="required">
            <description>If a string, a CSS rule like &amp;quot;.thinger&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="empty" scope="instance">
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="attr" scope="instance">
        <examples>
          <example>Make all nodes with a particular class focusable:
		dojo.query(".focusable").attr("tabIndex", -1);</example>
          <example>Disable a group of buttons:
		dojo.query("button.group").attr("disabled", true);</example>
          <example>innerHTML can be assigned or retrieved as well:
		// get the innerHTML (as an array) for each list item
		var ih = dojo.query("li.replaceable").attr("innerHTML");</example>
        </examples>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>the attribute to get/set</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>optional. The value to set the property to</description>
          </parameter>
        </parameters>
        <return-description>if no value is passed, the result is an array of attribute values
	If a value is passed, the return is this NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="adopt" scope="instance">
        <parameters>
          <parameter name="queryOrListOrNode" type="String|Array|DomNode" usage="required">
            <description>a DOM node or a query string or a query result.
	Represents the nodes to be adopted relative to the
	first element of this NodeList.</description>
          </parameter>
          <parameter name="position" type="String" usage="optional">
            <description>can be one of:
		&amp;quot;last&amp;quot; (default)
		&amp;quot;first&amp;quot;
		&amp;quot;before&amp;quot;
		&amp;quot;after&amp;quot;
		&amp;quot;only&amp;quot;
		&amp;quot;replace&amp;quot;
	or an offset in the childNodes property</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="addContent" scope="instance">
        <description>a copy of the HTML content is added to each item in the
	list, with an optional position argument. If no position
	argument is provided, the content is appended to the end of
	each item.</description>
        <examples>
          <example>appends content to the end if the position is omitted
		dojo.query("h3 &gt; p").addContent("hey there!");</example>
          <example>add something to the front of each element that has a
	"thinger" property:
		dojo.query("[thinger]").addContent("...", "first");</example>
          <example>adds a header before each element of the list
		dojo.query(".note").addContent("&lt;h4&gt;NOTE:&lt;/h4&gt;", "before");</example>
          <example>add a clone of a DOM node to the end of every element in
	the list, removing it from its existing parent.
		dojo.query(".note").addContent(dojo.byId("foo"));</example>
          <example>Append nodes from a templatized string.
	dojo.require("dojo.string");
	dojo.query(".note").addContent({
	template: '&lt;b&gt;${id}: &lt;/b&gt;&lt;span&gt;${name}&lt;/span&gt;',
	id: "user332",
	name: "Mr. Anderson"
	});</example>
          <example>Append nodes from a templatized string that also has widgets parsed.
	dojo.require("dojo.string");
	dojo.require("dojo.parser");
	var notes = dojo.query(".note").addContent({
	template: '&lt;button dojoType="dijit.form.Button"&gt;${text}&lt;/button&gt;',
	parse: true,
	text: "Send"
	});</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|DomNode|Object|dojo.NodeList" usage="required">
            <description>DOM node, HTML in string format, a NodeList or an Object. If a DOM node or
	NodeList, the content will be cloned if the current NodeList has more than one
	element. Only the DOM nodes are cloned, no event handlers. If it is an Object,
	it should be an object with at &amp;quot;template&amp;quot; String property that has the HTML string
	to insert. If dojo.string has already been dojo.required, then dojo.string.substitute
	will be used on the &amp;quot;template&amp;quot; to generate the final HTML string. Other allowed
	properties on the object are: &amp;quot;parse&amp;quot; if the HTML
	string should be parsed for widgets (dojo.require(&amp;quot;dojo.parser&amp;quot;) to get that
	option to work), and &amp;quot;templateFunc&amp;quot; if a template function besides dojo.string.substitute
	should be used to transform the &amp;quot;template&amp;quot;.</description>
          </parameter>
          <parameter name="position" type="String|Integer" usage="optional">
            <description>can be one of:
		&amp;quot;last&amp;quot;||&amp;quot;end&amp;quot; (default)
		&amp;quot;first||&amp;quot;start&amp;quot;
		&amp;quot;before&amp;quot;
		&amp;quot;after&amp;quot;
		&amp;quot;replace&amp;quot; (replaces nodes in this NodeList with new content)
		&amp;quot;only&amp;quot; (removes other children of the nodes so new content is the only child)
	or an offset in the childNodes property</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <parameters>
          <parameter name="className" type="String|Array" usage="required">
            <description>A String class name to add, or several space-separated class names,
	or an array of class names.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_place" scope="instance">
        <description>Allows for cloning the nodes in the array, and for
	optionally parsing widgets, if ary._runParse is true.</description>
        <parameters>
          <parameter name="ary" type="Array" usage="required"/>
          <parameter name="refNode" type="DOMNode" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
          <parameter name="useClone" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_normalize" scope="instance">
        <description>If content is an object, it can have special properties "template" and
	"parse". If "template" is defined, then the template value is run through
	dojo.string.substitute (if dojo.string.substitute has been dojo.required elsewhere),
	or if templateFunc is a function on the content, that function will be used to
	transform the template into a final string to be used for for passing to dojo._toDom.
	If content.parse is true, then it is remembered for later, for when the content
	nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
	(if dojo.parser has been dojo.required elsewhere).</description>
        <parameters>
          <parameter name="content" type="String|Element|Object|NodeList" usage="required"/>
          <parameter name="refNode" type="DOMNode" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_cloneNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.NodeList._placeMultiple">
    <methods/>
  </class>
  <class type="dojo.NodeList.val">
    <methods/>
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList.val.0"/>
  <class type="dojo.NodeList.prototype"/>
  <class type="dojo._base"/>
  <class type="dojo.Deferred">
    <description>The dojo.Deferred API is based on the concept of promises that provide a
	generic interface into the eventual completion of an asynchronous action.
	The motivation for promises fundamentally is about creating a
	separation of concerns that allows one to achieve the same type of
	call patterns and logical data flow in asynchronous code as can be
	achieved in synchronous code. Promises allows one
	to be able to call a function purely with arguments needed for
	execution, without conflating the call with concerns of whether it is
	sync or async. One shouldn't need to alter a call's arguments if the
	implementation switches from sync to async (or vice versa). By having
	async functions return promises, the concerns of making the call are
	separated from the concerns of asynchronous interaction (which are
	handled by the promise).
	
	The dojo.Deferred is a type of promise that provides methods for fulfilling the
	promise with a successful result or an error. The most important method for
	working with Dojo's promises is the then() method, which follows the
	CommonJS proposed promise API. An example of using a Dojo promise:
	
		var resultingPromise = someAsyncOperation.then(function(result){
			... handle result ...
		},
		function(error){
			... handle error ...
		});
	
	The .then() call returns a new promise that represents the result of the
	execution of the callback. The callbacks will never affect the original promises value.
	
	The dojo.Deferred instances also provide the following functions for backwards compatibility:
	
	* addCallback(handler)
	* addErrback(handler)
	* callback(result)
	* errback(result)
	
	Callbacks are allowed to return promises themselves, so
	you can build complicated sequences of events with ease.
	
	The creator of the Deferred may specify a canceller.  The canceller
	is a function that will be called if Deferred.cancel is called
	before the Deferred fires. You can use this to implement clean
	aborting of an XMLHttpRequest, etc. Note that cancel will fire the
	deferred with a CancelledError (unless your canceller returns
	another kind of error), so the errbacks should be prepared to
	handle that error for cancellable Deferreds.</description>
    <methods>
      <method name="when" scope="instance"/>
      <method name="then" scope="instance">
        <examples>
          <example>An example of using a CommonJS compliant promise:
		asyncComputeTheAnswerToEverything().
			then(addTwo).
			then(printResult, onError);
		&gt;44</example>
        </examples>
        <parameters>
          <parameter name="resolvedCallback" type="Function" usage="optional"/>
          <parameter name="errorCallback" type="Function" usage="optional"/>
          <parameter name="progressCallback" type="Function" usage="optional"/>
        </parameters>
        <return-description>Returns a new promise that represents the result of the
	execution of the callback. The callbacks will never affect the original promises value.</return-description>
        <return-types>
          <return-type type="Promise"/>
        </return-types>
      </method>
      <method name="resolve" scope="instance"/>
      <method name="reject" scope="instance"/>
      <method name="progress" scope="instance">
        <parameters>
          <parameter name="update" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="errback" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancel" scope="instance"/>
      <method name="callback" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addErrback" scope="instance">
        <parameters>
          <parameter name="errback" type="Function" usage="required"/>
        </parameters>
        <return-description>Returns this deferred object.</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="addCallbacks" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="optional">
            <description>The callback attached to this deferred object.</description>
          </parameter>
          <parameter name="errback" type="Function" usage="optional">
            <description>The error callback attached to this deferred object.</description>
          </parameter>
        </parameters>
        <return-description>Returns this deferred object.</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="addCallback" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
        <return-description>Returns this deferred object.</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="addBoth" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
        <return-description>Returns this deferred object.</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="Object">
    <methods>
      <method name="isInstanceOf" scope="instance">
        <description>This method is used with instances of classes produced with
	dojo.declare to determine of they support a certain interface or
	not. It models "instanceof" operator.</description>
        <examples>
          <example>	var A = dojo.declare(null, {
			// constructor, properties, and methods go here
			// ...
		});
		var B = dojo.declare(null, {
			// constructor, properties, and methods go here
			// ...
		});
		var C = dojo.declare([A, B], {
			// constructor, properties, and methods go here
			// ...
		});
		var D = dojo.declare(A, {
			// constructor, properties, and methods go here
			// ...
		});
	
		var a = new A(), b = new B(), c = new C(), d = new D();
	
		console.log(a.isInstanceOf(A)); // true
		console.log(b.isInstanceOf(A)); // false
		console.log(c.isInstanceOf(A)); // true
		console.log(d.isInstanceOf(A)); // true
	
		console.log(a.isInstanceOf(B)); // false
		console.log(b.isInstanceOf(B)); // true
		console.log(c.isInstanceOf(B)); // true
		console.log(d.isInstanceOf(B)); // false
	
		console.log(a.isInstanceOf(C)); // false
		console.log(b.isInstanceOf(C)); // false
		console.log(c.isInstanceOf(C)); // true
		console.log(d.isInstanceOf(C)); // false
	
		console.log(a.isInstanceOf(D)); // false
		console.log(b.isInstanceOf(D)); // false
		console.log(c.isInstanceOf(D)); // false
		console.log(d.isInstanceOf(D)); // true</example>
        </examples>
        <parameters>
          <parameter name="cls" type="Function" usage="required">
            <description>Class constructor.</description>
          </parameter>
        </parameters>
        <return-description>"true", if this object is inherited from this class, "false"
	otherwise.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inherited" scope="instance">
        <description>This method is used inside method of classes produced with
	dojo.declare to call a super method (next in the chain). It is
	used for manually controlled chaining. Consider using the regular
	chaining, because it is faster. Use "this.inherited()" only in
	complex cases.
	
	This method cannot me called from automatically chained
	constructors including the case of a special (legacy)
	constructor chaining. It cannot be called from chained methods.
	
	If "this.inherited()" cannot find the next-in-chain method, it
	does nothing and returns "undefined". The last method in chain
	can be a default method implemented in Object, which will be
	called last.
	
	If "name" is specified, it is assumed that the method that
	received "args" is the parent method for this call. It is looked
	up in the chain list and if it is found the next-in-chain method
	is called. If it is not found, the first-in-chain method is
	called.
	
	If "name" is not specified, it will be derived from the calling
	method (using a methoid property "nom").</description>
        <examples>
          <example>	var B = dojo.declare(A, {
			method1: function(a, b, c){
				this.inherited(arguments);
			},
			method2: function(a, b){
				return this.inherited(arguments, [a + b]);
			}
		});
		// next method is not in the chain list because it is added
		// manually after the class was created.
		B.prototype.method3 = function(){
			console.log("This is a dynamically-added method.");
			this.inherited("method3", arguments);
		};</example>
          <example>	var B = dojo.declare(A, {
			method: function(a, b){
				var super = this.inherited(arguments, true);
				// ...
				if(!super){
					console.log("there is no super method");
					return 0;
				}
				return super.apply(this, arguments);
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <description>The optional method name. Should be the same as the caller's
	name. Usually &amp;quot;name&amp;quot; is specified in complex dynamic cases, when
	the calling method was dynamically added, undecorated by
	dojo.declare, and it cannot be determined.</description>
          </parameter>
          <parameter name="args" type="Arguments" usage="required">
            <description>The caller supply this argument, which should be the original
	&amp;quot;arguments&amp;quot;.</description>
          </parameter>
          <parameter name="newArgs" type="Object" usage="optional">
            <description>If &amp;quot;true&amp;quot;, the found function will be returned without
	executing it.
	If Array, it will be used to call a super method. Otherwise
	&amp;quot;args&amp;quot; will be used.</description>
          </parameter>
        </parameters>
        <return-description>Whatever is returned by a super method, or a super method itself,
	if "true" was specified as newArgs.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getInherited" scope="instance">
        <description>This method is a convenience method for "this.inherited()".
	It uses the same algorithm but instead of executing a super
	method, it returns it, or "undefined" if not found.</description>
        <examples>
          <example>	var B = dojo.declare(A, {
			method: function(a, b){
				var super = this.getInherited(arguments);
				// ...
				if(!super){
					console.log("there is no super method");
					return 0;
				}
				return super.apply(this, arguments);
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <description>The optional method name. Should be the same as the caller's
	name. Usually &amp;quot;name&amp;quot; is specified in complex dynamic cases, when
	the calling method was dynamically added, undecorated by
	dojo.declare, and it cannot be determined.</description>
          </parameter>
          <parameter name="args" type="Arguments" usage="required">
            <description>The caller supply this argument, which should be the original
	&amp;quot;arguments&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-description>Returns a super method (Function) or "undefined".</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="freeze" scope="instance"/>
      <method name="extend" scope="instance">
        <description>Adds source properties to the constructor's prototype. It can
	override existing properties.
	
	This method is similar to dojo.extend function, but it is specific
	to constructors produced by dojo.declare. It is implemented
	using dojo.safeMixin, and it skips a constructor property,
	and properly decorates copied functions.</description>
        <examples>
          <example>	var A = dojo.declare(null, {
			m1: function(){},
			s1: "Popokatepetl"
		});
		A.extend({
			m1: function(){},
			m2: function(){},
			f1: true,
			d1: 42
		});</example>
        </examples>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>Source object which properties are going to be copied to the
	constructor's prototype.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="require">
    <methods>
      <method name="getText" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
          <parameter name="load" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojoConfig">
    <methods>
      <method name="addOnLoad" scope="instance"/>
    </methods>
  </class>
  <class type="navigator"/>
  <class type="dojo.config"/>
  <class type="console">
    <methods>
      <method name="warn" scope="instance"/>
      <method name="log" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="error" scope="instance"/>
      <method name="debug" scope="instance"/>
    </methods>
  </class>
  <class type="exports">
    <methods>
      <method name="toDom" scope="instance">
        <parameters>
          <parameter name="frag" type="Object" usage="required"/>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="name" type="String|Object" usage="required"/>
          <parameter name="value" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="refNode" type="DOMNode|String" usage="required"/>
          <parameter name="position" type="String|Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="has" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getNodeProp" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Anything"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Anything"/>
        </return-types>
      </method>
      <method name="empty" scope="instance"/>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="tag" type="DOMNode|String" usage="required"/>
          <parameter name="attrs" type="Object" usage="required"/>
          <parameter name="refNode" type="DOMNode|String" usage="optional"/>
          <parameter name="pos" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="config" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="names" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="e"/>
  <class type="lang"/>
  <class type="declare"/>
  <class type="on">
    <methods>
      <method name="_fixEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="se" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.Animation">
    <description>A generic animation class that fires callbacks into its handlers
	object at various states. Nearly all dojo animation functions
	return an instance of this method, usually without calling the
	.play() method beforehand. Therefore, you will likely need to
	call .play() on instances of `dojo.Animation` when one is
	returned.</description>
    <methods>
      <method name="stop" scope="instance">
        <parameters>
          <parameter name="gotoEnd" type="boolean" usage="optional">
            <description>If true, the animation will end.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="status" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="play" scope="instance">
        <parameters>
          <parameter name="delay" type="int" usage="optional">
            <description>How many milliseconds to delay before starting.</description>
          </parameter>
          <parameter name="gotoStart" type="Boolean" usage="optional">
            <description>If true, starts the animation from the beginning; otherwise,
	starts it from its current position.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation
	The instance to allow chaining.</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="pause" scope="instance">
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="gotoPercent" scope="instance">
        <parameters>
          <parameter name="percent" type="Decimal" usage="required">
            <description>A percentage in decimal notation (between and including 0.0 and 1.0).</description>
          </parameter>
          <parameter name="andPlay" type="Boolean" usage="optional">
            <description>If true, play the animation after setting the progress.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="easing" scope="instance"/>
      <method name="_stopTimer" scope="instance"/>
      <method name="_startTimer" scope="instance"/>
      <method name="_play" scope="instance">
        <parameters>
          <parameter name="gotoStart" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_getStep" scope="instance"/>
      <method name="_fire" scope="instance">
        <description>Convenience function.  Fire event "evt" and pass it the
	arguments specified in "args".
	Fires the callback in the scope of the `dojo.Animation`
	instance.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event to fire.</description>
          </parameter>
          <parameter name="args" type="Array" usage="optional">
            <description>The arguments to pass to the event.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_cycle" scope="instance">
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_clearTimer" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.Animation._getStep">
    <methods/>
  </class>
  <class type="dojo.Animation._startTimer">
    <methods/>
  </class>
  <class type="dojo.Animation._stopTimer">
    <methods/>
  </class>
  <class type="dojo.__AnimArgs" superclass="dojo.__FadeArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.__FadeArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo._Line">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="float" usage="required">
            <description>a floating point number greater than 0 and less than 1</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.__FadeArgs">
    <methods>
      <method name="easing" scope="instance"/>
    </methods>
  </class>
  <class type="config"/>
  <class type="has"/>
  <class type="opera"/>
  <class type="document">
    <properties>
      <property name="body" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.__XhrArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.contentHandlers">
    <description>A map of availble XHR transport handle types. Name matches the
	`handleAs` attribute passed to XHR calls. Each contentHandler is
	called, passing the xhr object for manipulation. The return value
	from the contentHandler will be passed to the `load` or `handle`
	functions defined in the original xhr call.</description>
    <methods>
      <method name="xml" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
        </return-types>
      </method>
      <method name="text" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="json-comment-optional" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="json-comment-filtered" scope="instance">
        <description>A contentHandler which expects comment-filtered JSON.
	the json-comment-filtered option was implemented to prevent
	"JavaScript Hijacking", but it is less secure than standard JSON. Use
	standard JSON instead. JSON prefixing can be used to subvert hijacking.
	
	Will throw a notice suggesting to use application/json mimetype, as
	json-commenting can introduce security issues. To decrease the chances of hijacking,
	use the standard `json` contentHandler, and prefix your "JSON" with: {}&amp;&amp;
	
	use djConfig.useCommentedJson = true to turn off the notice</description>
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="json" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="javascript" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.__IoArgs">
    <methods>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="response" type="Object" usage="required">
            <description>The response in the format as defined with handleAs.</description>
          </parameter>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required">
            <description>Provides additional information about the request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="handle" scope="instance">
        <parameters>
          <parameter name="loadOrError" type="String" usage="required">
            <description>Provides a string that tells you whether this function
	was called because of success (load) or failure (error).</description>
          </parameter>
          <parameter name="response" type="Object" usage="required">
            <description>The response in the format as defined with handleAs.</description>
          </parameter>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required">
            <description>Provides additional information about the request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="error" scope="instance">
        <parameters>
          <parameter name="response" type="Object" usage="required">
            <description>The response in the format as defined with handleAs.</description>
          </parameter>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required">
            <description>Provides additional information about the request.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.__IoCallbackArgs">
    <methods/>
  </class>
  <class type="dojo.__IoPublish">
    <methods/>
  </class>
  <class type="window">
    <properties>
      <property name="frames" scope="instance" type="Object"/>
      <property name="console" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="window.console">
    <methods>
      <method name="warn" scope="instance"/>
      <method name="trace" scope="instance">
        <parameters>
          <parameter name="_value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="timeEnd" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="time" scope="instance">
        <examples>
          <example>	console.time("load");
		console.time("myFunction");
		console.timeEnd("load");
		console.timeEnd("myFunction");</example>
        </examples>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="recss" scope="instance"/>
      <method name="profileEnd" scope="instance"/>
      <method name="profile" scope="instance"/>
      <method name="openObjectInspector" scope="instance"/>
      <method name="openDomInspector" scope="instance"/>
      <method name="openConsole" scope="instance"/>
      <method name="open" scope="instance"/>
      <method name="log" scope="instance"/>
      <method name="info" scope="instance"/>
      <method name="groupEnd" scope="instance"/>
      <method name="group" scope="instance"/>
      <method name="error" scope="instance"/>
      <method name="dirxml" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dir" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="debug" scope="instance"/>
      <method name="count" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="clear" scope="instance"/>
      <method name="assert" scope="instance">
        <parameters>
          <parameter name="truth" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_restoreBorder" scope="instance"/>
      <method name="_closeDomInspector" scope="instance"/>
    </methods>
  </class>
  <class type="dojo._firebug"/>
  <class type="dojo.aspect">
    <methods>
      <method name="before" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>This is the target object</description>
          </parameter>
          <parameter name="methodName" type="String" usage="required">
            <description>This is the name of the method to attach to.</description>
          </parameter>
          <parameter name="advice" type="Function" usage="required">
            <description>This is function to be called before the original method</description>
          </parameter>
        </parameters>
      </method>
      <method name="around" scope="instance">
        <examples>
          <example>If there are multiple "around" advisors, the most recent one is executed first,
	which can then delegate to the next one and so on. For example:
		around(obj, "foo", function(originalFoo){
			return function(){
				var start = new Date().getTime();
				var results = originalFoo.apply(this, arguments); // call the original
				var end = new Date().getTime();
				console.log("foo execution took " + (end - start) + " ms");
				return results;
			};
		});</example>
        </examples>
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>This is the target object</description>
          </parameter>
          <parameter name="methodName" type="String" usage="required">
            <description>This is the name of the method to attach to.</description>
          </parameter>
          <parameter name="advice" type="Function" usage="required">
            <description>This is function to be called around the original method</description>
          </parameter>
        </parameters>
      </method>
      <method name="after" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>This is the target object</description>
          </parameter>
          <parameter name="methodName" type="String" usage="required">
            <description>This is the name of the method to attach to.</description>
          </parameter>
          <parameter name="advice" type="Function" usage="required">
            <description>This is function to be called after the original method</description>
          </parameter>
          <parameter name="receiveArguments" type="Boolean" usage="optional">
            <description>If this is set to true, the advice function receives the original arguments (from when the original mehtod
	was called) rather than the return value of the original/previous method.</description>
          </parameter>
        </parameters>
        <return-description>A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
	stop the advice function from being executed.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.back">
    <methods>
      <method name="setInitialState" scope="instance">
        <description>It is recommended that you call this method as part of an event
	listener that is registered via dojo.addOnLoad().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>See the addToHistory() function for the list of valid args properties.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setHash" scope="instance">
        <parameters>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <description>Only call this method before the page's DOM is finished loading. Otherwise
	it will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,
	in order for this method to work, dojo.back will need to be part of a build layer.</description>
      </method>
      <method name="getHash" scope="instance"/>
      <method name="addToHistory" scope="instance">
        <description>To support getting back button notifications, the object
	argument should implement a function called either "back",
	"backButton", or "handle". The string "back" will be passed as
	the first and only argument to this callback.
	
	To support getting forward button notifications, the object
	argument should implement a function called either "forward",
	"forwardButton", or "handle". The string "forward" will be
	passed as the first and only argument to this callback.
	
	If you want the browser location string to change, define "changeUrl" on the object. If the
	value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
	identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
	not evaluate to false, that value will be used as the fragment identifier. For example,
	if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1
	
	There are problems with using dojo.back with semantically-named fragment identifiers
	("hash values" on an URL). In most browsers it will be hard for dojo.back to know
	distinguish a back from a forward event in those cases. For back/forward support to
	work best, the fragment ID should always be a unique value (something using new Date().getTime()
	for example). If you want to detect hash changes using semantic fragment IDs, then
	consider using dojo.hash instead (in Dojo 1.4+).</description>
        <examples>
          <example>	dojo.back.addToHistory({
			back: function(){ console.log('back pressed'); },
			forward: function(){ console.log('forward pressed'); },
			changeUrl: true
		});</example>
        </examples>
        <parameters>
          <parameter name="args" type="dojo.__backArgs" usage="required">
            <description>The state object that will be added to the history list.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_iframeLoaded" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="ifrLoc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="window.frames"/>
  <class type="dojo.behavior">
    <description>A very simple, lightweight mechanism for applying code to
	existing documents, based around `dojo.query` (CSS3 selectors) for node selection,
	and a simple two-command API: `dojo.behavior.add()` and `dojo.behavior.apply()`;
	
	Behaviors apply to a given page, and are registered following the syntax
	options described by `dojo.behavior.add` to match nodes to actions, or "behaviors".
	
	Added behaviors are applied to the current DOM when .apply() is called,
	matching only new nodes found since .apply() was last called.</description>
    <methods>
      <method name="apply" scope="instance">
        <description>Applies all currently registered behaviors to the document,
	taking care to ensure that only incremental updates are made
	since the last time add() or apply() were called.
	
	If new matching nodes have been added, all rules in a behavior will be
	applied to that node. For previously matched nodes, only
	behaviors which have been added since the last call to apply()
	will be added to the nodes.
	
	apply() is called once automatically by `dojo.addOnLoad`, so
	registering behaviors with `dojo.behavior.add` before the DOM is
	ready is acceptable, provided the dojo.behavior module is ready.
	
	Calling appy() manually after manipulating the DOM is required
	to rescan the DOM and apply newly .add()ed behaviors, or to match
	nodes that match existing behaviors when those nodes are added to
	the DOM.</description>
      </method>
      <method name="add" scope="instance">
        <description>Add the specified behavior to the list of behaviors which will
	be applied the next time apply() is called. Calls to add() for
	an already existing behavior do not replace the previous rules,
	but are instead additive. New nodes which match the rule will
	have all add()-ed behaviors applied to them when matched.
	
	The "found" method is a generalized handler that's called as soon
	as the node matches the selector. Rules for values that follow also
	apply to the "found" key.
	
	The "on*" handlers are attached with `dojo.connect()`, using the
	matching node
	
	If the value corresponding to the ID key is a function and not a
	list, it's treated as though it was the value of "found".
	
	dojo.behavior.add() can be called any number of times before
	the DOM is ready. `dojo.behavior.apply()` is called automatically
	by `dojo.addOnLoad`, though can be called to re-apply previously added
	behaviors anytime the DOM changes.
	
	There are a variety of formats permitted in the behaviorObject</description>
        <examples>
          <example>Simple list of properties. "found" is special. "Found" is assumed if
	no property object for a given selector, and property is a function.
	
		dojo.behavior.add({
			"#id": {
				"found": function(element){
					// node match found
				},
				"onclick": function(evt){
					// register onclick handler for found node
				}
			},
			"#otherid": function(element){
				// assumes "found" with this syntax
			}
		});</example>
          <example>If property is a string, a dojo.publish will be issued on the channel:
	
		dojo.behavior.add({
			// dojo.publish() whenever class="noclick" found on anchors
			"a.noclick": "/got/newAnchor",
			"div.wrapper": {
				"onclick": "/node/wasClicked"
			}
		});
		dojo.subscribe("/got/newAnchor", function(node){
			// handle node finding when dojo.behavior.apply() is called,
			// provided a newly matched node is found.
		});</example>
          <example>Scoping can be accomplished by passing an object as a property to
	a connection handle (on*):
	
		dojo.behavior.add({
			 	"#id": {
					// like calling dojo.hitch(foo,"bar"). execute foo.bar() in scope of foo
					"onmouseenter": { targetObj: foo, targetFunc: "bar" },
					"onmouseleave": { targetObj: foo, targetFunc: "baz" }
				}
		});</example>
          <example>Bahaviors match on CSS3 Selectors, powered by dojo.query. Example selectors:
	
		dojo.behavior.add({
			// match all direct descendants
			"#id4 &gt; *": function(element){
				// ...
			},
	
			// match the first child node that's an element
			"#id4 &gt; :first-child": { ... },
	
			// match the last child node that's an element
			"#id4 &gt; :last-child":  { ... },
	
			// all elements of type tagname
			"tagname": {
				// ...
			},
	
			"tagname1 tagname2 tagname3": {
				// ...
			},
	
			".classname": {
				// ...
			},
	
			"tagname.classname": {
				// ...
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="behaviorObj" type="Object" usage="required">
            <description>The behavior object that will be added to behaviors list. The behaviors
	in the list will be applied the next time apply() is called.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.cldr.monetary">
    <methods>
      <method name="getData" scope="instance">
        <parameters>
          <parameter name="code" type="String" usage="required">
            <description>an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.cldr">
    <properties>
      <property name="supplemental" scope="instance" type="Object"/>
      <property name="monetary" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.cldr.supplemental">
    <methods>
      <method name="getWeekend" scope="instance">
        <description>Returns a hash containing the start and end days of the weekend according to local custom using locale,
	or by default in the user's locale.
	e.g. {start:6, end:0}</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getFirstDayOfWeek" scope="instance">
        <description>Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
	e.g. Sunday (returns 0), or Monday (returns 1)</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_region" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="Color.named"/>
  <class type="Color">
    <methods>
      <method name="toHsv" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toHsl" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmyk" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmy" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="sanitize" scope="instance">
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="makeGrey" scope="instance">
        <parameters>
          <parameter name="g" type="Number" usage="required"/>
          <parameter name="a" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="fromRgb" scope="instance">
        <description>this function can handle all 4 CSS3 Color Module formats: rgb,
	rgba, hsl, hsla, including rgb(a) with percentage values.</description>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="named" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.__cookieProps">
    <methods/>
  </class>
  <class type="dojo.cookie">
    <description>If one argument is passed, returns the value of the cookie
	For two or more arguments, acts as a setter.</description>
    <methods>
      <method name="isSupported" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.currency">
    <description>extends dojo.number to provide culturally-appropriate formatting of values
	in various world currencies, including use of a currency symbol.  The currencies are specified
	by a three-letter international symbol in all uppercase, and support for the currencies is
	provided by the data in `dojo.cldr`.  The scripts generating dojo.cldr specify which
	currency support is included.  A fixed number of decimal places is determined based
	on the currency type and is not determined by the 'pattern' argument.  The fractional
	portion is optional, by default, and variable length decimals are not supported.</description>
    <methods>
      <method name="regexp" scope="instance">
        <description>Returns regular expression with positive and negative match, group and decimal separators
	Note: the options.places default, the number of decimal places to accept, is defined by the currency type.</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <description>Create a Number from a string using a known, localized pattern.
	[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	are chosen appropriate to the locale, as well as the appropriate symbols and delimiters
	and number of decimal places.</description>
        <parameters>
          <parameter name="expression" type="String" usage="required">
            <description>A string representation of a currency value</description>
          </parameter>
          <parameter name="options" type="dojo.currency.__ParseOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <description>Create a string from a Number using a known, localized pattern.
	[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements)
	appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
	as well as the appropriate symbols and delimiters and number of decimal places.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted.</description>
          </parameter>
          <parameter name="options" type="dojo.currency.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="_mixInDefaults" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__ParseOptions" scope="instance"/>
      <method name="__FormatOptions" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.currency.__FormatOptions" superclass="dojo.number.__FormatOptions">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.number.__FormatOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.currency.__ParseOptions" superclass="dojo.number.__ParseOptions">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.number.__ParseOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data">
    <methods>
      <method name="ObjectStore" scope="instance">
        <parameters>
          <parameter name="options" type="The" usage="required">
            <description>configuration information to pass into the data store.
	options.objectStore:
	The object store to use as the source provider for this data store</description>
          </parameter>
        </parameters>
      </method>
      <method name="ItemFileWriteStore" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="ItemFileReadStore" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="util" scope="instance" type="Object"/>
      <property name="api" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileReadStore" superclass="Evented">
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_getItemsFromLoadedData" scope="instance">
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required">
            <description>The JS data object containing the raw data to convery into item format.</description>
          </parameter>
        </parameters>
        <return-description>array
	Array of items in store item format.</return-description>
      </method>
      <method name="_getItemsArray" scope="instance">
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <description>The query options parameter, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="instance">
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="instance"/>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Evented" scope="instance"/>
    </mixins>
    <properties>
      <property name="_datatypeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileReadStore._features.dojo.data.api"/>
  <class type="dojo.data.ItemFileReadStore._datatypeMap"/>
  <class type="dojo.data.ItemFileWriteStore" superclass="dojo.data.ItemFileReadStore">
    <methods>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <description>anything</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object|array" usage="required"/>
          <parameter name="newValue" type="object|array" usage="required"/>
        </parameters>
      </method>
      <method name="onNew" scope="instance">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.
	If the store is still dirty (unsaved changes), then an error will be thrown instead of
	clearing the internal state for reload from the url.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_removeReferenceFromMap" scope="instance">
        <description>Method to remove an reference map entry for an item and attribute.  This will
	also perform cleanup on the map such that if there are no more references at all to
	the item, its reference object and entry are removed.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item holding a reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeArrayElement" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="something" type="The" usage="required">
            <description>array or object to examine.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_getValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="instance"/>
      <method name="_getIdentifierAttribute" scope="instance"/>
      <method name="_flatten" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="instance">
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_assert" scope="instance">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.ItemFileReadStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.ItemFileWriteStore._features.dojo.data.api"/>
  <class type="dojo.data.ItemFileWriteStore._datatypeMap.Date">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.data.ObjectStore" superclass="Evented">
    <methods>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance"/>
      <method name="onNew" scope="instance"/>
      <method name="onFetch" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance"/>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <description>The data to be added in as an item.</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <examples>
          <example>store.loadItem({
	item: item, // this item may or may not be loaded
	onItem: function(item){
	// do something with the item
	}
	});</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>attribute: /* string</description>
          </parameter>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="property" type="string" usage="required">
            <description>property to look up value for</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>The item to get the value from</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>property to look up value for</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>the default value</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>to delete</description>
          </parameter>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="The" usage="required">
            <description>configuration information to pass into the data store.
	options.objectStore:
	The object store to use as the source provider for this data store</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changing" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Evented" scope="instance"/>
    </mixins>
    <properties>
      <property name="_dirtyObjects" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo.data.ObjectStore._dirtyObjects"/>
  <class type="dojo.data.api">
    <methods>
      <method name="Write" scope="instance"/>
      <method name="Request" scope="instance"/>
      <method name="Read" scope="instance"/>
      <method name="Notification" scope="instance">
        <description>This API defines a set of APIs that all datastores that conform to the
	Notifications API must implement.  In general, most stores will implement
	these APIs as no-op functions for users who wish to monitor them to be able
	to connect to then via dojo.connect().  For non-users of dojo.connect,
	they should be able to just replace the function on the store to obtain
	notifications.  Both read-only and read-write stores may implement
	this feature.  In the case of a read-only store, this feature makes sense if
	the store itself does internal polling to a back-end server and periodically updates
	its cache of items (deletes, adds, and updates).</description>
        <examples>
          <example>	function onSet(item, attribute, oldValue, newValue) {
			//Do something with the information...
		};
		var store = new some.newStore();
		dojo.connect(store, "onSet", onSet);</example>
        </examples>
      </method>
      <method name="Identity" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.data.api.Identity" superclass="dojo.data.api.Read">
    <methods>
      <method name="getIdentityAttributes" scope="instance">
        <examples>
          <example>	var itemId = store.getIdentity(kermit);
		var identifiers = store.getIdentityAttributes(itemId);
		assert(typeof identifiers === "array" || identifiers === null);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item from the store from which to obtain the array of public attributes that
	compose the identifier, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <examples>
          <example>	var itemId = store.getIdentity(kermit);
		assert(kermit === store.findByIdentity(store.getIdentity(kermit)));</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item from the store from which to obtain its identifier.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>An anonymous object that defines the item to locate and callbacks to invoke when the
	item has been located and load has completed.  The format of the object is as follows:
	{
	identity: string|object,
	onItem: Function,
	onError: Function,
	scope: object
	}
	The *identity* parameter.
	The identity parameter is the identity of the item you wish to locate and load
	This attribute is required.  It should be a string or an object that toString()
	can be called on.
	
	The *onItem* parameter.
	Function(item)
	The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
	parameter, the item located, or null if none found.
	
	The *onError* parameter.
	Function(error)
	The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
	parameter, the error object
	
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onError, etc) will be invoked in the context of the scope object.
	In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global.
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global, item, request)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.api.Read" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.api.Notification" superclass="dojo.data.api.Read">
    <description>This API defines a set of APIs that all datastores that conform to the
	Notifications API must implement.  In general, most stores will implement
	these APIs as no-op functions for users who wish to monitor them to be able
	to connect to then via dojo.connect().  For non-users of dojo.connect,
	they should be able to just replace the function on the store to obtain
	notifications.  Both read-only and read-write stores may implement
	this feature.  In the case of a read-only store, this feature makes sense if
	the store itself does internal polling to a back-end server and periodically updates
	its cache of items (deletes, adds, and updates).</description>
    <methods>
      <method name="onSet" scope="instance">
        <description>This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
	Its purpose is to provide a hook point for those who wish to monitor actions on items in the store
	in a simple manner.  The general expected usage is to dojo.connect() to the store's
	implementation and be called after the store function is called.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item being modified.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute being changed represented as a string name.</description>
          </parameter>
          <parameter name="oldValue" type="object|array" usage="required">
            <description>The old value of the attribute.  In the case of single value calls, such as setValue, unsetAttribute, etc,
	this value will be generally be an atomic value of some sort (string, int, etc, object).  In the case of
	multi-valued attributes, it will be an array.</description>
          </parameter>
          <parameter name="newValue" type="object|array" usage="required">
            <description>The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
	generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
	it will be an array.  In the case of unsetAttribute, the new value will be 'undefined'.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onNew" scope="instance">
        <description>This function is called any time a new item is created in the store.
	It is called immediately after the store newItem processing has completed.</description>
        <parameters>
          <parameter name="newItem" type="item" usage="required">
            <description>The item created.</description>
          </parameter>
          <parameter name="parentInfo" type="object" usage="optional">
            <description>An optional javascript object that is passed when the item created was placed in the store
	hierarchy as a value f another item's attribute, instead of a root level item.  Note that if this
	function is invoked with a value for parentInfo, then onSet is not invoked stating the attribute of
	the parent item was modified.  This is to avoid getting two notification  events occurring when a new item
	with a parent is created.  The structure passed in is as follows:
	{
	item: someItem,							//The parent item
	attribute:	&amp;quot;attribute-name-string&amp;quot;,	//The attribute the new item was assigned to.
	oldValue: something	//Whatever was the previous value for the attribute.
	//If it is a single-value attribute only, then this value will be a single value.
	//If it was a multi-valued attribute, then this will be an array of all the values minues the new one.
	newValue: something	//The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
	//generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
	//it will be an array.
	}</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onDelete" scope="instance">
        <description>This function is called any time an item is deleted from the store.
	It is called immediately after the store deleteItem processing has completed.</description>
        <parameters>
          <parameter name="deletedItem" type="item" usage="required">
            <description>The item deleted.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="getFeatures" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.api.Read" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.api.Read">
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>An anonymous object that defines the item to load and callbacks to invoke when the
	load has completed.  The format of the object is as follows:
	{
	item: object,
	onItem: Function,
	onError: Function,
	scope: object
	}
	The *item* parameter.
	The item parameter is an object that represents the item in question that should be
	contained by the store.  This attribute is required.
	
	The *onItem* parameter.
	Function(item)
	The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
	parameter, the fully loaded item.
	
	The *onError* parameter.
	Function(error)
	The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
	parameter, the error object
	
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onError, etc) will be invoked in the context of the scope object.
	In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global().
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global(), item, request)</description>
          </parameter>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <examples>
          <example>	var yes = store.isItemLoaded(store.newItem());
		var no  = store.isItemLoaded("green");</example>
        </examples>
        <parameters>
          <parameter name="something" type="anything" usage="required">
            <description>Can be anything.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <examples>
          <example>	var yes = store.isItem(store.newItem());
		var no  = store.isItem("green");</example>
        </examples>
        <parameters>
          <parameter name="something" type="anything" usage="required">
            <description>Can be anything.</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <examples>
          <example>	var trueOrFalse = store.hasAttribute(kermit, "color");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access attributes on.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <examples>
          <example>	var friendsOfLuke = store.getValues(lukeSkywalker, "friends");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access values on.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
        </parameters>
        <return-description>an array that may contain literals and items</return-description>
      </method>
      <method name="getValue" scope="instance">
        <description>Saying that an "item x does not have a value for an attribute y"
	is identical to saying that an "item x does not have attribute y".
	It is an oxymoron to say "that attribute is present but has no values"
	or "the item has that attribute but does not have any attribute values".
	If store.hasAttribute(item, attribute) returns false, then
	store.getValue(item, attribute) will return undefined.</description>
        <examples>
          <example>	var darthVader = store.getValue(lukeSkywalker, "father");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access values on.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>Optional. A default value to use for the getValue return in the attribute does not exist or has no value.</description>
          </parameter>
        </parameters>
        <return-description>a literal, an item, null, or undefined (never an array)</return-description>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <description>Method to inspect the item and return an array of what attributes of the item were used
	to generate its label, if any.  This function is to assist UI developers in knowing what
	attributes can be ignored out of the attributes an item has when displaying it, in cases
	where the UI is using the label as an overall identifer should they wish to hide
	redundant information.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to return the list of label attributes for.</description>
          </parameter>
        </parameters>
        <return-description>An array of attribute names that were used to generate the label, or null if public attributes
	were not used to generate the label.</return-description>
      </method>
      <method name="getLabel" scope="instance">
        <description>Method to inspect the item and return a user-readable 'label' for the item
	that provides a general/adequate description of what the item is.  In general
	most labels will be a specific attribute value or collection of the attribute
	values that combine to label the item in some manner.  For example for an item
	that represents a person it may return the label as:  "firstname lastlame" where
	the firstname and lastname are attributes on the item.  If the store is unable
	to determine an adequate human readable label, it should return undefined.  Users that wish
	to customize how a store instance labels items should replace the getLabel() function on
	their instance of the store, or extend the store and replace the function in
	the extension class.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to return the label for.</description>
          </parameter>
        </parameters>
        <return-description>A user-readable string representing the item or undefined if no user-readable label can
	be generated.</return-description>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <examples>
          <example>	var array = store.getAttributes(kermit);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access attributes on.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <description>A Request object will always be returned and is returned immediately.
	The basic request is nothing more than the keyword args passed to fetch and
	an additional function attached, abort().  The returned request object may then be used
	to cancel a fetch.  All data items returns are passed through the callbacks defined in the
	fetch parameters and are not present on the 'request' object.
	
	This does not mean that custom stores can not add methods and properties to the request object
	returned, only that the API does not require it.  For more info about the Request API,
	see dojo.data.api.Request</description>
        <examples>
          <example>Fetch all books identified by the query and call 'showBooks' when complete
		var request = store.fetch({query:"all books", onComplete: showBooks});</example>
          <example>Fetch all items in the story and call 'showEverything' when complete.
		var request = store.fetch(onComplete: showEverything);</example>
          <example>Fetch only 10 books that match the query 'all books', starting at the fifth book found during the search.
	This demonstrates how paging can be done for specific queries.
		var request = store.fetch({query:"all books", start: 4, count: 10, onComplete: showBooks});</example>
          <example>Fetch all items that match the query, calling 'callback' each time an item is located.
		var request = store.fetch({query:"foo/bar", onItem:callback});</example>
          <example>Fetch the first 100 books by author King, call showKing when up to 100 items have been located.
		var request = store.fetch({query:{author:"King"}, start: 0, count:100, onComplete: showKing});</example>
          <example>Locate the books written by Author King, sort it on title and publisher, then return the first 100 items from the sorted items.
		var request = store.fetch({query:{author:"King"}, sort: [{ attribute: "title", descending: true}, {attribute: "publisher"}], ,start: 0, count:100, onComplete: 'showKing'});</example>
          <example>Fetch the first 100 books by authors starting with the name King, then call showKing when up to 100 items have been located.
		var request = store.fetch({query:{author:"King*"}, start: 0, count:100, onComplete: showKing});</example>
          <example>Fetch the first 100 books by authors ending with 'ing', but only have one character before it (King, Bing, Ling, Sing, etc.), then call showBooks when up to 100 items have been located.
		var request = store.fetch({query:{author:"?ing"}, start: 0, count:100, onComplete: showBooks});</example>
          <example>Fetch the first 100 books by author King, where the name may appear as King, king, KING, kInG, and so on, then call showKing when up to 100 items have been located.
		var request = store.fetch({query:{author:"King"}, queryOptions:(ignoreCase: true}, start: 0, count:100, onComplete: showKing});</example>
          <example>Paging
		var store = new dojo.data.LargeRdbmsStore({url:"jdbc:odbc:foobar"});
		var fetchArgs = {
			query: {type:"employees", name:"Hillary *"}, // string matching
			sort: [{attribute:"department", descending:true}],
			start: 0,
			count: 20,
			scope: displayer,
			onBegin: showThrobber,
			onItem: displayItem,
			onComplete: stopThrobber,
			onError: handleFetchError,
		};
		store.fetch(fetchArgs);
		...
	and then when the user presses the "Next Page" button...
		fetchArgs.start += 20;
		store.fetch(fetchArgs);  // get the next 20 items</example>
        </examples>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required">
            <description>The keywordArgs parameter may either be an instance of
	conforming to dojo.data.api.Request or may be a simple anonymous object
	that may contain any of the following:
	{
	query: query-object or query-string,
	queryOptions: object,
	onBegin: Function,
	onItem: Function,
	onComplete: Function,
	onError: Function,
	scope: object,
	start: int
	count: int
	sort: array
	}
	All implementations should accept keywordArgs objects with any of
	the 9 standard properties: query, onBegin, onItem, onComplete, onError
	scope, sort, start, and count.  Some implementations may accept additional
	properties in the keywordArgs object as valid parameters, such as
	{includeOutliers:true}.
	
	The *query* parameter.
	The query may be optional in some data store implementations.
	The dojo.data.api.Read API does not specify the syntax or semantics
	of the query itself -- each different data store implementation
	may have its own notion of what a query should look like.
	However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
	and dojox.data support an object structure query, where the object is a set of
	name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
	dijit widgets, such as ComboBox assume this to be the case when working with a datastore
	when they dynamically update the query.  Therefore, for maximum compatibility with dijit
	widgets the recommended query parameter is a key/value object.  That does not mean that the
	the datastore may not take alternative query forms, such as a simple string, a Date, a number,
	or a mix of such.  Ultimately, The dojo.data.api.Read API is agnostic about what the query
	format.
	Further note:  In general for query objects that accept strings as attribute
	value matches, the store should also support basic filtering capability, such as *
	(match any character) and ? (match single character).  An example query that is a query object
	would be like: { attrFoo: &amp;quot;value*&amp;quot;}.  Which generally means match all items where they have
	an attribute named attrFoo, with a value that starts with 'value'.
	
	The *queryOptions* parameter
	The queryOptions parameter is an optional parameter used to specify optiosn that may modify
	the query in some fashion, such as doing a case insensitive search, or doing a deep search
	where all items in a hierarchical representation of data are scanned instead of just the root
	items.  It currently defines two options that all datastores should attempt to honor if possible:
	{
	ignoreCase: boolean, //Whether or not the query should match case sensitively or not.  Default behaviour is false.
	deep: boolean 	//Whether or not a fetch should do a deep search of items and all child
	//items instead of just root-level items in a datastore.  Default is false.
	}
	
	The *onBegin* parameter.
	function(size, request);
	If an onBegin callback function is provided, the callback function
	will be called just once, before the first onItem callback is called.
	The onBegin callback function will be passed two arguments, the
	the total number of items identified and the Request object.  If the total number is
	unknown, then size will be -1.  Note that size is not necessarily the size of the
	collection of items returned from the query, as the request may have specified to return only a
	subset of the total set of items through the use of the start and count parameters.
	
	The *onItem* parameter.
	function(item, request);
	If an onItem callback function is provided, the callback function
	will be called as each item in the result is received. The callback
	function will be passed two arguments: the item itself, and the
	Request object.
	
	The *onComplete* parameter.
	function(items, request);
	
	If an onComplete callback function is provided, the callback function
	will be called just once, after the last onItem callback is called.
	Note that if the onItem callback is not present, then onComplete will be passed
	an array containing all items which matched the query and the request object.
	If the onItem callback is present, then onComplete is called as:
	onComplete(null, request).
	
	The *onError* parameter.
	function(errorData, request);
	If an onError callback function is provided, the callback function
	will be called if there is any sort of error while attempting to
	execute the query.
	The onError callback function will be passed two arguments:
	an Error object and the Request object.
	
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onComplete, onError, etc) will be invoked in the context of the scope
	object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global().
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global(), item, request)
	
	The *start* parameter.
	If a start parameter is specified, this is a indication to the datastore to
	only start returning items once the start number of items have been located and
	skipped.  When this parameter is paired with 'count', the store should be able
	to page across queries with millions of hits by only returning subsets of the
	hits for each query
	
	The *count* parameter.
	If a count parameter is specified, this is a indication to the datastore to
	only return up to that many items.  This allows a fetch call that may have
	millions of item matches to be paired down to something reasonable.
	
	The *sort* parameter.
	If a sort parameter is specified, this is a indication to the datastore to
	sort the items in some manner before returning the items.  The array is an array of
	javascript objects that must conform to the following format to be applied to the
	fetching of items:
	{
	attribute: attribute || attribute-name-string,
	descending: true|false;   // Optional.  Default is false.
	}
	Note that when comparing attributes, if an item contains no value for the attribute
	(undefined), then it the default ascending sort logic should push it to the bottom
	of the list.  In the descending order case, it such items should appear at the top of the list.</description>
          </parameter>
        </parameters>
        <return-description>The fetch() method will return a javascript object conforming to the API
	defined in dojo.data.api.Request.  In general, it will be the keywordArgs
	object returned with the required functions in Request.js attached.
	Its general purpose is to provide a convenient way for a caller to abort an
	ongoing fetch.
	
	The Request object may also have additional properties when it is returned
	such as request.store property, which is a pointer to the datastore object that
	fetch() is a method of.</return-description>
      </method>
      <method name="containsValue" scope="instance">
        <examples>
          <example>	var trueOrFalse = store.containsValue(kermit, "color", "green");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access values on.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match as a value for the attribute.</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <description>The close() method is intended for instructing the store to 'close' out
	any information associated with a particular request.  In general, this API
	expects to recieve as a parameter a request object returned from a fetch.
	It will then close out anything associated with that request, such as
	clearing any internal datastore caches and closing any 'open' connections.
	For some store implementations, this call may be a no-op.</description>
        <examples>
          <example>	var request = store.fetch({onComplete: doSomething});
		...
		store.close(request);</example>
        </examples>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>An instance of a request for the store to use to identify what to close out.
	If no request is passed, then the store should clear all internal caches (if any)
	and close out all 'open' connections.  It does not render the store unusable from
	there on, it merely cleans out any current data and resets the store to initial
	state.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Request">
    <methods>
      <method name="abort" scope="instance">
        <description>This function is a hook point for stores to provide as a way for
	a fetch to be halted mid-processing.  For more details on the fetch() api,
	please see dojo.data.api.Read.fetch().</description>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Write" superclass="dojo.data.api.Read">
    <methods>
      <method name="unsetAttribute" scope="instance">
        <examples>
          <example>	var success = store.unsetAttribute(kermit, "color");
		if (success) {assert(!store.hasAttribute(kermit, "color"));}</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to modify.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute of the item to unset represented as a string.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <examples>
          <example>	var success = store.setValues(kermit, "color", ["green", "aqua"]);
		success = store.setValues(kermit, "color", []);
		if (success) {assert(!store.hasAttribute(kermit, "color"));}</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to modify.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute of the item to change represented as a string name.</description>
          </parameter>
          <parameter name="values" type="array" usage="required">
            <description>An array of values to assign to the attribute..</description>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <examples>
          <example>	var success = store.set(kermit, "color", "green");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to modify.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute of the item to change represented as a string name.</description>
          </parameter>
          <parameter name="value" type="almost" usage="required">
            <description>The value to assign to the item.</description>
          </parameter>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <examples>
          <example>	store.save({onComplete: onSave});
		store.save({scope: fooObj, onComplete: onSave, onError: saveFailed});</example>
        </examples>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>{ onComplete: function
	onError: function
	scope: object
	}
	
	The *onComplete* parameter.
	function();
	
	If an onComplete callback function is provided, the callback function
	will be called just once, after the save has completed.  No parameters
	are generally passed to the onComplete.
	
	The *onError* parameter.
	function(errorData);
	
	If an onError callback function is provided, the callback function
	will be called if there is any sort of error while attempting to
	execute the save.  The onError function will be based one parameter, the
	error.
	
	The *scope* parameter.
	If a scope object is provided, all of the callback function (
	onComplete, onError, etc) will be invoked in the context of the scope
	object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global.
	For example, onComplete.call(scope) vs.
	onComplete.call(dojo.global)</description>
          </parameter>
        </parameters>
        <return-description>Nothing.  Since the saves are generally asynchronous, there is
	no need to return anything.  All results are passed via callbacks.</return-description>
      </method>
      <method name="revert" scope="instance">
        <description>Discards any unsaved changes.</description>
        <examples>
          <example>	var success = store.revert();</example>
        </examples>
      </method>
      <method name="newItem" scope="instance">
        <examples>
          <example>	var kermit = store.newItem({name: "Kermit", color:[blue, green]});</example>
        </examples>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional">
            <description>A javascript object defining the initial content of the item as a set of JavaScript 'property name: value' pairs.</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="optional">
            <description>An optional javascript object defining what item is the parent of this item (in a hierarchical store.  Not all stores do hierarchical items),
	and what attribute of that parent to assign the new item to.  If this is present, and the attribute specified
	is a multi-valued attribute, it will append this item into the array of values for that attribute.  The structure
	of the object is as follows:
	{
	parent: someItem,
	attribute: &amp;quot;attribute-name-string&amp;quot;
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <examples>
          <example>	var trueOrFalse = store.isDirty(kermit); // true if kermit is dirty
		var trueOrFalse = store.isDirty();       // true if any item is dirty</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="optional">
            <description>The item to check.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="deleteItem" scope="instance">
        <examples>
          <example>	var success = store.deleteItem(kermit);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to delete.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.api.Read" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.util"/>
  <class type="dojo.date.locale">
    <methods>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <description>Create a Date object from a string using a known localized pattern.
	By default, this method parses looking for both date and time in the string.
	Formatting patterns are chosen appropriate to the locale.  Different
	formatting lengths may be chosen, with "full" used by default.
	Custom patterns may be used or registered with translations using
	the dojo.date.locale.addCustomFormats method.
	
	Formatting patterns are implemented using [the syntax described at
	unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	When two digit years are used, a century is chosen according to a sliding
	window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	year &lt; 100CE requires strict mode.</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string representation of a date</description>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="isWeekend" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required">
            <description>'months' || 'days'</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>'wide' || 'abbr' || 'narrow' (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)</description>
          </parameter>
          <parameter name="context" type="String" usage="optional">
            <description>'standAlone' || 'format' (default)</description>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <description>override locale used to find the names</description>
          </parameter>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <description>Create a string from a Date object using a known localized pattern.
	By default, this method formats both date and time from dateObject.
	Formatting patterns are chosen appropriate to the locale.  Different
	formatting lengths may be chosen, with "full" used by default.
	Custom patterns may be used or registered with translations using
	the dojo.date.locale.addCustomFormats method.
	Formatting patterns are implemented using [the syntax described at
	unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>the date and/or time to be formatted.  If a time only is formatted,
	the values in the year, month, and day fields are irrelevant.  The
	opposite is true when formatting only dates.</description>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="instance">
        <description>The user may add custom localized formats where the bundle has properties following the
	same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	The pattern string should match the format used by the CLDR.
	See dojo.date.locale.format() for details.
	The resources must be loaded by dojo.requireLocalization() prior to use</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="_getZone" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>the date and/or time being formatted.</description>
          </parameter>
          <parameter name="getName" type="boolean" usage="required">
            <description>Whether to return the timezone string (if true), or the offset (if false)</description>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional">
            <description>The options being used for formatting</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDayOfWeek" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getGregorianBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getDayOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="__FormatOptions" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.date.locale.__FormatOptions">
    <methods/>
  </class>
  <class type="dojo.date">
    <methods>
      <method name="isLeapYear" scope="instance">
        <description>Leap years are years with an additional day YYYY-02-29, where the
	year number is a multiple of four with the following exception: If
	a year is a multiple of 100, then it is only a leap year if it is
	also a multiple of 400. For example, 1900 was not a leap year, but
	2000 is one.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getTimezoneName" scope="instance">
        <description>Try to get time zone info from toString or toLocaleString method of
	the Date object -- UTC offset is not a time zone.  See
	http://www.twinsun.com/tz/tz-link.htm Note: results may be
	inconsistent across browsers.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>Needed because the timezone may vary with time (daylight savings)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="Date" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="date2" type="Date" usage="optional">
            <description>object.  If not specified, the current Date is used.</description>
          </parameter>
          <parameter name="interval" type="String" usage="optional">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="compare" scope="instance">
        <description>Returns 0 if equal, positive if a &gt; b, else negative.</description>
        <parameters>
          <parameter name="date1" type="Date" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="date2" type="Date" usage="optional">
            <description>object.  If not specified, the current Date is used.</description>
          </parameter>
          <parameter name="portion" type="String" usage="optional">
            <description>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required">
            <description>Date object to start with</description>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>How much to add to the date.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="stamp" scope="instance" type="Object"/>
      <property name="locale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.date.stamp">
    <methods>
      <method name="toISOString" scope="instance">
        <description>When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	Does not check bounds.  Only years between 100 and 9999 are supported.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>A Date object</description>
          </parameter>
          <parameter name="options" type="dojo.date.stamp.__Options" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="fromISOString" scope="instance">
        <description>Accepts a string formatted according to a profile of ISO8601 as defined by
	[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	The following combinations are valid:
	
	* dates only
		* yyyy
		* yyyy-MM
		* yyyy-MM-dd
	* times only, with an optional time zone appended
		* THH:mm
		* THH:mm:ss
		* THH:mm:ss.SSS
	* and "datetimes" which could be any combination of the above
	
	timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	input may return null.  Arguments which are out of bounds will be handled
	by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	Only years between 100 and 9999 are supported.</description>
        <parameters>
          <parameter name="formattedString" type="String" usage="required">
            <description>A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00</description>
          </parameter>
          <parameter name="defaultTime" type="Number" usage="optional">
            <description>Used for defaults for fields omitted in the formattedString.
	Uses 1970-01-01T00:00:00.0Z by default.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="__Options" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.date.stamp.__Options">
    <methods/>
  </class>
  <class type="dojo.dnd">
    <methods>
      <method name="manager" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="isFormElement" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getUniqueId" scope="instance"/>
      <method name="autoScrollNodes" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousemove event</description>
          </parameter>
        </parameters>
      </method>
      <method name="autoScroll" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousemove event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_defaultCreator" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a container node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="_createTrTd" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>a text for TD</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_createSpan" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>a text for SPAN</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_createNode" scope="instance">
        <parameters>
          <parameter name="tag" type="String" usage="required">
            <description>a tag name or empty for SPAN</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="__TimedMoveableArgs" scope="instance"/>
      <method name="__SourceArgs" scope="instance"/>
      <method name="__SelectorArgs" scope="instance"/>
      <method name="__MoveableArgs" scope="instance"/>
      <method name="__ContainerArgs" scope="instance"/>
      <method name="TimedMoveable" scope="instance">
        <parameters>
          <parameter name="node" type="Node|String" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__TimedMoveableArgs" usage="required">
            <description>object with additional parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Target" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Source" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>node or node's id to build the source on</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional">
            <description>any property of this class may be configured via the params
	object which is mixed-in to the `dojo.dnd.Source` instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="Selector" scope="instance">
        <parameters>
          <parameter name="node" type="Node|String" usage="required">
            <description>node or node's id to build the selector on</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SelectorArgs" usage="optional">
            <description>a dictionary of parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="Mover" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event, which started the move;
	only pageX and pageY properties are used</description>
          </parameter>
          <parameter name="host" type="Object" usage="optional">
            <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
          </parameter>
        </parameters>
      </method>
      <method name="Moveable" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__MoveableArgs" usage="optional">
            <description>optional parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="Manager" scope="instance"/>
      <method name="Item" scope="instance"/>
      <method name="Container" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>node or node's id to build the container on</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__ContainerArgs" usage="required">
            <description>a dictionary of parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="Avatar" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="AutoSource" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="move" scope="instance" type="Object"/>
      <property name="_validOverflow" scope="instance" type="Object"/>
      <property name="_validNodes" scope="instance" type="Object"/>
      <property name="_defaultCreatorNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.AutoSource" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.Source" superclass="dojo.dnd.Selector">
    <methods>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDropInternal" scope="instance">
        <parameters>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDropExternal" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="instance"/>
      <method name="onDraggingOut" scope="instance"/>
      <method name="onDndStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which has the mouse over it</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
          <parameter name="target" type="Object" usage="required">
            <description>the target which accepts items</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="copyState" scope="instance">
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <description>the &amp;quot;copy&amp;quot; key was pressed</description>
          </parameter>
          <parameter name="self" type="Boolean" usage="optional">
            <description>optional flag that means that we are about to drop on itself</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>node or node's id to build the source on</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional">
            <description>any property of this class may be configured via the params
	object which is mixed-in to the `dojo.dnd.Source` instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_markTargetAnchor" scope="instance">
        <parameters>
          <parameter name="before" type="Boolean" usage="required">
            <description>insert before, if true, after otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="_markDndStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Selector" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.Avatar">
    <methods>
      <method name="update" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="construct" scope="instance"/>
      <method name="_generateText" scope="instance"/>
    </methods>
    <properties>
      <property name="manager" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Avatar.manager"/>
  <class type="dojo.dnd.__ContainerArgs">
    <methods>
      <method name="creator" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.dnd.Container" superclass="Evented">
    <methods>
      <method name="sync" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="startup" scope="instance"/>
      <method name="setItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="data" type="dojo.dnd.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectStart" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertNodes" scope="instance">
        <parameters>
          <parameter name="data" type="Array" usage="required">
            <description>a list of data items, which should be processed by the creator function</description>
          </parameter>
          <parameter name="before" type="Boolean" usage="required">
            <description>insert before the anchor, if true, and after the anchor otherwise</description>
          </parameter>
          <parameter name="anchor" type="Node" usage="required">
            <description>the anchor node to be used as a point of insertion</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.dnd.Item"/>
        </return-types>
      </method>
      <method name="getAllNodes" scope="instance">
        <return-types>
          <return-type type="NodeList"/>
        </return-types>
      </method>
      <method name="forInItems" scope="instance">
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="delItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>node or node's id to build the container on</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__ContainerArgs" usage="required">
            <description>a dictionary of parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="clearItems" scope="instance"/>
      <method name="_removeItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>a variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.dnd.Item" usage="required"/>
          <parameter name="hint" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildByEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_changeState" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>a name of the state to change</description>
          </parameter>
          <parameter name="newState" type="String" usage="required">
            <description>new state</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>a variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Evented" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.Item">
    <methods/>
  </class>
  <class type="dojo.dnd._defaultCreatorNodes"/>
  <class type="dojo.dnd.Manager" superclass="Evented">
    <methods>
      <method name="updateAvatar" scope="instance"/>
      <method name="stopDrag" scope="instance"/>
      <method name="startDrag" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="overSource" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the reporter</description>
          </parameter>
        </parameters>
      </method>
      <method name="outSource" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the reporter</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>keyboard event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>keyboard event</description>
          </parameter>
        </parameters>
      </method>
      <method name="makeAvatar" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="canDrop" scope="instance">
        <parameters>
          <parameter name="flag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setCopyStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Boolean" usage="required">
            <description>the copy status</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Evented" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.Manager.canDrop">
    <methods/>
  </class>
  <class type="dojo.dnd.Manager.avatar.node">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Manager.avatar.node.style"/>
  <class type="dojo.dnd.__MoveableArgs">
    <methods/>
  </class>
  <class type="dojo.dnd.Moveable" superclass="Evented">
    <methods>
      <method name="onSelectStart" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMoving" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStart" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse/touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse/touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onDragDetected" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__MoveableArgs" usage="optional">
            <description>optional parameters</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Evented" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.Mover" superclass="Evented">
    <methods>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse/touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event, which started the move;
	only pageX and pageY properties are used</description>
          </parameter>
          <parameter name="host" type="Object" usage="optional">
            <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Evented" scope="instance"/>
    </mixins>
    <properties>
      <property name="node" scope="instance-prototype" type="Node">
        <description>a node (or node's id) to be moved
	e: Event
	a mouse event, which started the move;
	only pageX and pageY properties are used</description>
      </property>
      <property name="marginBox" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Mover.node">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Mover.node.style"/>
  <class type="dojo.dnd.Mover.marginBox"/>
  <class type="dojo.dnd.__SelectorArgs" superclass="dojo.dnd.__ContainerArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.__ContainerArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.Selector" superclass="dojo.dnd.Container">
    <methods>
      <method name="sync" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="selectNone" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="selectAll" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="insertNodes" scope="instance">
        <parameters>
          <parameter name="addSelected" type="Boolean" usage="required">
            <description>all new nodes will be added to selected items, if true, no selection change otherwise</description>
          </parameter>
          <parameter name="data" type="Array" usage="required">
            <description>a list of data items, which should be processed by the creator function</description>
          </parameter>
          <parameter name="before" type="Boolean" usage="required">
            <description>insert before the anchor, if true, and after the anchor otherwise</description>
          </parameter>
          <parameter name="anchor" type="Node" usage="required">
            <description>the anchor node to be used as a point of insertion</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getSelectedNodes" scope="instance">
        <return-types>
          <return-type type="NodeList"/>
        </return-types>
      </method>
      <method name="forInSelectedItems" scope="instance">
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="deleteSelectedNodes" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node|String" usage="required">
            <description>node or node's id to build the selector on</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SelectorArgs" usage="optional">
            <description>a dictionary of parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeSelection" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_removeAnchor" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.__SourceArgs">
    <methods/>
  </class>
  <class type="dojo.dnd.Target" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.__TimedMoveableArgs" superclass="dojo.dnd.__MoveableArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.__MoveableArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.TimedMoveable" superclass="dojo.dnd.Moveable">
    <methods>
      <method name="onMoveStop" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node|String" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__TimedMoveableArgs" usage="required">
            <description>object with additional parameters.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Moveable" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd._validNodes"/>
  <class type="dojo.dnd._validOverflow"/>
  <class type="dojo.dnd.move">
    <methods>
      <method name="parentConstrainedMoveable" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__parentConstrainedMoveableArgs" usage="optional">
            <description>an optional object with parameters</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constrainedMoveable" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__constrainedMoveableArgs" usage="optional">
            <description>an optional object with additional parameters;
	the rest is passed to the base class</description>
          </parameter>
        </parameters>
      </method>
      <method name="boxConstrainedMoveable" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__boxConstrainedMoveableArgs" usage="optional">
            <description>an optional object with parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="__parentConstrainedMoveableArgs" scope="instance"/>
      <method name="__constrainedMoveableArgs" scope="instance"/>
      <method name="__boxConstrainedMoveableArgs" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.dnd.move.__constrainedMoveableArgs" superclass="dojo.dnd.__MoveableArgs">
    <methods>
      <method name="constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.__MoveableArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.move.constrainedMoveable" superclass="dojo.dnd.Moveable">
    <methods>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__constrainedMoveableArgs" usage="optional">
            <description>an optional object with additional parameters;
	the rest is passed to the base class</description>
          </parameter>
        </parameters>
      </method>
      <method name="constraints" scope="instance-prototype"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Moveable" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.move.__boxConstrainedMoveableArgs" superclass="dojo.dnd.move.__constrainedMoveableArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.__constrainedMoveableArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.move.boxConstrainedMoveable" superclass="dojo.dnd.move.constrainedMoveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__boxConstrainedMoveableArgs" usage="optional">
            <description>an optional object with parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.constrainedMoveable" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.move.__parentConstrainedMoveableArgs" superclass="dojo.dnd.move.__constrainedMoveableArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.__constrainedMoveableArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.dnd.move.parentConstrainedMoveable" superclass="dojo.dnd.move.constrainedMoveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__parentConstrainedMoveableArgs" usage="optional">
            <description>an optional object with parameters</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constraints" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.constrainedMoveable" scope="instance"/>
    </mixins>
    <properties>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.parentConstrainedMoveable.node"/>
  <class type="location"/>
  <class type="prop">
    <methods>
      <method name="set" scope="instance">
        <description>Handles normalized setting of properties on DOM nodes.
	
	When passing functions as values, note that they will not be
	directly assigned to slots on the node, but rather the default
	behavior will be removed and the new behavior will be added
	using `dojo.connect()`, meaning that event handler properties
	will be normalized and that some caveats with regards to
	non-standard behaviors for onsubmit apply. Namely that you
	should cancel form submission using `dojo.stopEvent()` on the
	passed event object instead of returning a boolean value from
	the handler itself.</description>
        <examples>
          <example>	// use prop() to set the tab index
		dojo.setProp("nodeId", "tabIndex", 3);</example>
          <example>Set multiple values at once, including event handlers:
		dojo.setProp("formId", {
			"foo": "bar",
			"tabIndex": -1,
			"method": "POST",
			"onsubmit": function(e){
				// stop submitting the form. Note that the IE behavior
				// of returning true or false will have no effect here
				// since our handler is connect()ed to the built-in
				// onsubmit behavior and so we need to use
				// dojo.stopEvent() to ensure that the submission
				// doesn't proceed.
				dojo.stopEvent(e);
	
				// submit the form with Ajax
				dojo.xhrPost({ form: "formId" });
			}
		});</example>
          <example>Style is s special case: Only set with an object hash of styles
		dojo.setProp("someNode",{
			id:"bar",
			style:{
				width:"200px", height:"100px", color:"#000"
			}
		});</example>
          <example>Again, only set style as an object hash of styles:
		var obj = { color:"#fff", backgroundColor:"#000" };
		dojo.setProp("someNode", "style", obj);
	
		// though shorter to use `dojo.style()` in this case:
		dojo.style("someNode", obj);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to the element to set the property on</description>
          </parameter>
          <parameter name="name" type="String|Object" usage="required">
            <description>the name of the property to set, or a hash object to set
	multiple properties at once.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>The value to set for the property</description>
          </parameter>
        </parameters>
        <return-description>the DOM node</return-description>
      </method>
      <method name="get" scope="instance">
        <description>Handles normalized getting of properties on DOM nodes.</description>
        <examples>
          <example>	// get the current value of the "foo" property on a node
		dojo.getProp(dojo.byId("nodeId"), "foo");
		// or we can just pass the id:
		dojo.getProp("nodeId", "foo");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>id or reference to the element to get the property on</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the property to get.</description>
          </parameter>
        </parameters>
        <return-description>the value of the requested property or its default value</return-description>
      </method>
    </methods>
  </class>
  <class type="exports.names"/>
  <class type="dom">
    <methods>
      <method name="setSelectable" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="selectable" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="isDescendant" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required"/>
          <parameter name="ancestor" type="DOMNode|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.fx">
    <methods>
      <method name="wipeOut" scope="instance">
        <description>Returns an animation that will shrink node defined in "args"
	from it's current height to 1px, and then hide it.</description>
        <examples>
          <example>	dojo.fx.wipeOut({ node:"someId" }).play()</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A hash-map of standard `dojo.Animation` constructor properties
	(such as easing: node: duration: and so on)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeIn" scope="instance">
        <description>Returns an animation that will expand the
	node defined in 'args' object from it's current height to
	it's natural height (with no scrollbar).
	Node must have no margin/border/padding.</description>
        <examples>
          <example>	dojo.fx.wipeIn({
			node:"someId"
		}).play()</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A hash-map of standard `dojo.Animation` constructor properties
	(such as easing: node: duration: and so on)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideTo" scope="instance">
        <description>Returns an animation that will slide "node"
	defined in args Object from its current position to
	the position defined by (args.left, args.top).</description>
        <examples>
          <example>	.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A hash-map of standard `dojo.Animation` constructor properties
	(such as easing: node: duration: and so on). Special args members
	are `top` and `left`, which indicate the new position to slide to.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="combine" scope="instance">
        <description>Combine an array of `dojo.Animation`s to run in parallel,
	providing a new `dojo.Animation` instance encompasing each
	animation, firing standard animation events.</description>
        <examples>
          <example>Fade out `node` while fading in `otherNode` simultaneously
		dojo.fx.combine([
			dojo.fadeIn({ node:node }),
			dojo.fadeOut({ node:otherNode })
		]).play();</example>
          <example>When the longest animation ends, execute a function:
		var anim = dojo.fx.combine([
			dojo.fadeIn({ node: n, duration:700 }),
			dojo.fadeOut({ node: otherNode, duration: 300 })
		]);
		dojo.connect(anim, "onEnd", function(){
			// overall animation is done.
		});
		anim.play(); // play the animation</example>
        </examples>
        <parameters>
          <parameter name="animations" type="Array&lt;dojo.Animation&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="chain" scope="instance">
        <description>Return a `dojo.Animation` which will play all passed
	`dojo.Animation` instances in sequence, firing its own
	synthesized events simulating a single animation. (eg:
	onEnd of this animation means the end of the chain,
	not the individual animations within)</description>
        <examples>
          <example>Once `node` is faded out, fade in `otherNode`
		dojo.fx.chain([
			dojo.fadeIn({ node:node }),
			dojo.fadeOut({ node:otherNode })
		]).play();</example>
        </examples>
        <parameters>
          <parameter name="animations" type="Array&lt;dojo.Animation&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="Toggler" scope="instance">
        <description>class constructor for an animation toggler. It accepts a packed
	set of arguments about what type of animation to use in each
	direction, duration, etc. All available members are mixed into
	these animations from the constructor (for example, `node`,
	`showDuration`, `hideDuration`).</description>
        <examples>
          <example>	var t = new dojo.fx.Toggler({
			node: "nodeId",
			showDuration: 500,
			// hideDuration will default to "200"
			showFunc: dojo.fx.wipeIn,
			// hideFunc will default to "fadeOut"
		});
		t.show(100); // delay showing for 100ms
		// ...time passes...
		t.hide();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="easing" scope="instance" type="Object">
        <description>Collection of easing functions to use beyond the default
	`dojo._defaultEasing` function.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.fx.Toggler">
    <description>class constructor for an animation toggler. It accepts a packed
	set of arguments about what type of animation to use in each
	direction, duration, etc. All available members are mixed into
	these animations from the constructor (for example, `node`,
	`showDuration`, `hideDuration`).</description>
    <methods>
      <method name="showFunc" scope="instance"/>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="delay" type="Integer" usage="optional">
            <description>Ammount of time to stall playing the show animation</description>
          </parameter>
        </parameters>
      </method>
      <method name="hideFunc" scope="instance"/>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="delay" type="Integer" usage="optional">
            <description>Ammount of time to stall playing the hide animation</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.fx.easing">
    <description>Easing functions are used to manipulate the iteration through
	an `dojo.Animation`s _Line. _Line being the properties of an Animation,
	and the easing function progresses through that Line determing
	how quickly (or slowly) it should go. Or more accurately: modify
	the value of the _Line based on the percentage of animation completed.
	
	All functions follow a simple naming convention of "ease type" + "when".
	If the name of the function ends in Out, the easing described appears
	towards the end of the animation. "In" means during the beginning,
	and InOut means both ranges of the Animation will applied, both
	beginning and end.
	
	One does not call the easing function directly, it must be passed to
	the `easing` property of an animation.</description>
    <methods>
      <method name="sineOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="linear" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticOut" scope="instance">
        <description>An easing function that elasticly snaps around the target value,
	near the end of the Animation
	
	Use caution when the elasticity will cause values to become
	negative as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticInOut" scope="instance">
        <description>An easing function that elasticly snaps around the value, near
	the beginning and end of the Animation.
	
	Use caution when the elasticity will cause values to become
	negative as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticIn" scope="instance">
        <description>An easing function the elastically snaps from the start value
	
	Use caution when the elasticity will cause values to become negative
	as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
      <method name="bounceIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
      <method name="backOut" scope="instance">
        <description>An easing function that pops past the range briefly, and slowly comes back.
	
	Use caution when the easing will cause values to become negative as some
	properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backInOut" scope="instance">
        <description>An easing function combining the effects of `backIn` and `backOut`.
	Use caution when the easing will cause values to become negative
	as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.gears">
    <methods>
      <method name="_gearsObject" scope="instance">
        <return-types>
          <return-type type="already defined elsewhere"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.has">
    <description>Returns the value of the feature named by name. The feature must have been
	previously added to the cache by has.add.</description>
    <methods>
      <method name="normalize" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="toAbsMid" type="Function" usage="required">
            <description>Resolves a relative module id into an absolute module id</description>
          </parameter>
        </parameters>
      </method>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required">
            <description>Gives the resolved module id to load.</description>
          </parameter>
          <parameter name="parentRequire" type="Function" usage="required">
            <description>The loader require function with respect to the module that contained the plugin resource in it's
	dependency list.</description>
          </parameter>
          <parameter name="loaded" type="Function" usage="required">
            <description>Callback to loader that consumes result of plugin demand.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clearElement" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <examples>
          <example>A redundant test, testFn with immediate execution:
					has.add("javascript", function(){ return true; }, true);</example>
          <example>Again with the redundantness. You can do this in your tests, but we should
	not be doing this in any internal has.js tests
					has.add("javascript", true);</example>
          <example>Three things are passed to the testFunction. `global`, `document`, and a generic element
	from which to work your test should the need arise.
					has.add("bug-byid", function(g, d, el){
							// g	== global, typically window, yadda yadda
							// d	== document object
							// el == the generic element. a `has` element.
							return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
					});</example>
        </examples>
        <parameters>
          <parameter name="name" type="String|Integer" usage="required">
            <description>The name (if a string) or identifier (if an integer) of the feature to test.</description>
          </parameter>
          <parameter name="test" type="Function" usage="required">
            <description>A test function to register. If a function, queued for testing until actually
	needed. The test function should return a boolean indicating
	the presence of a feature or bug.</description>
          </parameter>
          <parameter name="now" type="Boolean" usage="optional">
            <description>Optional. Omit if `test` is not a function. Provides a way to immediately
	run the test and cache the result.</description>
          </parameter>
          <parameter name="force" type="Boolean" usage="optional">
            <description>Optional. If the test already exists and force is truthy, then the existing
	test will be replaced; otherwise, add does not replace an existing test (that
	is, by default, the first test advice wins).</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.html">
    <methods>
      <method name="set" scope="instance">
        <description>Unless you need to use the params capabilities of this method, you should use
	dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
	an HTML string into the DOM, but it only handles inserting an HTML string as DOM
	elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
	or the other capabilities as defined by the params object for this method.</description>
        <examples>
          <example>A safe string/node/nodelist content replacement/injection with hooks for extension
	Example Usage:
	dojo.html.set(node, "some string");
	dojo.html.set(node, contentNode, {options});
	dojo.html.set(node, myNode.childNodes, {options});</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>the parent element that will receive the content</description>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required">
            <description>the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <description>Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setNodeContent" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>the parent element
	content:
	the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</description>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required"/>
        </parameters>
      </method>
      <method name="_secureForInnerHtml" scope="instance">
        <parameters>
          <parameter name="cont" type="String" usage="required">
            <description>An html string for insertion into the dom</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_emptyNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>the parent element</description>
          </parameter>
        </parameters>
      </method>
      <method name="_ContentSetter" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.html._ContentSetter">
    <methods>
      <method name="tearDown" scope="instance"/>
      <method name="setContent" scope="instance"/>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DomNode|NodeList" usage="optional">
            <description>An html string, node or enumerable list of nodes for insertion into the dom
	If not provided, the object's content property will be used</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="onEnd" scope="instance"/>
      <method name="onContentError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBegin" scope="instance"/>
      <method name="empty" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance"/>
      <method name="_onError" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="consoleText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixin" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.io.iframe">
    <methods>
      <method name="setSrc" scope="instance">
        <parameters>
          <parameter name="iframe" type="DOMNode" usage="required"/>
          <parameter name="src" type="String" usage="required"/>
          <parameter name="replace" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="send" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.io.iframe.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="doc" scope="instance">
        <parameters>
          <parameter name="iframeNode" type="DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="W3"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="fname" type="String" usage="required">
            <description>The name of the iframe. Used for the name attribute on the
	iframe.</description>
          </parameter>
          <parameter name="onloadstr" type="String" usage="required">
            <description>A string of JavaScript that will be executed when the content
	in the iframe loads.</description>
          </parameter>
          <parameter name="uri" type="String" usage="optional">
            <description>The value of the src attribute on the iframe element. If a
	value is not given, then dojo/resources/blank.html will be
	used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_iframeOnload" scope="instance"/>
      <method name="_fireNextRequest" scope="instance"/>
      <method name="__ioArgs" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.io.iframe.__ioArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.io">
    <properties>
      <property name="script" scope="instance" type="Object"/>
      <property name="iframe" scope="instance" type="Object">
        <description>Sends an Ajax I/O call using and Iframe (for instance, to upload files)</description>
      </property>
    </properties>
  </class>
  <class type="dojo.io.iframe.send">
    <methods/>
  </class>
  <class type="dojo.io.iframe._fireNextRequest">
    <methods/>
  </class>
  <class type="dojo.io.iframe._iframeOnload">
    <methods/>
    <properties>
      <property name="_currentDfd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.iframe._iframeOnload._currentDfd">
    <properties>
      <property name="ioArgs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.iframe._iframeOnload._currentDfd.ioArgs"/>
  <class type="dojo.io.script">
    <methods>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.io.script.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="attach" scope="instance">
        <description>Attaches the script element to the DOM.	 Use this method if you
	just want to attach a script to the DOM and do not care when or
	if it loads.</description>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="_validCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_resHandle" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_makeScriptDeferred" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_jsonpCallback" scope="instance">
        <parameters>
          <parameter name="json" type="JSON" usage="required">
            <description>Object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_ioCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredOk" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredCancel" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_canAttach" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addDeadScript" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__ioArgs" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.io.script.__ioArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.io.script._jsonpCallback">
    <methods/>
    <properties>
      <property name="ioArgs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.script._jsonpCallback.ioArgs"/>
  <class type="dojo.keys"/>
  <class type="dojo.mouseButtons">
    <methods>
      <method name="isRight" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isMiddle" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isLeft" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isButton" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
          <parameter name="button" type="Number" usage="required">
            <description>The button value (example: dojo.mouseButton.LEFT)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.number">
    <methods>
      <method name="round" scope="instance">
        <description>Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	fractional increments also, such as the nearest quarter.
	NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.</description>
        <examples>
          <example>&gt;&gt;&gt; dojo.number.round(-0.5)
	-1
	&gt;&gt;&gt; dojo.number.round(162.295, 2)
	162.29  // note floating point error.  Should be 162.3
	&gt;&gt;&gt; dojo.number.round(10.71, 0, 2.5)
	10.75</example>
        </examples>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The number to round</description>
          </parameter>
          <parameter name="places" type="Number" usage="optional">
            <description>The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	Must be non-negative.</description>
          </parameter>
          <parameter name="increment" type="Number" usage="optional">
            <description>Rounds next place to nearest value of increment/10.  10 by default.</description>
          </parameter>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <description>Returns regular expression with positive and negative match, group
	and decimal separators</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <description>Create a Number from a string using a known localized pattern.
	Formatting patterns are chosen appropriate to the locale
	and follow the syntax described by
	[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	Note that literal characters in patterns are not supported.</description>
        <parameters>
          <parameter name="expression" type="String" usage="required">
            <description>A string representation of a Number</description>
          </parameter>
          <parameter name="options" type="dojo.number.__ParseOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="NaN"/>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="format" scope="instance">
        <description>Create a string from a Number using a known localized pattern.
	Formatting patterns appropriate to the locale are chosen from the
	[Common Locale Data Repository](http://unicode.org/cldr) as well as the appropriate symbols and
	delimiters.
	If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_realNumberRegexp" scope="instance">
        <parameters>
          <parameter name="flags" type="dojo.number.__RealNumberRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_integerRegexp" scope="instance">
        <parameters>
          <parameter name="flags" type="dojo.number.__IntegerRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_formatAbsolute" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted, ignores sign</description>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <description>the number portion of a pattern (e.g. `#,##0.00`)</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatAbsoluteOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="_applyPattern" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted.</description>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <description>a pattern string as described by
	[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional">
            <description>_applyPattern is usually called via `dojo.number.format()` which
	populates an extra property in the options parameter, &amp;quot;customs&amp;quot;.
	The customs object specifies group and decimal parameters if set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__RegexpOptions" scope="instance"/>
      <method name="__RealNumberRegexpFlags" scope="instance"/>
      <method name="__ParseOptions" scope="instance"/>
      <method name="__IntegerRegexpFlags" scope="instance"/>
      <method name="__FormatOptions" scope="instance"/>
      <method name="__FormatAbsoluteOptions" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.number.__FormatOptions">
    <methods/>
  </class>
  <class type="dojo.number.__FormatAbsoluteOptions">
    <methods/>
  </class>
  <class type="dojo.number.__RegexpOptions">
    <methods/>
  </class>
  <class type="dojo.number.__ParseOptions">
    <methods/>
  </class>
  <class type="dojo.number.__RealNumberRegexpFlags">
    <methods/>
  </class>
  <class type="dojo.number.__IntegerRegexpFlags">
    <methods/>
  </class>
  <class type="dojo.NodeList._stash">
    <methods/>
  </class>
  <class type="Array"/>
  <class type="array"/>
  <class type="dojo.query">
    <description>dojo/query is responsible for loading the appropriate query engine and wrapping
	its results with a `dojo.NodeList`. You can use dojo/query with a specific selector engine
	by using it as a plugin. For example, if you installed the sizzle package, you could
	use it as the selector engine with:
		define("dojo/query!sizzle", function(query){
			query("div")...
	
	The id after the ! can be a module id of the selector engine or one of the following values:
		+ acme: This is the default engine used by Dojo base, and will ensure that the full
		Acme engine is always loaded.
	
		+ css2: If the browser has a native selector engine, this will be used, otherwise a
		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (&gt;)
		operators) and nothing more.
	
		+ css2.1: If the browser has a native selector engine, this will be used, otherwise the
		full Acme engine will be loaded.
	
		+ css3: If the browser has a native selector engine with support for CSS3 pseudo
		selectors (most modern browsers except IE8), this will be used, otherwise the
		full Acme engine will be loaded.
	
		+ Or the module id of a selector engine can be used to explicitly choose the selector engine
	
	For example, if you are using CSS3 pseudo selectors in module, you can specify that
	you will need support them with:
		define("dojo/query!css3", function(query){
			query('#t &gt; h3:nth-child(odd)')...
	
	You can also choose the selector engine/load configuration by setting the &lt;FIXME:what is the configuration setting?&gt;.
	For example:
		&lt;script data-dojo-config="query-selector:'css3'" src="dojo.js"&gt;&lt;/script&gt;</description>
    <methods>
      <method name="load" scope="instance">
        <examples>
          <example>	define(["dojo/query!custom"], function(qsa){
			// loaded selector/custom.js as engine
			qsa("#foobar").forEach(...);
		});</example>
        </examples>
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="parentRequire" type="Object" usage="required"/>
          <parameter name="loaded" type="Object" usage="required"/>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="pseudos" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.regexp">
    <methods>
      <method name="group" scope="instance">
        <parameters>
          <parameter name="expression" type="String" usage="required"/>
          <parameter name="nonCapture" type="Boolean" usage="optional">
            <description>If true, uses non-capturing match, otherwise matches are retained
	by regular expression.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="escapeString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="except" type="String" usage="optional">
            <description>a String with special characters to be left unescaped</description>
          </parameter>
        </parameters>
      </method>
      <method name="buildGroupRE" scope="instance">
        <description>A utility function used by some of the RE generators. The
	subexpressions are constructed by the function, re, in the second
	parameter.  re builds one subexpression for each elem in the array
	a, in the first parameter. Returns a string for a regular
	expression that groups all the subexpressions.</description>
        <parameters>
          <parameter name="arr" type="Object|Array" usage="required">
            <description>A single value or an array of values.</description>
          </parameter>
          <parameter name="re" type="Function" usage="required">
            <description>A function. Takes one parameter and converts it to a regular
	expression.</description>
          </parameter>
          <parameter name="nonCapture" type="Boolean" usage="optional">
            <description>If true, uses non-capturing match, otherwise matches are retained
	by regular expression. Defaults to false</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.rpc">
    <methods>
      <method name="RpcService" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <description>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</description>
          </parameter>
        </parameters>
      </method>
      <method name="JsonpService" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="requiredArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="JsonService" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.rpc.JsonService" superclass="dojo.rpc.RpcService">
    <methods>
      <method name="parseResults" scope="instance">
        <parameters>
          <parameter name="obj" type="anything" usage="required">
            <description>Object Object containing envelope of data we recieve from the server</description>
          </parameter>
        </parameters>
      </method>
      <method name="createRequest" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are creating the requst for</description>
          </parameter>
          <parameter name="params" type="array" usage="required">
            <description>The array of parameters for this request;</description>
          </parameter>
        </parameters>
      </method>
      <method name="callRemote" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>the name of the remote method you want to call.</description>
          </parameter>
          <parameter name="params" type="array" usage="required">
            <description>array of parameters to pass to method</description>
          </parameter>
        </parameters>
      </method>
      <method name="bind" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are calling</description>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <description>The parameters we are passing off to the method</description>
          </parameter>
          <parameter name="deferredRequestHandler" type="deferred" usage="required">
            <description>The Deferred object for this particular request</description>
          </parameter>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.rpc.RpcService" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.rpc.JsonpService" superclass="dojo.rpc.RpcService">
    <methods>
      <method name="createRequest" scope="instance">
        <parameters>
          <parameter name="parameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="requiredArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bind" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are calling</description>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <description>The parameters we are passing off to the method</description>
          </parameter>
          <parameter name="deferredRequestHandler" type="deferred" usage="required">
            <description>The Deferred object for this particular request</description>
          </parameter>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.rpc.RpcService" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.rpc.RpcService">
    <methods>
      <method name="resultCallback" scope="instance">
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required">
            <description>Deferred The deferred object handling a request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="processSmd" scope="instance">
        <parameters>
          <parameter name="object" type="smd" usage="required">
            <description>object defining this service.</description>
          </parameter>
        </parameters>
      </method>
      <method name="parseResults" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>Object that is the return results from an rpc request</description>
          </parameter>
        </parameters>
      </method>
      <method name="generateMethod" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are generating</description>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <description>the array of parameters for this call.</description>
          </parameter>
          <parameter name="url" type="string" usage="required">
            <description>the service url for this call</description>
          </parameter>
        </parameters>
      </method>
      <method name="errorCallback" scope="instance">
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required">
            <description>Deferred The deferred object handling a request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <description>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.selector"/>
  <class type="dojo.store">
    <methods>
      <method name="__CacheArgs" scope="instance"/>
      <method name="Memory" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.store.Memory" usage="required">
            <description>This provides any configuration information that will be mixed into the store.
	This should generally include the data property to provide the starting set of data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="JsonRest" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.store.JsonRest" usage="required">
            <description>This provides any configuration information that will be mixed into the store</description>
          </parameter>
        </parameters>
      </method>
      <method name="DataStore" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional">
            <description>This provides any configuration information that will be mixed into the store,
	including a reference to the Dojo data store under the property &amp;quot;store&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Cache" scope="instance">
        <examples>
          <example>	var master = new dojo.store.Memory(data);
		var cacher = new dojo.store.Memory();
		var store = new dojo.store.Cache(master, cacher);</example>
        </examples>
      </method>
    </methods>
    <properties>
      <property name="util" scope="instance" type="Object"/>
      <property name="api" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.store.__CacheArgs">
    <methods>
      <method name="isLoaded" scope="instance"/>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.store.Cache">
    <methods>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identifier for the object in question.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.__RemoveOptions" usage="optional">
            <description>Any additional parameters needed to describe how the remove should be performed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object|String" usage="required">
            <description>The object or string containing query information. Dependent on the query engine used.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.util.SimpleQueryEngine.__queryOptions" usage="optional">
            <description>An optional keyword arguments object with additional parameters describing the query.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A QueryResults object that can be used to iterate over.</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to put to the store.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.__PutOptions" usage="optional">
            <description>Any additional parameters needed to describe how the put should be performed.</description>
          </parameter>
        </parameters>
        <return-description>Number
	The new id for the object.</return-description>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identifier for the object in question.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.__GetOptions" usage="optional">
            <description>Any additional parameters needed to describe how the get should be performed.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A QueryResults object.</return-description>
      </method>
      <method name="evict" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identifier for the object in question.</description>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to add to the store.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.__AddOptions" usage="optional">
            <description>Any additional parameters needed to describe how the add should be performed.</description>
          </parameter>
        </parameters>
        <return-description>Number
	The new id for the object.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.store.DataStore">
    <methods>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required">
            <description>The identity to use to delete the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required">
            <description>The query to use for retrieving objects from the store</description>
          </parameter>
          <parameter name="options" type="Object" usage="optional">
            <description>Optional options object as used by the underlying dojo.data Store.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A query results object that can be used to iterate over results.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional">
            <description>This provides any configuration information that will be mixed into the store,
	including a reference to the Dojo data store under the property &amp;quot;store&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_objectConverter" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.store.JsonRest">
    <methods>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to delete the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required">
            <description>The query to use for retrieving objects from the store.</description>
          </parameter>
          <parameter name="options" type="dojo.store.api.Store.QueryOptions" usage="optional">
            <description>The optional arguments to apply to the resultset.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.api.Store.QueryResults
	The results of the query, extended with iterative methods.</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="options" type="dojo.store.api.Store.PutDirectives" usage="optional">
            <description>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
	property if a specific id is to be used.</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to get the identity from</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to lookup the object</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
        <return-description>Object
	The object in the store that matches the given id.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.store.JsonRest" usage="required">
            <description>This provides any configuration information that will be mixed into the store</description>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="options" type="dojo.store.api.Store.PutDirectives" usage="optional">
            <description>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
	property if a specific id is to be used.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.store.Memory">
    <methods>
      <method name="setData" scope="instance">
        <parameters>
          <parameter name="data" type="Array&lt;Object&gt;" usage="required">
            <description>An array of objects to use as the source of data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to delete the object</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	Returns true if an object was removed, falsy (undefined) if no object matched the id</return-description>
      </method>
      <method name="queryEngine" scope="instance"/>
      <method name="query" scope="instance">
        <examples>
          <example>Given the following store:
	
		var store = new dojo.store.Memory({
			data: [
				{id: 1, name: "one", prime: false },
				{id: 2, name: "two", even: true, prime: true},
				{id: 3, name: "three", prime: true},
				{id: 4, name: "four", even: true, prime: false},
				{id: 5, name: "five", prime: true}
			]
		});
	
	...find all items where "prime" is true:
	
		var results = store.query({ prime: true });
	
	...or find all items where "even" is true:
	
		var results = store.query({ even: true });</example>
        </examples>
        <parameters>
          <parameter name="query" type="Object" usage="required">
            <description>The query to use for retrieving objects from the store.</description>
          </parameter>
          <parameter name="options" type="dojo.store.api.Store.QueryOptions" usage="optional">
            <description>The optional arguments to apply to the resultset.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.api.Store.QueryResults
	The results of the query, extended with iterative methods.</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="options" type="dojo.store.api.Store.PutDirectives" usage="optional">
            <description>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
	property if a specific id is to be used.</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to get the identity from</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to lookup the object</description>
          </parameter>
        </parameters>
        <return-description>Object
	The object in the store that matches the given id.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.store.Memory" usage="required">
            <description>This provides any configuration information that will be mixed into the store.
	This should generally include the data property to provide the starting set of data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="options" type="dojo.store.api.Store.PutDirectives" usage="optional">
            <description>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
	property if a specific id is to be used.</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.store.api">
    <methods>
      <method name="Store" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.store.api.Store">
    <methods>
      <method name="transaction" scope="instance">
        <return-description>dojo.store.api.Store.Transaction
	This represents the new current transaction.</return-description>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to delete the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="queryEngine" scope="instance"/>
      <method name="query" scope="instance">
        <examples>
          <example>Given the following store:
	
	...find all items where "prime" is true:
	
		store.query({ prime: true }).forEach(function(object){
			// handle each object
		});</example>
        </examples>
        <parameters>
          <parameter name="query" type="String|Object|Function" usage="required">
            <description>The query to use for retrieving objects from the store.</description>
          </parameter>
          <parameter name="options" type="dojo.store.api.Store.QueryOptions" usage="required">
            <description>The optional arguments to apply to the resultset.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.api.Store.QueryResults
	The results of the query, extended with iterative methods.</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.api.Store.PutDirectives" usage="optional">
            <description>Additional directives for storing objects.</description>
          </parameter>
        </parameters>
        <return-description>Number|String</return-description>
      </method>
      <method name="getMetadata" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to return metadata for.</description>
          </parameter>
        </parameters>
        <return-description>Object
	An object containing metadata.</return-description>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to get the identity from</description>
          </parameter>
        </parameters>
        <return-description>String|Number</return-description>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parent" type="Object" usage="required">
            <description>The object to find the children of.</description>
          </parameter>
          <parameter name="options" type="dojo.store.api.Store.QueryOptions" usage="optional">
            <description>Additional options to apply to the retrieval of the children.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.api.Store.QueryResults
	A result set of the children of the parent object.</return-description>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to lookup the object</description>
          </parameter>
        </parameters>
        <return-description>Object
	The object in the store that matches the given id.</return-description>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.api.Store.PutDirectives" usage="optional">
            <description>Additional directives for creating objects.</description>
          </parameter>
        </parameters>
        <return-description>Number|String</return-description>
      </method>
      <method name="Transaction" scope="instance"/>
      <method name="QueryResults" scope="instance"/>
    </methods>
    <properties>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.store.api.Store.data"/>
  <class type="dojo.store.api.Store.QueryResults">
    <methods>
      <method name="then" scope="instance">
        <parameters>
          <parameter name="callback" type="This" usage="required">
            <description>is called when the query is completed successfully, and is passed a single argument
	that is an array representing the query results.</description>
          </parameter>
          <parameter name="errorHandler" type="This" usage="required">
            <description>is called if the query failed, and is passed a single argument that is the error
	for the failure.</description>
          </parameter>
        </parameters>
      </method>
      <method name="observe" scope="instance">
        <parameters>
          <parameter name="listener" type="Function" usage="required">
            <description>The listener function is called when objects in the query results are modified
	to affect the query result. The listener function is called with the following
	arguments:
	 listener(object, removedFrom, insertedInto);
	* The object parameter indicates the object that was create, modified, or deleted.
	* The removedFrom parameter indicates the index in the result array where
	the object used to be. If the value is -1, then the object is an addition to
	this result set (due to a new object being created, or changed such that it
	is a part of the result set).
	* The insertedInto parameter indicates the index in the result array where
	the object should be now. If the value is -1, then the object is a removal
	from this result set (due to an object being deleted, or changed such that it
	is not a part of the result set).</description>
          </parameter>
          <parameter name="includeAllUpdates" type="This" usage="required">
            <description>indicates whether or not to include object updates that do not affect
	the inclusion or order of the object in the query results. By default this is false,
	which means that if any object is updated in such a way that it remains
	in the result set and it's position in result sets is not affected, then the listener
	will not be fired.</description>
          </parameter>
        </parameters>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>that is called for each object in the query results</description>
          </parameter>
          <parameter name="thisObject" type="The" usage="required">
            <description>object to use as |this| in the callback.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.api.Store.QueryResults</return-description>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>that is called for each object in the query results</description>
          </parameter>
          <parameter name="thisObject" type="The" usage="required">
            <description>object to use as |this| in the callback.</description>
          </parameter>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>that is called for each object in the query results</description>
          </parameter>
          <parameter name="thisObject" type="The" usage="required">
            <description>object to use as |this| in the callback.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.api.Store.QueryResults</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.store.api.Store.Transaction">
    <methods>
      <method name="commit" scope="instance"/>
      <method name="abort" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="thisObject" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.store.util"/>
  <class type="dojo.string">
    <methods>
      <method name="trim" scope="instance">
        <description>This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	The short yet performant version of this function is dojo.trim(),
	which is part of Dojo base.  Uses String.prototype.trim instead, if available.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>String to be trimmed</description>
          </parameter>
        </parameters>
        <return-description>String
	Returns the trimmed string</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="substitute" scope="instance">
        <examples>
          <example>Substitutes two expressions in a string from an Array or Object
		// returns "File 'foo.html' is not found in directory '/temp'."
		// by providing substitution data in an Array
		dojo.string.substitute(
			"File '${0}' is not found in directory '${1}'.",
			["foo.html","/temp"]
		);
	
		// also returns "File 'foo.html' is not found in directory '/temp'."
		// but provides substitution data in an Object structure.  Dotted
		// notation may be used to traverse the structure.
		dojo.string.substitute(
			"File '${name}' is not found in directory '${info.dir}'.",
			{ name: "foo.html", info: { dir: "/temp" } }
		);</example>
          <example>Use a transform function to modify the values:
		// returns "file 'foo.html' is not found in directory '/temp'."
		dojo.string.substitute(
			"${0} is not found in ${1}.",
			["foo.html","/temp"],
			function(str){
				// try to figure out the type
				var prefix = (str.charAt(0) == "/") ? "directory": "file";
				return prefix + " '" + str + "'";
			}
		);</example>
          <example>Use a formatter
		// returns "thinger -- howdy"
		dojo.string.substitute(
			"${0:postfix}", ["thinger"], null, {
				postfix: function(value, key){
					return value + " -- howdy";
				}
			}
		);</example>
        </examples>
        <parameters>
          <parameter name="template" type="String" usage="required">
            <description>a string with expressions in the form `${key}` to be replaced or
	`${key:format}` which specifies a format function. keys are case-sensitive.</description>
          </parameter>
          <parameter name="map" type="Object|Array" usage="required">
            <description>hash to search for substitutions</description>
          </parameter>
          <parameter name="transform" type="Function" usage="optional">
            <description>a function to process all parameters before substitution takes
	place, e.g. mylib.encodeXML</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>where to look for optional format function; default to the global
	namespace</description>
          </parameter>
        </parameters>
      </method>
      <method name="rep" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>the string to replicate</description>
          </parameter>
          <parameter name="num" type="Integer" usage="required">
            <description>number of times to replicate the string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="pad" scope="instance">
        <examples>
          <example>	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
		dojo.string.pad("Dojo", 10, "+", true);</example>
        </examples>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>the string to pad</description>
          </parameter>
          <parameter name="size" type="Integer" usage="required">
            <description>length to provide padding</description>
          </parameter>
          <parameter name="ch" type="String" usage="optional">
            <description>character to pad, defaults to '0'</description>
          </parameter>
          <parameter name="end" type="Boolean" usage="optional">
            <description>adds padding at the end if true, otherwise pads at start</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.touch">
    <methods>
      <method name="release" scope="instance">
        <parameters>
          <parameter name="node" type="Dom" usage="required">
            <description>Target node to listen to</description>
          </parameter>
          <parameter name="listener" type="Function" usage="required">
            <description>Callback function</description>
          </parameter>
        </parameters>
        <return-description>A handle which will be used to remove the listener by handle.remove()</return-description>
      </method>
      <method name="press" scope="instance">
        <parameters>
          <parameter name="node" type="Dom" usage="required">
            <description>Target node to listen to</description>
          </parameter>
          <parameter name="listener" type="Function" usage="required">
            <description>Callback function</description>
          </parameter>
        </parameters>
        <return-description>A handle which will be used to remove the listener by handle.remove()</return-description>
      </method>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="node" type="Dom" usage="required">
            <description>Target node to listen to</description>
          </parameter>
          <parameter name="listener" type="Function" usage="required">
            <description>Callback function</description>
          </parameter>
        </parameters>
        <return-description>A handle which will be used to remove the listener by handle.remove()</return-description>
      </method>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="node" type="Dom" usage="required">
            <description>Target node to listen to</description>
          </parameter>
          <parameter name="listener" type="Function" usage="required">
            <description>Callback function</description>
          </parameter>
        </parameters>
        <return-description>A handle which will be used to remove the listener by handle.remove()</return-description>
      </method>
    </methods>
  </class>
  <class type="baseWindow.doc">
    <properties>
      <property name="documentElement" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Math"/>
  <class type="baseWindow.doc.documentElement"/>
  <class type="dojo.window">
    <methods>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="nothing to do"/>
        </return-types>
      </method>
      <method name="getBox" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Window"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.NodeList"/>
  <class type="dojox">
    <description>DojoX is a collection of subprojects provided by Dojo committers and subject to
	the generous licensing and policies of the [Dojo CLA](http://dojotoolkit.org/cla)
	Each subproject in DojoX has its own top-level directory and a README file with
	status information and project status and a stability rating (experimental, beta, stable)
	
	Projects may or may not depend on other top-level Dojo projects, like Dojo or Dijit.
	Unlike Dojo and Dijit, code is not subject to i18n and a11y restrictions and may vary
	in quality (experimental code is encouraged in DojoX, but currently prohibited in Dojo
	and Dijit)
	
	DojoX projects may mature to a stable state and stay in DojoX, or on occasion
	after proving themselves may migrate to Dojo Core or Dijit.  Dojo and Dijit projects
	are constrained both by development resources as well as design goals, so DojoX is
	a natural place to provide enhanced behavior or extend Dojo Core or Dijit primitives.
	DojoX can also be an incubator for entirely new projects.</description>
    <methods>
      <method name="flash" scope="instance">
        <description>The goal of dojox.flash is to make it easy to extend Flash's capabilities
	into an Ajax/DHTML environment.
	
	dojox.flash provides an easy object for interacting with the Flash plugin.
	This object provides methods to determine the current version of the Flash
	plugin (dojox.flash.info); write out the necessary markup to
	dynamically insert a Flash object into the page (dojox.flash.Embed; and
	do dynamic installation and upgrading of the current Flash plugin in
	use (dojox.flash.Install). If you want to call methods on the Flash object
	embedded into the page it is your responsibility to use Flash's ExternalInterface
	API and get a reference to the Flash object yourself.
	
	To use dojox.flash, you must first wait until Flash is finished loading
	and initializing before you attempt communication or interaction.
	To know when Flash is finished use dojo.connect:
	
		dojo.connect(dojox.flash, "loaded", myInstance, "myCallback");
	
	Then, while the page is still loading provide the file name:
	
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"));
	
	If no SWF files are specified, then Flash is not initialized.
	
	Your Flash must use Flash's ExternalInterface to expose Flash methods and
	to call JavaScript.
	
	setSwf can take an optional 'visible' attribute to control whether
	the Flash object is visible or not on the page; the default is visible:
	
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"),
	false);
	
	Once finished, you can query Flash version information:
	
		dojox.flash.info.version
	
	Or can communicate with Flash methods that were exposed:
	
		var f = dojox.flash.get();
		var results = f.sayHello("Some Message");
	
	Your Flash files should use DojoExternalInterface.as to register methods;
	this file wraps Flash's normal ExternalInterface but correct various
	serialization bugs that ExternalInterface has.
	
	Note that dojox.flash is not meant to be a generic Flash embedding
	mechanism; it is as generic as necessary to make Dojo Storage's
	Flash Storage Provider as clean and modular as possible. If you want
	a generic Flash embed mechanism see [SWFObject](http://blog.deconcept.com/swfobject/).
	
	Notes:
	Note that dojox.flash can currently only work with one Flash object
	on the page; it does not yet support multiple Flash objects on
	the same page.
	
	Your code can detect whether the Flash player is installing or having
	its version revved in two ways. First, if dojox.flash detects that
	Flash installation needs to occur, it sets dojox.flash.info.installing
	to true. Second, you can detect if installation is necessary with the
	following callback:
	
		dojo.connect(dojox.flash, "installing", myInstance, "myCallback");
	
	You can use this callback to delay further actions that might need Flash;
	when installation is finished the full page will be refreshed and the
	user will be placed back on your page with Flash installed.
	
	-------------------
	Todo/Known Issues
	-------------------
	
	* On Internet Explorer, after doing a basic install, the page is
	not refreshed or does not detect that Flash is now available. The way
	to fix this is to create a custom small Flash file that is pointed to
	during installation; when it is finished loading, it does a callback
	that says that Flash installation is complete on IE, and we can proceed
	to initialize the dojox.flash subsystem.
	* Things aren't super tested for sending complex objects to Flash
	methods, since Dojo Storage only needs strings
	
	Author- Brad Neuberg, http://codinginparadise.org</description>
      </method>
    </methods>
    <properties>
      <property name="xmpp" scope="instance" type="Object">
        <description>TODOC</description>
      </property>
      <property name="xml" scope="instance" type="Object">
        <description>XML utilities.  Currently only includes a DomParser, which returns a psuedo-XML document in JSON-like form.</description>
      </property>
      <property name="wire" scope="instance" type="Object">
        <description>Declarative data binding and action tags for simplified MVC</description>
      </property>
      <property name="widget" scope="instance" type="Object">
        <description>A collection of un-categorized widgets, or code not requiring its own package.</description>
      </property>
      <property name="validate" scope="instance" type="Object">
        <description>Additional validation routines for Strings, Numbers, credit cards, and other esoteric needs.</description>
      </property>
      <property name="uuid" scope="instance" type="Object">
        <description>Universally Unique Identifier (UUID) implementations, including an implementation of UUID 2</description>
      </property>
      <property name="timing" scope="instance" type="Object">
        <description>A set of objects to perform advanced time-based tasks, including a basic Timer.</description>
      </property>
      <property name="testing" scope="instance" type="Object">
        <description>TODOC</description>
      </property>
      <property name="string" scope="instance" type="Object">
        <description>A collection of various objects for advanced string manipulation, including a Builder and a tokenizer.</description>
      </property>
      <property name="store" scope="instance" type="Object"/>
      <property name="storage" scope="instance" type="Object">
        <description>Objects for mass storage within the browser.  For when cookies just aren't enough.</description>
      </property>
      <property name="sql" scope="instance" type="Object">
        <description>If true, then we print out any SQL that is executed
	to the debug window</description>
      </property>
      <property name="socket" scope="instance" type="Object"/>
      <property name="sketch" scope="instance" type="Object">
        <description>TODOC</description>
      </property>
      <property name="secure" scope="instance" type="Object">
        <description>TODOC</description>
      </property>
      <property name="rpc" scope="instance" type="Object">
        <description>TODOC</description>
      </property>
      <property name="robot" scope="instance" type="Object">
        <description>TODOC</description>
      </property>
      <property name="rails" scope="instance" type="Object"/>
      <property name="mvc" scope="instance" type="Object"/>
      <property name="mobile" scope="instance" type="Object"/>
      <property name="mdnd" scope="instance" type="Object"/>
      <property name="math" scope="instance" type="Object">
        <description>A collection of various advanced math functions.</description>
      </property>
      <property name="layout" scope="instance" type="Object">
        <description>A collection of layout related Widgets</description>
      </property>
      <property name="lang" scope="instance" type="Object">
        <description>Language specific extensions</description>
      </property>
      <property name="jsonPath" scope="instance" type="Object">
        <description>A query system for JavaScript objects</description>
      </property>
      <property name="json" scope="instance" type="Object"/>
      <property name="io" scope="instance" type="Object">
        <description>Extensions to the Core dojo.io transports</description>
      </property>
      <property name="image" scope="instance" type="Object">
        <description>A collection of image related widgets</description>
      </property>
      <property name="html" scope="instance" type="Object">
        <description>TODOC</description>
      </property>
      <property name="highlight" scope="instance" type="Object">
        <description>A client-side syntax highlighting engine.</description>
      </property>
      <property name="help" scope="instance" type="Object">
        <description>TODOC</description>
      </property>
      <property name="grid" scope="instance" type="Object">
        <description>An advanced Grid widget with virtual scrolling, cell editing, and much more</description>
      </property>
      <property name="gfx3d" scope="instance" type="Object">
        <description>A 3d API for dojox.gfx</description>
      </property>
      <property name="gfx" scope="instance" type="Object">
        <description>Cross-browser vector graphics API</description>
      </property>
      <property name="gesture" scope="instance" type="Object"/>
      <property name="geo" scope="instance" type="Object"/>
      <property name="gauges" scope="instance" type="Object"/>
      <property name="gantt" scope="instance" type="Object"/>
      <property name="fx" scope="instance" type="Object">
        <description>Extension animations to the core dojo FX project</description>
      </property>
      <property name="form" scope="instance" type="Object">
        <description>Form-related widgets</description>
      </property>
      <property name="encoding" scope="instance" type="Object">
        <description>Various encoding algorithms, including crypto and digests.</description>
      </property>
      <property name="embed" scope="instance" type="Object">
        <description>Base code for embedding for external objects like Flash, Quicktime</description>
      </property>
      <property name="editor" scope="instance" type="Object">
        <description>Extensions for dijit.Editor</description>
      </property>
      <property name="dtl" scope="instance" type="Object">
        <description>Django Templating Language implementation</description>
      </property>
      <property name="drawing" scope="instance" type="Object">
        <description>A vector drawing program</description>
      </property>
      <property name="dnd" scope="instance" type="Object"/>
      <property name="date" scope="instance" type="Object">
        <description>Additional date manipulation functions</description>
      </property>
      <property name="data" scope="instance" type="Object">
        <description>Additional dojo.data data stores and demos</description>
      </property>
      <property name="css3" scope="instance" type="Object"/>
      <property name="cometd" scope="instance" type="Object">
        <description>A cometd client written in Dojo</description>
      </property>
      <property name="color" scope="instance" type="Object">
        <description>Advanced color methods, including HSV, HSL, and CMYK conversion, a color generator and advanced colorspace calculations.</description>
      </property>
      <property name="collections" scope="instance" type="Object">
        <description>A set of lists and hashes for easy use within your applications.</description>
      </property>
      <property name="charting" scope="instance" type="Object">
        <description>Vector graphic, data-driven graphs and charts</description>
      </property>
      <property name="calc" scope="instance" type="Object"/>
      <property name="av" scope="instance" type="Object">
        <description>Provides Audio/Video capabilities</description>
      </property>
      <property name="atom" scope="instance" type="Object">
        <description>Implements the Atom Syndication Format and Atom Publishing Protocol</description>
      </property>
      <property name="app" scope="instance" type="Object"/>
      <property name="analytics" scope="instance" type="Object">
        <description>Website analytics and client monitoring system</description>
      </property>
      <property name="NodeList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="djConfig"/>
  <class type="dojox.analytics">
    <methods>
      <method name="Urchin" scope="instance">
        <description>A small class object will allows for lazy-loading the Google Analytics API
	at any point during a page lifecycle. Most commonly, Google-Analytics is loaded
	via a synchronous script tag in the body, which causes `dojo.addOnLoad` to
	stall until the external API has been completely loaded. The Urchin helper
	will load the API on the fly, and provide a convenient API to use, wrapping
	Analytics for Ajaxy or single page applications.
	
	The class can be instantiated two ways: Programatically, by passing an
	`acct:` parameter, or via Markup / dojoType and defining a djConfig
	parameter `urchin:`
	
	IMPORTANT:
	This module will not work simultaneously with the core dojox.analytics
	package. If you need the ability to run Google Analytics AND your own local
	analytics system, you MUST include dojox.analytics._base BEFORE dojox.analytics.Urchin</description>
        <examples>
          <example>	// create the tracker programatically:
		var tracker = new dojox.analytics.Urchin({ acct:"UA-123456-7" });</example>
          <example>	// define the urchin djConfig option:
		var djConfig = { urchin: "UA-123456-7" };
	
		// and in markup:
		&lt;div dojoType="dojox.analytics.Urchin"&gt;&lt;/div&gt;
		// or code:
		new dojox.analytics.Urchin();</example>
          <example>	// create and define all analytics with one tag.
		&lt;div dojoType="dojox.analytics.Urchin" acct="UA-12345-67"&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="plugins" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.Urchin">
    <description>A small class object will allows for lazy-loading the Google Analytics API
	at any point during a page lifecycle. Most commonly, Google-Analytics is loaded
	via a synchronous script tag in the body, which causes `dojo.addOnLoad` to
	stall until the external API has been completely loaded. The Urchin helper
	will load the API on the fly, and provide a convenient API to use, wrapping
	Analytics for Ajaxy or single page applications.
	
	The class can be instantiated two ways: Programatically, by passing an
	`acct:` parameter, or via Markup / dojoType and defining a djConfig
	parameter `urchin:`
	
	IMPORTANT:
	This module will not work simultaneously with the core dojox.analytics
	package. If you need the ability to run Google Analytics AND your own local
	analytics system, you MUST include dojox.analytics._base BEFORE dojox.analytics.Urchin</description>
    <methods>
      <method name="trackPageView" scope="instance">
        <examples>
          <example>Track clicks from a container of anchors and populate a `ContentPane`
		// 'tracker' is our `Urchin` instance, pane is the `ContentPane` ref.
		dojo.connect(container, "onclick", function(e){
			var ref = dojo.attr(e.target, "href");
			tracker.trackPageView(ref);
			pane.attr("href", ref);
		});</example>
        </examples>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <description>String A location to tell the tracker to track, eg: &amp;quot;/my-ajaxy-endpoint&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_gotGA" scope="instance"/>
      <method name="GAonLoad" scope="instance">
        <description>This function is executed when the tracker variable is
	complete and initialized. The initial trackPageView (with
	no arguments) is called here as well, so remeber to call
	manually if overloading this method.</description>
        <examples>
          <example>Create an Urchin tracker that will track a specific page on init
	after page load (or parsing, if parseOnLoad is true)
		dojo.addOnLoad(function(){
			new dojox.ananlytics.Urchin({
				acct:"UA-12345-67",
				GAonLoad: function(){
					this.trackPageView("/custom-page");
				}
			});
		});</example>
        </examples>
      </method>
    </methods>
  </class>
  <class type="dojox.analytics.plugins"/>
  <class type="dependencies"/>
  <class type="dojox.app">
    <methods>
      <method name="view" scope="instance"/>
      <method name="scene" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="animation" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="module" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.app.animation">
    <methods>
      <method name="start" scope="instance"/>
      <method name="slide" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="play" scope="instance"/>
      <method name="onAfterEnd" scope="instance"/>
      <method name="initState" scope="instance"/>
      <method name="groupedPlay" scope="instance">
        <parameters>
          <parameter name="args" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="flip" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fade" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="chainedPlay" scope="instance">
        <parameters>
          <parameter name="args" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="beforeStart" scope="instance"/>
      <method name="beforeClear" scope="instance"/>
      <method name="_removeState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onAfterEnd" scope="instance"/>
      <method name="_beforeStart" scope="instance"/>
      <method name="_beforeClear" scope="instance"/>
      <method name="_applyState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.app.animation.node">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.app.animation.node.style"/>
  <class type="dojox.app.module"/>
  <class type="dojox.app.scene" superclass="dijit._WidgetBase">
    <methods>
      <method name="transition" scope="instance">
        <parameters>
          <parameter name="transitionTo" type="Object" usage="required"/>
          <parameter name="opts" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="splitChildRef" scope="instance">
        <parameters>
          <parameter name="childId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadChild" scope="instance">
        <parameters>
          <parameter name="childId" type="Object" usage="required"/>
          <parameter name="subIds" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layoutChildren" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required">
            <description>parent node</description>
          </parameter>
          <parameter name="dim" type="Object" usage="required">
            <description>{l, t, w, h} object specifying dimensions of container into which to place children</description>
          </parameter>
          <parameter name="children" type="Array&lt;Widget&gt;" usage="required">
            <description>an array of Widgets or at least objects containing:
	* domNode: pointer to DOM node to position
	* region or layoutAlign: position to place DOM node
	* resize(): (optional) method to set size of node
	* id: (optional) Id of widgets, referenced from resize object, below.</description>
          </parameter>
          <parameter name="changedRegionId" type="String" usage="optional">
            <description>If specified, the slider for the region with the specified id has been dragged, and thus
	the region's height or width should be adjusted according to changedRegionSize</description>
          </parameter>
          <parameter name="changedRegionSize" type="Number" usage="optional">
            <description>See changedRegionId.</description>
          </parameter>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="getParent" scope="instance"/>
      <method name="getChildren" scope="instance"/>
      <method name="deactive" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="activate" scope="instance"/>
      <method name="_setSelectedChildAttr" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="opts" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.app.scene.domNode.style"/>
  <class type="dojox.app.view" superclass="Widget">
    <methods>
      <method name="toString" scope="instance"/>
      <method name="getParent" scope="instance"/>
      <method name="deactivate" scope="instance"/>
      <method name="activate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="TemplatedMixin.prototype" scope="instance"/>
      <mixin type="Container.prototype" scope="instance"/>
      <mixin type="Contained.prototype" scope="instance"/>
      <mixin type="WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="Widget" scope="instance"/>
      <mixin type="TemplatedMixin" scope="instance"/>
      <mixin type="Container" scope="instance"/>
      <mixin type="Contained" scope="instance"/>
      <mixin type="WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.io">
    <methods>
      <method name="Connection" scope="instance">
        <description>This object implements a transport layer for working with ATOM feeds and ATOM publishing protocols.
	Specifically, it provides a mechanism by which feeds can be fetched and entries can be fetched, created
	deleted, and modified.  It also provides access to the introspection data.</description>
        <parameters>
          <parameter name="sync" type="Boolean" usage="required"/>
          <parameter name="preventCache" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="model" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.Connection">
    <description>This object implements a transport layer for working with ATOM feeds and ATOM publishing protocols.
	Specifically, it provides a mechanism by which feeds can be fetched and entries can be fetched, created
	deleted, and modified.  It also provides access to the introspection data.</description>
    <methods>
      <method name="updateEntry" scope="instance">
        <description>This function takes a specific dojox.atom.io.model.Entry object and pushes the
	changes back to the provider of the Entry.
	The entry MUST have a link tag with rel="edit" for this to work.</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required">
            <description>The dojox.atom.io.model.Entry object to update.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the results from the entry update.
	The callback should accept two parameters:  The first is an Entry object, and the second is the URL of that Entry
	Either can be null, depending on the value of retrieveUpdated.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="retrieveUpdated" type="boolean" usage="required">
            <description>A boolean flag denoting if the entry that was updated should then be
	retrieved and returned to the caller via the callback.</description>
          </parameter>
          <parameter name="xmethod" type="boolean" usage="required">
            <description>Whether to use POST for PUT/DELETE items and send the X-Method-Override header.</description>
          </parameter>
          <parameter name="scope" type="Object" usage="required">
            <description>The scope to use for all callbacks.</description>
          </parameter>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="getService" scope="instance">
        <description>This function takes the URL for an ATOM item and feed and returns
	the introspection document.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL of the ATOM document to obtain the introspection document of.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the introspection document when it has been retrieved.
	The callback should accept two parameters:  The introspection document object and the original complete DOM object.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="getFeed" scope="instance">
        <description>This function takes the URL for a specific ATOM feed and returns
	the data from that feed to the caller through the use of a callback
	handler.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL of the ATOM feed to fetch.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the feed when it has been retrieved.
	The callback should accept two parameters:  The feed object and the original complete DOM object.</description>
          </parameter>
          <parameter name="errorCallback" type="Function" usage="required"/>
          <parameter name="scope" type="Object" usage="required">
            <description>The scope to use for all callbacks.</description>
          </parameter>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="getEntry" scope="instance">
        <description>This function takes the URL for an ATOM entry and returns the constructed dojox.atom.io.model.Entry object through
	the specified callback.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL of the ATOM Entry document to parse.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the Entry object obtained.
	The callback should accept two parameters, the dojox.atom.io.model.Entry object and the original dom.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="deleteEntry" scope="instance">
        <description>This function takes a specific dojox.atom.io.model.Entry object and calls for a delete on the
	service housing the ATOM Entry database.
	The entry MUST have a link tag with rel="edit" for this to work.</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required">
            <description>The dojox.atom.io.model.Entry object to delete.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the results from the entry delete.
	The callback is called only if the delete is successful.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="xmethod" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="sync" type="Boolean" usage="required"/>
          <parameter name="preventCache" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="addEntry" scope="instance">
        <description>This function takes a specific dojox.atom.io.model.Entry object and pushes the
	changes back to the provider of the Entry.</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required">
            <description>The dojox.atom.io.model.Entry object to publish.</description>
          </parameter>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the results from the entry publish.
	The callback should accept two parameters:   The first is an dojox.atom.io.model.Entry object, and the second is the location of the entry
	Either can be null, depending on the value of retrieveUpdated.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="retrieveEntry" type="boolean" usage="required">
            <description>A boolean flag denoting if the entry that was created should then be
	retrieved and returned to the caller via the callback.</description>
          </parameter>
          <parameter name="scope" type="Object" usage="required">
            <description>The scope to use for all callbacks.</description>
          </parameter>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="_getXmlDoc" scope="instance">
        <description>This internal function takes the URL for an XML document and and passes the
	parsed contents to a specified callback.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL of the XML document to retrieve</description>
          </parameter>
          <parameter name="nodeName" type="Object" usage="required"/>
          <parameter name="newNode" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the retrieved XML data.
	The callback should accept one parameter, the DOM of the parsed XML document.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.atom">
    <properties>
      <property name="widget" scope="instance" type="Object"/>
      <property name="io" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model">
    <methods>
      <method name="Workspace" scope="instance">
        <description>Class container for 'Workspace' types.</description>
        <parameters>
          <parameter name="title" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Service" scope="instance">
        <description>Class container for 'Feed' types.
	
	
	builds a Service document.  each element of this, except for the namespace, is the href of
	a service that the server supports.  Some of the common services are:
	"create-entry" , "user-prefs" , "search-entries" , "edit-template" , "categories"</description>
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Person" scope="instance">
        <description>Class container for 'person' types, such as Author, controbutors, and so on.</description>
        <parameters>
          <parameter name="personType" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="email" type="Object" usage="required"/>
          <parameter name="uri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Node" scope="instance">
        <parameters>
          <parameter name="name_space" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="attributes" type="Object" usage="required"/>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="shortNs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Link" scope="instance">
        <description>Class container for 'link' types.</description>
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="rel" type="Object" usage="required"/>
          <parameter name="hrefLang" type="Object" usage="required"/>
          <parameter name="title" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Generator" scope="instance">
        <description>Class container for 'Generator' types.</description>
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="version" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="Feed" scope="instance">
        <description>Class container for 'Feed' types.</description>
      </method>
      <method name="Entry" scope="instance">
        <description>Class container for 'Entry' types.</description>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="Content" scope="instance">
        <description>Class container for 'Content' types. Such as summary, content, username, and so on types of data.</description>
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="xmlLang" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Collection" scope="instance">
        <description>Class container for 'Collection' types.</description>
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="title" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Category" scope="instance">
        <description>Class container for 'Category' types.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="AtomItem" scope="instance">
        <description>Class container for generic Atom items.
	
	
	child objects can override this if they want to be called after a Dom build</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.atom.io.model.Node">
    <methods>
      <method name="toString" scope="instance"/>
      <method name="getAttribute" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="name_space" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="attributes" type="Object" usage="required"/>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="shortNs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addContent" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addAttribute" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveAttributes" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.atom.io.model.AtomItem" superclass="model.Node">
    <description>Class container for generic Atom items.
	
	
	child objects can override this if they want to be called after a Dom build</description>
    <methods>
      <method name="setTitle" scope="instance">
        <description>Function to set the title of the item.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The title to set.</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>The type of title format, text, xml, xhtml, etc.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeLink" scope="instance">
        <description>Function to remove a link from the list of links.</description>
        <parameters>
          <parameter name="href" type="String" usage="required">
            <description>The href.</description>
          </parameter>
          <parameter name="rel" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeExtensions" scope="instance">
        <description>Function to remove extensions that match a namespace and name.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required">
            <description>The namespace of the extension.</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The name of the extension</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeCategories" scope="instance">
        <description>Function to remove all categories that match a particular scheme and term.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required">
            <description>The scheme to filter on.</description>
          </parameter>
          <parameter name="term" type="String" usage="required">
            <description>The term to filter on.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeBasicLinks" scope="instance">
        <description>Function to remove all basic link from the list of links.</description>
      </method>
      <method name="getExtensions" scope="instance">
        <description>Function to get extensions that match a namespace and name.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required">
            <description>The namespace of the extension.</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The name of the extension</description>
          </parameter>
        </parameters>
      </method>
      <method name="getCategories" scope="instance">
        <description>Function to get all categories that match a particular scheme.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required">
            <description>The scheme to filter on.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addNamespace" scope="instance">
        <parameters>
          <parameter name="fullName" type="Object" usage="required"/>
          <parameter name="shortName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addLink" scope="instance">
        <description>Function to add in a link to the list of links.</description>
        <parameters>
          <parameter name="href" type="String" usage="required">
            <description>The href.</description>
          </parameter>
          <parameter name="rel" type="String" usage="required"/>
          <parameter name="hrefLang" type="String" usage="required"/>
          <parameter name="title" type="String" usage="required">
            <description>A title to associate with the link.</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>The type of link is is.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addExtension" scope="instance">
        <description>Function to add in an extension namespace into the item.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required">
            <description>The namespace of the extension.</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The name of the extension</description>
          </parameter>
          <parameter name="attributes" type="Array" usage="required">
            <description>The attributes associated with the extension.</description>
          </parameter>
          <parameter name="content" type="String" usage="required">
            <description>The content of the extension.</description>
          </parameter>
          <parameter name="shortNS" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="addContributor" scope="instance">
        <description>Function to add in an author to the list of authors.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The author's name.</description>
          </parameter>
          <parameter name="email" type="String" usage="required">
            <description>The author's e-mail address.</description>
          </parameter>
          <parameter name="uri" type="String" usage="required">
            <description>A URI associated with the author.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addCategory" scope="instance">
        <description>Function to add in a category to the list of categories.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="addAuthor" scope="instance">
        <description>Function to add in an author to the list of authors.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The author's name.</description>
          </parameter>
          <parameter name="email" type="String" usage="required">
            <description>The author's e-mail address.</description>
          </parameter>
          <parameter name="uri" type="String" usage="required">
            <description>A URI associated with the author.</description>
          </parameter>
        </parameters>
      </method>
      <method name="accept" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="_getAttributeNames" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.AtomItem.title"/>
  <class type="dojox.atom.io.model.Category" superclass="model.Node">
    <description>Class container for 'Category' types.</description>
    <methods>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the category tag, which is an XML structure.</description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Category data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="_getAttributeNames" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="model.Node" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.io.model.Content" superclass="model.Node">
    <description>Class container for 'Content' types. Such as summary, content, username, and so on types of data.</description>
    <methods>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the content tag, which is an XML structure.</description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="xmlLang" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Content data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.
	Handle checking for XML content as the content type</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="_getAttributeNames" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="model.Node" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.io.model.Link" superclass="model.Node">
    <description>Class container for 'link' types.</description>
    <methods>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the link tag, which is an XML structure.</description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="rel" type="Object" usage="required"/>
          <parameter name="hrefLang" type="Object" usage="required"/>
          <parameter name="title" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the link data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>DOM node to process for link data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="_getAttributeNames" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="model.Node" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.io.model.Person" superclass="model.Node">
    <description>Class container for 'person' types, such as Author, controbutors, and so on.</description>
    <methods>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the Person tag, which is an XML structure.</description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="personType" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="email" type="Object" usage="required"/>
          <parameter name="uri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the person data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>DOM node to process for person data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="accept" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="_getAttributeNames" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="_accepts" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Person._accepts"/>
  <class type="dojox.atom.io.model.Generator" superclass="model.Node">
    <description>Class container for 'Generator' types.</description>
    <methods>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the Generator tag, which is an XML structure.</description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="version" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the generator data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>DOM node to process for link data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="model.Node" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.io.model.Entry" superclass="model.AtomItem">
    <description>Class container for 'Entry' types.</description>
    <methods>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the entry tag, which is an XML structure.</description>
        <parameters>
          <parameter name="amPrimary" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="setEditHref" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getEditHref" scope="instance">
        <description>Function to get the href that allows editing of this feed entry.</description>
        <return-description>The href that specifies edit capability.</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="_accepts" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Entry._accepts"/>
  <class type="dojox.atom.io.model.Feed" superclass="model.AtomItem">
    <description>Class container for 'Feed' types.</description>
    <methods>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the feed tag, which is an XML structure.</description>
      </method>
      <method name="setEntries" scope="instance">
        <description>Function to get an entry by its id.</description>
        <parameters>
          <parameter name="arrayOfEntry" type="array" usage="required">
            <description>An array of entry objects to add to the feed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeEntry" scope="instance">
        <description>Function to remove an entry from the list of links.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The entry.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSelfHref" scope="instance">
        <description>Function to get the href that refers to this feed.</description>
        <return-description>The href that refers to this feed or null if none.</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getFirstEntry" scope="instance">
        <description>Function to get the first entry of the feed.</description>
        <return-description>The first entry in the feed.</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getEntry" scope="instance">
        <description>Function to get an entry by its id.</description>
        <parameters>
          <parameter name="entryId" type="String" usage="required"/>
        </parameters>
        <return-description>The entry desired, or null if none.</return-description>
      </method>
      <method name="createEntry" scope="instance">
        <description>Function to Create a new entry object in the feed.</description>
        <return-description>An empty entry object in the feed.</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="addEntry" scope="instance">
        <description>Function to add an entry to this feed.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The entry object to add.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="_accepts" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Feed._accepts"/>
  <class type="dojox.atom.io.model.Service" superclass="model.AtomItem">
    <description>Class container for 'Feed' types.
	
	
	builds a Service document.  each element of this, except for the namespace, is the href of
	a service that the server supports.  Some of the common services are:
	"create-entry" , "user-prefs" , "search-entries" , "edit-template" , "categories"</description>
    <methods>
      <method name="getCollection" scope="instance">
        <description>Function to collections that match a specific url.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>e URL to match collections against.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Service data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="model.AtomItem" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.io.model.Workspace" superclass="model.AtomItem">
    <description>Class container for 'Workspace' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="title" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Workspace data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="model.AtomItem" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.io.model.Collection" superclass="model.AtomItem">
    <description>Class container for 'Collection' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="title" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Collection data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="model.AtomItem" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.widget">
    <methods>
      <method name="PeopleEditor" scope="instance">
        <description>An editor for dojox.atom.io.model.Person objects.  Displays multiple rows for the respective arrays
	of people.  Can add/remove rows on the fly.</description>
      </method>
      <method name="FeedViewerGrouping" scope="instance">
        <description>Grouping of feed entries.</description>
      </method>
      <method name="FeedViewerEntry" scope="instance">
        <description>Widget for handling the display of an entry and specific events associated with it.</description>
      </method>
      <method name="FeedViewer" scope="instance">
        <description>An ATOM feed viewer that allows for viewing a feed, deleting entries, and editing entries.
	
	
	The body of the feed viewer table so we can access it and populate it.  Will be assigned via template.
	
	
	The overal table container which contains the feed viewer table.  Will be assigned via template.
	
	
	The topic to broadcast when any entry is clicked so that a listener can pick up it and display it.
	
	
	The URL to which to connect to initially on creation.</description>
      </method>
      <method name="FeedEntryViewer" scope="instance">
        <description>An ATOM feed entry editor for publishing updated ATOM entries, or viewing non-editable entries.
	
	
	The topic to listen on for entries to edit.</description>
      </method>
      <method name="FeedEntryEditor" scope="instance">
        <description>An ATOM feed entry editor that allows viewing of the individual attributes of an entry.
	
	
	Flag denoting if the current entry is editable or not.</description>
      </method>
      <method name="EntryHeader" scope="instance">
        <description>Widget representing a header in a FeedEntryViewer/Editor</description>
      </method>
      <method name="AtomEntryCategoryFilter" scope="instance">
        <description>A filter to be applied to the list of entries.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor" superclass="FeedEntryViewer">
    <description>An ATOM feed entry editor that allows viewing of the individual attributes of an entry.
	
	
	Flag denoting if the current entry is editable or not.</description>
    <methods>
      <method name="setUpdated" scope="instance">
        <description>Function to set the contents of the updated node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the udpated data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setTitle" scope="instance">
        <description>Function to set the contents of the title node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="titleAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the title data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSummary" scope="instance">
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the summary data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setId" scope="instance">
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="idAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the ID data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setEntry" scope="instance">
        <description>Function to set the current entry that is being edited.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>Instance of dojox.atom.io.model.Entry to display for reading/editing.</description>
          </parameter>
          <parameter name="feed" type="object" usage="required"/>
          <parameter name="leaveMenuState" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setContributors" scope="instance">
        <description>Function to set the contents of the contributor node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the contributor data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContent" scope="instance">
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	
	summaryAnchorNode:
	The DOM node to attach the content data to.</description>
        <parameters>
          <parameter name="contentAnchorNode" type="DOM" usage="required">
            <description>node</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAuthors" scope="instance">
        <description>Function to set the contents of the author node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="authorsAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the author data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="saveEdits" scope="instance">
        <description>Saves edits submitted when the 'save' button is pressed.  Distinguishes between new and existing
	entries and saves appropriately.  Fetches the values of the editors, and, if existing, compares them to
	the existing values and submits the updates, otherwise creates a new entry and posts it as a new entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="clearEditors" scope="instance"/>
      <method name="clear" scope="instance">
        <description>Clears the editor, destorys all editors, leaving the editor completely clear</description>
      </method>
      <method name="cancelEdits" scope="instance">
        <description>Cancels edits and reverts the editor to its previous state (display mode)</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_toggleNew" scope="instance">
        <description>Function to put the editor into a state to create a new entry.</description>
      </method>
      <method name="_toggleEdit" scope="instance">
        <description>Internal function for toggling/enabling the display of edit mode</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_switchEditor" scope="instance">
        <description>Function to switch between a rich text editor and a textarea widget.  Used for title, summary,
	And content when switching between text and html/xhtml content.</description>
        <parameters>
          <parameter name="event" type="object" usage="required">
            <description>The event generated by the change in the select box on the page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isEditable" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object to examine</description>
          </parameter>
        </parameters>
        <return-description>Boolean denoting if the entry seems editable or not..</return-description>
      </method>
      <method name="_handleSave" scope="instance">
        <description>Function for handling the save of an entry, cleaning up the display after the edit is completed.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>dojox.atom.io.model.Entry object
	The entry that was saved.
	Location: String
	A URL to be used, not used here, but part of the call back from the AtomIO</description>
          </parameter>
          <parameter name="location" type="string" usage="required"/>
        </parameters>
        <return-description>Nothing.
	Close the editor and revert out.</return-description>
      </method>
      <method name="_handleEvent" scope="instance">
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required">
            <description>The topic message containing the entry that was selected for view.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_enforceXhtml" scope="instance">
        <description>Function for cleaning up/enforcing the XHTML standard in HTML returned from the editor2 widget.</description>
        <parameters>
          <parameter name="html" type="string" usage="required">
            <description>HTML string to be enforced as xhtml.</description>
          </parameter>
        </parameters>
        <return-description>string of cleaned up HTML.</return-description>
      </method>
      <method name="_displaySections" scope="instance">
        <description>Function to display the appropriate sections based on validity.</description>
      </method>
      <method name="_createPeopleEditor" scope="instance">
        <description>Creates a People Editor widget, sets its value, and returns it.</description>
        <parameters>
          <parameter name="anchorNode" type="DOM" usage="required">
            <description>The node to attach the editor to.</description>
          </parameter>
          <parameter name="node" type="DOM" usage="required">
            <description>An object containing the value to be put into the editor. Typically, this is an
	dojox.atom.io.model.Person object.</description>
          </parameter>
        </parameters>
        <return-description>A new People Editor object.</return-description>
      </method>
      <method name="_createEditor" scope="instance">
        <description>Function to create an appropriate text editor widget based on the given parameters.</description>
        <parameters>
          <parameter name="anchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the editor widget to.</description>
          </parameter>
          <parameter name="node" type="DOM" usage="required">
            <description>An object containing the value to be put into the editor.  This ranges from an anonymous object
	with a value parameter to a dojox.atom.io.model.Content object.</description>
          </parameter>
          <parameter name="multiline" type="boolean" usage="required">
            <description>A boolean indicating whether the content should be multiline (such as a textarea) instead of a
	single line (such as a textbox).</description>
          </parameter>
          <parameter name="rte" type="object" usage="required">
            <description>A boolean indicating whether the content should be a rich text editor widget.</description>
          </parameter>
        </parameters>
        <return-description>Either a widget (for textarea or textbox widgets) or an anonymous object to be used to create a
	rich text area widget.</return-description>
      </method>
      <method name="_closeTag" scope="instance">
        <description>Function for closing tags in a text of HTML/XHTML</description>
        <parameters>
          <parameter name="xhtml" type="string" usage="required">
            <description>String XHTML string which needs the closing tag.</description>
          </parameter>
          <parameter name="tag" type="string" usage="required">
            <description>The tag to close.</description>
          </parameter>
        </parameters>
        <return-description>string of cleaned up HTML.
	
	NOTE:  Probably should redo this function in a more efficient way.  This could get expensive.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="FeedEntryViewer" scope="instance"/>
    </mixins>
    <properties>
      <property name="save" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelUpdated" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelTitle" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelSummary" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelId" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelContributors" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelContent" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelAuthors" scope="instance" type="Object"/>
      <property name="entryTitleSelect" scope="instance" type="Object"/>
      <property name="entrySummarySelect" scope="instance" type="Object"/>
      <property name="entryContentSelect" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
      <property name="doNew" scope="instance" type="Object"/>
      <property name="displayOptions" scope="instance" type="Object"/>
      <property name="close" scope="instance" type="Object"/>
      <property name="cancel" scope="instance" type="Object"/>
      <property name="_editors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.displayOptions"/>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelTitle"/>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelAuthors"/>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelContributors"/>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelId"/>
  <class type="dojox.atom.widget.FeedEntryEditor.close"/>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelUpdated"/>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelSummary"/>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelContent"/>
  <class type="dojox.atom.widget.FeedEntryEditor.doNew"/>
  <class type="dojox.atom.widget.FeedEntryEditor.edit"/>
  <class type="dojox.atom.widget.FeedEntryEditor.save"/>
  <class type="dojox.atom.widget.FeedEntryEditor.cancel"/>
  <class type="dojox.atom.widget.FeedEntryEditor.entryTitleSelect"/>
  <class type="dojox.atom.widget.FeedEntryEditor._editors"/>
  <class type="dojox.atom.widget.FeedEntryEditor.entrySummarySelect"/>
  <class type="dojox.atom.widget.FeedEntryEditor.entryContentSelect"/>
  <class type="dojox.atom.widget.PeopleEditor" superclass="_Widget">
    <description>An editor for dojox.atom.io.model.Person objects.  Displays multiple rows for the respective arrays
	of people.  Can add/remove rows on the fly.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="getValues" scope="instance">
        <description>Gets the values of this editor in an array, with each Person as an object within the array.</description>
        <return-description>An array of anonymous objects representing dojox.atom.io.model.Persons.</return-description>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_removeEditor" scope="instance">
        <description>Removes a Person from our list of editors by removing the block of editors that
	make up that Person.</description>
        <parameters>
          <parameter name="event" type="object" usage="required">
            <description>The event generated when the remove button is pressed on the page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createEditors" scope="instance">
        <description>creates editor boxes (textbox widgets) for the individual values of a Person.</description>
        <parameters>
          <parameter name="name" type="string" usage="required">
            <description>The name of this Person.</description>
          </parameter>
          <parameter name="email" type="string" usage="required">
            <description>The email of this Person.</description>
          </parameter>
          <parameter name="uri" type="string" usage="required">
            <description>The Person's URI.</description>
          </parameter>
          <parameter name="index" type="int" usage="required">
            <description>The row index to use for this Person.</description>
          </parameter>
          <parameter name="widgetName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_createEditor" scope="instance">
        <description>Creates an individual editor widget (textbox) for a value.</description>
        <parameters>
          <parameter name="value" type="string" usage="required">
            <description>The initial value of the textbox</description>
          </parameter>
          <parameter name="id" type="string" usage="required">
            <description>The id the textbox should have.</description>
          </parameter>
          <parameter name="name" type="string" usage="required">
            <description>The text to put in the label element for this textbox.</description>
          </parameter>
          <parameter name="labelNode" type="DOM" usage="required">
            <description>The node to attach the label to.</description>
          </parameter>
          <parameter name="node" type="DOM" usage="required">
            <description>The node to attach the editor rows to.</description>
          </parameter>
        </parameters>
        <return-description>Editor widget.</return-description>
      </method>
      <method name="_add" scope="instance">
        <description>Adds a new block of blank editors to represent a Person.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Templated.prototype" scope="instance"/>
      <mixin type="_Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_Templated" scope="instance"/>
      <mixin type="_Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer" superclass="_Widget">
    <description>An ATOM feed entry editor for publishing updated ATOM entries, or viewing non-editable entries.
	
	
	The topic to listen on for entries to edit.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setUpdatedHeader" scope="instance">
        <description>Function to set the contents of the updated header node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the updated header data to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setUpdated" scope="instance">
        <description>Function to set the contents of the updated node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the udpated data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setTitleHeader" scope="instance">
        <description>Function to set the contents of the title header node in the template to some value.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	
	titleAchorNode:
	The DOM node to attach the title data to.
	editMode:
	Boolean to indicate if the display should be in edit mode or not.</description>
        <parameters>
          <parameter name="titleHeaderNode" type="DOM" usage="required">
            <description>node</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setTitle" scope="instance">
        <description>Function to set the contents of the title node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	
	titleAchorNode:
	The DOM node to attach the title data to.</description>
        <parameters>
          <parameter name="titleAnchorNode" type="Object" usage="required"/>
          <parameter name="editMode" type="Boolean" usage="required">
            <description>to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="The" usage="required">
            <description>Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSummaryHeader" scope="instance">
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the summary title to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSummary" scope="instance">
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the summary data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setIdHeader" scope="instance">
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	
	idAnchorNode:
	The DOM node to attach the ID data to.</description>
        <parameters>
          <parameter name="idHeaderNode" type="DOM" usage="required">
            <description>node</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setId" scope="instance">
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="idAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the ID data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setFieldValidity" scope="instance">
        <description>Function to set whether a field in the view is valid and displayable.
	This is needed for over-riding of the set* functions and customization of how data is displayed in the attach point.
	So if custom implementations use their own display logic, they can still enable the field.</description>
        <parameters>
          <parameter name="field" type="string" usage="required">
            <description>The field name to set the valid parameter on.  Such as 'content', 'id', etc.</description>
          </parameter>
          <parameter name="isValid" type="boolean" usage="required">
            <description>Flag denoting if the field is valid or not.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setEntry" scope="instance">
        <description>Function to set the current entry that is being edited.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>Instance of dojox.atom.io.model.Entry to display for reading/editing.</description>
          </parameter>
          <parameter name="feed" type="object" usage="required"/>
          <parameter name="leaveMenuState" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setDisplaySections" scope="instance">
        <description>Function for setting which sections of the entry should be displayed.</description>
        <parameters>
          <parameter name="sectionsArray" type="array" usage="required">
            <description>Array of string names that indicate which sections to display.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setContributorsHeader" scope="instance">
        <description>Function to set the contents of the contributor header node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the contributor title to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContributors" scope="instance">
        <description>Function to set the contents of the contributor node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the contributor data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContentHeader" scope="instance">
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contentHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the content data to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContent" scope="instance">
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contentAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the content data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAuthorsHeader" scope="instance">
        <description>Function to set the title format for the authors section of the author row in the template to some value from the entry.
	This exists specifically so users can over-ride how the author data is filled out from an entry.</description>
        <parameters>
          <parameter name="authorHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the author section header data to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAuthors" scope="instance">
        <description>Function to set the contents of the author node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	
	authorsAchorNode:
	The DOM node to attach the author data to.</description>
        <parameters>
          <parameter name="authorsAnchorNode" type="DOM" usage="required">
            <description>node</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="isFieldValid" scope="instance">
        <description>Function to return if a displayable field is valid or not</description>
        <parameters>
          <parameter name="field" type="string" usage="required">
            <description>The field name to get the valid parameter of.  Such as 'content', 'id', etc.</description>
          </parameter>
        </parameters>
        <return-description>boolean denoting if the field is valid and set.</return-description>
      </method>
      <method name="getFeed" scope="instance"/>
      <method name="getEntry" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="clearNodes" scope="instance">
        <description>Function to clear all the display nodes for the ATOM entry from the viewer.</description>
      </method>
      <method name="clear" scope="instance">
        <description>Function to clear the state of the widget.</description>
      </method>
      <method name="_toggleOptions" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="checkBox" type="object" usage="required">
            <description>The checkbox object to toggle the selection on.</description>
          </parameter>
        </parameters>
        <return-description>Nothing</return-description>
      </method>
      <method name="_toggleCheckbox" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="checkBox" type="object" usage="required">
            <description>The checkbox object to toggle the selection on.</description>
          </parameter>
        </parameters>
        <return-description>Nothing</return-description>
      </method>
      <method name="_setDisplaySectionsCheckboxes" scope="instance">
        <description>Internal function for setting which checkboxes on the display are selected.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_readDisplaySections" scope="instance">
        <description>Internal function for reading what is currently checked for display and generating the display list from it.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_handleEvent" scope="instance">
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required">
            <description>The topic message containing the entry that was selected for view.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_displaySections" scope="instance">
        <description>Internal function for determining which sections of the view to actually display.</description>
        <return-description>Nothing.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Templated.prototype" scope="instance"/>
      <mixin type="_Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_Templated" scope="instance"/>
      <mixin type="_Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="feedEntryCheckBoxLabelUpdated" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelTitle" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelSummary" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelId" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelContributors" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelContent" scope="instance" type="Object"/>
      <property name="feedEntryCheckBoxLabelAuthors" scope="instance" type="Object"/>
      <property name="displayOptions" scope="instance" type="Object"/>
      <property name="close" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.displayOptions"/>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelTitle"/>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelAuthors"/>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelContributors"/>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelId"/>
  <class type="dojox.atom.widget.FeedEntryViewer.close"/>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelUpdated"/>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelSummary"/>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelContent"/>
  <class type="dojox.atom.widget.EntryHeader" superclass="_Widget">
    <description>Widget representing a header in a FeedEntryViewer/Editor</description>
    <methods>
      <method name="setListHeader" scope="instance">
        <parameters>
          <parameter name="title" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="clear" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Templated.prototype" scope="instance"/>
      <mixin type="_Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_Templated" scope="instance"/>
      <mixin type="_Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.widget.FeedViewer" superclass="_Widget">
    <description>An ATOM feed viewer that allows for viewing a feed, deleting entries, and editing entries.
	
	
	The body of the feed viewer table so we can access it and populate it.  Will be assigned via template.
	
	
	The overal table container which contains the feed viewer table.  Will be assigned via template.
	
	
	The topic to broadcast when any entry is clicked so that a listener can pick up it and display it.
	
	
	The URL to which to connect to initially on creation.</description>
    <methods>
      <method name="startup" scope="instance">
        <description>The startup function.  Parses the filters and sets the feed based on the given url.</description>
      </method>
      <method name="setFeedFromUrl" scope="instance">
        <description>Function setting the dojox.atom.io.model.Feed data into the view.</description>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <description>The URL to the feed to load.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setFeed" scope="instance">
        <description>Function setting the dojox.atom.io.model.Feed data into the view.
	
	entry:
	The dojox.atom.io.model.Feed object to process</description>
        <parameters>
          <parameter name="feed" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="removeCategoryIncludeFilter" scope="instance">
        <description>Function to remove a filter for entry inclusion in the feed view.</description>
        <parameters>
          <parameter name="filter" type="object" usage="required">
            <description>The basic items to identify the filter that is present.
	Should be of format: {scheme: &amp;lt;some text or null&amp;gt;, term: &amp;lt;some text or null&amp;gt;, label: &amp;lt;some text or null&amp;gt;}</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="postCreate" scope="instance">
        <description>The postCreate function.  Creates our AtomIO object for future interactions and subscribes to the
	event given in markup/creation.</description>
      </method>
      <method name="onEntrySelected" scope="instance">
        <description>Function intended for over0-riding/replacement as an attachpoint to for other items to recieve
	selection notification.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object selected.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="destroy" scope="instance">
        <description>Destroys this widget, including all descendants and subscriptions.</description>
      </method>
      <method name="deleteEntry" scope="instance">
        <description>Function for deleting a row from the view</description>
        <parameters>
          <parameter name="entryRow" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <description>Function clearing all current entries in the feed view.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="appendGrouping" scope="instance">
        <description>Function for appending a grouping of entries to the feed view.
	
	entry:
	The title of the new grouping to create on the view.</description>
        <parameters>
          <parameter name="titleText" type="string" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="appendEntry" scope="instance">
        <description>Function for appending an entry to the feed view.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object to append</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="addCategoryIncludeFilter" scope="instance">
        <description>Function to add a filter for entry inclusion in the feed view.</description>
        <parameters>
          <parameter name="filter" type="object" usage="required">
            <description>The basic items to filter on and the values.
	Should be of format: {scheme: &amp;lt;some text or null&amp;gt;, term: &amp;lt;some text or null&amp;gt;, label: &amp;lt;some text or null&amp;gt;}</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_rowSelected" scope="instance">
        <description>Internal function for handling the selection of feed entries.</description>
        <parameters>
          <parameter name="evt" type="object" usage="required">
            <description>The click event that triggered a selection.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_removeEntry" scope="instance">
        <description>callback for when an entry is deleted from a feed.</description>
        <parameters>
          <parameter name="entry" type="FeedViewerEntry" usage="required"/>
          <parameter name="success" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isRelativeURL" scope="instance">
        <description>Method to determine if the URL is relative or absolute.  Basic assumption is if it doesn't start
	with http:// or file://, it's relative to the current document.</description>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <description>The URL to inspect.</description>
          </parameter>
        </parameters>
        <return-description>boolean indicating whether it's a relative url or not.</return-description>
      </method>
      <method name="_isFilterAccepted" scope="instance">
        <description>Internal function to do matching of category filters to widgets.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
        <return-description>boolean denoting if this entry matched one of the accept filters.</return-description>
      </method>
      <method name="_isEditable" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object to examine</description>
          </parameter>
        </parameters>
        <return-description>Boolean denoting if the entry seems editable or not..</return-description>
      </method>
      <method name="_handleEvent" scope="instance">
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required">
            <description>The topic message containing the entry that was selected for view.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_displayDateForEntry" scope="instance">
        <description>Internal function for determining of a particular entry is editable.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object to examine.</description>
          </parameter>
        </parameters>
        <return-description>An appropriate date for the feed viewer display.</return-description>
      </method>
      <method name="_deselectCurrentSelection" scope="instance">
        <description>Internal function for unselecting the current selection.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_calculateBaseURL" scope="instance">
        <description>Internal function to calculate a baseline URL from the provided full URL.</description>
        <parameters>
          <parameter name="fullURL" type="string" usage="required">
            <description>The full URL as a string.</description>
          </parameter>
          <parameter name="currentPageRelative" type="boolean" usage="required">
            <description>Flag to denote of the base URL should be calculated as just the server base, or relative to the current page/location in the URL.</description>
          </parameter>
        </parameters>
        <return-description>String of the baseline URL</return-description>
      </method>
      <method name="_addEntry" scope="instance">
        <description>callback function used when adding an entry to the feed.  After the entry has been posted to the feed,
	we add it to our feed representation (to show it on the page) and publish an event to update any entry viewers.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="CategoryIncludeFilter" scope="instance">
        <description>The initializer function.</description>
        <parameters>
          <parameter name="scheme" type="Object" usage="required"/>
          <parameter name="term" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Templated.prototype" scope="instance"/>
      <mixin type="_Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_Templated" scope="instance"/>
      <mixin type="_Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.widget.FeedViewerEntry" superclass="_Widget">
    <description>Widget for handling the display of an entry and specific events associated with it.</description>
    <methods>
      <method name="setTitle" scope="instance">
        <description>Function to set the title of the entry.</description>
        <parameters>
          <parameter name="text" type="string" usage="required">
            <description>The title.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setTime" scope="instance">
        <description>Function to set the time of the entry.</description>
        <parameters>
          <parameter name="timeText" type="string" usage="required">
            <description>The string form of the date.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onClick" scope="instance">
        <description>Attach point for when a row is clicked on.</description>
        <parameters>
          <parameter name="e" type="object" usage="required">
            <description>The event generated by the click.</description>
          </parameter>
        </parameters>
      </method>
      <method name="enableDelete" scope="instance">
        <description>Function to enable the delete action on this entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="disableDelete" scope="instance">
        <description>Function to disable the delete action on this entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="deleteEntry" scope="instance">
        <description>Function to handle the delete event and delete the entry.</description>
        <parameters>
          <parameter name="event" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="deleteButton" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerEntry.deleteButton">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerEntry.deleteButton.style"/>
  <class type="dojox.atom.widget.FeedViewerGrouping" superclass="_Widget">
    <description>Grouping of feed entries.</description>
    <methods>
      <method name="setText" scope="instance">
        <description>Sets the text to be shown above this grouping.</description>
        <parameters>
          <parameter name="text" type="The" usage="required">
            <description>text to show.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.widget.AtomEntryCategoryFilter" superclass="_Widget">
    <description>A filter to be applied to the list of entries.</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="_Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.atom.widget.FeedViewer.CategoryIncludeFilter">
    <description>The initializer function.</description>
    <methods>
      <method name="match" scope="instance">
        <description>Function to determine if this category filter matches against a category on an atom entry</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required"/>
        </parameters>
        <return-description>boolean denoting if this category filter matched to this entry.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <description>The initializer function.</description>
        <parameters>
          <parameter name="scheme" type="Object" usage="required"/>
          <parameter name="term" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.av">
    <methods>
      <method name="_Media" scope="instance">
        <description>Calculates the current status of the playing media and fires
	the appropriate events.</description>
      </method>
      <method name="FLVideo" scope="instance">
        <examples>
          <example>markup:
		&lt;div id="vid" initialVolume=".7",
			mediaUrl="../resources/Grog.flv"
			dojoType="dojox.av.FLVideo"&gt;&lt;/div&gt;
	programmatic:
		new dojox.av.FLVideo({
			initialVolume:.7,
			mediaUrl:"../resources/Grog.flv"
		}, "vid");
	
	mediaUrl: String
	REQUIRED: The Url of the video file that will be played.
	NOTE: Must be either an absolute URL or relative to the HTML file.
	Relative paths will be converted to abslute paths</example>
        </examples>
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="FLAudio" scope="instance">
        <description>This class is brand new, so there is a lot of
	functionality not yet available. The initial
	purpose is for playing "event" sounds like button
	clicks, and for loading and controlling multiple
	sounds at once. As of yet, streaming is not supported
	and polling the sounds for events during playback
	may still be missing information. Markup is not
	supported, as it may not be needed.
	
	TODO:
	Streaming, playback events, crossdomain, CDN support,
	(alternate SWF location), global volume, ID3 tag,
	factor out doLater, onLoadStatus needs work,
	play(position) / seek()</description>
        <examples>
          <example>	new dojox.av.FLAudio({
			initialVolume:.7,
			initialPan:0,
			autoPlay:false
		});</example>
        </examples>
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLAudio">
    <description>This class is brand new, so there is a lot of
	functionality not yet available. The initial
	purpose is for playing "event" sounds like button
	clicks, and for loading and controlling multiple
	sounds at once. As of yet, streaming is not supported
	and polling the sounds for events during playback
	may still be missing information. Markup is not
	supported, as it may not be needed.
	
	TODO:
	Streaming, playback events, crossdomain, CDN support,
	(alternate SWF location), global volume, ID3 tag,
	factor out doLater, onLoadStatus needs work,
	play(position) / seek()</description>
    <methods>
      <method name="stop" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="setVolume" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>volume: Number
	0 to 1
	index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="setPan" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>pan:Number -1 to 1
	index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="pause" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="onPlayStatus" scope="instance">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onLoadStatus" scope="instance">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="onID3" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onAllLoaded" scope="instance"/>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>url: String
	(required) path to MP3 media
	url must be absolute or relative to SWF,
	not dojo or the html. An effort will be made
	to fix incorrect paths.
	id: String
	(optional) an identifier to later determine
	which media to control.</description>
          </parameter>
        </parameters>
        <return-description>The normalized url, which can be used to identify the
	audio.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="init" scope="instance"/>
      <method name="getVolume" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPosition" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPan" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="doPlay" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>volume: Number
	Sets the volume
	pan: Number
	Sets left/right pan
	index:Number OR id:String OR url:String
	Choose one of the above to indentify
	the media you wish to control. id is
	set by you. index is the order in which
	media was added (zero based)
	NOTE: lack of an identifier will default
	to first (or only) item.
	NOTE: Can't name this method &amp;quot;play()&amp;quot; as it causes
	an IE error.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sub" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeVolume" scope="instance">
        <parameters>
          <parameter name="vol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeUrl" scope="instance">
        <parameters>
          <parameter name="_url" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_flashObject" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLAudio._flashObject">
    <methods>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.av.FLVideo" superclass="dijit._Widget">
    <methods>
      <method name="volume" scope="instance">
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="seek" scope="instance">
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="play" scope="instance">
        <parameters>
          <parameter name="newUrl" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="pause" scope="instance"/>
      <method name="onSwfSized" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="instance"/>
      <method name="onStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="instance"/>
      <method name="onPosition" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlayerStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPause" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="mov" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <examples>
          <example> console.warn("ERROR-"+data.type.toUpperCase()+":",
			data.info.code, " - URL:", url);</example>
        </examples>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloaded" scope="instance">
        <parameters>
          <parameter name="percent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBuffer" scope="instance">
        <parameters>
          <parameter name="isBuffering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="instance"/>
      <method name="_checkBuffer" scope="instance">
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
          <parameter name="bufferLength" type="Float" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.av._Media.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dojox.av._Media" scope="instance"/>
    </mixins>
    <properties>
      <property name="_flashObject" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLVideo._flashObject">
    <methods>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.av._Media">
    <description>Calculates the current status of the playing media and fires
	the appropriate events.</description>
    <methods>
      <method name="onSwfSized" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="instance"/>
      <method name="onStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="instance"/>
      <method name="onPosition" scope="instance">
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="onPlayerStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPause" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="mov" type="SWF" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <examples>
          <example> console.warn("ERROR-"+data.type.toUpperCase()+":",
			data.info.code, " - URL:", url);</example>
        </examples>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloaded" scope="instance">
        <parameters>
          <parameter name="percent" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBuffer" scope="instance">
        <parameters>
          <parameter name="isBuffering" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getTime" scope="instance">
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_sub" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeVolume" scope="instance">
        <parameters>
          <parameter name="vol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeUrl" scope="instance">
        <parameters>
          <parameter name="_url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initStatus" scope="instance"/>
      <method name="_figureStatus" scope="instance"/>
      <method name="_eventFactory" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.av.widget">
    <methods>
      <method name="VolumeButton" scope="instance">
        <description>Controls and displays the volume of the media. This widget
	opens a slider on click that is used to adjust the volume.
	The icon changes according to the volume level.</description>
      </method>
      <method name="Status" scope="instance">
        <description>Displays the name of the media file, and it's current status
	(playing, paused, buffering, etc.) in the middle. Displays
	the playhead time on the left and the duration on the right.</description>
      </method>
      <method name="ProgressSlider" scope="instance">
        <description>Displays the current playhead position of the media. Has two
	progress bars: one for playhead position, and one for download
	progress.</description>
      </method>
      <method name="Player" scope="instance">
        <description>Currently for markup only. All controls should reside as child
	nodes within the Player node. 'controlType' is used to determine
	the placement of the control. If no type or an unrecoginized type
	is used, it will be left-aligned in the same row as the volume.
	Note:
	Be sure to use 'controlType' as a node attribute. It is not a
	property of the widget.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.av.widget.Player" playerWidth="100%"&gt;
	 		&lt;div controlType="video" initialVolume=".1"
	 			mediaUrl="video/Grog.flv" autoPlay="true"
				isDebug="false" dojoType="dojox.av.FLVideo"&gt;&lt;/div&gt;
			 	&lt;div controlType="play" dojoType="dojox.av.widget.PlayButton"&gt;&lt;/div&gt;
			 	&lt;div controlType="volume" dojoType="dojox.av.widget.VolumeButton"&gt;&lt;/div&gt;
			 	&lt;div controlType="progress" dojoType="dojox.av.widget.ProgressSlider"&gt;&lt;/div&gt;
			 	&lt;div controlType="status" dojoType="dojox.av.widget.Status"&gt;&lt;/div&gt;
	 &lt;/div&gt;</example>
        </examples>
      </method>
      <method name="PlayButton" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.av.widget.PlayButton" superclass="dijit._Widget">
    <methods>
      <method name="showPlay" scope="instance"/>
      <method name="showPause" scope="instance"/>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onPlay" scope="instance"/>
      <method name="onPause" scope="instance"/>
      <method name="onClick" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.av.widget.Player" superclass="dijit._Widget">
    <description>Currently for markup only. All controls should reside as child
	nodes within the Player node. 'controlType' is used to determine
	the placement of the control. If no type or an unrecoginized type
	is used, it will be left-aligned in the same row as the volume.
	Note:
	Be sure to use 'controlType' as a node attribute. It is not a
	property of the widget.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fillContent" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.av.widget.ProgressSlider" superclass="dijit._Widget">
    <description>Displays the current playhead position of the media. Has two
	progress bars: one for playhead position, and one for download
	progress.</description>
    <methods>
      <method name="startDrag" scope="instance"/>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
          <parameter name="playerWidget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setLoadedPosition" scope="instance">
        <parameters>
          <parameter name="decimal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setHandle" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="playerDimensions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="evt" type="HTMLEvent" usage="required"/>
        </parameters>
      </method>
      <method name="handleOver" scope="instance"/>
      <method name="handleOut" scope="instance"/>
      <method name="endDrag" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.av.widget.Status" superclass="dijit._Widget">
    <description>Displays the name of the media file, and it's current status
	(playing, paused, buffering, etc.) in the middle. Displays
	the playhead time on the left and the duration on the right.</description>
    <methods>
      <method name="toSeconds" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStatus" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
          <parameter name="isError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="instance"/>
      <method name="onStart" scope="instance"/>
      <method name="onPosition" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="instance"/>
      <method name="onPaused" scope="instance"/>
      <method name="onMetaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="instance"/>
      <method name="onBuffer" scope="instance">
        <parameters>
          <parameter name="isBuffering" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="titleNode" scope="instance" type="Object"/>
      <property name="durNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status.durNode"/>
  <class type="dojox.av.widget.Status.titleNode"/>
  <class type="dojox.av.widget.VolumeButton" superclass="dijit._Widget">
    <description>Controls and displays the volume of the media. This widget
	opens a slider on click that is used to adjust the volume.
	The icon changes according to the volume level.</description>
    <methods>
      <method name="updateIcon" scope="instance">
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="instance"/>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onShowVolume" scope="instance">
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="playerDimensions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHideVolume" scope="instance"/>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onDocClick" scope="instance">
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="handleOver" scope="instance"/>
      <method name="handleOut" scope="instance"/>
      <method name="endDrag" scope="instance"/>
      <method name="_getVolumeDim" scope="instance"/>
      <method name="_getHandleDim" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="calc">
    <methods>
      <method name="toFrac" scope="instance">
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pow" scope="instance">
        <parameters>
          <parameter name="base" type="Object" usage="required"/>
          <parameter name="exponent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generatePoints" scope="instance">
        <parameters>
          <parameter name="funcToGraph" type="Function" usage="required"/>
          <parameter name="x" type="String" usage="required"/>
          <parameter name="y" type="String" usage="required"/>
          <parameter name="width" type="Number" usage="required"/>
          <parameter name="minX" type="Number" usage="required"/>
          <parameter name="maxX" type="Number" usage="required"/>
          <parameter name="minY" type="Number" usage="required"/>
          <parameter name="maxY" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="someone pushed cancel in the val code"/>
        </return-types>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="chart" type="Chart" usage="required"/>
          <parameter name="functionToGraph" type="Function" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.calc">
    <methods>
      <method name="_Executor" scope="instance"/>
      <method name="Standard" scope="instance"/>
      <method name="Grapher" scope="instance"/>
      <method name="GraphPro" scope="instance"/>
      <method name="FuncGen" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.calc.FuncGen" superclass="dijit._WidgetBase">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="saveFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="readyStatus" scope="instance"/>
      <method name="onSelect" scope="instance"/>
      <method name="onSaved" scope="instance"/>
      <method name="onReset" scope="instance"/>
      <method name="onDelete" scope="instance"/>
      <method name="onClear" scope="instance"/>
      <method name="deleteThing" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="combo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.FuncGen.combo"/>
  <class type="dojox.calc.GraphPro" superclass="dojox.calc.Standard">
    <methods>
      <method name="makeGrapherWindow" scope="instance"/>
      <method name="makeFunctionWindow" scope="instance"/>
      <method name="executorLoaded" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.calc.Standard" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.calc.Standard" superclass="dijit._WidgetBase">
    <methods>
      <method name="setTextboxValue" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saveFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putInAnsIfTextboxIsHighlighted" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="print" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="isRight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="parseTextbox" scope="instance"/>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBlur" scope="instance"/>
      <method name="loadStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="isReadOnly" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertText" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertOperator" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertMinus" scope="instance"/>
      <method name="executorLoaded" scope="instance"/>
      <method name="cycleCommands" scope="instance">
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cycleCommandUp" scope="instance"/>
      <method name="cycleCommandDown" scope="instance"/>
      <method name="clearText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="displayBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.Grapher" superclass="dijit._WidgetBase">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setStatus" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
          <parameter name="status" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectAll" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onErase" scope="instance"/>
      <method name="onDraw" scope="instance"/>
      <method name="onDelete" scope="instance"/>
      <method name="makeDirty" scope="instance"/>
      <method name="erase" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="drawOne" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance"/>
      <method name="createFunction" scope="instance"/>
      <method name="checkDirty1" scope="instance"/>
      <method name="checkDirty" scope="instance"/>
      <method name="changedColor" scope="instance"/>
      <method name="addXYAxes" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.calc.Standard.textboxWidget.textbox"/>
  <class type="dojox.calc.Standard.displayBox"/>
  <class type="dojox.calc._Executor" superclass="dijit._WidgetBase">
    <methods>
      <method name="onLoad" scope="instance"/>
      <method name="normalizedFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="eval" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="deleteFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLoad" scope="instance">
        <parameters>
          <parameter name="env" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Function" scope="instance">
        <parameters>
          <parameter name="name" type="this" usage="required">
            <description>argument is simply a String that represents the name of the function being evaluated. It can be undefined, but in that case the function is a one time use.</description>
          </parameter>
          <parameter name="args" type="the" usage="required">
            <description>function arguments (a String)</description>
          </parameter>
          <parameter name="body" type="the" usage="required">
            <description>function body, also a String</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="Chart">
    <description>Bidi stands for support for languages with a bidirectional script.
	There's a special need for displaying BIDI text in rtl direction
	in ltr GUI, sometimes needed auto support.
	dojox.charting does not support control over base text direction provided in Dojo.</description>
    <methods>
      <method name="truncateBidi" scope="instance">
        <description>Can be two types of labels: html or gfx.
	gfx labels:
	Need to be stored in registry to be used when the textDir will be set dynamically.
	Additional work on truncated labels is needed for case as 111111A (A stands for "bidi" character rtl directioned).
	let say in this case the truncation is "111..." If the textDir is auto, the display should be: "...111" but in gfx
	case we will get "111...". Because this.surface.setTextDir will calculate the dir of truncated
	label, which value is "111..." but th real is "111111A".
	each time we created a gfx truncated label we store it in the truncatedLabelsRegistry.
	html labels:
	no need for repository (stored in another place). Here we only need to update the current dir according to textDir.</description>
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
          <parameter name="labelType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTextDir" scope="instance">
        <description>Allows dynamically set the textDir, goes over all the text-children and
	updates their base text direction.</description>
        <parameters>
          <parameter name="newTextDir" type="String" usage="required"/>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="getTextDir" scope="instance">
        <description>If textDir is ltr or rtl returns the value.
	If it's auto, calls to another function that responsible
	for checking the value, and defining the direction.</description>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>Used in case textDir is &amp;quot;auto&amp;quot;, this case the direction is according to the first
	strong (directionally - which direction is strong defined) letter.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTextDirAttr" scope="instance">
        <parameters>
          <parameter name="textDir" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="Chart.postscript">
    <description>Used for setting the textDir of the chart.</description>
    <methods/>
    <properties>
      <property name="surface" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Chart.postscript.surface"/>
  <class type="Chart.setTextDir">
    <description>Allows dynamically set the textDir, goes over all the text-children and
	updates their base text direction.</description>
    <methods/>
  </class>
  <class type="dojox.charting">
    <methods>
      <method name="__SeriesCtorArgs" scope="instance">
        <parameters>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot (by name) that this series belongs to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__ChartCtorArgs" scope="instance">
        <parameters>
          <parameter name="margins" type="Object" usage="optional">
            <description>Optional margins for the chart, in the form of { l, t, r, b}.</description>
          </parameter>
          <parameter name="stroke" type="dojox.gfx.Stroke" usage="optional">
            <description>An optional outline/stroke for the chart.</description>
          </parameter>
          <parameter name="fill" type="dojox.gfx.Fill" usage="optional">
            <description>An optional fill for the chart.</description>
          </parameter>
          <parameter name="delayInMs" type="Number" usage="required">
            <description>Delay in ms for delayedRender(). Default: 200.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__Chart3DCtorArgs" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The DOM node to construct the chart on.</description>
          </parameter>
          <parameter name="lights" type="Lighting" usage="required">
            <description>properties for the 3d scene</description>
          </parameter>
          <parameter name="camera" type="Object" usage="required">
            <description>Camera properties describing the viewing camera position.</description>
          </parameter>
          <parameter name="theme" type="Object" usage="required">
            <description>Charting theme to use for coloring chart elements.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Theme" scope="instance">
        <description>While you can set up style definitions on a chart directly (usually through the various add methods
	on a dojox.charting.Chart object), a Theme simplifies this manual setup by allowing you to
	pre-define all of the various visual parameters of each element in a chart.
	
	Most of the properties of a Theme are straight-forward; if something is line-based (such as
	an axis or the ticks on an axis), they will be defined using basic stroke parameters.  Likewise,
	if an element is primarily block-based (such as the background of a chart), it will be primarily
	fill-based.
	
	In addition (for convenience), a Theme definition does not have to contain the entire JSON-based
	structure.  Each theme is built on top of a default theme (which serves as the basis for the theme
	"GreySkies"), and is mixed into the default theme object.  This allows you to create a theme based,
	say, solely on colors for data series.
	
	Defining a new theme is relatively easy; see any of the themes in dojox.charting.themes for examples
	on how to define your own.
	
	When you set a theme on a chart, the theme itself is deep-cloned.  This means that you cannot alter
	the theme itself after setting the theme value on a chart, and expect it to change your chart.  If you
	are looking to make alterations to a theme for a chart, the suggestion would be to create your own
	theme, based on the one you want to use, that makes those alterations before it is applied to a chart.
	
	Finally, a Theme contains a number of functions to facilitate rendering operations on a chart--the main
	helper of which is the ~next~ method, in which a chart asks for the information for the next data series
	to be rendered.
	
	A note on colors:
	The Theme constructor was on the use of dojox.color.Palette (in general) for creating a visually distinct
	set of colors for usage in a chart.  A palette is usually comprised of 5 different color definitions, and
	no more.  If you have a need to render a chart with more than 5 data elements, you can simply "push"
	new color definitions into the theme's .color array.  Make sure that you do that with the actual
	theme object from a Chart, and not in the theme itself (i.e. either do that before using .setTheme
	on a chart).</description>
        <examples>
          <example>The default theme (and structure) looks like so:
		// all objects are structs used directly in dojox.gfx
		chart:{
			stroke: null,
			fill: "white",
			pageStyle: null // suggested page style as an object suitable for dojo.style()
		},
		plotarea:{
			stroke: null,
			fill: "white"
		},
		axis:{
			stroke:	{ // the axis itself
				color: "#333",
				width: 1
			},
			tick: {	// used as a foundation for all ticks
				color:     "#666",
				position:  "center",
				font:      "normal normal normal 7pt Tahoma",	// labels on axis
				fontColor: "#333"								// color of labels
			},
			majorTick:	{ // major ticks on axis, and used for major gridlines
				width:  1,
				length: 6
			},
			minorTick:	{ // minor ticks on axis, and used for minor gridlines
				width:  0.8,
				length: 3
			},
			microTick:	{ // minor ticks on axis, and used for minor gridlines
				width:  0.5,
				length: 1
			}
		},
		series: {
			stroke:  {width: 1.5, color: "#333"},		// line
			outline: {width: 0.1, color: "#ccc"},		// outline
			//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},
			shadow: null,								// no shadow
			fill:    "#ccc",							// fill, if appropriate
			font:    "normal normal normal 8pt Tahoma",	// if there's a label
			fontColor: "#000"							// color of labels
			labelWiring: {width: 1, color: "#ccc"},		// connect marker and target data item(slice, column, bar...)
		},
		marker: {	// any markers on a series
			symbol:  "m-3,3 l3,-6 3,6 z",				// symbol
			stroke:  {width: 1.5, color: "#333"},		// stroke
			outline: {width: 0.1, color: "#ccc"},		// outline
			shadow: null,								// no shadow
			fill:    "#ccc",							// fill if needed
			font:    "normal normal normal 8pt Tahoma",	// label
			fontColor: "#000"
		},
		indicator: {
			lineStroke:  {width: 1.5, color: "#333"},		// line
			lineOutline: {width: 0.1, color: "#ccc"},		// line outline
			lineShadow: null,								// no line shadow
			stroke:  {width: 1.5, color: "#333"},			// label background stroke
			outline: {width: 0.1, color: "#ccc"},			// label background outline
			shadow: null,									// no label background shadow
			fill:  "#ccc",									// label background fill
			radius: 3,										// radius of the label background
			font:    "normal normal normal 10pt Tahoma",	// label font
			fontColor: "#000"								// label color
			markerFill:    "#ccc",							// marker fill
			markerSymbol:  "m-3,0 c0,-4 6,-4 6,0 m-6,0 c0,4 6,4 6,0",	// marker symbol
			markerStroke:  {width: 1.5, color: "#333"},		// marker stroke
			markerOutline: {width: 0.1, color: "#ccc"},		// marker outline
			markerShadow: null,								// no marker shadow
		}</example>
          <example>Defining a new theme is pretty simple:
		dojox.charting.themes.Grasslands = new dojox.charting.Theme({
			colors: [ "#70803a", "#dde574", "#788062", "#b1cc5d", "#eff2c2" ]
		});
	
		myChart.setTheme(dojox.charting.themes.Grasslands);</example>
        </examples>
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="StoreSeries" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required">
            <description>A dojo object store.</description>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required">
            <description>A store-specific keyword parameters used for querying objects.
	See dojo.store docs</description>
          </parameter>
          <parameter name="value" type="Function|Object|String|Null" usage="required">
            <description>Function, which takes an object handle, and
	produces an output possibly inspecting the store's item. Or
	a dictionary object, which tells what names to extract from
	an object and how to map them to an output. Or a string, which
	is a numeric field name to use for plotting. If undefined, null
	or empty string (the default), &amp;quot;value&amp;quot; field is extracted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Series" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart that this series belongs to.</description>
          </parameter>
          <parameter name="data" type="Array|Object" usage="required">
            <description>The array of data points (either numbers or objects) that
	represents the data to be drawn. Or it can be an object. In
	the latter case, it should have a property &amp;quot;data&amp;quot; (an array),
	destroy(), and setSeriesObject().</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.__SeriesCtorArgs" usage="optional">
            <description>An optional keyword arguments object to set details for this series.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Element" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart that this element belongs to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="DataSeries" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required">
            <description>A dojo.data store object.</description>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required">
            <description>A store-specific keyword parameters used for fetching items.
	See dojo.data.api.Read.fetch().</description>
          </parameter>
          <parameter name="value" type="Function|Object|String|Null" usage="required">
            <description>Function, which takes a store, and an object handle, and
	produces an output possibly inspecting the store's item. Or
	a dictionary object, which tells what names to extract from
	an object and how to map them to an output. Or a string, which
	is a numeric field name to use for plotting. If undefined, null
	or empty string (the default), &amp;quot;value&amp;quot; field is extracted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="DataChart" scope="instance">
        <description>This code should be considered very experimental and the APIs subject
	to change. This is currently an alpha version and will need some testing
	and review.
	
	The main reason for this extension is to create animated charts, generally
	available with scroll=true, and a property field that gets continually updated.
	The previous property settings are kept in memory and displayed until scrolled
	off the chart.
	
	Although great effort was made to maintain the integrity of the current
	charting APIs, some things have been added or modified in order to get
	the store to connect and also to get the data to scroll/animate.
	"displayRange" in particular is used to force the xaxis to a specific
	size and keep the chart from stretching or squashing to fit the data.
	
	Currently, plot lines can only be set at initialization. Setting
	a new store query will have no effect (although using setStore
	may work but its untested).</description>
        <examples>
          <example>	var chart = new dojox.charting.DataChart("myNode", {
			displayRange:8,
			store:dataStore,
			query:{symbol:"*"},
			fieldName:"price"
			type: dojox.charting.plot2d.Columns
		});
	
	properties:</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to attach the chart to.</description>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Chart3D" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
          <parameter name="camera" type="Object" usage="required"/>
          <parameter name="theme" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Chart" scope="instance">
        <description>dojox.charting.Chart is the primary object used for any kind of charts.  It
	is simple to create--just pass it a node reference, which is used as the
	container for the chart--and a set of optional keyword arguments and go.
	
	Note that like most of dojox.gfx, most of dojox.charting.Chart's methods are
	designed to return a reference to the chart itself, to allow for functional
	chaining.  This makes defining everything on a Chart very easy to do.</description>
        <examples>
          <example>Create an area chart, with smoothing.
		new dojox.charting.Chart(node))
			.addPlot("default", { type: "Areas", tension: "X" })
			.setTheme(dojox.charting.themes.Shrooms)
			.addSeries("Series A", [1, 2, 0.5, 1.5, 1, 2.8, 0.4])
			.addSeries("Series B", [2.6, 1.8, 2, 1, 1.4, 0.7, 2])
			.addSeries("Series C", [6.3, 1.8, 3, 0.5, 4.4, 2.7, 2])
			.render();</example>
          <example>The form of data in a data series can take a number of forms: a simple array,
	an array of objects {x,y}, or something custom (as determined by the plot).
	Here's an example of a Candlestick chart, which expects an object of
	{ open, high, low, close }.
		new dojox.charting.Chart(node))
			.addPlot("default", {type: "Candlesticks", gap: 1})
			.addAxis("x", {fixLower: "major", fixUpper: "major", includeZero: true})
			.addAxis("y", {vertical: true, fixLower: "major", fixUpper: "major", natural: true})
			.addSeries("Series A", [
					{ open: 20, close: 16, high: 22, low: 8 },
					{ open: 16, close: 22, high: 26, low: 6, mid: 18 },
					{ open: 22, close: 18, high: 22, low: 11, mid: 21 },
					{ open: 18, close: 29, high: 32, low: 14, mid: 27 },
					{ open: 29, close: 24, high: 29, low: 13, mid: 27 },
					{ open: 24, close: 8, high: 24, low: 5 },
					{ open: 8, close: 16, high: 22, low: 2 },
					{ open: 16, close: 12, high: 19, low: 7 },
					{ open: 12, close: 20, high: 22, low: 8 },
					{ open: 20, close: 16, high: 22, low: 8 },
					{ open: 16, close: 22, high: 26, low: 6, mid: 18 },
					{ open: 22, close: 18, high: 22, low: 11, mid: 21 },
					{ open: 18, close: 29, high: 32, low: 14, mid: 27 },
					{ open: 29, close: 24, high: 29, low: 13, mid: 27 },
					{ open: 24, close: 8, high: 24, low: 5 },
					{ open: 8, close: 16, high: 22, low: 2 },
					{ open: 16, close: 12, high: 19, low: 7 },
					{ open: 12, close: 20, high: 22, low: 8 },
					{ open: 20, close: 16, high: 22, low: 8 },
					{ open: 16, close: 22, high: 26, low: 6 },
					{ open: 22, close: 18, high: 22, low: 11 },
					{ open: 18, close: 29, high: 32, low: 14 },
					{ open: 29, close: 24, high: 29, low: 13 },
					{ open: 24, close: 8, high: 24, low: 5 },
					{ open: 8, close: 16, high: 22, low: 2 },
					{ open: 16, close: 12, high: 19, low: 7 },
					{ open: 12, close: 20, high: 22, low: 8 },
					{ open: 20, close: 16, high: 22, low: 8 }
				],
				{ stroke: { color: "green" }, fill: "lightgreen" }
			)
			.render();</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.__ChartCtorArgs" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Chart
	The newly created chart.</return-description>
      </method>
    </methods>
    <properties>
      <property name="widget" scope="instance" type="Object"/>
      <property name="themes" scope="instance" type="Object"/>
      <property name="scaler" scope="instance" type="Object"/>
      <property name="plot3d" scope="instance" type="Object"/>
      <property name="plot2d" scope="instance" type="Object"/>
      <property name="axis2d" scope="instance" type="Object"/>
      <property name="action2d" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Chart">
    <description>dojox.charting.Chart is the primary object used for any kind of charts.  It
	is simple to create--just pass it a node reference, which is used as the
	container for the chart--and a set of optional keyword arguments and go.
	
	Note that like most of dojox.gfx, most of dojox.charting.Chart's methods are
	designed to return a reference to the chart itself, to allow for functional
	chaining.  This makes defining everything on a Chart very easy to do.</description>
    <methods>
      <method name="zoomIn" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the axis as defined by addAxis.</description>
          </parameter>
          <parameter name="range" type="Array" usage="required">
            <description>The end points of the zoom range, measured in axis ticks.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the series as defined in addSeries.</description>
          </parameter>
          <parameter name="data" type="Array|Object" usage="required">
            <description>The array of data points (either numbers or objects) that
	represents the data to be drawn. Or it can be an object. In
	the latter case, it should have a property &amp;quot;data&amp;quot; (an array),
	destroy(), and setSeriesObject().</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="setWindow" scope="instance">
        <parameters>
          <parameter name="sx" type="Number" usage="required">
            <description>The scale for the x axis.</description>
          </parameter>
          <parameter name="sy" type="Number" usage="required">
            <description>The scale for the y axis.</description>
          </parameter>
          <parameter name="dx" type="Number" usage="required">
            <description>The pixel offset on the x axis.</description>
          </parameter>
          <parameter name="dy" type="Number" usage="required">
            <description>The pixel offset on the y axis.</description>
          </parameter>
          <parameter name="zoom" type="Boolean|Object" usage="optional">
            <description>The chart zooming animation trigger.  This is null by default,
	e.g. {duration: 1200}, or just set true.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="setTheme" scope="instance">
        <parameters>
          <parameter name="theme" type="dojox.charting.Theme" usage="required">
            <description>The theme to be used for visual rendering.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="setSeriesOrder" scope="instance">
        <parameters>
          <parameter name="newOrder" type="Array" usage="required">
            <description>Array of series names compatible with getPlotOrder(). All
	series should belong to the same plot.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="setPlotOrder" scope="instance">
        <parameters>
          <parameter name="newOrder" type="Array" usage="required">
            <description>Array of plot names compatible with getPlotOrder().</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="setAxisWindow" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the axis as defined by addAxis.</description>
          </parameter>
          <parameter name="scale" type="Number" usage="required">
            <description>The scale on the target axis.</description>
          </parameter>
          <parameter name="offset" type="Number" usage="required">
            <description>Any offest, as measured by axis tick</description>
          </parameter>
          <parameter name="zoom" type="Boolean|Object" usage="optional">
            <description>The chart zooming animation trigger.  This is null by default,
	e.g. {duration: 1200}, or just set true.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="resize" scope="instance">
        <description>Resize the chart and its surface to the width and height dimensions.
	If no width/height or box is provided, resize the surface to the marginBox of the chart.</description>
        <parameters>
          <parameter name="width" type="Number" usage="required">
            <description>The new width of the chart.</description>
          </parameter>
          <parameter name="height" type="Number" usage="required">
            <description>The new height of the chart.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="removeSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the series as defined by addSeries.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="removePlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the plot as defined using addPlot.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="removeAxis" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The axis name, as defined in addAxis.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="moveSeriesToFront" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Series' name to move.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="moveSeriesToBack" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Series' name to move.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="movePlotToFront" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plot's name to move.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="movePlotToBack" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plot's name to move.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="getSeriesOrder" scope="instance">
        <parameters>
          <parameter name="plotName" type="String" usage="required">
            <description>Plot's name.</description>
          </parameter>
        </parameters>
        <return-description>Array</return-description>
      </method>
      <method name="getSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name the series was defined by.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Series
	The series.</return-description>
      </method>
      <method name="getPlotOrder" scope="instance">
        <return-description>Array</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getPlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name the plot was defined by.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	The plot.</return-description>
      </method>
      <method name="getGeometry" scope="instance">
        <return-description>Object
	An map of geometry objects, a one-to-one mapping of axes.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getCoords" scope="instance">
        <return-description>Object
	The resulting coordinates of the chart.  See dojo.coords for details.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getAxis" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name the axis was defined by.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The axis as stored in the chart's axis map.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="fullRender" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="fullGeometry" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="fireEvent" scope="instance">
        <parameters>
          <parameter name="seriesName" type="String" usage="required">
            <description>Series name.</description>
          </parameter>
          <parameter name="eventName" type="String" usage="required">
            <description>Event name to simulate: onmouseover, onmouseout, onclick.</description>
          </parameter>
          <parameter name="index" type="Number" usage="required">
            <description>Valid data value index for the event.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance">
        <return-description>void</return-description>
      </method>
      <method name="delayedRender" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.__ChartCtorArgs" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Chart
	The newly created chart.</return-description>
      </method>
      <method name="connectToPlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the plot as defined by addPlot.</description>
          </parameter>
          <parameter name="object" type="Object" usage="required">
            <description>The object to be connected.</description>
          </parameter>
          <parameter name="method" type="Function" usage="required">
            <description>The function to be executed.</description>
          </parameter>
        </parameters>
        <return-description>Array
	A handle to the connection, as defined by dojo.connect (see dojo.connect).</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="calculateGeometry" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the data series to be plotted.</description>
          </parameter>
          <parameter name="data" type="Array|Object" usage="required">
            <description>The array of data points (either numbers or objects) that
	represents the data to be drawn. Or it can be an object. In
	the latter case, it should have a property &amp;quot;data&amp;quot; (an array),
	destroy(), and setSeriesObject().</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.__SeriesCtorArgs" usage="optional">
            <description>An optional keyword arguments object that will be mixed into
	the resultant series object.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart:
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="addPlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the plot to be added to the chart.  If you only plan on using one plot, call it &amp;quot;default&amp;quot;.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__PlotCtorArgs" usage="required">
            <description>An object with optional parameters for the plot in question.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="addAxis" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the axis.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>An optional keyword arguments object for use in defining details of an axis.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="_makeDirty" scope="instance"/>
      <method name="_makeClean" scope="instance"/>
      <method name="_invalidateDependentPlots" scope="instance">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
          <parameter name="verticalAxis" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.__ChartCtorArgs">
    <methods/>
  </class>
  <class type="dojox.charting.Chart3D">
    <methods>
      <method name="render" scope="instance"/>
      <method name="removeWall" scope="instance">
        <parameters>
          <parameter name="wall" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePlot" scope="instance">
        <parameters>
          <parameter name="plot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="generate" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
          <parameter name="camera" type="Object" usage="required"/>
          <parameter name="theme" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addWall" scope="instance">
        <parameters>
          <parameter name="wall" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addPlot" scope="instance">
        <parameters>
          <parameter name="plot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_generateWalls" scope="instance"/>
      <method name="_generatePlots" scope="instance"/>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="gfx3d">
    <methods>
      <method name="Viewport" scope="instance"/>
      <method name="Scene" scope="instance"/>
    </methods>
    <properties>
      <property name="vector" scope="instance" type="Object"/>
      <property name="scheduler" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object">
        <description>class constants, and methods of dojox.gfx3d.matrix</description>
      </property>
      <property name="lighting" scope="instance" type="Object"/>
      <property name="drawer" scope="instance" type="Object"/>
      <property name="_creators" scope="instance" type="Object">
        <description>object creators
	
	
	todo : override the add/remove if necessary</description>
      </property>
    </properties>
  </class>
  <class type="gfx">
    <methods>
      <method name="Surface" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.DataChart" superclass="dojox.charting.Chart">
    <description>This code should be considered very experimental and the APIs subject
	to change. This is currently an alpha version and will need some testing
	and review.
	
	The main reason for this extension is to create animated charts, generally
	available with scroll=true, and a property field that gets continually updated.
	The previous property settings are kept in memory and displayed until scrolled
	off the chart.
	
	Although great effort was made to maintain the integrity of the current
	charting APIs, some things have been added or modified in order to get
	the store to connect and also to get the data to scroll/animate.
	"displayRange" in particular is used to force the xaxis to a specific
	size and keep the chart from stretching or squashing to fit the data.
	
	Currently, plot lines can only be set at initialization. Setting
	a new store query will have no effect (although using setStore
	may work but its untested).</description>
    <methods>
      <method name="show" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required">
            <description>String</description>
          </parameter>
          <parameter name="fieldName" type="Object" usage="required">
            <description>String</description>
          </parameter>
          <parameter name="queryOptions" type="Object" usage="required">
            <description>Object</description>
          </parameter>
        </parameters>
      </method>
      <method name="seriesLabels" scope="instance">
        <parameters>
          <parameter name="val" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="resizeChart" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="storeObject" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="err" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDataReceived" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onData" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="getProperty" scope="instance">
        <parameters>
          <parameter name="item" type="storeObject" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="convertLabels" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to attach the chart to.</description>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Chart" scope="instance"/>
    </mixins>
    <properties>
      <property name="yaxis" scope="instance" type="Object">
        <description>optional parameters for yaxis (see above)
	store: Object
	dojo.data store (currently nly supports Persevere)</description>
      </property>
      <property name="xaxis" scope="instance" type="Object">
        <description>First query for store
	grid: Object
	Options for the grid plot
	chartPlot: Object
	Options for chart elements (lines, bars, etc)</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.DataChart.xaxis"/>
  <class type="dojox.charting.DataChart.yaxis"/>
  <class type="dojox.charting.DataChart.chartTheme.plotarea"/>
  <class type="dojox.charting.DataSeries">
    <methods>
      <method name="setSeriesObject" scope="instance">
        <parameters>
          <parameter name="series" type="dojox.charting.Series" usage="required">
            <description>Our interface to the chart.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFetchError" scope="instance">
        <parameters>
          <parameter name="errorData" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required">
            <description>A dojo.data store object.</description>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required">
            <description>A store-specific keyword parameters used for fetching items.
	See dojo.data.api.Read.fetch().</description>
          </parameter>
          <parameter name="value" type="Function|Object|String|Null" usage="required">
            <description>Function, which takes a store, and an object handle, and
	produces an output possibly inspecting the store's item. Or
	a dictionary object, which tells what names to extract from
	an object and how to map them to an output. Or a string, which
	is a numeric field name to use for plotting. If undefined, null
	or empty string (the default), &amp;quot;value&amp;quot; field is extracted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_pushDataChanges" scope="instance"/>
      <method name="_onStoreSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onStoreNew" scope="instance"/>
      <method name="_onStoreDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fieldValue" scope="instance">
        <parameters>
          <parameter name="field" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dictValue" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="dict" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultValue" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildItemMap" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.Element">
    <methods>
      <method name="purgeGroup" scope="instance">
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="getTextWithLimitLength" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="optional">
            <description>candidate text.</description>
          </parameter>
          <parameter name="font" type="String" usage="optional">
            <description>text's font style.</description>
          </parameter>
          <parameter name="limitWidth" type="Number" usage="optional">
            <description>text limited width in px.</description>
          </parameter>
          <parameter name="truncated" type="whether" usage="required">
            <description>text has been truncated
	}</description>
          </parameter>
        </parameters>
        <return-description>Object
	{
	text: processed text, maybe truncated or not</return-description>
      </method>
      <method name="getTextWithLimitCharCount" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="optional">
            <description>candidate text.</description>
          </parameter>
          <parameter name="font" type="String" usage="optional">
            <description>text's font style.</description>
          </parameter>
          <parameter name="wcLimit" type="Number" usage="optional">
            <description>text limited character count.</description>
          </parameter>
          <parameter name="truncated" type="whether" usage="required">
            <description>text has been truncated
	}</description>
          </parameter>
        </parameters>
        <return-description>Object
	{
	text: processed text, maybe truncated or not</return-description>
      </method>
      <method name="getTextWidth" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyHtmlElements" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="createGroup" scope="instance">
        <parameters>
          <parameter name="creator" type="dojox.gfx.Surface" usage="optional">
            <description>An optional surface in which to create this group.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart that this element belongs to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="cleanGroup" scope="instance">
        <parameters>
          <parameter name="creator" type="dojox.gfx.Surface" usage="optional">
            <description>An optional surface to work with.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="_shapeFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="bbox" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pseudoRadialFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="center" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_plotFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="chart" scope="instance-prototype" type="dojox.charting.Chart">
        <description>The parent chart for this element.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.Element.chart"/>
  <class type="dojox.charting.Series" superclass="dojox.charting.Element">
    <methods>
      <method name="update" scope="instance">
        <parameters>
          <parameter name="data" type="Array|Object" usage="required">
            <description>The array of data points (either numbers or objects) that
	represents the data to be drawn. Or it can be an object. In
	the latter case, it should have a property &amp;quot;data&amp;quot; (an array),
	destroy(), and setSeriesObject().</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart that this series belongs to.</description>
          </parameter>
          <parameter name="data" type="Array|Object" usage="required">
            <description>The array of data points (either numbers or objects) that
	represents the data to be drawn. Or it can be an object. In
	the latter case, it should have a property &amp;quot;data&amp;quot; (an array),
	destroy(), and setSeriesObject().</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.__SeriesCtorArgs" usage="optional">
            <description>An optional keyword arguments object to set details for this series.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.__SeriesCtorArgs">
    <methods/>
  </class>
  <class type="dojox.charting.StoreSeries">
    <methods>
      <method name="setSeriesObject" scope="instance">
        <parameters>
          <parameter name="series" type="dojox.charting.Series" usage="required">
            <description>Our interface to the chart.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required">
            <description>A dojo object store.</description>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required">
            <description>A store-specific keyword parameters used for querying objects.
	See dojo.store docs</description>
          </parameter>
          <parameter name="value" type="Function|Object|String|Null" usage="required">
            <description>Function, which takes an object handle, and
	produces an output possibly inspecting the store's item. Or
	a dictionary object, which tells what names to extract from
	an object and how to map them to an output. Or a string, which
	is a numeric field name to use for plotting. If undefined, null
	or empty string (the default), &amp;quot;value&amp;quot; field is extracted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_pushDataChanges" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.Theme">
    <description>While you can set up style definitions on a chart directly (usually through the various add methods
	on a dojox.charting.Chart object), a Theme simplifies this manual setup by allowing you to
	pre-define all of the various visual parameters of each element in a chart.
	
	Most of the properties of a Theme are straight-forward; if something is line-based (such as
	an axis or the ticks on an axis), they will be defined using basic stroke parameters.  Likewise,
	if an element is primarily block-based (such as the background of a chart), it will be primarily
	fill-based.
	
	In addition (for convenience), a Theme definition does not have to contain the entire JSON-based
	structure.  Each theme is built on top of a default theme (which serves as the basis for the theme
	"GreySkies"), and is mixed into the default theme object.  This allows you to create a theme based,
	say, solely on colors for data series.
	
	Defining a new theme is relatively easy; see any of the themes in dojox.charting.themes for examples
	on how to define your own.
	
	When you set a theme on a chart, the theme itself is deep-cloned.  This means that you cannot alter
	the theme itself after setting the theme value on a chart, and expect it to change your chart.  If you
	are looking to make alterations to a theme for a chart, the suggestion would be to create your own
	theme, based on the one you want to use, that makes those alterations before it is applied to a chart.
	
	Finally, a Theme contains a number of functions to facilitate rendering operations on a chart--the main
	helper of which is the ~next~ method, in which a chart asks for the information for the next data series
	to be rendered.
	
	A note on colors:
	The Theme constructor was on the use of dojox.color.Palette (in general) for creating a visually distinct
	set of colors for usage in a chart.  A palette is usually comprised of 5 different color definitions, and
	no more.  If you have a need to render a chart with more than 5 data elements, you can simply "push"
	new color definitions into the theme's .color array.  Make sure that you do that with the actual
	theme object from a Chart, and not in the theme itself (i.e. either do that before using .setTheme
	on a chart).</description>
    <methods>
      <method name="skip" scope="instance"/>
      <method name="setMarkers" scope="instance">
        <examples>
          <example>	myTheme.setMarkers({ "CIRCLE": foo });</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reverseFills" scope="instance"/>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="dojox.charting.Theme" usage="required">
            <description>The theme to post process with.</description>
          </parameter>
          <parameter name="elementType" type="String" usage="required">
            <description>The type of element being filled.  Can be &amp;quot;bar&amp;quot; or &amp;quot;circle&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Theme
	The post-processed theme.</return-description>
        <return-types>
          <return-type type="dojox.charting.Theme"/>
        </return-types>
      </method>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="String" usage="optional">
            <description>An optional element type (for use with series themes)</description>
          </parameter>
          <parameter name="mixin" type="Object" usage="optional">
            <description>An optional object to mix into the theme.</description>
          </parameter>
          <parameter name="doPost" type="Boolean" usage="optional">
            <description>A flag to post-process the results.</description>
          </parameter>
        </parameters>
        <return-description>Object
	An object of the structure { series, marker, symbol }</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspectObjects" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTick" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Tick name, can be &amp;quot;major&amp;quot;, &amp;quot;minor&amp;quot;, or &amp;quot;micro&amp;quot;.</description>
          </parameter>
          <parameter name="mixin" type="Object" usage="optional">
            <description>Optional object to mix in to the tick.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance">
        <return-description>dojox.charting.Theme
	The cloned theme; any alterations made will not affect the original.</return-description>
        <return-types>
          <return-type type="dojox.charting.Theme"/>
        </return-types>
      </method>
      <method name="clear" scope="instance"/>
      <method name="addMixin" scope="instance">
        <parameters>
          <parameter name="theme" type="dojox.charting.Theme" usage="required">
            <description>The theme to mixin to.</description>
          </parameter>
          <parameter name="elementType" type="String" usage="required">
            <description>The type of element in question. Can be &amp;quot;line&amp;quot;, &amp;quot;bar&amp;quot; or &amp;quot;circle&amp;quot;</description>
          </parameter>
          <parameter name="mixin" type="Object|Array" usage="required">
            <description>The object or objects to mix into the theme.</description>
          </parameter>
          <parameter name="doPost" type="Boolean" usage="required">
            <description>If true, run the new theme through the post-processor.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Theme
	The new theme.</return-description>
        <return-types>
          <return-type type="dojox.charting.Theme"/>
        </return-types>
      </method>
      <method name="addMarker" scope="instance">
        <examples>
          <example>	myTheme.addMarker("Ellipse", foo);</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="segment" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_buildMarkerArray" scope="instance"/>
      <method name="__DefineColorArgs" scope="instance">
        <parameters>
          <parameter name="num" type="Number" usage="optional">
            <description>The number of colors to generate.  Defaults to 5.</description>
          </parameter>
          <parameter name="colors" type="Array&lt;String&gt;|Array&lt;dojo.Color&gt;" usage="optional">
            <description>A pre-defined set of colors; this is passed through to the Theme directly.</description>
          </parameter>
          <parameter name="hue" type="Number" usage="optional">
            <description>A hue to base the generated colors from (a number from 0 - 359).</description>
          </parameter>
          <parameter name="saturation" type="Number" usage="optional">
            <description>If a hue is passed, this is used for the saturation value (0 - 100).</description>
          </parameter>
          <parameter name="low" type="Number" usage="optional">
            <description>An optional value to determine the lowest value used to generate a color (HSV model)</description>
          </parameter>
          <parameter name="high" type="Number" usage="optional">
            <description>An optional value to determine the highest value used to generate a color (HSV model)</description>
          </parameter>
          <parameter name="base" type="String|dojo.Color" usage="optional">
            <description>A base color to use if we are defining colors using dojox.color.Palette</description>
          </parameter>
          <parameter name="generator" type="String" usage="optional">
            <description>The generator function name from dojox.color.Palette.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="shapeSpaces" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.shapeSpaces"/>
  <class type="dojox.charting.Theme.__DefineColorArgs">
    <methods/>
  </class>
  <class type="dojox.charting.action2d">
    <methods>
      <method name="__TouchZoomAndPanCtorArgs" scope="instance"/>
      <method name="__TouchIndicatorCtorArgs" scope="instance"/>
      <method name="__TooltipCtorArgs" scope="instance"/>
      <method name="__ShakeCtorArgs" scope="instance"/>
      <method name="__PlotActionCtorArgs" scope="instance">
        <parameters>
          <parameter name="duration" type="Number" usage="optional">
            <description>The amount of time in milliseconds for an animation to last.  Default is 400.</description>
          </parameter>
          <parameter name="easing" type="dojo.fx.easing.*" usage="optional">
            <description>An easing object (see dojo.fx.easing) for use in an animation.  The
	default is dojo.fx.easing.backOut.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__MoveSliceCtorArgs" scope="instance"/>
      <method name="__MouseZoomAndPanCtorArgs" scope="instance"/>
      <method name="__MouseIndicatorCtorArgs" scope="instance"/>
      <method name="__MagnifyCtorArgs" scope="instance"/>
      <method name="__HighlightCtorArgs" scope="instance"/>
      <method name="_IndicatorElement" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_GlassView" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="TouchZoomAndPan" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="Object" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__TouchZoomAndPanCtorArgs" usage="optional">
            <description>Optional arguments for the action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="TouchIndicator" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="Object" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__TouchIndicatorCtorArgs" usage="optional">
            <description>Optional arguments for the chart action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Tooltip" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__TooltipCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Shake" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__ShakeCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="PlotAction" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The name of the plot this action belongs to.  If none is passed &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwargs" type="dojox.charting.action2d.__PlotActionCtorArgs" usage="optional">
            <description>Optional arguments for the action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="MoveSlice" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MoveSliceCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="MouseZoomAndPan" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="Object" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MouseZoomAndPanCtorArgs" usage="optional">
            <description>Optional arguments for the chart action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="MouseIndicator" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="Object" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MouseIndicatorCtorArgs" usage="optional">
            <description>Optional arguments for the chart action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Magnify" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot to apply the action to. If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MagnifyCtorArgs" usage="optional">
            <description>Optional keyword arguments for this action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Highlight" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="charting.action2d.__HighlightCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="ChartAction" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="String|dojox.charting.plot2d.Base" usage="optional">
            <description>Optional target plot for this chart action.  Default is &amp;quot;default&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Base" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="String|dojox.charting.plot2d.Base" usage="optional">
            <description>Optional target plot for this action.  Default is &amp;quot;default&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.action2d.Base">
    <methods>
      <method name="disconnect" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="String|dojox.charting.plot2d.Base" usage="optional">
            <description>Optional target plot for this action.  Default is &amp;quot;default&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.action2d.ChartAction" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="String|dojox.charting.plot2d.Base" usage="optional">
            <description>Optional target plot for this chart action.  Default is &amp;quot;default&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.action2d.__HighlightCtorArgs" superclass="dojox.charting.action2d.__PlotActionCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__PlotActionCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.action2d.Highlight" superclass="dojox.charting.action2d.PlotAction">
    <methods>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the highlighting action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="charting.action2d.__HighlightCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.PlotAction" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight.defaultParams"/>
  <class type="dojox.charting.action2d.Highlight.optionalParams"/>
  <class type="dojox.charting.action2d.PlotAction" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="disconnect" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The name of the plot this action belongs to.  If none is passed &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwargs" type="dojox.charting.action2d.__PlotActionCtorArgs" usage="optional">
            <description>Optional arguments for the action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="overOutEvents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__MagnifyCtorArgs" superclass="dojox.charting.action2d.__PlotActionCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__PlotActionCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.action2d.Magnify" superclass="dojox.charting.action2d.PlotAction">
    <methods>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the magnifying action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot to apply the action to. If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MagnifyCtorArgs" usage="optional">
            <description>Optional keyword arguments for this action.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.PlotAction" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Magnify.defaultParams"/>
  <class type="dojox.charting.action2d.__MouseIndicatorCtorArgs">
    <methods>
      <method name="labelFunc" scope="instance"/>
      <method name="fillFunc" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.action2d.MouseIndicator" superclass="dojox.charting.action2d.ChartAction">
    <methods>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="Object" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MouseIndicatorCtorArgs" usage="optional">
            <description>Optional arguments for the chart action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
      <method name="_onMouseSingle" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_disconnectHandles" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.ChartAction" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.MouseIndicator.defaultParams"/>
  <class type="dojox.charting.action2d.MouseIndicator.optionalParams"/>
  <class type="dojox.charting.action2d.__MouseZoomAndPanCtorArgs">
    <methods/>
  </class>
  <class type="dojox.charting.action2d.MouseZoomAndPan" superclass="dojox.charting.action2d.ChartAction">
    <methods>
      <method name="onMouseWheel" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDoubleClick" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="Object" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MouseZoomAndPanCtorArgs" usage="optional">
            <description>Optional arguments for the chart action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
      <method name="_onZoom" scope="instance">
        <parameters>
          <parameter name="scroll" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_disconnectHandles" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.ChartAction" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.MouseZoomAndPan.defaultParams"/>
  <class type="dojox.charting.action2d.__MoveSliceCtorArgs" superclass="dojox.charting.action2d.__PlotActionCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__PlotActionCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.action2d.MoveSlice" superclass="dojox.charting.action2d.PlotAction">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the slice moving action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MoveSliceCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.PlotAction" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.MoveSlice.defaultParams"/>
  <class type="dojox.charting.action2d.PlotAction.overOutEvents"/>
  <class type="dojox.charting.action2d.__PlotActionCtorArgs">
    <methods/>
  </class>
  <class type="dfe"/>
  <class type="dojox.charting.action2d.__ShakeCtorArgs" superclass="dojox.charting.action2d.__PlotActionCtorArgstorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__PlotActionCtorArgstorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.action2d.Shake" superclass="dojox.charting.action2d.PlotAction">
    <methods>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the slice moving action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__ShakeCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.PlotAction" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Shake.defaultParams"/>
  <class type="dojox.charting.action2d.__TooltipCtorArgs" superclass="dojox.charting.action2d.__PlotActionCtorArgs">
    <methods>
      <method name="text" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__PlotActionCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.action2d.Tooltip" superclass="dojox.charting.action2d.PlotAction">
    <methods>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the highlighting action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__TooltipCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.PlotAction" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Tooltip.defaultParams"/>
  <class type="dojox.charting.action2d.__TouchIndicatorCtorArgs">
    <methods>
      <method name="labelFunc" scope="instance"/>
      <method name="fillFunc" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.action2d.TouchIndicator" superclass="dojox.charting.action2d.ChartAction">
    <methods>
      <method name="onTouchStart" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchMove" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchEnd" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="Object" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__TouchIndicatorCtorArgs" usage="optional">
            <description>Optional arguments for the chart action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
      <method name="_onTouchSingle" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="delayed" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onTouchDual" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.ChartAction" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.TouchIndicator.defaultParams"/>
  <class type="dojox.charting.action2d.TouchIndicator.optionalParams"/>
  <class type="dojox.charting.action2d.TouchIndicator.chart"/>
  <class type="dojox.charting.action2d._GlassView" superclass="Element">
    <methods>
      <method name="render" scope="instance"/>
      <method name="isDirty" scope="instance">
        <return-description>Boolean
	If this plot needs to be rendered, this will return true.</return-description>
      </method>
      <method name="initializeScalers" scope="instance"/>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.action2d._IndicatorElement
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d._IndicatorElement"/>
        </return-types>
      </method>
      <method name="cleanGroup" scope="instance">
        <parameters>
          <parameter name="creator" type="dojox.gfx.Surface" usage="optional">
            <description>An optional surface to work with.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Element" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.action2d.__TouchZoomAndPanCtorArgs">
    <methods/>
  </class>
  <class type="dojox.charting.action2d.TouchZoomAndPan" superclass="dojox.charting.action2d.ChartAction">
    <methods>
      <method name="onTouchStart" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchMove" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchEnd" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDoubleTap" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="Object" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.action2d.__TouchZoomAndPanCtorArgs" usage="optional">
            <description>Optional arguments for the action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
      <method name="_startScroll" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.ChartAction" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.TouchZoomAndPan.defaultParams"/>
  <class type="dojox.charting.action2d.TouchZoomAndPan.chart"/>
  <class type="dojox.charting.action2d._IndicatorElement" superclass="Element">
    <methods>
      <method name="stopTrack" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="isDirty" scope="instance">
        <return-description>Boolean
	If this plot needs to be rendered, this will return true.</return-description>
      </method>
      <method name="initializeScalers" scope="instance"/>
      <method name="initTrack" scope="instance"/>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.action2d._IndicatorElement
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d._IndicatorElement"/>
        </return-types>
      </method>
      <method name="cleanGroup" scope="instance">
        <parameters>
          <parameter name="creator" type="dojox.gfx.Surface" usage="optional">
            <description>An optional surface to work with.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="_updateVisibility" scope="instance">
        <parameters>
          <parameter name="cp" type="Object" usage="required"/>
          <parameter name="limit" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateIndicator" scope="instance">
        <parameters>
          <parameter name="cp1" type="Object" usage="required"/>
          <parameter name="cp2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_trackMove" scope="instance"/>
      <method name="_renderText" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="inter" type="Object" usage="required"/>
          <parameter name="t" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
          <parameter name="c1" type="Object" usage="required"/>
          <parameter name="c2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderIndicator" scope="instance">
        <parameters>
          <parameter name="coord" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="hn" type="Object" usage="required"/>
          <parameter name="vn" type="Object" usage="required"/>
          <parameter name="min" type="Object" usage="required"/>
          <parameter name="max" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getData" scope="instance">
        <parameters>
          <parameter name="cd" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Element" scope="instance"/>
    </mixins>
    <properties>
      <property name="inter" scope="instance-prototype" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d._IndicatorElement.inter">
    <properties>
      <property name="opt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d._IndicatorElement.inter.opt"/>
  <class type="dojox.charting.action2d._IndicatorElement.chart"/>
  <class type="dojox.charting.axis2d">
    <methods>
      <method name="__AxisCtorArgs" scope="instance">
        <parameters>
          <parameter name="vertical" type="Boolean" usage="optional">
            <description>A flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).</description>
          </parameter>
          <parameter name="fixUpper" type="String" usage="optional">
            <description>Align the greatest value on the axis with the specified tick level. Options are &amp;quot;major&amp;quot;, &amp;quot;minor&amp;quot;, &amp;quot;micro&amp;quot;, or &amp;quot;none&amp;quot;.  Defaults to &amp;quot;none&amp;quot;.</description>
          </parameter>
          <parameter name="fixLower" type="String" usage="optional">
            <description>Align the smallest value on the axis with the specified tick level. Options are &amp;quot;major&amp;quot;, &amp;quot;minor&amp;quot;, &amp;quot;micro&amp;quot;, or &amp;quot;none&amp;quot;.  Defaults to &amp;quot;none&amp;quot;.</description>
          </parameter>
          <parameter name="natural" type="Boolean" usage="optional">
            <description>Ensure tick marks are made on &amp;quot;natural&amp;quot; numbers. Defaults to false.</description>
          </parameter>
          <parameter name="leftBottom" type="Boolean" usage="optional">
            <description>The position of a vertical axis; if true, will be placed against the left-bottom corner of the chart.  Defaults to true.</description>
          </parameter>
          <parameter name="includeZero" type="Boolean" usage="optional">
            <description>Include 0 on the axis rendering.  Default is false.</description>
          </parameter>
          <parameter name="fixed" type="Boolean" usage="optional">
            <description>Force all axis labels to be fixed numbers.  Default is true.</description>
          </parameter>
          <parameter name="majorLabels" type="Boolean" usage="optional">
            <description>Flag to draw all labels at major ticks. Default is true.</description>
          </parameter>
          <parameter name="minorTicks" type="Boolean" usage="optional">
            <description>Flag to draw minor ticks on an axis.  Default is true.</description>
          </parameter>
          <parameter name="minorLabels" type="Boolean" usage="optional">
            <description>Flag to draw labels on minor ticks. Default is true.</description>
          </parameter>
          <parameter name="microTicks" type="Boolean" usage="optional">
            <description>Flag to draw micro ticks on an axis. Default is false.</description>
          </parameter>
          <parameter name="htmlLabels" type="Boolean" usage="optional">
            <description>Flag to use HTML (as opposed to the native vector graphics engine) to draw labels. Default is true.</description>
          </parameter>
          <parameter name="min" type="Number" usage="optional">
            <description>The smallest value on an axis. Default is 0.</description>
          </parameter>
          <parameter name="max" type="Number" usage="optional">
            <description>The largest value on an axis. Default is 1.</description>
          </parameter>
          <parameter name="from" type="Number" usage="optional">
            <description>Force the chart to render data visible from this value. Default is 0.</description>
          </parameter>
          <parameter name="to" type="Number" usage="optional">
            <description>Force the chart to render data visible to this value. Default is 1.</description>
          </parameter>
          <parameter name="majorTickStep" type="Number" usage="optional">
            <description>The amount to skip before a major tick is drawn.  Default is 4.</description>
          </parameter>
          <parameter name="minorTickStep" type="Number" usage="optional">
            <description>The amount to skip before a minor tick is drawn. Default is 2.</description>
          </parameter>
          <parameter name="microTickStep" type="Number" usage="optional">
            <description>The amount to skip before a micro tick is drawn. Default is 1.</description>
          </parameter>
          <parameter name="labels" type="Array&lt;Object&gt;" usage="optional">
            <description>An array of labels for major ticks, with corresponding numeric values, ordered by value.</description>
          </parameter>
          <parameter name="labelFunc" type="Function" usage="optional">
            <description>An optional function used to compute label values.</description>
          </parameter>
          <parameter name="maxLabelSize" type="Number" usage="optional">
            <description>The maximum size, in pixels, for a label.  To be used with the optional label function.</description>
          </parameter>
          <parameter name="stroke" type="dojox.gfx.Stroke" usage="optional">
            <description>An optional stroke to be used for drawing an axis.</description>
          </parameter>
          <parameter name="majorTick" type="Object" usage="optional">
            <description>An object containing a dojox.gfx.Stroke, and a length (number) for a major tick.</description>
          </parameter>
          <parameter name="minorTick" type="Object" usage="optional">
            <description>An object containing a dojox.gfx.Stroke, and a length (number) for a minor tick.</description>
          </parameter>
          <parameter name="microTick" type="Object" usage="optional">
            <description>An object containing a dojox.gfx.Stroke, and a length (number) for a micro tick.</description>
          </parameter>
          <parameter name="tick" type="Object" usage="optional">
            <description>An object containing a dojox.gfx.Stroke, and a length (number) for a tick.</description>
          </parameter>
          <parameter name="font" type="String" usage="optional">
            <description>An optional font definition (as used in the CSS font property) for labels.</description>
          </parameter>
          <parameter name="fontColor" type="String|dojo.Color" usage="optional">
            <description>An optional color to be used in drawing labels.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Invisible" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart the axis belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>Any optional keyword arguments to be used to define this axis.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Default" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart the axis belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>Any optional keyword arguments to be used to define this axis.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Base" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this axis belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>An optional arguments object to define the axis parameters.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.axis2d.Base" superclass="dojox.charting.Element">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Base
	A reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Base"/>
        </return-types>
      </method>
      <method name="initialized" scope="instance">
        <return-description>Boolean
	If the axis is initialized or not.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getTicks" scope="instance">
        <return-description>Object
	The ticks object.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getScaler" scope="instance">
        <return-description>Object
	The scaler object (see dojox.charting.scaler.linear for more information)</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getOffsets" scope="instance">
        <return-description>Object
	An object of the form { l, r, t, b }.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this axis belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>An optional arguments object to define the axis parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.axis2d.Base
	A reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Base"/>
        </return-types>
      </method>
      <method name="calculate" scope="instance">
        <parameters>
          <parameter name="min" type="Object" usage="required"/>
          <parameter name="max" type="Object" usage="required"/>
          <parameter name="span" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Base
	A reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Base"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.axis2d.Default" superclass="dojox.charting.axis2d.Invisible">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height}.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="labelTooltip" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
          <parameter name="truncatedLabel" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
          <parameter name="elemType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getOffsets" scope="instance">
        <return-description>Object
	The calculated offsets in the form of { l, r, t, b } (left, right, top, bottom).</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="createText" scope="instance">
        <parameters>
          <parameter name="labelType" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
          <parameter name="align" type="Object" usage="required"/>
          <parameter name="textContent" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
          <parameter name="fontColor" type="Object" usage="required"/>
          <parameter name="labelWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createLine" scope="instance">
        <parameters>
          <parameter name="creator" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart the axis belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>Any optional keyword arguments to be used to define this axis.</description>
          </parameter>
        </parameters>
      </method>
      <method name="cleanGroup" scope="instance">
        <parameters>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.axis2d.Invisible" scope="instance"/>
    </mixins>
    <properties>
      <property name="scaler" scope="instance" type="Object"/>
      <property name="optionalParams" scope="instance" type="Object">
        <description>Any optional parameters needed to define an axis.</description>
      </property>
      <property name="opt" scope="instance-prototype" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object">
        <description>The default parameters used to define any axis.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.defaultParams"/>
  <class type="dojox.charting.axis2d.Default.optionalParams"/>
  <class type="dojox.charting.axis2d.Default.scaler"/>
  <class type="dojox.charting.axis2d.Default.chart.theme"/>
  <class type="dojox.charting.axis2d.Default.opt"/>
  <class type="dojox.charting.axis2d.__AxisCtorArgs">
    <methods>
      <method name="labelFunc" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.axis2d.Invisible" superclass="dojox.charting.axis2d.Base">
    <methods>
      <method name="setWindow" scope="instance">
        <parameters>
          <parameter name="scale" type="Number" usage="required">
            <description>The new scale for the axis.</description>
          </parameter>
          <parameter name="offset" type="Number" usage="required">
            <description>The new offset for the axis.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="initialized" scope="instance">
        <return-description>Boolean
	Whether a scaler has been calculated and if the axis is not dirty.</return-description>
      </method>
      <method name="getWindowScale" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getWindowOffset" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getTicks" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getScaler" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="dependOnData" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart the axis belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>Any optional keyword arguments to be used to define this axis.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="calculate" scope="instance">
        <parameters>
          <parameter name="min" type="Number" usage="required">
            <description>The smallest value represented on this axis.</description>
          </parameter>
          <parameter name="max" type="Number" usage="required">
            <description>The largest value represented on this axis.</description>
          </parameter>
          <parameter name="span" type="Number" usage="required">
            <description>The span in pixels over which axis calculations are made.</description>
          </parameter>
          <parameter name="labels" type="Array&lt;String&gt;" usage="required">
            <description>Optional list of labels.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="_groupLabelWidth" scope="instance">
        <parameters>
          <parameter name="labels" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
          <parameter name="wcLimit" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.axis2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="scaler" scope="instance" type="Object"/>
      <property name="optionalParams" scope="instance" type="Object">
        <description>Any optional parameters needed to define an axis.</description>
      </property>
      <property name="opt" scope="instance-prototype" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object">
        <description>The default parameters used to define any axis.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.defaultParams"/>
  <class type="dojox.charting.axis2d.Invisible.optionalParams"/>
  <class type="dojox.charting.axis2d.Invisible.scaler"/>
  <class type="dojox.charting.axis2d.Invisible.opt"/>
  <class type="dojox.charting.axis2d.Invisible.chart.theme"/>
  <class type="du"/>
  <class type="dojox.charting.plot2d">
    <methods>
      <method name="__PlotCtorArgs" scope="instance"/>
      <method name="__PieCtorArgs" scope="instance"/>
      <method name="__GridCtorArgs" scope="instance"/>
      <method name="__DefaultCtorArgs" scope="instance"/>
      <method name="__BarCtorArgs" scope="instance"/>
      <method name="_PlotEvents" scope="instance"/>
      <method name="StackedLines" scope="instance"/>
      <method name="StackedColumns" scope="instance"/>
      <method name="StackedBars" scope="instance"/>
      <method name="StackedAreas" scope="instance"/>
      <method name="Stacked" scope="instance"/>
      <method name="Spider" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Scatter" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define this plot's parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Pie" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="OHLC" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="MarkersOnly" scope="instance"/>
      <method name="Markers" scope="instance"/>
      <method name="Lines" scope="instance"/>
      <method name="Grid" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__GridCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the parameters of the underlying grid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Default" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional">
            <description>An optional arguments object to help define this plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Columns" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="ClusteredColumns" scope="instance"/>
      <method name="ClusteredBars" scope="instance"/>
      <method name="Candlesticks" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Bubble" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional">
            <description>Optional keyword arguments object to help define plot parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Base" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.chart.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__PlotCtorArgs" usage="optional">
            <description>An optional arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Bars" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Areas" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.plot2d.Areas" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
    <properties>
      <property name="opt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Areas.opt"/>
  <class type="dojox.charting.plot2d.Default" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Default
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Default"/>
        </return-types>
      </method>
      <method name="createPath" scope="instance">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional">
            <description>An optional arguments object to help define this plot.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.__BarCtorArgs" superclass="dojox.charting.plot2d.__DefaultCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__DefaultCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Bars" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Bars
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Bars"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="createRect" scope="instance">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_animateBar" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="hoffset" type="Object" usage="required"/>
          <parameter name="hsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars.defaultParams"/>
  <class type="dojox.charting.plot2d.Bars.optionalParams"/>
  <class type="dojox.charting.plot2d.Bars.chart"/>
  <class type="dojox.charting.plot2d.Base" superclass="dojox.charting.Element">
    <methods>
      <method name="toPage" scope="instance">
        <parameters>
          <parameter name="coord" type="Object" usage="optional">
            <description>The coordinates in plot axis data coordinate space. For cartesian charts that is of the following form:
	`{ hAxisName: 50, vAxisName: 200 }`
	If not provided return the tranform method instead of the result of the transformation.</description>
          </parameter>
        </parameters>
        <return-description>Object
	The resulting page pixel coordinates. That is of the following form:
	`{ x: 50, y: 200 }`</return-description>
      </method>
      <method name="toData" scope="instance">
        <parameters>
          <parameter name="coord" type="Object" usage="required">
            <description>The pixel coordinate in page coordinate space. That is of the following form:
	`{ x: 50, y: 200 }`
	If not provided return the tranform method instead of the result of the transformation.</description>
          </parameter>
        </parameters>
        <return-description>Object
	The resulting plot axis data coordinates. For cartesian charts that is of the following form:
	`{ hAxisName: 50, vAxisName: 200 }`</return-description>
      </method>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="dojox.charting.axis2d.Base" usage="required">
            <description>The axis to set.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="performZoom" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <return-description>Boolean
	The state of the plot.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isDataDirty" scope="instance">
        <return-description>Boolean
	Flag indicating if any of this plot's series are invalid and need rendering.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="initializeScalers" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>Size of a plot area in pixels as {width, height}.</description>
          </parameter>
          <parameter name="stats" type="Object" usage="required">
            <description>Min/max of data in both directions as {hmin, hmax, vmin, vmax}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="getRequiredColors" scope="instance">
        <return-description>Number
	The number of colors needed.</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.chart.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__PlotCtorArgs" usage="optional">
            <description>An optional arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="calculateAxes" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="dojox.charting.Series" usage="required">
            <description>The series to be added.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d._PlotEvents.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
      <mixin type="dojox.charting.plot2d._PlotEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="chart" scope="instance" type="Object"/>
      <property name="_vScaler" scope="instance" type="Object"/>
      <property name="_vAxis" scope="instance" type="Object"/>
      <property name="_hScaler" scope="instance" type="Object"/>
      <property name="_hAxis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base.chart"/>
  <class type="dojox.charting.plot2d.Base._vAxis"/>
  <class type="dojox.charting.plot2d.Base._hAxis"/>
  <class type="dojox.charting.plot2d.Base._hScaler"/>
  <class type="dojox.charting.plot2d.Base._vScaler"/>
  <class type="dojox.charting.plot2d._PlotEvents">
    <methods>
      <method name="resetEvents" scope="instance"/>
      <method name="raiseEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required">
            <description>An object intended to represent event parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="plotEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required">
            <description>An object intended to represent event parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fireEvent" scope="instance">
        <parameters>
          <parameter name="seriesName" type="String" usage="required">
            <description>Series name.</description>
          </parameter>
          <parameter name="eventName" type="String" usage="required">
            <description>Event name to emulate.</description>
          </parameter>
          <parameter name="index" type="Number" usage="required">
            <description>Valid data value index used to raise an event.</description>
          </parameter>
          <parameter name="eventObject" type="Object" usage="optional">
            <description>Optional event object. Especially useful for synthetic events.
	Default: null.</description>
          </parameter>
        </parameters>
      </method>
      <method name="events" scope="instance">
        <return-description>Boolean
	A flag indicating that there are handlers attached.</return-description>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to connect to.</description>
          </parameter>
          <parameter name="method" type="String|Function" usage="required">
            <description>The method to fire when our plotEvent is fired.</description>
          </parameter>
        </parameters>
        <return-description>Array
	The handle as returned from dojo.connect (see dojo.connect).</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_reconnectEvents" scope="instance">
        <parameters>
          <parameter name="seriesName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectSingleEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="eventName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectEvents" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.plot2d.Bubble" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Bubble
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Bubble"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional">
            <description>Optional keyword arguments object to help define plot parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_animateBubble" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble.defaultParams"/>
  <class type="dojox.charting.plot2d.Bubble.optionalParams"/>
  <class type="dojox.charting.plot2d.Bubble.chart"/>
  <class type="dojox.charting.plot2d.Candlesticks" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Candlesticks
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Candlesticks"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="collectStats" scope="instance">
        <parameters>
          <parameter name="series" type="Array&lt;dojox.charting.Series&gt;" usage="required">
            <description>The data series array to be drawn on this plot.</description>
          </parameter>
        </parameters>
        <return-description>Object
	Returns an object in the form of { hmin, hmax, vmin, vmax }.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_animateCandlesticks" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="voffset" type="Object" usage="required"/>
          <parameter name="vsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Candlesticks.defaultParams"/>
  <class type="dojox.charting.plot2d.Candlesticks.optionalParams"/>
  <class type="dojox.charting.plot2d.Candlesticks.chart"/>
  <class type="dojox.charting.plot2d.ClusteredBars" superclass="dojox.charting.plot2d.Bars">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.ClusteredBars
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.ClusteredBars"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Bars" scope="instance"/>
    </mixins>
    <properties>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredBars.chart"/>
  <class type="dojox.charting.plot2d.ClusteredColumns" superclass="dojox.charting.plot2d.Columns">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.ClusteredColumns
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.ClusteredColumns"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Columns" scope="instance"/>
    </mixins>
    <properties>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredColumns.chart"/>
  <class type="dojox.charting.plot2d.Columns" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Columns
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Columns"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="createRect" scope="instance">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_animateColumn" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="voffset" type="Object" usage="required"/>
          <parameter name="vsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns.defaultParams"/>
  <class type="dojox.charting.plot2d.Columns.optionalParams"/>
  <class type="dojox.charting.plot2d.Columns.chart"/>
  <class type="dojox.charting.plot2d.__DefaultCtorArgs" superclass="dojox.charting.plot2d.__PlotCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__PlotCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Default.defaultParams"/>
  <class type="dojox.charting.plot2d.Default.optionalParams"/>
  <class type="dojox.charting.plot2d.Default.chart"/>
  <class type="dojox.charting.plot2d.__GridCtorArgs" superclass="dojox.charting.plot2d.__DefaultCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__DefaultCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Grid" superclass="dojox.charting.plot2d.Element">
    <methods>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="performZoom" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <return-description>Boolean
	If this plot needs to be rendered, this will return true.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="initializeScalers" scope="instance"/>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="getRequiredColors" scope="instance">
        <return-description>Number
	Returns 0, since there are no series associated with this plot type.</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="createLine" scope="instance">
        <parameters>
          <parameter name="creator" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__GridCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the parameters of the underlying grid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Grid
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="cleanGroup" scope="instance"/>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="_animateGrid" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Element" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="_vAxis" scope="instance" type="Object"/>
      <property name="_hAxis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid.defaultParams"/>
  <class type="dojox.charting.plot2d.Grid._vAxis"/>
  <class type="dojox.charting.plot2d.Grid._hAxis"/>
  <class type="dojox.charting.plot2d.Grid.chart.theme"/>
  <class type="dojox.charting.plot2d.Lines" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
    <properties>
      <property name="opt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Lines.opt"/>
  <class type="dojox.charting.plot2d.Markers" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
    <properties>
      <property name="opt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Markers.opt"/>
  <class type="dojox.charting.plot2d.MarkersOnly" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
    <properties>
      <property name="opt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.MarkersOnly.opt"/>
  <class type="dojox.charting.plot2d.OHLC" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.OHLC
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.OHLC"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="collectStats" scope="instance">
        <parameters>
          <parameter name="series" type="Array&lt;dojox.charting.Series&gt;" usage="required">
            <description>The data series array to be drawn on this plot.</description>
          </parameter>
        </parameters>
        <return-description>Object
	Returns an object in the form of { hmin, hmax, vmin, vmax }.</return-description>
      </method>
      <method name="_animateOHLC" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="voffset" type="Object" usage="required"/>
          <parameter name="vsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.OHLC.defaultParams"/>
  <class type="dojox.charting.plot2d.OHLC.optionalParams"/>
  <class type="dojox.charting.plot2d.OHLC.chart"/>
  <class type="dojox.charting.plot2d.__PieCtorArgs" superclass="dojox.charting.plot2d.__DefaultCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__DefaultCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Pie" superclass="dojox.charting.Element">
    <methods>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Pie
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Pie
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="continue"/>
          <return-type type="stop iteration"/>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="initializeScalers" scope="instance"/>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="getRequiredColors" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Pie
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Pie
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="_getProperLabelRadius" scope="instance">
        <parameters>
          <parameter name="slices" type="Object" usage="required"/>
          <parameter name="labelHeight" type="Object" usage="required"/>
          <parameter name="minRidius" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calculateLabelR" scope="instance">
        <parameters>
          <parameter name="firstSlice" type="Object" usage="required"/>
          <parameter name="slices" type="Object" usage="required"/>
          <parameter name="labelHeight" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d._PlotEvents.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
      <mixin type="dojox.charting.plot2d._PlotEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="run" scope="instance-prototype" type="Object"/>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.defaultParams"/>
  <class type="dojox.charting.plot2d.Pie.optionalParams"/>
  <class type="dojox.charting.plot2d.Pie.chart"/>
  <class type="dojox.charting.plot2d.Pie.opt"/>
  <class type="dojox.charting.plot2d.Pie.run"/>
  <class type="dojox.charting.plot2d.Scatter" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Scatter
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Scatter"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define this plot's parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_animateScatter" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter.defaultParams"/>
  <class type="dojox.charting.plot2d.Scatter.optionalParams"/>
  <class type="dojox.charting.plot2d.Scatter.chart"/>
  <class type="dojox.charting.plot2d.Spider" superclass="dojox.charting.Element">
    <methods>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Spider
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Spider"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Spider
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Spider"/>
        </return-types>
      </method>
      <method name="plotEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required">
            <description>An object intended to represent event parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="initializeScalers" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>Size of a plot area in pixels as {width, height}.</description>
          </parameter>
          <parameter name="stats" type="Object" usage="required">
            <description>Min/max of data in both directions as {hmin, hmax, vmin, vmax}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="getRequiredColors" scope="instance">
        <return-description>Number
	The number of colors needed.</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Spider
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Spider"/>
        </return-types>
      </method>
      <method name="calculateAxes" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="dojox.charting.Series" usage="required">
            <description>The series to be added.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="_getObjectLength" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCoordinate" scope="instance">
        <parameters>
          <parameter name="circle" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="angle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBoundary" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_drawArrow" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createSeriesEntry" scope="instance">
        <parameters>
          <parameter name="ts" type="Object" usage="required"/>
          <parameter name="osps" type="Object" usage="required"/>
          <parameter name="sps" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="sk" type="Object" usage="required"/>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="ro" type="Object" usage="required"/>
          <parameter name="ms" type="Object" usage="required"/>
          <parameter name="at" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildPoints" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="circle" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="angle" type="Object" usage="required"/>
          <parameter name="recursive" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d._PlotEvents.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
      <mixin type="dojox.charting.plot2d._PlotEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="opt" scope="instance-prototype" type="Object"/>
      <property name="defaultParams" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.defaultParams"/>
  <class type="dojox.charting.plot2d.Spider.optionalParams"/>
  <class type="dojox.charting.plot2d.Spider.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.chart.theme"/>
  <class type="dojox.charting.plot2d.Spider.opt"/>
  <class type="dojox.charting.plot2d.Stacked" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Stacked
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Stacked"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
    <properties>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Stacked.chart"/>
  <class type="dojox.charting.plot2d.StackedAreas" superclass="dojox.charting.plot2d.Stacked">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Stacked" scope="instance"/>
    </mixins>
    <properties>
      <property name="opt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedAreas.opt"/>
  <class type="dojox.charting.plot2d.StackedBars" superclass="Bars">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.StackedBars
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.StackedBars"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Bars" scope="instance"/>
    </mixins>
    <properties>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedBars.chart"/>
  <class type="dojox.charting.plot2d.StackedColumns" superclass="dojox.charting.plot2d.Columns">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.StackedColumns
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.StackedColumns"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Columns" scope="instance"/>
    </mixins>
    <properties>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedColumns.chart"/>
  <class type="dojox.charting.plot2d.StackedLines" superclass="dojox.charting.plot2d.Stacked">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Stacked" scope="instance"/>
    </mixins>
    <properties>
      <property name="opt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedLines.opt"/>
  <class type="dojox.charting.plot3d">
    <methods>
      <method name="Cylinders" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Base" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Bars" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.plot3d.Bars" superclass="dojox.charting.plot3d.Base">
    <methods>
      <method name="getDepth" scope="instance"/>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot3d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="material" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Bars.material"/>
  <class type="dojox.charting.plot3d.Base">
    <methods>
      <method name="setData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="instance"/>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.plot3d.Cylinders" superclass="dojox.charting.plot3d.Base">
    <methods>
      <method name="getDepth" scope="instance"/>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot3d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="material" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Cylinders.material"/>
  <class type="dojox.charting.scaler"/>
  <class type="common"/>
  <class type="themes">
    <properties>
      <property name="Tom" scope="instance" type="Object"/>
      <property name="ThreeD" scope="instance" type="Object"/>
      <property name="Renkoo" scope="instance" type="Object"/>
      <property name="Electric" scope="instance" type="Object"/>
      <property name="Claro" scope="instance" type="Object"/>
      <property name="Chris" scope="instance" type="Object"/>
      <property name="Charged" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes">
    <properties>
      <property name="PlotKit" scope="instance" type="Object"/>
      <property name="Julie" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Theme"/>
  <class type="themes.Charged">
    <methods>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="themes.Chris">
    <methods>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="themes.Claro">
    <methods>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="themes.Electric">
    <methods>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Julie">
    <methods>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.PlotKit"/>
  <class type="pk">
    <properties>
      <property name="red" scope="instance" type="Object"/>
      <property name="purple" scope="instance" type="Object"/>
      <property name="orange" scope="instance" type="Object"/>
      <property name="green" scope="instance" type="Object"/>
      <property name="cyan" scope="instance" type="Object"/>
      <property name="blue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="pk.blue.chart"/>
  <class type="pk.blue.plotarea"/>
  <class type="pk.blue">
    <properties>
      <property name="plotarea" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="pk.cyan.chart"/>
  <class type="pk.cyan.plotarea"/>
  <class type="pk.cyan">
    <properties>
      <property name="plotarea" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="pk.green.chart"/>
  <class type="pk.green.plotarea"/>
  <class type="pk.green">
    <properties>
      <property name="plotarea" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="pk.orange.chart"/>
  <class type="pk.orange.plotarea"/>
  <class type="pk.orange">
    <properties>
      <property name="plotarea" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="pk.purple.chart"/>
  <class type="pk.purple.plotarea"/>
  <class type="pk.purple">
    <properties>
      <property name="plotarea" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="pk.red.chart"/>
  <class type="pk.red.plotarea"/>
  <class type="pk.red">
    <properties>
      <property name="plotarea" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="themes.Renkoo">
    <methods>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="themes.ThreeD.series">
    <properties>
      <property name="shadow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="themes.ThreeD.series.shadow"/>
  <class type="themes.ThreeD">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="series" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="themes.Tom">
    <methods>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="Legend">
    <description>Since dojox.charting.widget.Legend inherits from _Widget use the bidi support
	that introduced there.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setTextDirAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('textDir', value)</description>
        <parameters>
          <parameter name="textDir" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="Legend.postMixInProperties">
    <methods/>
  </class>
  <class type="Chart.postMixInProperties">
    <methods/>
  </class>
  <class type="dojox.charting.widget">
    <methods>
      <method name="Sparkline" scope="instance"/>
      <method name="SelectableLegend" scope="instance"/>
      <method name="Legend" scope="instance"/>
      <method name="Chart" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.widget.Chart" superclass="dijit._Widget">
    <methods>
      <method name="resize" scope="instance">
        <description>Resize the domNode and the widget surface to the dimensions of a box of the following form:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	If no box is provided, resize the surface to the marginBox of the domNode.</description>
        <parameters>
          <parameter name="box" type="If" usage="required">
            <description>passed, denotes the new size of the widget.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Chart.domNode"/>
  <class type="dojox.charting.widget.Legend" superclass="dijit._Widget">
    <methods>
      <method name="refresh" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_makeIcon" scope="instance">
        <parameters>
          <parameter name="div" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isReversal" scope="instance"/>
      <method name="_addLabel" scope="instance">
        <parameters>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.widget.SelectableLegend" superclass="dojox.charting.widget.Legend">
    <methods>
      <method name="refresh" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_toggle" scope="instance">
        <parameters>
          <parameter name="shapes" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="isOff" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="seriesName" type="Object" usage="required"/>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isPie" scope="instance"/>
      <method name="_highlight" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="iconShape" type="Object" usage="required"/>
          <parameter name="shapes" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="isOff" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="seriesName" type="Object" usage="required"/>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getTransitionFill" scope="instance">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFilledShape" scope="instance">
        <parameters>
          <parameter name="shapes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAnim" scope="instance">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyEvents" scope="instance"/>
      <method name="_addLabel" scope="instance">
        <parameters>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.widget.Legend" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.widget.Sparkline" superclass="dojox.charting.widget.Chart">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.widget.Chart" scope="instance"/>
    </mixins>
    <properties>
      <property name="margins" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Sparkline.margins"/>
  <class type="dojox.collections">
    <methods>
      <method name="Stack" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
          <return-type type="dojox.collections.Iterator"/>
          <return-type type="object"/>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="SortedList" scope="instance">
        <parameters>
          <parameter name="dictionary" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.SortedList"/>
          <return-type type="bool"/>
          <return-type type="dojox.collections.DictionaryEntry"/>
          <return-type type="object"/>
          <return-type type="dojox.collections.DictionaryIterator"/>
          <return-type type="array"/>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="Queue" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.Queue"/>
          <return-type type="bool"/>
          <return-type type="object"/>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="Iterator" scope="instance">
        <parameters>
          <parameter name="a" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="DictionaryIterator" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="DictionaryEntry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="Dictionary" scope="instance">
        <parameters>
          <parameter name="dictionary" type="dojox.collections.Dictionary" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.Dictionary"/>
          <return-type type="bool"/>
          <return-type type="dojox.collections.DictionaryEntry"/>
          <return-type type="object"/>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="BinaryTree" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ArrayList" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.ArrayList"/>
          <return-type type="bool"/>
          <return-type type="dojox.collections.Iterator"/>
          <return-type type="int"/>
          <return-type type="object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.collections.ArrayList">
    <methods>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="delim" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="toArray" scope="instance"/>
      <method name="sort" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="optional"/>
        </parameters>
      </method>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="reverse" scope="instance"/>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="indexOf" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.ArrayList"/>
        </return-types>
      </method>
      <method name="clear" scope="instance"/>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="a" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.collections.BinaryTree">
    <methods>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="order" type="Object" usage="required"/>
          <parameter name="sep" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="search" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance"/>
      <method name="deleteData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance"/>
      <method name="clear" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="TraversalMethods" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.BinaryTree.TraversalMethods"/>
  <class type="dojox.collections.Dictionary">
    <methods>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getValueList" scope="instance"/>
      <method name="getKeyList" scope="instance"/>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="contains" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Dictionary"/>
        </return-types>
      </method>
      <method name="clear" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.collections.Queue">
    <methods>
      <method name="toArray" scope="instance"/>
      <method name="peek" scope="instance"/>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="enqueue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="dequeue" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Queue"/>
        </return-types>
      </method>
      <method name="clear" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.collections.SortedList">
    <methods>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="indexOfValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="indexOfKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getValueList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getKeyList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getKey" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="getByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="contains" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.SortedList"/>
        </return-types>
      </method>
      <method name="clear" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.collections.Stack">
    <methods>
      <method name="toArray" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="push" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="pop" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="peek" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="clone" scope="instance"/>
      <method name="clear" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.collections.DictionaryEntry">
    <methods>
      <method name="valueOf" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.collections.Iterator">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.collections.DictionaryIterator">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.color">
    <methods>
      <method name="fromXYZ" scope="instance">
        <parameters>
          <parameter name="xyz" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="fromHsv" scope="instance">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="value" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromHsl" scope="instance">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="luminosity" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromCmyk" scope="instance">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
          <parameter name="black" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromCmy" scope="instance">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="Color" scope="instance"/>
    </methods>
    <properties>
      <property name="Palette" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color.Color">
    <methods>
      <method name="toXYZ" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dxc">
    <methods>
      <method name="Palette" scope="instance">
        <description>A Palette is a representation of a set of colors.  While the standard
	number of colors contained in a palette is 5, it can really handle any
	number of colors.
	
	A palette is useful for the ability to transform all the colors in it
	using a simple object-based approach.  In addition, you can generate
	palettes using dojox.color.Palette.generate; these generated palettes
	are based on the palette generators at http://kuler.adobe.com.</description>
        <parameters>
          <parameter name="base" type="String|Array|dojox.color.Color|dojox.color.Palette" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dxc.Palette">
    <description>A Palette is a representation of a set of colors.  While the standard
	number of colors contained in a palette is 5, it can really handle any
	number of colors.
	
	A palette is useful for the ability to transform all the colors in it
	using a simple object-based approach.  In addition, you can generate
	palettes using dojox.color.Palette.generate; these generated palettes
	are based on the palette generators at http://kuler.adobe.com.</description>
    <methods>
      <method name="transform" scope="instance">
        <description>{palette}.transform is a simple way to uniformly transform
	all of the colors in a palette using any of 5 formulae:
	RGBA, HSL, HSV, CMYK or CMY.
	
	Once the forumula to be used is determined, you can pass any
	number of parameters based on the formula "d"[param]; for instance,
	{ use: "rgba", dr: 20, dg: -50 } will take all of the colors in
	palette, add 20 to the R value and subtract 50 from the G value.
	
	Unlike other types of transformations, transform does *not* alter
	the original palette but will instead return a new one.</description>
        <parameters>
          <parameter name="kwArgs" type="dojox.color.Palette.__transformArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="base" type="String|dojox.color.Color" usage="required"/>
          <parameter name="type" type="Function|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="generators" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dxc.Palette.generators">
    <methods>
      <method name="triadic" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="splitComplementary" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__splitComplementaryArgs" usage="required"/>
        </parameters>
      </method>
      <method name="shades" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="monochromatic" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="compound" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="complementary" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="analogous" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__analogousArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.color.Palette">
    <methods>
      <method name="__transformArgs" scope="instance">
        <parameters>
          <parameter name="use" type="String" usage="optional">
            <description>Specify the color model to use for the transformation.  Can be &amp;quot;rgb&amp;quot;, &amp;quot;rgba&amp;quot;, &amp;quot;hsv&amp;quot;, &amp;quot;hsl&amp;quot;, &amp;quot;cmy&amp;quot;, &amp;quot;cmyk&amp;quot;.</description>
          </parameter>
          <parameter name="dr" type="Number" usage="optional">
            <description>The delta to be applied to the red aspect of the RGB/RGBA color model.</description>
          </parameter>
          <parameter name="dg" type="Number" usage="optional">
            <description>The delta to be applied to the green aspect of the RGB/RGBA color model.</description>
          </parameter>
          <parameter name="db" type="Number" usage="optional">
            <description>The delta to be applied to the blue aspect of the RGB/RGBA color model.</description>
          </parameter>
          <parameter name="da" type="Number" usage="optional">
            <description>The delta to be applied to the alpha aspect of the RGBA color model.</description>
          </parameter>
          <parameter name="dc" type="Number" usage="optional">
            <description>The delta to be applied to the cyan aspect of the CMY/CMYK color model.</description>
          </parameter>
          <parameter name="dm" type="Number" usage="optional">
            <description>The delta to be applied to the magenta aspect of the CMY/CMYK color model.</description>
          </parameter>
          <parameter name="dy" type="Number" usage="optional">
            <description>The delta to be applied to the yellow aspect of the CMY/CMYK color model.</description>
          </parameter>
          <parameter name="dk" type="Number" usage="optional">
            <description>The delta to be applied to the black aspect of the CMYK color model.</description>
          </parameter>
          <parameter name="dh" type="Number" usage="optional">
            <description>The delta to be applied to the hue aspect of the HSL/HSV color model.</description>
          </parameter>
          <parameter name="ds" type="Number" usage="optional">
            <description>The delta to be applied to the saturation aspect of the HSL/HSV color model.</description>
          </parameter>
          <parameter name="dv" type="Number" usage="optional">
            <description>The delta to be applied to the value aspect of the HSV color model.</description>
          </parameter>
          <parameter name="dl" type="Number" usage="optional">
            <description>The delta to be applied to the luminosity aspect of the HSL color model.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__splitComplementaryArgs" scope="instance">
        <parameters>
          <parameter name="base" type="dojo.Color" usage="required">
            <description>The base color to be used to generate the palette.</description>
          </parameter>
          <parameter name="da" type="Number" usage="optional">
            <description>The delta angle to be used to determine where the split for the complementary rules happen.
	In degrees, the default is 30.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__generatorArgs" scope="instance">
        <parameters>
          <parameter name="base" type="dojo.Color" usage="required">
            <description>The base color to be used to generate the palette.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__analogousArgs" scope="instance">
        <parameters>
          <parameter name="base" type="dojo.Color" usage="required">
            <description>The base color to be used to generate the palette.</description>
          </parameter>
          <parameter name="high" type="Number" usage="optional">
            <description>The difference between the hue of the base color and the highest hue.  In degrees, default is 60.</description>
          </parameter>
          <parameter name="low" type="Number" usage="optional">
            <description>The difference between the hue of the base color and the lowest hue.  In degrees, default is 18.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.color.Palette.__transformArgs">
    <methods/>
  </class>
  <class type="dojox.color.Palette.__generatorArgs">
    <methods/>
  </class>
  <class type="dojox.color.Palette.__analogousArgs">
    <methods/>
  </class>
  <class type="dojox.color.Palette.__splitComplementaryArgs">
    <methods/>
  </class>
  <class type="dojox.cometd">
    <methods>
      <method name="timesync" scope="instance"/>
      <method name="longPollTransportJsonEncoded" scope="instance"/>
      <method name="longPollTransportFormEncoded" scope="instance"/>
      <method name="callbackPollTransport" scope="instance"/>
      <method name="_ack" scope="instance"/>
      <method name="RestChannels" scope="instance">
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <description>arguments:
	The *autoSubscribeRoot* parameter:
	When this is set, all REST service requests that have this
	prefix will be auto-subscribed. The default is '/' (all REST requests).
	The *url* parameter:
	This is the url to connect to for server-sent messages. The default
	is &amp;quot;/channels&amp;quot;.
	The *autoReconnectTime* parameter:
	This is amount time to wait to reconnect with a connection is broken
	The *reloadDataOnReconnect* parameter:
	This indicates whether RestChannels should re-download data when a connection
	is restored (value of true), or if it should re-subscribe with retroactive subscriptions
	(Subscribe-Since header) using HEAD requests (value of false). The
	default is true.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Connection" scope="instance">
        <parameters>
          <parameter name="prefix" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.cometd.RestChannels">
    <methods>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>the uri for the resource you want to monitor</description>
          </parameter>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional">
            <description>See dojo.xhr
	
	headers:
	These are the headers to be applied to the channel subscription request
	
	callback:
	This will be called when a event occurs for the channel
	The callback will be called with a single argument:
		callback(message)
	where message is an object that follows the XHR API:
	status : Http status
	statusText : Http status text
	getAllResponseHeaders() : The response headers
	getResponseHeaders(headerName) : Retrieve a header by name
	responseText : The response body as text
	with the following additional Bayeux properties
	data : The response body as JSON
	channel : The channel/url of the response</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="don't process the response, the response will be received in the main channels response"/>
        </return-types>
      </method>
      <method name="receive" scope="instance">
        <parameters>
          <parameter name="message" type="A" usage="required">
            <description>cometd/XHR message</description>
          </parameter>
        </parameters>
      </method>
      <method name="publish" scope="instance">
        <description>This does a simple POST operation to the provided URL,
	POST is the semantic equivalent of publishing a message within REST/Channels</description>
        <parameters>
          <parameter name="channel" type="Channel" usage="required">
            <description>path to publish to</description>
          </parameter>
          <parameter name="data" type="data" usage="required">
            <description>to publish</description>
          </parameter>
        </parameters>
      </method>
      <method name="open" scope="instance">
        <description>Note that if there is no connection open, this is automatically called when you do a subscription,
	it is often not necessary to call this</description>
        <return-types>
          <return-type type="this can be called after dojo is unloaded, just do nothing in that case"/>
        </return-types>
      </method>
      <method name="onprogress" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="contentType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="disconnected" scope="instance"/>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <description>arguments:
	The *autoSubscribeRoot* parameter:
	When this is set, all REST service requests that have this
	prefix will be auto-subscribed. The default is '/' (all REST requests).
	The *url* parameter:
	This is the url to connect to for server-sent messages. The default
	is &amp;quot;/channels&amp;quot;.
	The *autoReconnectTime* parameter:
	This is amount time to wait to reconnect with a connection is broken
	The *reloadDataOnReconnect* parameter:
	This indicates whether RestChannels should re-download data when a connection
	is restored (value of true), or if it should re-subscribe with retroactive subscriptions
	(Subscribe-Since header) using HEAD requests (value of false). The
	default is true.</description>
          </parameter>
        </parameters>
      </method>
      <method name="absoluteUrl" scope="instance">
        <parameters>
          <parameter name="baseUrl" type="Object" usage="required"/>
          <parameter name="relativeUrl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_send" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="indicate an error"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.cometd.Connection">
    <methods>
      <method name="unsubscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>name of the cometd channel to unsubscribe from</description>
          </parameter>
          <parameter name="objOrFunc" type="Object" usage="optional">
            <description>an object scope for funcName or the name or reference to a
	function to be called when messages are delivered to the
	channel. If null then all subscribers to the channel are unsubscribed.</description>
          </parameter>
          <parameter name="funcName" type="String" usage="optional">
            <description>the second half of the objOrFunc/funcName pair for identifying
	a callback function to notifiy upon channel message delivery</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="tunnelInit" scope="instance">
        <parameters>
          <parameter name="childLocation" type="Object" usage="required"/>
          <parameter name="childDomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="subscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <description>`dojox.cometd.subscribe()` handles all the hard work of telling
	the server that we want to be notified when events are
	published on a particular topic. `subscribe` accepts a function
	to handle messages and returns a `dojo.Deferred` object which
	has an extra property added to it which makes it suitable for
	passing to `dojox.cometd.unsubscribe()` as a "subscription
	handle" (much like the handle object that `dojo.connect()`
	produces and which `dojo.disconnect()` expects).
	
	Note that of a subscription is registered before a connection
	with the server is established, events sent before the
	connection is established will not be delivered to this client.
	The deferred object which `subscribe` returns will callback
	when the server successfuly acknolwedges receipt of our
	"subscribe" request.</description>
        <examples>
          <example>Simple subscribe use-case
		dojox.cometd.init("http://myserver.com:8080/cometd");
		// log out all incoming messages on /foo/bar
		dojox.cometd.subscribe("/foo/bar", console, "debug");</example>
          <example>Subscribe before connection is initialized
		dojox.cometd.subscribe("/foo/bar", console, "debug");
		dojox.cometd.init("http://myserver.com:8080/cometd");</example>
          <example>Subscribe an unsubscribe
		dojox.cometd.init("http://myserver.com:8080/cometd");
		var h = dojox.cometd.subscribe("/foo/bar", console, "debug");
		dojox.cometd.unsubscribe(h);</example>
          <example>Listen for successful subscription:
		dojox.cometd.init("http://myserver.com:8080/cometd");
		var h = dojox.cometd.subscribe("/foo/bar", console, "debug");
		h.addCallback(function(){
			console.debug("subscription to /foo/bar established");
		});</example>
        </examples>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>name of the cometd channel to subscribe to</description>
          </parameter>
          <parameter name="objOrFunc" type="Object" usage="required">
            <description>an object scope for funcName or the name or reference to a
	function to be called when messages are delivered to the
	channel</description>
          </parameter>
          <parameter name="funcName" type="String" usage="required">
            <description>the second half of the objOrFunc/funcName pair for identifying
	a callback function to notifiy upon channel message delivery</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="state" scope="instance"/>
      <method name="startBatch" scope="instance"/>
      <method name="publish" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>the destination channel for the message</description>
          </parameter>
          <parameter name="data" type="Object" usage="required">
            <description>a JSON object containing the message &amp;quot;payload&amp;quot;
	properties:
	Optional. Other meta-data to be mixed into the top-level of the
	message</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <description>Initialize the cometd implementation of the Bayeux protocol by
	sending a handshake message. The cometd state will be changed to CONNECTING
	until a handshake response is received and the first successful connect message
	has returned.
	The protocol state changes may be monitored
	by subscribing to the dojo topic "/prefix/meta" (typically "/cometd/meta") where
	events are published in the form
	{cometd:this,action:"handshake",successful:true,state:this.state()}</description>
        <examples>
          <example>	dojox.cometd.init("/cometd");
		dojox.cometd.init("http://xdHost/cometd",{ext:{user:"fred",pwd:"secret"}});</example>
        </examples>
        <parameters>
          <parameter name="root" type="String" usage="required">
            <description>The URL of the cometd server. If the root is absolute, the host
	is examined to determine if xd transport is needed. Otherwise the
	same domain is assumed.</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional">
            <description>An optional object that is used as the basis of the handshake message</description>
          </parameter>
          <parameter name="bargs" type="Object" usage="optional">
            <description>An optional object of bind args mixed in with the send of the handshake</description>
          </parameter>
        </parameters>
      </method>
      <method name="endBatch" scope="instance"/>
      <method name="disconnect" scope="instance">
        <description>Disconnect from the server by sending a disconnect message</description>
        <examples>
          <example>	dojox.cometd.disconnect();</example>
        </examples>
      </method>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sendMessage" scope="instance">
        <parameters>
          <parameter name="message" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_publishMeta" scope="instance">
        <parameters>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="successful" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnload" scope="instance"/>
      <method name="_interval" scope="instance"/>
      <method name="_finishInit" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_extendOut" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_extendIn" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectTimeout" scope="instance"/>
      <method name="_backon" scope="instance"/>
      <method name="_backoff" scope="instance"/>
    </methods>
    <properties>
      <property name="currentTransport" scope="instance" type="Object"/>
      <property name="_advice" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.Connection._advice"/>
  <class type="dojox.cometd.Connection.currentTransport"/>
  <class type="dojox.cometd._ack">
    <methods>
      <method name="_out" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_in" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.cometd.callbackPollTransport">
    <methods>
      <method name="tunnelInit" scope="instance"/>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_cometd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.callbackPollTransport._cometd"/>
  <class type="dojox.cometd.longPollTransportFormEncoded">
    <methods>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelConnect" scope="instance"/>
      <method name="_connect" scope="instance"/>
    </methods>
    <properties>
      <property name="_cometd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportFormEncoded._cometd"/>
  <class type="dojox.cometd.longPollTransportJsonEncoded">
    <methods>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelConnect" scope="instance"/>
      <method name="_connect" scope="instance"/>
    </methods>
    <properties>
      <property name="_cometd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportJsonEncoded._cometd"/>
  <class type="dojox.cometd.timesync">
    <methods>
      <method name="setTimeout" scope="instance">
        <parameters>
          <parameter name="call" type="function" usage="required">
            <description>the function to call when the timeout occurs
	atTimeOrTime:
	a long timestamp or a Date representing the server time at
	which the timeout should occur.</description>
          </parameter>
          <parameter name="atTimeOrDate" type="long|Date" usage="required"/>
        </parameters>
      </method>
      <method name="getServerTime" scope="instance"/>
      <method name="getServerDate" scope="instance"/>
      <method name="_out" scope="instance">
        <description>Look for handshake and connect messages and add the ext:{timesync:{}} fields</description>
        <parameters>
          <parameter name="msg" type="The" usage="required">
            <description>outgoing bayeux message</description>
          </parameter>
        </parameters>
      </method>
      <method name="_in" scope="instance">
        <description>Look for ext:{timesync:{}} field and calculate offset if present.</description>
        <parameters>
          <parameter name="msg" type="Object" usage="required">
            <description>The incoming bayeux message</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.css3.fx">
    <methods>
      <method name="shrink" scope="instance">
        <description>Shrinks an element, same as expand({ node: node, endScale: .01 });</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rotate" scope="instance">
        <description>Rotates an element from args.startAngle to args.endAngle</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="puff" scope="instance">
        <description>Fades out an element and scales it to args.endScale</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flip" scope="instance">
        <description>Flips an element around his y axis. The default is a 360deg flip
	but it's possible to run a partial flip using args.whichAnims</description>
        <examples>
          <example>	// half flip
		dojox.css3.fx.flip({
			node: domNode,
			whichAnim: [0, 1]
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="expand" scope="instance">
        <description>Scales an element to args.endScale</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bounce" scope="instance">
        <description>Vertical bounce animation, the scaleX, scaleY deformation and the
	jump height (args.jumpHeight) can be specified</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.css3">
    <methods>
      <method name="transition" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="fx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.css3.transition">
    <methods>
      <method name="start" scope="instance"/>
      <method name="slide" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="play" scope="instance"/>
      <method name="onAfterEnd" scope="instance"/>
      <method name="initState" scope="instance"/>
      <method name="groupedPlay" scope="instance">
        <parameters>
          <parameter name="args" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="flip" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fade" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="chainedPlay" scope="instance">
        <parameters>
          <parameter name="args" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="beforeStart" scope="instance"/>
      <method name="beforeClear" scope="instance"/>
      <method name="_removeState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onAfterEnd" scope="instance"/>
      <method name="_beforeStart" scope="instance"/>
      <method name="_beforeClear" scope="instance"/>
      <method name="_applyState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.css3.transition.node">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.css3.transition.node.style"/>
  <class type="dojox.data">
    <methods>
      <method name="restListener" scope="instance">
        <description>Example:
		dojo.connect(window,"onMessage",null,function(event) {
			var data = dojo.fromJson(event.data);
			dojox.restListener(data);
		});</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="XmlStore" scope="instance">
        <description>A data store for XML based services or documents</description>
        <parameters>
          <parameter name="args" type="object" usage="required">
            <description>An anonymous object to initialize properties.  It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="XmlItem" scope="instance">
        <description>This class represents an item of 'XmlStore' holding an XML element.
	'element'
	element:
	An XML element</description>
        <parameters>
          <parameter name="element" type="An" usage="required">
            <description>XML element</description>
          </parameter>
          <parameter name="store" type="The" usage="required">
            <description>containing store, if any.</description>
          </parameter>
          <parameter name="query" type="The" usage="required">
            <description>query to use to look up a specific element.
	Usually an XPath or dojo.query statement.</description>
          </parameter>
        </parameters>
      </method>
      <method name="WikipediaStore" scope="instance">
        <description>The WikipediaStore is a data store interface to Wikipedia, using the
	Wikipedia SMD spec from dojox.rpc. It currently is useful only for
	finding articles that contain some particular text or grabbing single
	articles by full name; no wildcards or other filtering are supported.</description>
        <examples>
          <example>	var store = new dojox.data.WikipediaStore();
		store.fetch({
			query: {title:"Dojo Toolkit"},
			onItem: function(item){
				dojo.byId("somediv").innerHTML = item.text["*"];
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="StoreExplorer" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="SnapLogicStore" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An object that contains properties for initializing the new data store object. The
	following properties are understood:</description>
          </parameter>
        </parameters>
      </method>
      <method name="ServiceStore" scope="instance">
        <description>ServiceStore can do client side caching and result set updating if
	dojox.data.ClientFilter is loaded. Do this add:
		dojo.require("dojox.data.ClientFilter")
	prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
	To utilize client side filtering with a subclass, you can break queries into
	client side and server side components by putting client side actions in
	clientFilter property in fetch calls. For example you could override fetch:
		fetch: function(args){
			// do the sorting and paging on the client side
			args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			// args.query will be passed to the service object for the server side handling
			return this.inherited(arguments);
		}
	When extending this class, if you would like to create lazy objects, you can follow
	the example from dojox.data.tests.stores.ServiceStore:
		var lazyItem = {
			_loadObject: function(callback){
				this.name="loaded";
				delete this._loadObject;
				callback(this);
			}
		};
	setup a byId alias to the api call</description>
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <description>arguments
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	
	The *estimateCountFactor* parameter
	This parameter is used by the ServiceStore to estimate the total count. When
	paging is indicated in a fetch and the response includes the full number of items
	requested by the fetch's count parameter, then the total count will be estimated
	to be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server
	does not support paging, and the response is the full set of items, where the
	total count is equal to the numer of items returned. If the server does support
	paging, an estimateCountFactor of 2 is a good value for estimating the total count
	It is also possible to override _processResults if the server can provide an exact
	total count.
	
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary. This will only work with a synchronous capable service.</description>
          </parameter>
        </parameters>
      </method>
      <method name="S3Store" scope="instance"/>
      <method name="RailsStore" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="QueryReadStore" scope="instance">
        <examples>
          <example>	// The parameter "query" contains the data that are sent to the server.
		var store = new dojox.data.QueryReadStore({url:'/search.php'});
		store.fetch({query:{name:'a'}, queryOptions:{ignoreCase:false}});
	
		// Since "serverQuery" is given, it overrules and those data are
		// sent to the server.
		var store = new dojox.data.QueryReadStore({url:'/search.php'});
		store.fetch({serverQuery:{name:'a'}, queryOptions:{ignoreCase:false}});
	
		&lt;div dojoType="dojox.data.QueryReadStore"
			jsId="store2"
			url="../tests/stores/QueryReadStore.php"
			requestMethod="post"&gt;&lt;/div&gt;
		&lt;div dojoType="dojox.grid.data.DojoData"
			jsId="model2"
			store="store2"
			sortFields="[{attribute: 'name', descending: true}]"
			rowsPerPage="30"&gt;&lt;/div&gt;
		&lt;div dojoType="dojox.Grid" id="grid2"
			model="model2"
			structure="gridLayout"
			style="height:300px; width:800px;"&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="PicasaStore" scope="instance">
        <description>The PicasaStore is a Datastore interface to one of the basic services
	of the Picasa service, the public photo feed.  This does not provide
	access to all the services of Picasa.
	This store cannot do * and ? filtering as the picasa service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="PersevereStore" scope="instance"/>
      <method name="OpmlStore" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>url: String, label: String}  Where label is optional and configures what should be used as the return from getLabel()</description>
          </parameter>
        </parameters>
      </method>
      <method name="OpenSearchStore" scope="instance">
        <description>The OpenSearchStore is a Datastore interface to any search
	engine that implements the open search specifications.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="KeyValueStore" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>dataVar: jsonObject}</description>
          </parameter>
        </parameters>
      </method>
      <method name="JsonRestStore" scope="instance">
        <description>The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
	When using a Rest store on a public network, it is important to implement proper security measures to
	control access to resources.
	On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
	GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
	query (like /table/?name=foo).
	PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
	provide the modified object
	POST - This should create a new object. The URL will correspond to the target store (like /table/)
	and the body should be the properties of the new object. The server's response should include a
	Location header that indicates the id of the newly created object. This id will be used for subsequent
	PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
	the temporary randomly generated id used by client, and this location is used for subsequent
	PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
	to receiving a response from the server.
	DELETE - This should delete an object by id.
	These articles include more detailed information on using the JsonRestStore:
	http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
	http://blog.medryx.org/2008/07/24/jsonreststore-overview/</description>
        <examples>
          <example>A JsonRestStore takes a REST service or a URL and uses it the remote communication for a
	read/write dojo.data implementation. A JsonRestStore can be created with a simple URL like:
		new JsonRestStore({target:"/MyData/"});</example>
          <example>To use a JsonRestStore with a service, you should create a
	service with a REST transport. This can be configured with an SMD:
		{
			services: {
				jsonRestStore: {
					transport: "REST",
					envelope: "URL",
					target: "store.php",
					contentType:"application/json",
					parameters: [
						{name: "location", type: "string", optional: true}
					]
				}
			}
		}
	The SMD can then be used to create service, and the service can be passed to a JsonRestStore. For example:
		var myServices = new dojox.rpc.Service(dojo.moduleUrl("dojox.rpc.tests.resources", "test.smd"));
		var jsonStore = new dojox.data.JsonRestStore({service:myServices.jsonRestStore});</example>
          <example>The JsonRestStore also supports lazy loading. References can be made to objects that have not been loaded.
	For example if a service returned:
		{"name":"Example","lazyLoadedObject":{"$ref":"obj2"}}
	And this object has accessed using the dojo.data API:
		var obj = jsonStore.getValue(myObject,"lazyLoadedObject");
	The object would automatically be requested from the server (with an object id of "obj2").</example>
        </examples>
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <description>arguments
	
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	The function should also have the following methods:
	put(id,value) - puts the value at the given id
	post(id,value) - posts (appends) the value at the given id
	delete(id) - deletes the value corresponding to the given id
	Note that it is critical that the service parses responses as JSON.
	If you are using dojox.rpc.Service, the easiest way to make sure this
	happens is to make the responses have a content type of
	application/json. If you are creating your own service, make sure you
	use handleAs: &amp;quot;json&amp;quot; with your XHR requests.
	
	The *target* parameter
	This is the target URL for this Service store. This may be used in place
	of a service parameter to connect directly to RESTful URL without
	using a dojox.rpc.Service object.
	
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary</description>
          </parameter>
        </parameters>
      </method>
      <method name="JsonQueryRestStore" scope="instance"/>
      <method name="ItemExplorer" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="HtmlTableStore" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="HtmlStore" scope="instance">
        <description>The HtmlStore can be created in one of two ways: a) by parsing an existing
	table or list DOM node on the current page or b) by referencing an external url and giving
	the id of the table or list in that page.  The remote url will be parsed as an html page.
	
	The HTML table or list should be of the following form:
	
		&lt;table id="myTable"&gt;
			&lt;thead&gt;
				&lt;tr&gt;
					&lt;th&gt;Attribute1&lt;/th&gt;
					&lt;th&gt;Attribute2&lt;/th&gt;
				&lt;/tr&gt;
			&lt;/thead&gt;
			&lt;tbody&gt;
				&lt;tr&gt;
					&lt;td&gt;Value1.1&lt;/td&gt;
					&lt;td&gt;Value1.2&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;Value2.1&lt;/td&gt;
					&lt;td&gt;Value2.2&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/tbody&gt;
		&lt;/table&gt;
	
	-or-
	
		&lt;ul id="myUnorderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ul&gt;
	
	-or-
	
		&lt;ol id="myOrderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ol&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An anonymous object to initialize properties.  It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="GoogleWebSearchStore" scope="instance"/>
      <method name="GoogleVideoSearchStore" scope="instance"/>
      <method name="GoogleSearchStore" scope="instance">
        <description>The GoogleSearchStore is a Datastore interface to
	the Google search service. The constructor accepts the following arguments:
	&lt;ul&gt;
	&lt;li&gt;label - the label attribute to use. Defaults to titleNoFormatting&lt;/li&gt;
	&lt;li&gt;key - The API key to use. This is optional&lt;/li&gt;
	&lt;li&gt;lang - The language locale to use. Defaults to the browser locale&lt;/li&gt;
	&lt;/ul&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GoogleNewsSearchStore" scope="instance"/>
      <method name="GoogleLocalSearchStore" scope="instance"/>
      <method name="GoogleImageSearchStore" scope="instance"/>
      <method name="GoogleFeedStore" scope="instance"/>
      <method name="GoogleBookSearchStore" scope="instance"/>
      <method name="GoogleBlogSearchStore" scope="instance"/>
      <method name="FlickrStore" scope="instance">
        <description>The FlickrStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="FlickrRestStore" scope="instance">
        <description>The FlickrRestStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="FileStore" scope="instance">
        <description>A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
	for initialization:</description>
        <examples>
          <example>options="expand,dirsOnly,showHiddenFiles"</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="CsvStore" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>identifier: String} The column label for the column to use for the identity.  Optional.  If not set, the identity is the row number.</description>
          </parameter>
        </parameters>
      </method>
      <method name="CssRuleStore" scope="instance">
        <description>The CssRuleStore allows users to get information about active CSS rules in the page running the CssRuleStore.
	It can also filter out rules from specific stylesheets.  The attributes it exposes on rules are as follows:
	selector:				The selector text.
	classes:				An array of classes present in this selector.
	rule:					The actual DOM Rule object.
	style:					The actual DOM CSSStyleDeclaration object.
	cssText:				The cssText string provided on the rule object.
	styleSheet:				The originating DOM Stylesheet object.
	parentStyleSheet: 		The parent stylesheet to the sheet this rule originates from.
	parentStyleSheetHref: 	The href of the parent stylesheet.
	AND every style attribute denoted as style.*, such as style.textAlign or style.backgroundColor</description>
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="CssClassStore" scope="instance">
        <description>The CssClassStore allows users to get information about active Css classes in the page running the CssClassStore.
	It can also filter out classes from specific stylesheets.  The attributes it exposes on classes are as follows:
	class:		The classname, including the '.'.
	classSans:	The classname without the '.'.</description>
      </method>
      <method name="CouchDBRestStore" scope="instance"/>
      <method name="ClientFilter" scope="instance">
        <description>To a update a result set after a notification (onNew, onSet, and onDelete),
	widgets can call the updateResultSet method. Widgets can use the updated
	result sets to determine how to react to notifications, and how to update their displayed results
	based on changes.
	
	This module will use the best available information to update result sets, using query attribute
	objects to determine if items are in a result set, and using the sort arrays to maintain sort
	information. However, queries can be opaque strings, and this module can not update
	results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
	and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
	isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
	definition of isUpdateable and matchesQuery
	isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
	matchesQuery(item,request) - item is the item to test, and request is the value arguments object
	for the fetch function.
	
	You can define a property on this object instance "cacheByDefault" to a value of true that will
	cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
	This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.</description>
        <examples>
          <example>to make a updated-result-set data store from an existing data store:
		dojo.declare("dojox.data.MyLiveDataStore",
			dojox.data.MyDataStore,dojox.data.ClientFilter], // subclass LiveResultSets if available
			{}
		);</example>
        </examples>
      </method>
      <method name="CdfStore" scope="instance">
        <examples>
          <example>	'&lt;data jsxid="jsxroot"&gt;&lt;record jsxtext="A"/&gt;&lt;record jsxtext="B" jsxid="2" jsxid="2"/&gt;&lt;/data&gt;'</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="AtomReadStore" scope="instance">
        <description>A data store for Atom XML based services or documents.	This store is still under development
	and doesn't support wildcard filtering yet.	Attribute filtering is limited to category or id.</description>
        <parameters>
          <parameter name="args" type="object" usage="required">
            <description>An anonymous object to initialize properties.	It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="AppStore" scope="instance">
        <description>The APP Store is instantiated either in markup or programmatically by supplying a
	url of the Collection to be used.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An anonymous object to initialize properties.  It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="AndOrWriteStore" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="AndOrReadStore" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="util" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrReadStore">
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_getItemsFromLoadedData" scope="instance">
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required">
            <description>The JS data object containing the raw data to convery into item format.</description>
          </parameter>
        </parameters>
        <return-description>array
	Array of items in store item format.</return-description>
      </method>
      <method name="_getItemsArray" scope="instance">
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <description>The query options parameter, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="instance">
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="instance"/>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_datatypeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrReadStore._features.dojo.data.api"/>
  <class type="dojox.data.AndOrReadStore._datatypeMap"/>
  <class type="dojox.data.AndOrWriteStore" superclass="dojox.data.AndOrReadStore">
    <methods>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <description>anything</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
        </parameters>
      </method>
      <method name="onNew" scope="instance">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.
	If the store is still dirty (unsaved changes), then an error will be thrown instead of
	clearing the internal state for reload from the url.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_removeReferenceFromMap" scope="instance">
        <description>Method to remove an reference map entry for an item and attribute.  This will
	also perform cleanup on the map such that if there are no more references at all to
	the item, its reference object and entry are removed.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item holding a reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="strin" usage="required">
            <description>The attribute on parentItem that contains the reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeArrayElement" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="something" type="The" usage="required">
            <description>array or object to examine.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_getValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="instance"/>
      <method name="_getIdentifierAttribute" scope="instance"/>
      <method name="_flatten" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="instance">
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_assert" scope="instance">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.AndOrReadStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.AndOrWriteStore._features.dojo.data.api"/>
  <class type="dojox.data.AndOrWriteStore._datatypeMap.Date">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.AppStore" superclass="dojo.data.util.simpleFetch">
    <description>The APP Store is instantiated either in markup or programmatically by supplying a
	url of the Collection to be used.</description>
    <methods>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <description>anything</description>
          </parameter>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>{ onComplete: function
	onError: function
	scope: object
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="revert" scope="instance"/>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <description>The APP Store is instantiated either in markup or programmatically by supplying a
	url of the Collection to be used.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An anonymous object to initialize properties.  It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setFeed" scope="instance">
        <description>Sets the internal feed using a dojox.atom.io.model.Feed object.  Also adds
	a property to the entries to track that they belong to this store. It
	also parses stored requests (since we were waiting on a callback) and
	executes those as well.</description>
        <parameters>
          <parameter name="feed" type="dojox.atom.io.model.Feed" usage="required">
            <description>object
	The Feed to use for this data store.</description>
          </parameter>
          <parameter name="data" type="unused" usage="required">
            <description>Signature for this function is defined by AtomIO.getFeed, since this is a callback.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getAllItems" scope="instance">
        <description>Function to return all entries in the Feed as an array of items.</description>
        <return-description>Array of all entries in the feed.</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_finishFetchItems" scope="instance">
        <description>Internal function for finishing a fetch request.  Needed since the feed
	might not have been loaded, so we finish the fetch in a callback.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>Fetch items (Atom entries) that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
          <parameter name="trim" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <description>This function tests whether the item passed in is indeed an item
	in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <description>This function tests whether the item passed in is indeed a valid
	'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
        <return-description>Returns a boolean indicating whether this is a valid attribute.</return-description>
      </method>
      <method name="_addUpdate" scope="instance">
        <description>Internal function to add an updated entry to our updates array</description>
        <parameters>
          <parameter name="update" type="Object" usage="required">
            <description>dojox.atom.io.model.Entry object
	The updated Entry we've changed.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.AtomReadStore" superclass="dojo.data.util.simpleFetch">
    <description>A data store for Atom XML based services or documents.	This store is still under development
	and doesn't support wildcard filtering yet.	Attribute filtering is limited to category or id.</description>
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>containing the args for loadItem.	See dojo.data.api.Read.loadItem()</description>
          </parameter>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>'item' must be created by the AtomReadStore instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>An attribute of an Atom Entry item.</description>
          </parameter>
        </parameters>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <description>'item' must be an instance of an object created by the AtomReadStore instance.
	Accepted attributes are id, subtitle, title, summary, content, author, updated,
	published, category, link and alternate</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An item returned by a call to the 'fetch' method.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A attribute of the Atom Entry</description>
          </parameter>
        </parameters>
        <return-description>An array of values for the attribute value found, otherwise 'defaultValue'</return-description>
      </method>
      <method name="getValue" scope="instance">
        <description>'item' must be an instance of an object created by the AtomReadStore instance.
	Accepted attributes are id, subtitle, title, summary, content, author, updated,
	published, category, link and alternate</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An item returned by a call to the 'fetch' method.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A attribute of the Atom Entry</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>A default value</description>
          </parameter>
        </parameters>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getFeedValues" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeedValue" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <description>'item' must be have been created by the AtomReadStore instance.
	tag names of child elements and XML attribute names of attributes
	specified to the element are returned along with special attribute
	names applicable to the element including "tagName", "childNodes"
	if the element has child elements, "text()" if the element has
	child text nodes, and attribute names in '_attributeMap' that match
	the tag name of the element.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element</description>
          </parameter>
        </parameters>
        <return-description>An array of attributes found</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <description>An anonymous object to initialize properties.	It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_unescapeHTML" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="document" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItem" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFetchUrl" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.CdfStore">
    <methods>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <description>anything</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="revert" scope="instance">
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="optional"/>
          <parameter name="parentInfo" type="object" usage="optional">
            <description>|| String?</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="jsx3.xml.Entity"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <description>The store always loads all items, so if it's an item, then it's loaded.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required">
            <description>?</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasProperty" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetch" scope="instance">
        <description>Returns an Array of items based on the request arguments.
	If the store is in ASYNC mode, the items should be expected in an onComplete
	method passed in the request object. If store is in SYNC mode, the items will
	be return directly as well as within the onComplete method.
	note:
	The mode can be set on store initialization or during a fetch as one of the
	parameters.
	
	query: String
	The items in the store are treated as objects, but this is reading an XML
	document. Further, the actual querying of the items takes place in Tibco GI's
	jsx3.xml.Entity. Therefore, we are using their syntax which is xpath.
	Note:
	As conforming to a CDF document, most, if not all nodes are considered "records"
	and their tagNames are as such. The root node is named "data".
	
	examples:
	All items:
		store.fetch({query:"*"});
	Item with a jsxid attribute equal to "1" (note you could use byId for this)
		store.fetch({query:"//record[@jsxid='1']"});
	All items with any jsxid attribute:
		"//record[@jsxid='*']"
	The items with a jsxid of '1' or '4':
		"//record[@jsxid='4' or @jsxid='1']"
	All children within a "group" node (could be multiple group nodes):
	"//group/record"
	All children within a specific group node:
	"//group[@name='mySecondGroup']/record"
	Any record, anywhere in the document:
		"//record"
	Only the records beneath the root (data) node:
		"//data/record"
	
	See:
	http://www.tibco.com/devnet/resources/gi/3_7/api/html/jsx3/xml/Entity.html#method:selectNodes
	http://www.w3.org/TR/xpath
	http://msdn.microsoft.com/en-us/library/ms256086.aspx
	
	See dojo.data.Read.fetch():
	onBegin
	onComplete
	onItem
	onError
	scope
	start
	count
	sort</description>
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="byId" scope="instance-prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
      </method>
      <method name="_makeXmlString" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadCDF" scope="instance">
        <return-types>
          <return-type type="jsx3.xml.CDF"/>
          <return-type type="dojo.Deferred"/>
          <return-type type="Error"/>
        </return-types>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="cdfDoc" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.ClientFilter">
    <description>To a update a result set after a notification (onNew, onSet, and onDelete),
	widgets can call the updateResultSet method. Widgets can use the updated
	result sets to determine how to react to notifications, and how to update their displayed results
	based on changes.
	
	This module will use the best available information to update result sets, using query attribute
	objects to determine if items are in a result set, and using the sort arrays to maintain sort
	information. However, queries can be opaque strings, and this module can not update
	results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
	and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
	isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
	definition of isUpdateable and matchesQuery
	isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
	matchesQuery(item,request) - item is the item to test, and request is the value arguments object
	for the fetch function.
	
	You can define a property on this object instance "cacheByDefault" to a value of true that will
	cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
	This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.</description>
    <methods>
      <method name="updateResultSet" scope="instance">
        <description>This will attempt to update the provide result based on previous notification, adding new items
	from onNew calls, removing deleted items, and updating modified items, and properly removing
	and adding items as required by the query and sort parameters. This function will return:
	0: Indicates it could not successfully update the result set
	1: Indicates it could successfully handle all the notifications, but no changes were made to the result set
	2: Indicates it successfully handled all the notifications and result set has been updated.</description>
        <parameters>
          <parameter name="resultSet" type="Array" usage="required">
            <description>The result set array that should be updated</description>
          </parameter>
          <parameter name="request" type="Object" usage="required">
            <description>This object follows the same meaning as the keywordArgs passed to a dojo.data.api.Read.fetch.</description>
          </parameter>
        </parameters>
      </method>
      <method name="querySuperSet" scope="instance">
        <parameters>
          <parameter name="argsSuper" type="Dojo" usage="required">
            <description>Data Fetch arguments</description>
          </parameter>
          <parameter name="argsSub" type="Dojo" usage="required">
            <description>Data Fetch arguments</description>
          </parameter>
        </parameters>
      </method>
      <method name="matchesQuery" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeComparator" scope="instance">
        <parameters>
          <parameter name="sort" type="See" usage="required">
            <description>dojox.data.api.Read.fetch</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="keep the order unchanged"/>
        </return-types>
      </method>
      <method name="isUpdateable" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>See dojo.data.api.Read.fetch request</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>To a update a result set after a notification (onNew, onSet, and onDelete),
	widgets can call the updateResultSet method. Widgets can use the updated
	result sets to determine how to react to notifications, and how to update their displayed results
	based on changes.
	
	This module will use the best available information to update result sets, using query attribute
	objects to determine if items are in a result set, and using the sort arrays to maintain sort
	information. However, queries can be opaque strings, and this module can not update
	results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
	and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
	isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
	definition of isUpdateable and matchesQuery
	isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
	matchesQuery(item,request) - item is the item to test, and request is the value arguments object
	for the fetch function.
	
	You can define a property on this object instance "cacheByDefault" to a value of true that will
	cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
	This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.</description>
        <examples>
          <example>to make a updated-result-set data store from an existing data store:
		dojo.declare("dojox.data.MyLiveDataStore",
			dojox.data.MyDataStore,dojox.data.ClientFilter], // subclass LiveResultSets if available
			{}
		);</example>
        </examples>
      </method>
      <method name="clientSidePaging" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>See dojo.data.api.Read.fetch request</description>
          </parameter>
          <parameter name="baseResults" type="Array" usage="required">
            <description>This provides the result set to start with for client side querying</description>
          </parameter>
        </parameters>
      </method>
      <method name="clearCache" scope="instance"/>
      <method name="cachingFetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.CouchDBRestStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStores" scope="instance">
        <parameters>
          <parameter name="couchServerUrl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="service" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CouchDBRestStore.service"/>
  <class type="dojox.data.CssClassStore" superclass="dojox.data.CssRuleStore">
    <description>The CssClassStore allows users to get information about active Css classes in the page running the CssClassStore.
	It can also filter out classes from specific stylesheets.  The attributes it exposes on classes are as follows:
	class:		The classname, including the '.'.
	classSans:	The classname without the '.'.</description>
    <methods>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="request" type="request" usage="required"/>
        </parameters>
      </method>
      <method name="_handleRule" scope="instance">
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
          <parameter name="styleSheet" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="instance"/>
      <method name="_handleFetchByIdentityReturn" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.CssRuleStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.CssRuleStore">
    <description>The CssRuleStore allows users to get information about active CSS rules in the page running the CssRuleStore.
	It can also filter out rules from specific stylesheets.  The attributes it exposes on rules are as follows:
	selector:				The selector text.
	classes:				An array of classes present in this selector.
	rule:					The actual DOM Rule object.
	style:					The actual DOM CSSStyleDeclaration object.
	cssText:				The cssText string provided on the rule object.
	styleSheet:				The originating DOM Stylesheet object.
	parentStyleSheet: 		The parent stylesheet to the sheet this rule originates from.
	parentStyleSheetHref: 	The href of the parent stylesheet.
	AND every style attribute denoted as style.*, such as style.textAlign or style.backgroundColor</description>
    <methods>
      <method name="setContext" scope="instance">
        <parameters>
          <parameter name="context" type="Array" usage="required">
            <description>- Array of CSS string paths to execute queries within</description>
          </parameter>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="_handleRule" scope="instance">
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
          <parameter name="styleSheet" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="instance"/>
      <method name="_handleFetchReturn" scope="instance">
        <parameters>
          <parameter name="request" type="Request" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.CsvStore">
    <methods>
      <method name="loadItem" scope="instance">
        <description>The CsvStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>identifier: String} The column label for the column to use for the identity.  Optional.  If not set, the identity is the row number.</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_splitLines" scope="instance">
        <parameters>
          <parameter name="csvContent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processData" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required">
            <description>The CSV data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_getIndex" scope="instance">
        <parameters>
          <parameter name="item" type="The" usage="required">
            <description>idem handle to get the index for.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_createItemFromIdentity" scope="instance">
        <parameters>
          <parameter name="identity" type="String" usage="required">
            <description>The identity</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.FileStore">
    <description>A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
	for initialization:</description>
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
	for initialization:</description>
        <examples>
          <example>options="expand,dirsOnly,showHiddenFiles"</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResult" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemArray" scope="instance">
        <parameters>
          <parameter name="itemArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.FlickrRestStore" superclass="dojox.data.FlickrStore">
    <description>The FlickrRestStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
    <methods>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>The FlickrRestStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processFlickrData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <description>Data returned from Flickr</description>
          </parameter>
          <parameter name="request" type="Object" usage="required">
            <description>The original dojo.data.Request object passed in by the user.</description>
          </parameter>
          <parameter name="cacheKey" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>A request object</description>
          </parameter>
          <parameter name="fetchHandler" type="Function" usage="required">
            <description>A function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="Function" usage="required">
            <description>A function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkPrevRanges" scope="instance">
        <parameters>
          <parameter name="primaryKey" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.FlickrStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_sortAttributes" scope="instance" type="Object">
        <description>A quick lookup of valid attribute names in a sort query.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.data.FlickrRestStore._sortAttributes"/>
  <class type="dojox.data.FlickrStore">
    <description>The FlickrStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>The FlickrStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>String. The string to un-escape</description>
          </parameter>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped)
	characters (&lt;,&gt;,&amp;, ", etc,).</return-description>
      </method>
      <method name="_processFlickrData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.GoogleFeedStore" superclass="GoogleSearchStore.Search">
    <methods>
      <method name="getFeedValues" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeedValue" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createContent" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="GoogleSearchStore.Search" scope="instance"/>
    </mixins>
    <properties>
      <property name="_queryAttrs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleFeedStore._queryAttrs"/>
  <class type="GoogleSearchStore"/>
  <class type="dojox.data.GoogleSearchStore">
    <description>The GoogleSearchStore is a Datastore interface to
	the Google search service. The constructor accepts the following arguments:
	&lt;ul&gt;
	&lt;li&gt;label - the label attribute to use. Defaults to titleNoFormatting&lt;/li&gt;
	&lt;li&gt;key - The API key to use. This is optional&lt;/li&gt;
	&lt;li&gt;lang - The language locale to use. Defaults to the browser locale&lt;/li&gt;
	&lt;/ul&gt;</description>
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object
	fetchHandler:
	A function to call for fetched items
	errorHandler:
	A function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>The GoogleSearchStore is a Datastore interface to
	the Google search service. The constructor accepts the following arguments:
	&lt;ul&gt;
	&lt;li&gt;label - the label attribute to use. Defaults to titleNoFormatting&lt;/li&gt;
	&lt;li&gt;key - The API key to use. This is optional&lt;/li&gt;
	&lt;li&gt;lang - The language locale to use. Defaults to the browser locale&lt;/li&gt;
	&lt;/ul&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getSort" scope="instance"/>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_format" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="base implementation does not format any items"/>
        </return-types>
      </method>
      <method name="_createContent" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_queryAttrs" scope="instance" type="Hash">
        <description>Maps query hash keys to Google query parameters.</description>
      </property>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleSearchStore._aggregatedAttributes"/>
  <class type="dojox.data.GoogleSearchStore._queryAttrs"/>
  <class type="dojox.data.GoogleWebSearchStore" superclass="SearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="SearchStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.GoogleBlogSearchStore" superclass="SearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="SearchStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.GoogleLocalSearchStore" superclass="SearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="SearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_queryAttrs" scope="instance" type="Object"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleLocalSearchStore._aggregatedAttributes"/>
  <class type="dojox.data.GoogleLocalSearchStore._queryAttrs"/>
  <class type="dojox.data.GoogleVideoSearchStore" superclass="SearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="SearchStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.GoogleNewsSearchStore" superclass="SearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="SearchStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.GoogleBookSearchStore" superclass="SearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="SearchStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.GoogleImageSearchStore" superclass="SearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="SearchStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.HtmlStore">
    <description>The HtmlStore can be created in one of two ways: a) by parsing an existing
	table or list DOM node on the current page or b) by referencing an external url and giving
	the id of the table or list in that page.  The remote url will be parsed as an html page.
	
	The HTML table or list should be of the following form:
	
		&lt;table id="myTable"&gt;
			&lt;thead&gt;
				&lt;tr&gt;
					&lt;th&gt;Attribute1&lt;/th&gt;
					&lt;th&gt;Attribute2&lt;/th&gt;
				&lt;/tr&gt;
			&lt;/thead&gt;
			&lt;tbody&gt;
				&lt;tr&gt;
					&lt;td&gt;Value1.1&lt;/td&gt;
					&lt;td&gt;Value1.2&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;Value2.1&lt;/td&gt;
					&lt;td&gt;Value2.2&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/tbody&gt;
		&lt;/table&gt;
	
	-or-
	
		&lt;ul id="myUnorderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ul&gt;
	
	-or-
	
		&lt;ol id="myOrderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ol&gt;</description>
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <description>The HtmlStore can be created in one of two ways: a) by parsing an existing
	table or list DOM node on the current page or b) by referencing an external url and giving
	the id of the table or list in that page.  The remote url will be parsed as an html page.
	
	The HTML table or list should be of the following form:
	
		&lt;table id="myTable"&gt;
			&lt;thead&gt;
				&lt;tr&gt;
					&lt;th&gt;Attribute1&lt;/th&gt;
					&lt;th&gt;Attribute2&lt;/th&gt;
				&lt;/tr&gt;
			&lt;/thead&gt;
			&lt;tbody&gt;
				&lt;tr&gt;
					&lt;td&gt;Value1.1&lt;/td&gt;
					&lt;td&gt;Value1.2&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;Value2.1&lt;/td&gt;
					&lt;td&gt;Value2.2&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/tbody&gt;
		&lt;/table&gt;
	
	-or-
	
		&lt;ul id="myUnorderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ul&gt;
	
	-or-
	
		&lt;ol id="myOrderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ol&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An anonymous object to initialize properties.  It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_indexItems" scope="instance"/>
      <method name="_getHeadings" scope="instance"/>
      <method name="_getAllItems" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_finishFetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>If '_fetchUrl' is specified, it is used to load an XML document
	with a query string.
	Otherwise and if 'url' is specified, the XML document is
	loaded and list XML elements that match to a query (set of element
	names and their text attribute values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If '_rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.data.HtmlTableStore">
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getHeadings" scope="instance"/>
      <method name="_getAllItems" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_finishFetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>If '_fetchUrl' is specified, it is used to load an XML document
	with a query string.
	Otherwise and if 'url' is specified, the XML document is
	loaded and list XML elements that match to a query (set of element
	names and their text attribute values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If '_rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.data.ItemExplorer" superclass="dijit.Tree">
    <methods>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshItem" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateItem" scope="instance">
        <parameters>
          <parameter name="vals" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_enableFields" scope="instance">
        <parameters>
          <parameter name="selection" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_editProperty" scope="instance"/>
      <method name="_destroyProperty" scope="instance"/>
      <method name="_createEditDialog" scope="instance">
        <return-types>
          <return-type type="isFocused"/>
          <return-type type="Object"/>
          <return-type type="this.store.getItemByIdentity(this._editDialog.attr(&quot;value&quot;)._reference)"/>
        </return-types>
      </method>
      <method name="_addProperty" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Tree" scope="instance"/>
    </mixins>
    <properties>
      <property name="rootModelNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.ItemExplorer.rootModelNode"/>
  <class type="dojox.data.JsonQueryRestStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="matchesQuery" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.util.JsonQuery.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
      <mixin type="dojox.data.util.JsonQuery" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.JsonRestStore" superclass="dojox.data.ServiceStore">
    <description>The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
	When using a Rest store on a public network, it is important to implement proper security measures to
	control access to resources.
	On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
	GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
	query (like /table/?name=foo).
	PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
	provide the modified object
	POST - This should create a new object. The URL will correspond to the target store (like /table/)
	and the body should be the properties of the new object. The server's response should include a
	Location header that indicates the id of the newly created object. This id will be used for subsequent
	PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
	the temporary randomly generated id used by client, and this location is used for subsequent
	PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
	to receiving a response from the server.
	DELETE - This should delete an object by id.
	These articles include more detailed information on using the JsonRestStore:
	http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
	http://blog.medryx.org/2008/07/24/jsonreststore-overview/</description>
    <methods>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance"/>
      <method name="onNew" scope="instance"/>
      <method name="onDelete" scope="instance"/>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="data" type="object" usage="required">
            <description>The data to be added in as an item.</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>The value to test for being an item</description>
          </parameter>
          <parameter name="anyStore" type="boolean" usage="required">
            <description>If true, this will return true if the value is an item for any JsonRestStore,
	not just this instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getParent" scope="instance">
        <parameters>
          <parameter name="item" type="The" usage="required">
            <description>item to find the parent of</description>
          </parameter>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getConstructor" scope="instance"/>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>to delete</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
	When using a Rest store on a public network, it is important to implement proper security measures to
	control access to resources.
	On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
	GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
	query (like /table/?name=foo).
	PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
	provide the modified object
	POST - This should create a new object. The URL will correspond to the target store (like /table/)
	and the body should be the properties of the new object. The server's response should include a
	Location header that indicates the id of the newly created object. This id will be used for subsequent
	PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
	the temporary randomly generated id used by client, and this location is used for subsequent
	PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
	to receiving a response from the server.
	DELETE - This should delete an object by id.
	These articles include more detailed information on using the JsonRestStore:
	http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
	http://blog.medryx.org/2008/07/24/jsonreststore-overview/</description>
        <examples>
          <example>A JsonRestStore takes a REST service or a URL and uses it the remote communication for a
	read/write dojo.data implementation. A JsonRestStore can be created with a simple URL like:
		new JsonRestStore({target:"/MyData/"});</example>
          <example>To use a JsonRestStore with a service, you should create a
	service with a REST transport. This can be configured with an SMD:
		{
			services: {
				jsonRestStore: {
					transport: "REST",
					envelope: "URL",
					target: "store.php",
					contentType:"application/json",
					parameters: [
						{name: "location", type: "string", optional: true}
					]
				}
			}
		}
	The SMD can then be used to create service, and the service can be passed to a JsonRestStore. For example:
		var myServices = new dojox.rpc.Service(dojo.moduleUrl("dojox.rpc.tests.resources", "test.smd"));
		var jsonStore = new dojox.data.JsonRestStore({service:myServices.jsonRestStore});</example>
          <example>The JsonRestStore also supports lazy loading. References can be made to objects that have not been loaded.
	For example if a service returned:
		{"name":"Example","lazyLoadedObject":{"$ref":"obj2"}}
	And this object has accessed using the dojo.data API:
		var obj = jsonStore.getValue(myObject,"lazyLoadedObject");
	The object would automatically be requested from the server (with an object id of "obj2").</example>
        </examples>
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <description>arguments
	
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	The function should also have the following methods:
	put(id,value) - puts the value at the given id
	post(id,value) - posts (appends) the value at the given id
	delete(id) - deletes the value corresponding to the given id
	Note that it is critical that the service parses responses as JSON.
	If you are using dojox.rpc.Service, the easiest way to make sure this
	happens is to make the responses have a content type of
	application/json. If you are creating your own service, make sure you
	use handleAs: &amp;quot;json&amp;quot; with your XHR requests.
	
	The *target* parameter
	This is the target URL for this Service store. This may be used in place
	of a service parameter to connect directly to RESTful URL without
	using a dojox.rpc.Service object.
	
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary</description>
          </parameter>
        </parameters>
      </method>
      <method name="changing" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelChanging" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required">
            <description>item to cancel changes on</description>
          </parameter>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="don't change anything, and deal with the stupid post-commit lint complaints"/>
        </return-types>
      </method>
      <method name="_constructor" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.ServiceStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="service" scope="instance" type="Object"/>
      <property name="schema" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonRestStore.service"/>
  <class type="dojox.data.JsonRestStore.schema"/>
  <class type="dojox.data.ServiceStore">
    <description>ServiceStore can do client side caching and result set updating if
	dojox.data.ClientFilter is loaded. Do this add:
		dojo.require("dojox.data.ClientFilter")
	prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
	To utilize client side filtering with a subclass, you can break queries into
	client side and server side components by putting client side actions in
	clientFilter property in fetch calls. For example you could override fetch:
		fetch: function(args){
			// do the sorting and paging on the client side
			args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			// args.query will be passed to the service object for the server side handling
			return this.inherited(arguments);
		}
	When extending this class, if you would like to create lazy objects, you can follow
	the example from dojox.data.tests.stores.ServiceStore:
		var lazyItem = {
			_loadObject: function(callback){
				this.name="loaded";
				delete this._loadObject;
				callback(this);
			}
		};
	setup a byId alias to the api call</description>
    <methods>
      <method name="loadItem" scope="instance">
        <examples>
          <example>store.loadItem({
	item: item, // this item may or may not be loaded
	onItem: function(item){
	// do something with the item
	}
	});</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>attribute: /* string</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="property" type="string" usage="required">
            <description>property to look up value for</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>The item to get the value from</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>property to look up value for</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>the default value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="return the plain value since it was found"/>
        </return-types>
      </method>
      <method name="getSchema" scope="instance"/>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>ServiceStore can do client side caching and result set updating if
	dojox.data.ClientFilter is loaded. Do this add:
		dojo.require("dojox.data.ClientFilter")
	prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
	To utilize client side filtering with a subclass, you can break queries into
	client side and server side components by putting client side actions in
	clientFilter property in fetch calls. For example you could override fetch:
		fetch: function(args){
			// do the sorting and paging on the client side
			args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			// args.query will be passed to the service object for the server side handling
			return this.inherited(arguments);
		}
	When extending this class, if you would like to create lazy objects, you can follow
	the example from dojox.data.tests.stores.ServiceStore:
		var lazyItem = {
			_loadObject: function(callback){
				this.name="loaded";
				delete this._loadObject;
				callback(this);
			}
		};
	setup a byId alias to the api call</description>
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <description>arguments
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	
	The *estimateCountFactor* parameter
	This parameter is used by the ServiceStore to estimate the total count. When
	paging is indicated in a fetch and the response includes the full number of items
	requested by the fetch's count parameter, then the total count will be estimated
	to be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server
	does not support paging, and the response is the full set of items, where the
	total count is equal to the numer of items returned. If the server does support
	paging, an estimateCountFactor of 2 is a good value for estimating the total count
	It is also possible to override _processResults if the server can provide an exact
	total count.
	
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary. This will only work with a synchronous capable service.</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.KeyValueStore">
    <methods>
      <method name="loadItem" scope="instance">
        <description>The KeyValueStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>dataVar: jsonObject}</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_processData" scope="instance">
        <parameters>
          <parameter name="data" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_finishFetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_createItem" scope="instance">
        <parameters>
          <parameter name="something" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.OpenSearchStore">
    <description>The OpenSearchStore is a Datastore interface to any search
	engine that implements the open search specifications.</description>
    <methods>
      <method name="processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>The OpenSearchStore is a Datastore interface to any search
	engine that implements the open search specifications.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOsdd" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDxml" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDrss" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDfeed" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDatom" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemxml" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemrss" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemfeed" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItematom" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getNodeXml" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="skipFirst" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createSearchUrl" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="urlElement" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.OpenSearchStore.urlElement"/>
  <class type="dojox.data.OpmlStore">
    <methods>
      <method name="loadItem" scope="instance">
        <description>The OpmlStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke the callback handlers.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <description>Four things are verified to ensure that "something" is an item:
	something can not be null, the nodeType must be an XML Element,
	the tagName must be "outline", and the node must be a member of
	XML document for this datastore.</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>url: String, label: String}  Where label is optional and configures what should be used as the return from getLabel()</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeChildNodesThatAreNotElementNodes" scope="instance">
        <parameters>
          <parameter name="node" type="node" usage="required"/>
          <parameter name="recursive" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_processRawXmlTree" scope="instance">
        <parameters>
          <parameter name="rawXmlTree" type="xmlDoc" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_getItemsArray" scope="instance">
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <description>The query options parameter, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_checkChildNodes" scope="instance">
        <description>Internal function to recurse over all child nodes from the store and add them
	As non-toplevel items</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The child node to walk.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="item" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.PersevereStore" superclass="dojox.data.JsonQueryRestStore">
    <methods>
      <method name="getStores" scope="instance">
        <parameters>
          <parameter name="path" type="String" usage="optional">
            <description>URL of the Persevere server's root, this normally just &amp;quot;/&amp;quot;
	which is the default value if the target is not provided</description>
          </parameter>
          <parameter name="sync" type="Boolean" usage="optional">
            <description>Indicates that the operation should happen synchronously.
	return:
	A map/object of datastores will be returned if it is performed asynchronously,
	otherwise it will return a Deferred object that will provide the map/object.
	The name of each property is a the name of a store,
	and the value is the actual data store object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addProxy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonQueryRestStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.json.ref">
    <methods>
      <method name="toJson" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required">
            <description>an object to be serialized.</description>
          </parameter>
          <parameter name="prettyPrint" type="Boolean" usage="optional">
            <description>if true, we indent objects and arrays to make the output prettier.
	The variable dojo.toJsonIndentStr is used as the indent string
	-- to use something other than the default (tab),
	change that variable before calling dojo.toJson().</description>
          </parameter>
          <parameter name="idPrefix" type="Object" usage="optional">
            <description>The prefix that has been used for the absolute ids
	
	return:
	a String representing the serialized version of the passed object.</description>
          </parameter>
          <parameter name="indexSubObjects" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="use the default serializer for primitives"/>
        </return-types>
      </method>
      <method name="resolveJson" scope="instance">
        <description>A JSON Schema object that can be used to advise the handling of the JSON (defining ids, date properties, urls, etc)</description>
        <parameters>
          <parameter name="root" type="Object" usage="required">
            <description>The root object of the object graph to be processed</description>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <description>with additional arguments:
	
	The *index* parameter.
	This is the index object (map) to use to store an index of all the objects.
	If you are using inter-message referencing, you must provide the same object for each call.
	The *defaultId* parameter.
	This is the default id to use for the root object (if it doesn't define it's own id)
	The *idPrefix* parameter.
	This the prefix to use for the ids as they enter the index. This allows multiple tables
	to use ids (that might otherwise collide) that enter the same global index.
	idPrefix should be in the form &amp;quot;/Service/&amp;quot;.  For example,
	if the idPrefix is &amp;quot;/Table/&amp;quot;, and object is encountered {id:&amp;quot;4&amp;quot;,...}, this would go in the
	index as &amp;quot;/Table/4&amp;quot;.
	The *idAttribute* parameter.
	This indicates what property is the identity property. This defaults to &amp;quot;id&amp;quot;
	The *assignAbsoluteIds* parameter.
	This indicates that the resolveJson should assign absolute ids (__id) as the objects are being parsed.
	
	The *schemas* parameter
	This provides a map of schemas, from which prototypes can be retrieved
	The *loader* parameter
	This is a function that is called added to the reference objects that can't be resolved (lazy objects)
	return:
	An object, the result of the processing</description>
          </parameter>
        </parameters>
      </method>
      <method name="fromJson" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a string literal of a JSON item, for instance:
	'{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }'</description>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <description>See resolveJson
	
	return:
	An object, the result of the evaluation</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addProp" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.PicasaStore">
    <description>The PicasaStore is a Datastore interface to one of the basic services
	of the Picasa service, the public photo feed.  This does not provide
	access to all the services of Picasa.
	This store cannot do * and ? filtering as the picasa service
	provides no interface for wildcards.</description>
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>The PicasaStore is a Datastore interface to one of the basic services
	of the Picasa service, the public photo feed.  This does not provide
	access to all the services of Picasa.
	This store cannot do * and ? filtering as the picasa service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="instance">
        <description>Utility function to un-escape XML special characters in an HTML string.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The string to un-escape</description>
          </parameter>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped) characters (&lt;,&gt;,&amp;, ", etc,).
	
	TODO: Check to see if theres already compatible escape() in dojo.string or dojo.html</return-description>
      </method>
      <method name="_processPicasaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.QueryReadStore">
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_xhrFetchHandler" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_filterResponse" scope="instance">
        <parameters>
          <parameter name="data" type="The" usage="required">
            <description>data received from server</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.QueryReadStore._features.dojo.data.api"/>
  <class type="dojox.data.RailsStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.S3Store" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.SnapLogicStore">
    <methods>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>See dojo.data.api.Read.close() for generic interface.
	
	In addition to the standard Read API fetch support, this store supports an optimization for
	for retrieving the total count of records in the Pipeline without retrieving the data. To
	use this optimization, simply provide an onBegin handler without an onItem or onComplete handler.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An object that contains properties for initializing the new data store object. The
	following properties are understood:</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_partHandler" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>The request/handle object used with the original fetch() call.</description>
          </parameter>
          <parameter name="part" type="String" usage="required">
            <description>A value indicating which request this handler call is for (this.Parts).</description>
          </parameter>
          <parameter name="response" type="Object" usage="required">
            <description>Response received from the underlying IO transport.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fetchHandler" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="Parts" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.SnapLogicStore.Parts"/>
  <class type="dojox.data.StoreExplorer" superclass="dijit.layout.BorderContainer">
    <methods>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setItemName" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="createNew" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_formatCell" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.BorderContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.StoreExplorer.grid._pending_requests"/>
  <class type="dojox.data.StoreExplorer.grid">
    <methods>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_pending_requests" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.WikipediaStore" superclass="dojox.data.ServiceStore">
    <description>The WikipediaStore is a data store interface to Wikipedia, using the
	Wikipedia SMD spec from dojox.rpc. It currently is useful only for
	finding articles that contain some particular text or grabbing single
	articles by full name; no wildcards or other filtering are supported.</description>
    <methods>
      <method name="fetch" scope="instance">
        <examples>
          <example>Loading a page:
		store.fetch({
			query: {title:"Dojo Toolkit"},
			// define your handlers here
		});</example>
          <example>Searching for pages containing "dojo":
		store.fetch({
			query: {
				action: "query",
				text: "dojo"
			},
			// define your handlers here
		});</example>
          <example>Searching for the next 50 pages containing "dojo":
		store.fetch({
			query: {
				action: "query",
				text: "dojo",
				start: 10,
				count: 50 // max 500; will be capped if necessary
			},
			// define your handlers here
		});</example>
        </examples>
        <parameters>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.ServiceStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.XmlItem">
    <description>This class represents an item of 'XmlStore' holding an XML element.
	'element'
	element:
	An XML element</description>
    <methods>
      <method name="toString" scope="instance">
        <return-description>a value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="element" type="An" usage="required">
            <description>XML element</description>
          </parameter>
          <parameter name="store" type="The" usage="required">
            <description>containing store, if any.</description>
          </parameter>
          <parameter name="query" type="The" usage="required">
            <description>query to use to look up a specific element.
	Usually an XPath or dojo.query statement.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.XmlStore">
    <description>A data store for XML based services or documents</description>
    <methods>
      <method name="unsetAttribute" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	'attribute' can be an XML attribute name of the element or one of
	special names described below.
	If 'attribute' specifies "tagName", nothing is removed and false is
	returned.
	If 'attribute' specifies "childNodes" or "text()", all child nodes
	are removed.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the XML attribute is removed.
	Otherwise, child elements of the tag name specified with
	'attribute' are removed.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of child elements, an XML attribute name or one of
	special names</description>
          </parameter>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", nothing is set and false is
	returned.
	If 'attribute' specifies "childNodes", the value (array of XML
	elements) is set to the element's childNodes.
	If 'attribute' specifies "text()", a text node is created with
	the values and set it to the element as a child.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the first value is set to
	the XML attribute.
	Otherwise, child elements of the tag name specified with
	'attribute' are replaced with new child elements and their
	child text nodes of values.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of child elements, an XML attribute name or one of
	special names
	value:
	A attribute value to set
	notify:
	A non-API optional argument, used to indicate if notification API should be called
	or not.</description>
          </parameter>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", nothing is set and false is
	returned.
	If 'attribute' specifies "childNodes", the value (XML element) is
	added to the element.
	If 'attribute' specifies "text()", a text node is created with
	the value and set it to the element as a child.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value is set to the XML
	attribute.
	Otherwise, a text node is created with the value and set it to
	the first child element of the tag name specified with 'attribute'.
	If the child element does not exist, it is created.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="value" type="almost" usage="required">
            <description>A attribute value to set</description>
          </parameter>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <description>'url' is used to save XML documents for new, modified and/or
	deleted XML elements.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>An object for callbacks</description>
          </parameter>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <return-description>True</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="newItem" scope="instance">
        <description>At least, 'keywordArgs' must contain "tagName" to be used for
	the new	element.
	Other attributes in 'keywordArgs' are set to the new element,
	including "text()", but excluding "childNodes".</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="optional">
            <description>An object containing initial attributes</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
        <return-description>An XML element</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>containing the args for loadItem.  See dojo.data.api.Read.loadItem()</description>
          </parameter>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <description>If 'item' is specified, true is returned if the item is new,
	modified or deleted.
	Otherwise, true is returned if there are any new, modified
	or deleted items.</description>
        <parameters>
          <parameter name="item" type="item" usage="optional">
            <description>An item (XML element) to check</description>
          </parameter>
        </parameters>
        <return-description>True if an item or items are new, modified or deleted, otherwise
	false</return-description>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
        </parameters>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", the tag name of the element is
	returned.
	If 'attribute' specifies "childNodes", child elements are returned.
	If 'attribute' specifies "text()", the values of child text nodes
	are returned.
	For generic attributes, if 'attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value of the XML
	attribute is returned.
	Otherwise, child elements of the tag name specified with
	'attribute' are returned.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of child elements, An XML attribute name or one of
	special names</description>
          </parameter>
        </parameters>
        <return-description>An array of attribute values found, otherwise an empty array</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", the tag name of the element is
	returned.
	If 'attribute' specifies "childNodes", the first element child is
	returned.
	If 'attribute' specifies "text()", the value of the first text
	child is returned.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value of the XML
	attribute is returned.
	Otherwise, the first child element of the tag name specified with
	'attribute' is returned.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>A default value</description>
          </parameter>
        </parameters>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
        <return-types>
          <return-type type="object"/>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <description>For XmlStore, if sendQuery is false and no keyAttribute was set, then this function
	returns null, as xpath is used for the identity, which is not a public attribute of
	the item.  If sendQuery is true and keyAttribute is set, then this function
	returns an array of one attribute name: keyAttribute.   This means the server side
	implementation must apply a keyAttribute to a returned node that always allows
	it to be looked up again.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item from the store from which to obtain the array of public attributes that
	compose the identifier, if any.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The XML Item from the store from which to obtain its identifier.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance">
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	tag names of child elements and XML attribute names of attributes
	specified to the element are returned along with special attribute
	names applicable to the element including "tagName", "childNodes"
	if the element has child elements, "text()" if the element has
	child text nodes, and attribute names in '_attributeMap' that match
	the tag name of the element.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element</description>
          </parameter>
        </parameters>
        <return-description>An array of attributes found</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element to delete</description>
          </parameter>
        </parameters>
        <return-description>True</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <description>An anonymous object to initialize properties.  It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_saveItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_restoreItems" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getXPath" scope="instance">
        <description>A function to compute the xpath of a node in a DOM document.  Used for
	Client side query handling and identity.</description>
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getRootElement" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMElement"/>
        </return-types>
      </method>
      <method name="_getPutUrl" scope="instance">
        <description>This default implementation just returns 'url'.
	Sub-classes may override this method for the custom URL.</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A put URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPutContent" scope="instance">
        <description>This default implementation generates an XML document for one
	(the first only) new or modified element.
	Sub-classes may override this method for the custom put content
	generation.</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A post content</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getPostUrl" scope="instance">
        <description>This default implementation just returns 'url'.
	Sub-classes may override this method for the custom URL.</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A post URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPostContent" scope="instance">
        <description>This default implementation generates an XML document for one
	(the first only) new or modified element.
	Sub-classes may override this method for the custom post content
	generation.</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A post content</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getItems" scope="instance">
        <description>This default implementation walks through child elements of
	the document element to see if all properties of 'query' object
	match corresponding attributes of the element (item).
	If 'request' is not specified, all child elements are returned.
	Sub-classes may override this method for the custom search in
	an XML document.</description>
        <parameters>
          <parameter name="document" type="An" usage="required">
            <description>XML document</description>
          </parameter>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
        </parameters>
        <return-description>An array of items</return-description>
      </method>
      <method name="_getItemIndex" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="_getItem" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getFetchUrl" scope="instance">
        <description>This default implementation generates a query string in the form of
	"?name1=value1&amp;name2=value2..." off properties of 'query' object
	specified in 'request' and appends it to 'url', if 'sendQuery'
	is set to false.
	Otherwise, 'url' is returned as is.
	Sub-classes may override this method for the custom URL generation.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
        </parameters>
        <return-description>A fetch URL</return-description>
      </method>
      <method name="_getDocument" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getDeleteUrl" scope="instance">
        <description>This default implementation returns 'url' with 'keyAttribute'
	as a query string.
	Sub-classes may override this method for the custom URL based on
	changes (new, deleted, or modified).</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to delete</description>
          </parameter>
        </parameters>
        <return-description>A delete URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getAttribute" scope="instance">
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_forgetItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_flattenNodes" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>If 'sendQuery' is true, an XML document is loaded from
	'url' with a query string.
	Otherwise, an XML document is loaded and list XML elements that
	match to a query (set of element names and their text attribute
	values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If 'rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_backupItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="new or already modified"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.rpc">
    <methods>
      <method name="toOrdered" scope="instance">
        <parameters>
          <parameter name="parameters" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTarget" scope="instance">
        <parameters>
          <parameter name="smd" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Service" scope="instance">
        <description>dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
	dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
	a "No match found" error.</description>
        <parameters>
          <parameter name="smd" type="object" usage="required">
            <description>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Rest" scope="instance">
        <parameters>
          <parameter name="path" type="String" usage="required"/>
          <parameter name="isJson" type="Boolean" usage="optional"/>
          <parameter name="schema" type="Object" usage="optional"/>
          <parameter name="getRequest" type="Function" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="OfflineRest" scope="instance" type="Object"/>
      <property name="JsonRest" scope="instance" type="Object"/>
      <property name="Client" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.Rest">
    <methods>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="server error, let the error propagate"/>
        </return-types>
      </method>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="serializedContent" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.util">
    <methods>
      <method name="JsonQuery" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.data.util.JsonQuery">
    <methods>
      <method name="querySuperSet" scope="instance">
        <parameters>
          <parameter name="argsSuper" type="Object" usage="required"/>
          <parameter name="argsSub" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="matchesQuery" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isUpdateable" scope="instance"/>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_toJsonQuery" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="jsonQueryPagination" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.buddhist">
    <methods>
      <method name="isLeapYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
        </parameters>
      </method>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
        </parameters>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="dojox.date.buddhist.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.buddhist.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;,  &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="date1" type="buddhist.Date" usage="required"/>
          <parameter name="date2" type="buddhist.Date" usage="required"/>
          <parameter name="portion" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="dojox.date.buddhist.Date" usage="required">
            <description>buddhist.Date Date object to start with</description>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>How much to add to the date.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.date.buddhist.Date"/>
        </return-types>
      </method>
      <method name="Date" scope="instance">
        <description>This fucntion initialize the date object values</description>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
	
			var date2 = new dojox.date.buddhist.Date(date1);
	
			var date3 = new dojox.date.buddhist.Date(2552,2,12);</example>
        </examples>
      </method>
    </methods>
    <properties>
      <property name="locale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.buddhist.Date">
    <description>This fucntion initialize the date object values</description>
    <methods>
      <method name="valueOf" scope="instance"/>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toGregorian" scope="instance">
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="setSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			date1.setMonth(0); //first month</example>
        </examples>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="instance"/>
      <method name="setFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			date1.setFullYear(2552);
			date1.setFullYear(2552, 1, 1);</example>
        </examples>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
          <parameter name="month" type="number" usage="optional"/>
          <parameter name="date" type="number" usage="optional"/>
        </parameters>
      </method>
      <method name="setDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			date1.setDate(2);</example>
        </examples>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="getSeconds" scope="instance"/>
      <method name="getMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
	
			console.log(date1.getMonth()+1);</example>
        </examples>
      </method>
      <method name="getMinutes" scope="instance"/>
      <method name="getMilliseconds" scope="instance"/>
      <method name="getHours" scope="instance"/>
      <method name="getFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
	
			console.log(date1.getFullYear());</example>
        </examples>
      </method>
      <method name="getDay" scope="instance">
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
	
			console.log(date1.getDate());</example>
        </examples>
        <parameters>
          <parameter name="isNumber" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="fromGregorian" scope="instance">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>This fucntion initialize the date object values</description>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
	
			var date2 = new dojox.date.buddhist.Date(date1);
	
			var date3 = new dojox.date.buddhist.Date(2552,2,12);</example>
        </examples>
      </method>
      <method name="_getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="month" type="number" usage="required"/>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="_addSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_addMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_addMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date">
    <methods>
      <method name="timezone" scope="instance">
        <description>mix-in to dojo.date to provide timezones based on
	the Olson timezone data.
	If you pass "timezone" as a parameter to your format options,
	then you get the date formatted (and offset) for that timezone</description>
      </method>
    </methods>
    <properties>
      <property name="relative" scope="instance" type="Object"/>
      <property name="posix" scope="instance" type="Object"/>
      <property name="php" scope="instance" type="Object"/>
      <property name="islamic" scope="instance" type="Object"/>
      <property name="hebrew" scope="instance" type="Object"/>
      <property name="buddhist" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.buddhist.locale">
    <methods>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="date" type="buddhist" usage="required">
            <description>Date Object?</description>
          </parameter>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="instance">
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_getBuddhistBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.hebrew">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="month" type="hebrew.Date" usage="required"/>
        </parameters>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="dojox.date.hebrew.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.hebrew.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;,  &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="compare" scope="instance">
        <description>Returns 0 if equal, positive if a &gt; b, else negative.
	date1:
	hebrew.Date object
	date2:
	hebrew.Date object.  If not specified, the current hebrew.Date is used.</description>
        <parameters>
          <parameter name="dateheb1" type="hebrew.Date" usage="required"/>
          <parameter name="dateheb2" type="hebrew.Date" usage="required"/>
          <parameter name="portion" type="String" usage="optional">
            <description>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="dojox.date.hebrew.Date" usage="required">
            <description>hebrew.Date Date object to start with</description>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>How much to add to the date.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.date.hebrew.Date"/>
        </return-types>
      </method>
      <method name="Date" scope="instance">
        <description>A Date-like object which implements the Hebrew Calendar.  Because this object
	implements many of the same methods as the native JavaScript Date object, which
	implements the Gregorian calendar, it can often be used its place.  Note that
	this object does not extend Date or use its prototype.</description>
        <examples>
          <example>	dojo.require("dojox.date.hebrew.Date");
	
		var date = new dojox.date.hebrew.Date();
		console.log(date.getFullYear()+'\'+date.getMonth()+'\'+date.getDate());</example>
        </examples>
      </method>
    </methods>
    <properties>
      <property name="numerals" scope="instance" type="Object"/>
      <property name="locale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.hebrew.Date">
    <description>A Date-like object which implements the Hebrew Calendar.  Because this object
	implements many of the same methods as the native JavaScript Date object, which
	implements the Gregorian calendar, it can often be used its place.  Note that
	this object does not extend Date or use its prototype.</description>
    <methods>
      <method name="valueOf" scope="instance"/>
      <method name="toString" scope="instance">
        <description>returns a string representation of the date in "dd, MM, yyyy HH:mm:ss" format (all numeric)
	For user presentation, use dojox.date.hebrew.locale.format which will present in the appropriate language
	and format.  toString() language- and culturally-specific conventions to keep this module free of
	dependencies on dojox.date.locale and dojo.cldr.</description>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			console.log(date1.toString());
			&gt;&gt;&gt; "1, 6, 5769 0:0:0"</example>
        </examples>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toGregorian" scope="instance">
        <examples>
          <example>		var dateHebrew = new dojox.date.hebrew.Date(5768,11,20);
			var dateGregorian = dateHebrew.toGregorian();</example>
        </examples>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="setSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setMonth(0); //first month</example>
        </examples>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="instance">
        <description>Sets the hour and optionally minutes, seconds, milliseconds also.</description>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setHours(12, 30, 0, 0);</example>
        </examples>
      </method>
      <method name="setFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setFullYear(5768);
			date1.setFullYear(5768, 1, 1);</example>
        </examples>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
          <parameter name="month" type="number" usage="optional"/>
          <parameter name="date" type="number" usage="optional"/>
        </parameters>
      </method>
      <method name="setDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			date1.setDate(2);</example>
        </examples>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="isLeapYear" scope="instance">
        <description>The Leap year contains additional month adar sheni
	
	return (year * 12 + 17) % 19 &gt;= 12;</description>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="getSeconds" scope="instance"/>
      <method name="getMonth" scope="instance">
        <description>the result is the index in the month array:
	0. Tishri
	1. Heshvan
	2. Kislev
	3. Tevet
	4. Shevat
	5. Adar I (leap years only)
	6. Adar
	7. Nisan
	8. Iyar
	9. Sivan
	10. Tammuz
	11.	Av
	12. Elul - 12
	For non leap years, for months after Shevat, the actual position of
	the month in the year (used for short format) is less than
	the "absolute" index by 1.</description>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
	
			console.log(date1.getMonth()+1);
			&gt;&gt; 7</example>
        </examples>
      </method>
      <method name="getMinutes" scope="instance"/>
      <method name="getMilliseconds" scope="instance"/>
      <method name="getHours" scope="instance"/>
      <method name="getFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
	
			console.log(date1.getFullYear());
			&gt;&gt; 5769</example>
        </examples>
      </method>
      <method name="getDaysInHebrewMonth" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required"/>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="getDay" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
	
			console.log(date1.getDay());</example>
        </examples>
      </method>
      <method name="getDateLocalized" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
	
			console.log(date1.getDate());</example>
        </examples>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
	
			console.log(date1.getDate());</example>
        </examples>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="fromGregorian" scope="instance">
        <examples>
          <example>		var dateHebrew = new dojox.date.hebrew.Date();
			var dateGregorian = new Date(2008,10,12);
			dateHebrew.fromGregorian(dateGregorian);</example>
        </examples>
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
	
			var date2 = new dojox.date.hebrew.Date(date1);
	
			var date3 = new dojox.date.hebrew.Date(5768,2,12);</example>
        </examples>
      </method>
      <method name="_yearType" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_startOfYear" scope="instance">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="_setDay" scope="instance"/>
      <method name="_handleGetYearLength" scope="instance">
        <parameters>
          <parameter name="eyear" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="_getJulianDayFromGregorianDate" scope="instance">
        <parameters>
          <parameter name="gdate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_floorDivide" scope="instance">
        <parameters>
          <parameter name="numerator" type="Object" usage="required"/>
          <parameter name="denominator" type="Object" usage="required"/>
          <parameter name="remainder" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_computeHebrewFields" scope="instance">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_addSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_addMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_addMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.hebrew.locale">
    <methods>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <examples>
          <example>		var dateHebrew = dojox.date.hebrew.locale.parse('11/10/5740', {datePattern:'dd/MM/yy', selector:'date'});
			in Hebrew locale string for parsing contains Hebrew Numerals
	
		options = {datePattern:'dd MMMM yy', selector:'date'};
	
		 y - year
		 M, MM  - short month
		MMM, MMMM - long month
		d - date
		a - am, pm
		 E, EE, EEE, EEEE  - week day
	
			h, H, k, K, m, s, S,  -  time format</example>
        </examples>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="hebrew.Date"/>
        </return-types>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required">
            <description>'months' || 'days'</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>'wide' || 'narrow' || 'abbr' (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)
	use:
	'standAlone' || 'format' (default)</description>
          </parameter>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional">
            <description>override locale used to find the names</description>
          </parameter>
          <parameter name="date" type="dojox.date.hebrew.Date" usage="optional">
            <description>required for item=months to determine leap month name
	
	using  var monthNames = dojox.date.hebrew.locale.getNames('months', 'wide', 'format', 'he', new hebrewDate(5768, 2, 12));</description>
          </parameter>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <description>Create a string from a hebrew.Date object using a known pattern.
	By default, this method formats both date and time from dateObject.
	Default formatting lengths is 'short'</description>
        <parameters>
          <parameter name="dateObject" type="hebrew.Date" usage="required">
            <description>the date and/or time to be formatted.  If a time only is formatted,
	the values in the year, month, and day fields are irrelevant.  The
	opposite is true when formatting only dates.</description>
          </parameter>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="instance">
        <description>The user may add custom localized formats where the bundle has properties following the
	same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	The pattern string should match the format used by the CLDR.
	See dojo.date.locale.format() for details.
	The resources must be loaded by dojo.requireLocalization() prior to use</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="_getHebrewBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.hebrew.numerals">
    <methods>
      <method name="parseYearHebrewLetters" scope="instance">
        <examples>
          <example>		var date = new dojox.date.hebrew.Date();
						date.setFullYear(dojox.date.hebrew.numerals.parseYearHebrewLetters('\u05ea\u05e9\u05e1\u05f4\u05d7'));</example>
        </examples>
        <parameters>
          <parameter name="year" type="String" usage="required">
            <description>hebrew year</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="parseMonthHebrewLetters" scope="instance">
        <examples>
          <example>		var date = new dojox.date.hebrew.Date();
							var number = dojox.date.hebrew.numerals.parseMonthHebrewLetters("\u05ea\u05de\u05d5\u05d6"); // Tammuz
			date.setMonth(number);</example>
        </examples>
        <parameters>
          <parameter name="monthStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="parseDayHebrewLetters" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
	
			date1.setDate(dojox.date.hebrew.numerals.parseDayHebrewLetters('\u05d0')); // ALEPH</example>
        </examples>
        <parameters>
          <parameter name="day" type="String" usage="required">
            <description>hebrew</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getYearHebrewLetters" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
	
			document.writeln(dojox.date.hebrew.numerals.getYearHebrewLetters(date1.getFullYear());</example>
        </examples>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getMonthHebrewLetters" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
	
			document.writeln(dojox.date.hebrew.numerals.getMonthHebrewLetters(date1.getMonth());</example>
        </examples>
        <parameters>
          <parameter name="month" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getDayHebrewLetters" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
	
			document.writeln(dojox.date.hebrew.numerals.getDayHebrewLetters(date1.getDay());</example>
        </examples>
        <parameters>
          <parameter name="day" type="Object" usage="required"/>
          <parameter name="nogrsh" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.islamic">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="month" type="islamic.Date" usage="required"/>
        </parameters>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="dojox.date.islamic.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.islamic.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;,  &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="compare" scope="instance">
        <description>Returns 0 if equal, positive if a &gt; b, else negative.</description>
        <parameters>
          <parameter name="date1" type="islamic.Date" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="date2" type="islamic.Date" usage="required">
            <description>object.  If not specified, the current islamic.Date is used.</description>
          </parameter>
          <parameter name="portion" type="String" usage="optional">
            <description>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="dojox.date.islamic.Date" usage="required">
            <description>islamic.Date Date object to start with</description>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>How much to add to the date.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.date.islamic.Date"/>
        </return-types>
      </method>
      <method name="Date" scope="instance">
        <description>This module is similar to the Date() object provided by JavaScript</description>
        <examples>
          <example>	dojo.require("dojox.date.islamic.Date");
	
		var date = new dojox.date.islamic.Date();
		document.writeln(date.getFullYear()+'\'+date.getMonth()+'\'+date.getDate());</example>
        </examples>
      </method>
    </methods>
    <properties>
      <property name="locale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.islamic.Date">
    <description>This module is similar to the Date() object provided by JavaScript</description>
    <methods>
      <method name="valueOf" scope="instance"/>
      <method name="toString" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.toString());</example>
        </examples>
      </method>
      <method name="toGregorian" scope="instance">
        <examples>
          <example>		var dateIslamic = new dojox.date.islamic.Date(1429,11,20);
			var dateGregorian = dateIslamic.toGregorian();</example>
        </examples>
      </method>
      <method name="setSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			date1.setMonth(2);</example>
        </examples>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="instance"/>
      <method name="setFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			date1.setYear(1429);</example>
        </examples>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			date1.setDate(2);</example>
        </examples>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="getSeconds" scope="instance"/>
      <method name="getMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
	
			document.writeln(date1.getMonth()+1);</example>
        </examples>
      </method>
      <method name="getMinutes" scope="instance"/>
      <method name="getMilliseconds" scope="instance"/>
      <method name="getHours" scope="instance"/>
      <method name="getFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
	
			document.writeln(date1.getFullYear());</example>
        </examples>
      </method>
      <method name="getDaysInIslamicMonth" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required">
            <description>dojox.date.islamic.Date</description>
          </parameter>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.date.islamic.Date"/>
        </return-types>
      </method>
      <method name="getDay" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
	
			document.writeln(date1.getDay());</example>
        </examples>
      </method>
      <method name="getDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
	
			document.writeln(date1.getDate);</example>
        </examples>
      </method>
      <method name="fromGregorian" scope="instance">
        <examples>
          <example>		var dateIslamic = new dojox.date.islamic.Date();
			var dateGregorian = new Date(2008,10,12);
			dateIslamic.fromGregorian(dateGregorian);</example>
        </examples>
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>This function initialize the date object values</description>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
	
			var date2 = new dojox.date.islamic.Date("12\2\1429");
	
			var date3 = new dojox.date.islamic.Date(date2);
	
			var date4 = new dojox.date.islamic.Date(1429,2,12);</example>
        </examples>
      </method>
      <method name="_yearStart" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_monthStart" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
          <parameter name="month" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_mod" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_civilLeapYear" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_addSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_addMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_addMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.islamic.locale">
    <methods>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="date" type="islamic" usage="required">
            <description>Date Object?</description>
          </parameter>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="dateObject" type="islamic.Date" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="instance">
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="_getIslamicBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.php">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="DateFormat" scope="instance">
        <parameters>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.php.DateFormat">
    <methods>
      <method name="z" scope="instance"/>
      <method name="y" scope="instance"/>
      <method name="w" scope="instance"/>
      <method name="t" scope="instance"/>
      <method name="s" scope="instance"/>
      <method name="r" scope="instance"/>
      <method name="o" scope="instance"/>
      <method name="n" scope="instance"/>
      <method name="m" scope="instance"/>
      <method name="l" scope="instance"/>
      <method name="j" scope="instance"/>
      <method name="i" scope="instance"/>
      <method name="h" scope="instance"/>
      <method name="g" scope="instance"/>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="e" scope="instance"/>
      <method name="d" scope="instance"/>
      <method name="c" scope="instance"/>
      <method name="b" scope="instance"/>
      <method name="a" scope="instance"/>
      <method name="Z" scope="instance"/>
      <method name="Y" scope="instance"/>
      <method name="W" scope="instance"/>
      <method name="U" scope="instance"/>
      <method name="T" scope="instance"/>
      <method name="S" scope="instance"/>
      <method name="P" scope="instance"/>
      <method name="O" scope="instance"/>
      <method name="N" scope="instance"/>
      <method name="M" scope="instance"/>
      <method name="L" scope="instance"/>
      <method name="I" scope="instance"/>
      <method name="H" scope="instance"/>
      <method name="G" scope="instance"/>
      <method name="F" scope="instance"/>
      <method name="D" scope="instance"/>
      <method name="B" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.date.php.DateFormat.format">
    <methods/>
  </class>
  <class type="dojox.date.php.DateFormat.constructor.prototype"/>
  <class type="dojox.date.posix">
    <methods>
      <method name="strftime" scope="instance">
        <description>see http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="setIsoWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="week" type="Number" usage="required">
            <description>can be positive or negative: -1 is the year's last week.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getStartOfWeek" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDay" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getIsoWeeksInYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getIsoWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.relative">
    <methods>
      <method name="format" scope="instance">
        <description>Create a string from a Date object using the most significant information
	and a known localized pattern.  This method formats both the date and
	time from dateObject.  Formatting patterns are chosen appropriate to
	the locale.
	
	If the day portion of the date falls within the current date (or the
	relativeDate option, if present), then the time will be all that
	is displayed
	
	If the day portion of the date falls within the past week (or the
	week preceeding relativeDate, if present), then the display will show
	day of week and time.  This functionality can be turned off by setting
	weekCheck to false.
	
	If the year portion of the date falls within the current year (or the
	year portion of relativeDate, if present), then the display will show
	month and day.
	
	Otherwise, this function is equivalent to calling dojo.date.format with
	formatLength of "medium"</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>the date and time to be formatted.</description>
          </parameter>
          <parameter name="options" type="dojox.date.relative.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="__FormatOptions" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.date.relative.__FormatOptions">
    <methods/>
  </class>
  <class type="ddl"/>
  <class type="dojo._contentHandlers">
    <methods>
      <method name="olson-zoneinfo" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="auto" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.timezone">
    <description>mix-in to dojo.date to provide timezones based on
	the Olson timezone data.
	If you pass "timezone" as a parameter to your format options,
	then you get the date formatted (and offset) for that timezone</description>
    <methods>
      <method name="loadZoneData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <description>The data to load - contains &amp;quot;zones&amp;quot; and &amp;quot;rules&amp;quot; parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="getTzInfo" scope="instance">
        <parameters>
          <parameter name="dt" type="Date" usage="required">
            <description>The Date - a &amp;quot;proxyDate&amp;quot;</description>
          </parameter>
          <parameter name="tz" type="String" usage="required">
            <description>String representation of the timezone you want to get info
	for date</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAllZones" scope="instance"/>
    </methods>
  </class>
  <class type="_ddl">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getZone" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Object" usage="required"/>
          <parameter name="getName" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dnd">
    <methods>
      <method name="Selector" scope="instance"/>
      <method name="BoundingBoxController" scope="instance">
        <parameters>
          <parameter name="sources" type="Array" usage="required">
            <description>an array of dojox.dnd.Selectors which need to be aware of
	the positioning of the bounding box.</description>
          </parameter>
          <parameter name="domNode" type="String|DomNode" usage="required">
            <description>the DOM node or id which represents the bounding box on the page.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dnd.BoundingBoxController">
    <methods>
      <method name="shouldStartDrawingBox" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required">
            <description>the mouse event which caused this callback to fire.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="sources" type="Array" usage="required">
            <description>an array of dojox.dnd.Selectors which need to be aware of
	the positioning of the bounding box.</description>
          </parameter>
          <parameter name="domNode" type="String|DomNode" usage="required">
            <description>the DOM node or id which represents the bounding box on the page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="boundingBoxIsViable" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required">
            <description>the mouse event which caused this callback to fire.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required">
            <description>the mouse event which caused this callback to fire.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required">
            <description>the mouse event which caused this callback to fire.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required">
            <description>the mouse event which caused this callback to fire.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finishSelecting" scope="instance"/>
      <method name="_drawBoundingBox" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dnd.Selector" superclass="dojo.dnd.Selector">
    <methods>
      <method name="shift" scope="instance">
        <parameters>
          <parameter name="toNext" type="Boolean" usage="required">
            <description>If true, we select the next node, otherwise the previous one.</description>
          </parameter>
          <parameter name="add" type="Boolean" usage="optional">
            <description>If true, add to selection, otherwise current selection is
	removed before adding any nodes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="selectNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>Node to select (id or DOM Node)</description>
          </parameter>
          <parameter name="add" type="Boolean" usage="optional">
            <description>If true, node is added to selection, otherwise current
	selection is removed, and node will be the only selection.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="selectByBBox" scope="instance">
        <parameters>
          <parameter name="left" type="Number" usage="required">
            <description>Left coordinate of the bounding box</description>
          </parameter>
          <parameter name="top" type="Number" usage="required">
            <description>Top coordinate of the bounding box</description>
          </parameter>
          <parameter name="right" type="Number" usage="required">
            <description>Right coordinate of the bounding box</description>
          </parameter>
          <parameter name="bottom" type="Number" usage="required">
            <description>Bottom coordinate of the bounding box</description>
          </parameter>
          <parameter name="add" type="Boolean" usage="optional">
            <description>If true, node is added to selection, otherwise current
	selection is removed, and node will be the only selection.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>Node to check (id or DOM Node)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="deselectNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>Node to deselect (id or DOM Node)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_liberalBBLogic" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="left" type="Object" usage="required"/>
          <parameter name="top" type="Object" usage="required"/>
          <parameter name="right" type="Object" usage="required"/>
          <parameter name="bottom" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_isBoundedByBox" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>Node to check (id or DOM Node)</description>
          </parameter>
          <parameter name="left" type="Number" usage="required">
            <description>Left coordinate of the bounding box</description>
          </parameter>
          <parameter name="top" type="Number" usage="required">
            <description>Top coordinate of the bounding box</description>
          </parameter>
          <parameter name="right" type="Number" usage="required">
            <description>Right coordinate of the bounding box</description>
          </parameter>
          <parameter name="bottom" type="Number" usage="required">
            <description>Bottom coordinate of the bounding box</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getNodeId" scope="instance">
        <parameters>
          <parameter name="nodeId" type="String" usage="required">
            <description>the id of the node to use as the base node</description>
          </parameter>
          <parameter name="toNext" type="Boolean" usage="required">
            <description>If true, we select the next node, otherwise the previous one.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_conservativeBBLogic" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="left" type="Object" usage="required"/>
          <parameter name="top" type="Object" usage="required"/>
          <parameter name="right" type="Object" usage="required"/>
          <parameter name="bottom" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Selector" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.drawing">
    <methods>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRegistered" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Drawing" scope="instance">
        <description>Drawing is similar to DojoX Sketch, but is designed to be more versatile
	extendable and customizable.
	Drawing currently only initiates from HTML although it's technically not
	a Dijit to keep the file size light. But if Dijit is available, Drawing
	will register itself with it and can be accessed dijit.byId('myDrawing')
	
	NOTES:
	Although not Drawing and Toolbar, all other objects are created with a custom
	declare. See dojox.drawing.util.oo
	
	The files are laid out as such:
	- Drawing
	The master class. More than one instance of a Drawing can be placed
	on a page at one time (although this has not yet been tested). Plugins
	can be added in markup.
	- Toolbar
	Like Drawing, Toolbar is a psudeo Dijit that does not need Dijit. It is
	optional. It can be oriented horizontal or vertical by placing one of
	those params in the class (at least one is required).  Plugins
	can be added in markup. A drawingId is required to point toolbar to
	the drawing.
	- defaults
	Contains the default styles and dimensions for Stencils. An individual
	Stencil can be changed by calling stencil.att({color obj}); To change
	all styles, a custom defaults file should be used.
	-Stencils
	Drawing uses a concept of 'Stencils' to avoid confusion between a
	Dojox Shape and a Drawing Shape. The classes in the 'stencils' package
	are display only, they are not used for actually drawing (see 'tools').
	This package contains _Base from which stencils inherit most of their
	methods.(Path and Image are display only and not found in Tools)
	- Tools
	The Tools package contains Stencils that are attached to mouse events
	and can be used for drawing. Items in this package can also be selected
	and modified.
	- Tools / Custom
	Holds tools that do not directly extend Stencil base classes and often
	have very custom code.
	- Library (not implemented)
	The Library package, which is not yet implemented, will be the place to
	hold stencils that have very specific data points that result in a picture.
	Flag-like-banners, fancy borders, or other complex shapes would go here.
	- Annotations
	Annotations 'decorate' and attach to other Stencils, such as a 'Label'
	that can show text on a stencil, or an 'Angle' that shows while dragging
	or modifying a Vector, or an Arrow head that is attached to the beginning
	or end of a line.
	- Manager
	Contains classes that control functionality of a Drawing.
	- Plugins
	Contains optional classes that are 'plugged into' a Drawing. There are two
	types: 'drawing' plugins that modify the canvas, and 'tools' which would
	show in the toolbar.
	- Util
	A collection of common tasks.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.drawing.Drawing" id="drawing" defaults="myCustom.defaults"
			plugins="[{'name':'dojox.drawing.plugins.drawing.Grid', 'options':{gap:100}}]"&gt;
		 &lt;/div&gt;</example>
          <example>	&lt;div dojoType="dojox.drawing.Toolbar" drawingId="drawing" class="drawingToolbar vertical"&gt;
			&lt;div tool="dojox.drawing.tools.Line" selected="false"&gt;Line&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.Rect" selected="false"&gt;Rect&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.Ellipse" selected="false"&gt;Ellipse&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.TextBlock" selected="false"&gt;Statement&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.custom.Equation" selected="false"&gt;Equation&lt;/div&gt;
			&lt;div plugin="dojox.drawing.plugins.tools.Pan" options="{}"&gt;Pan&lt;/div&gt;
			&lt;div plugin="dojox.drawing.plugins.tools.Zoom" options="{zoomInc:.1,minZoom:.5,maxZoom:2}"&gt;Zoom&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="HTMLNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="util" scope="instance" type="Object"/>
      <property name="ui" scope="instance" type="Object"/>
      <property name="tools" scope="instance" type="Object"/>
      <property name="stencil" scope="instance" type="Object"/>
      <property name="plugins" scope="instance" type="Object"/>
      <property name="manager" scope="instance" type="Object"/>
      <property name="library" scope="instance" type="Object"/>
      <property name="defaults" scope="instance" type="Object">
        <description>Styles and defaults used for Drawing stencils and text.</description>
      </property>
      <property name="annotations" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.Drawing">
    <description>Drawing is similar to DojoX Sketch, but is designed to be more versatile
	extendable and customizable.
	Drawing currently only initiates from HTML although it's technically not
	a Dijit to keep the file size light. But if Dijit is available, Drawing
	will register itself with it and can be accessed dijit.byId('myDrawing')
	
	NOTES:
	Although not Drawing and Toolbar, all other objects are created with a custom
	declare. See dojox.drawing.util.oo
	
	The files are laid out as such:
	- Drawing
	The master class. More than one instance of a Drawing can be placed
	on a page at one time (although this has not yet been tested). Plugins
	can be added in markup.
	- Toolbar
	Like Drawing, Toolbar is a psudeo Dijit that does not need Dijit. It is
	optional. It can be oriented horizontal or vertical by placing one of
	those params in the class (at least one is required).  Plugins
	can be added in markup. A drawingId is required to point toolbar to
	the drawing.
	- defaults
	Contains the default styles and dimensions for Stencils. An individual
	Stencil can be changed by calling stencil.att({color obj}); To change
	all styles, a custom defaults file should be used.
	-Stencils
	Drawing uses a concept of 'Stencils' to avoid confusion between a
	Dojox Shape and a Drawing Shape. The classes in the 'stencils' package
	are display only, they are not used for actually drawing (see 'tools').
	This package contains _Base from which stencils inherit most of their
	methods.(Path and Image are display only and not found in Tools)
	- Tools
	The Tools package contains Stencils that are attached to mouse events
	and can be used for drawing. Items in this package can also be selected
	and modified.
	- Tools / Custom
	Holds tools that do not directly extend Stencil base classes and often
	have very custom code.
	- Library (not implemented)
	The Library package, which is not yet implemented, will be the place to
	hold stencils that have very specific data points that result in a picture.
	Flag-like-banners, fancy borders, or other complex shapes would go here.
	- Annotations
	Annotations 'decorate' and attach to other Stencils, such as a 'Label'
	that can show text on a stencil, or an 'Angle' that shows while dragging
	or modifying a Vector, or an Arrow head that is attached to the beginning
	or end of a line.
	- Manager
	Contains classes that control functionality of a Drawing.
	- Plugins
	Contains optional classes that are 'plugged into' a Drawing. There are two
	types: 'drawing' plugins that modify the canvas, and 'tools' which would
	show in the toolbar.
	- Util
	A collection of common tasks.</description>
    <methods>
      <method name="unSetTool" scope="instance"/>
      <method name="toSelected" scope="instance">
        <examples>
          <example>	myDrawing.toSelected('attr', {x:10})</example>
        </examples>
        <parameters>
          <parameter name="func" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="setTool" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectAll" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="box" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAll" scope="instance"/>
      <method name="registerTool" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onSurfaceReady" scope="instance"/>
      <method name="onRenderStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initPlugins" scope="instance"/>
      <method name="importer" scope="instance">
        <parameters>
          <parameter name="objects" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getShapeProps" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getConstructor" scope="instance">
        <parameters>
          <parameter name="abbr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="exporter" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="HTMLNode" usage="required"/>
        </parameters>
      </method>
      <method name="changeDefaults" scope="instance">
        <examples>
          <example>	myDrawing.changeDefaults({
			norm:{
				fill:"#0000ff",
				width:5,
				color:"#ffff00"
			}
		});
	
	console.log("-----&gt;&gt;&gt; changeDefault: ",newStyle, " value?: ",value);</example>
        </examples>
        <parameters>
          <parameter name="newStyle" type="Object" usage="required">
            <description>An object that represents one of the objects in
	drawing.style that will be mixed in. Not all
	properties are necessary. Only one object may
	be changed at a time. The object boolean parameter
	is not required and if not set objects will automatically
	be changed.
	Changing non-objects like angleSnap requires value
	to be true.</description>
          </parameter>
          <parameter name="value" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="addUI" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>Object The parameters used to draw the object. See stencil._Base and each
	tool for specific parameters of teh data or points objects.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addStencil" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>Object The parameters used to draw the object. See stencil._Base and each
	tool for specific parameters of teh data or points objects.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addPlugin" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createCanvas" scope="instance"/>
    </methods>
    <properties>
      <property name="defaults" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.Drawing.defaults"/>
  <class type="dojox.drawing.annotations"/>
  <class type="dojox.drawing.defaults">
    <description>This object contains defaults for objects used in Drawing.
	To change one item's style, use item.attr();
	To change all these styles, create a copy of this file
	and point to it in the Drawing properties:
		&lt;div dojoType="dojox.drawing.Drawing" id="drawing" defaults="MyCustom.defaults"&gt;&lt;/div&gt;
	See:
	Drawing.changeDefaults
	
	Determines whether in draw or edit mode (whether stencils
	are clickable.  If clickMode is false, the original
	functionality of silently switching between select modes
	is enabled.  If clickMode is true, it allows powerpoint-
	like functionality.  Clickable is used by powerpoint to
	distinguish when things can be selected and when they can't</description>
    <methods>
      <method name="copy" scope="instance"/>
    </methods>
    <properties>
      <property name="textMode" scope="instance" type="Object">
        <description>These styles apply to the containing
	text box (edit mode), and not the text itself</description>
      </property>
      <property name="textDisabled" scope="instance" type="Object">
        <description>Style of disabled text</description>
      </property>
      <property name="text" scope="instance" type="Object">
        <description>Style of text</description>
      </property>
      <property name="selected" scope="instance" type="Object">
        <description>Selected style of all shapes
	styles not shown will used from
	norm</description>
      </property>
      <property name="norm" scope="instance" type="Object">
        <description>Normal style of all shapes
	will get overridden by
	above andes styles
	
	
	square, butt, round</description>
      </property>
      <property name="hitSelected" scope="instance" type="Object">
        <description>Selected style of a hit area</description>
      </property>
      <property name="hitNorm" scope="instance" type="Object">
        <description>Normal style of a hit area</description>
      </property>
      <property name="hitHighlighted" scope="instance" type="Object">
        <description>Highlighted style of a hit area</description>
      </property>
      <property name="highlighted" scope="instance" type="Object">
        <description>Highlighted style of all shapes
	NOT CURRENTLY BEING USED</description>
      </property>
      <property name="disabled" scope="instance" type="Object">
        <description>Disabled or &amp;quot;locked&amp;quot; or &amp;quot;fade&amp;quot; style of all shapes</description>
      </property>
      <property name="button" scope="instance" type="Object"/>
      <property name="arrows" scope="instance" type="Object">
        <description>Size of arrows on vectors.
	length is in pixels
	width is actually an angle
	but is close to pixels in size</description>
      </property>
      <property name="anchors" scope="instance" type="Object">
        <description>Style for the anchor resize-points
	not really an anchor prop</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.norm"/>
  <class type="dojox.drawing.defaults.selected"/>
  <class type="dojox.drawing.defaults.highlighted"/>
  <class type="dojox.drawing.defaults.disabled"/>
  <class type="dojox.drawing.defaults.hitNorm">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitNorm.color"/>
  <class type="dojox.drawing.defaults.hitNorm.fill"/>
  <class type="dojox.drawing.defaults.hitSelected">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitSelected.fill"/>
  <class type="dojox.drawing.defaults.hitHighlighted">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitHighlighted.fill"/>
  <class type="dojox.drawing.defaults.anchors"/>
  <class type="dojox.drawing.defaults.arrows"/>
  <class type="dojox.drawing.defaults.text"/>
  <class type="dojox.drawing.defaults.textDisabled"/>
  <class type="dojox.drawing.defaults.textMode">
    <properties>
      <property name="edit" scope="instance" type="Object"/>
      <property name="create" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.textMode.create"/>
  <class type="dojox.drawing.defaults.textMode.edit"/>
  <class type="dojox.drawing.defaults.button">
    <properties>
      <property name="selected" scope="instance" type="Object"/>
      <property name="over" scope="instance" type="Object"/>
      <property name="norm" scope="instance" type="Object"/>
      <property name="icon" scope="instance" type="Object"/>
      <property name="down" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.norm">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.norm.fill"/>
  <class type="dojox.drawing.defaults.button.over">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.over.fill"/>
  <class type="dojox.drawing.defaults.button.down">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.down.fill"/>
  <class type="dojox.drawing.defaults.button.selected">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.selected.fill"/>
  <class type="dojox.drawing.defaults.button.icon">
    <properties>
      <property name="selected" scope="instance" type="Object"/>
      <property name="norm" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.icon.norm"/>
  <class type="dojox.drawing.defaults.button.icon.selected"/>
  <class type="dojox.drawing.library">
    <properties>
      <property name="icons" scope="instance" type="Object">
        <description>A collection of icon Stencils for use with the buttons in the ui/Toolbar.</description>
      </property>
      <property name="greek" scope="instance" type="Object">
        <description>Greek characters used by typesetter and greekPalette.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.library.greek">
    <description>These are used to convert between the character and
	the written version of greek letters.  Any character
	can be included here and it will automatically be added
	to the palette and converted by typesetter</description>
  </class>
  <class type="dojox.drawing.library.icons">
    <description>Each icon name coresponds to a Stencil or a Plugin. One can be inserted
	into a button by adding the property: 'icon', which points to one of
	these Stencil objects.</description>
    <properties>
      <property name="zoomOut" scope="instance" type="Object"/>
      <property name="zoomIn" scope="instance" type="Object"/>
      <property name="zoom100" scope="instance" type="Object"/>
      <property name="vector" scope="instance" type="Object"/>
      <property name="triangle" scope="instance" type="Object"/>
      <property name="textBlock" scope="instance" type="Object"/>
      <property name="rect" scope="instance" type="Object"/>
      <property name="plus" scope="instance" type="Object"/>
      <property name="pencil" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
      <property name="pan" scope="instance" type="Object"/>
      <property name="line" scope="instance" type="Object"/>
      <property name="iconize" scope="instance" type="Object"/>
      <property name="equation" scope="instance" type="Object"/>
      <property name="ellipse" scope="instance" type="Object"/>
      <property name="axes" scope="instance" type="Object"/>
      <property name="arrow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.line"/>
  <class type="dojox.drawing.library.icons.ellipse"/>
  <class type="dojox.drawing.library.icons.rect"/>
  <class type="dojox.drawing.library.icons.triangle"/>
  <class type="dojox.drawing.library.icons.path"/>
  <class type="dojox.drawing.library.icons.arrow"/>
  <class type="dojox.drawing.library.icons.textBlock"/>
  <class type="dojox.drawing.library.icons.equation"/>
  <class type="dojox.drawing.library.icons.axes"/>
  <class type="dojox.drawing.library.icons.vector"/>
  <class type="dojox.drawing.library.icons.pan"/>
  <class type="dojox.drawing.library.icons.plus"/>
  <class type="dojox.drawing.library.icons.zoomIn"/>
  <class type="dojox.drawing.library.icons.zoomOut"/>
  <class type="dojox.drawing.library.icons.zoom100"/>
  <class type="dojox.drawing.library.icons.iconize"/>
  <class type="dojox.drawing.library.icons.pencil"/>
  <class type="dojox.drawing.manager">
    <properties>
      <property name="keys" scope="instance" type="Object">
        <description>A singleton, master object that detects
	keyboard keys and events
	Connect to it like:
	dojo.connect(this.keys, &amp;quot;onEnter&amp;quot;, ....);</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.manager.keys">
    <methods>
      <method name="scanForFields" scope="instance"/>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onEsc" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onEnter" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onArrow" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="enable" scope="instance">
        <parameters>
          <parameter name="_enabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="editMode" scope="instance">
        <parameters>
          <parameter name="_isedit" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixin" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLetter" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.manager.keys.scanForFields">
    <methods/>
  </class>
  <class type="dojox.drawing.plugins">
    <methods>
      <method name="Greeks" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tools" scope="instance" type="Object"/>
      <property name="drawing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing">
    <methods>
      <method name="GreekPalette" scope="instance">
        <description>Grid showing all available entity options which the
	user can pick from.  The library loaded for use by the picker
	is found in dojox.drawing.library.greek.  Adding characters
	there will automatically add them to the palette.
	
	This works as a popup and as such its onChange and onCancel
	close it.  TextBlock manages it, since it's what uses the assist
	so it calls show (all actual popup management happens here).
	In order to activate the plugin require it and then include the
	markup in the example:</description>
        <examples>
          <example>	&lt;!--Because this is a widget it is included in markup and NOT like the other plugins--&gt;
		&lt;div dojoType="dojox.drawing.plugins.drawing.GreekPalette" id="greekPalette"&gt;&lt;/div&gt;</example>
        </examples>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette" superclass="dijit._Widget">
    <description>Grid showing all available entity options which the
	user can pick from.  The library loaded for use by the picker
	is found in dojox.drawing.library.greek.  Adding characters
	there will automatically add them to the palette.
	
	This works as a popup and as such its onChange and onCancel
	close it.  TextBlock manages it, since it's what uses the assist
	so it calls show (all actual popup management happens here).
	In order to activate the plugin require it and then include the
	markup in the example:</description>
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="closeAll" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setCurrent" scope="instance">
        <description>At any point in time there's exactly one
	cell with tabIndex != -1.   If focus is inside the palette then
	focus is on that cell.
	
	After calling this method, arrow key handlers and mouse click handlers
	should focus the cell in a setTimeout().</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_preparePalette" scope="instance">
        <parameters>
          <parameter name="choices" type="Array&lt;Array&lt;String&gt;&gt;" usage="required">
            <description>id's for each cell of the palette, used to create Dye JS object for each cell</description>
          </parameter>
          <parameter name="titles" type="Array&lt;String&gt;" usage="required">
            <description>Localized tooltip for each cell</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required">
            <description>event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_navigateByArrow" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayDetails" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="previewNode" scope="instance" type="Object"/>
      <property name="descNode" scope="instance" type="Object"/>
      <property name="_textBlock" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette._textBlock"/>
  <class type="dojox.drawing.plugins.drawing.GreekPalette.previewNode"/>
  <class type="dojox.drawing.plugins.drawing.GreekPalette.descNode"/>
  <class type="dojox.drawing.plugins.Greeks">
    <methods>
      <method name="getValue" scope="instance"/>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.plugins.tools">
    <properties>
      <property name="ZoomOut" scope="instance" type="Object"/>
      <property name="ZoomIn" scope="instance" type="Object"/>
      <property name="Zoom100" scope="instance" type="Object"/>
      <property name="Pan" scope="instance" type="Object"/>
      <property name="Iconize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Iconize">
    <properties>
      <property name="setup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Iconize.setup"/>
  <class type="dojox.drawing.plugins.tools.Pan">
    <properties>
      <property name="setup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Pan.setup"/>
  <class type="dojox.drawing.plugins.tools.ZoomIn">
    <properties>
      <property name="setup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.ZoomIn.setup"/>
  <class type="dojox.drawing.plugins.tools.Zoom100">
    <properties>
      <property name="setup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Zoom100.setup"/>
  <class type="dojox.drawing.plugins.tools.ZoomOut">
    <properties>
      <property name="setup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.ZoomOut.setup"/>
  <class type="__StencilData"/>
  <class type="dojox.drawing.stencil"/>
  <class type="StencilArgs"/>
  <class type="dojox.drawing.tools">
    <properties>
      <property name="custom" scope="instance" type="Object"/>
      <property name="TextBlock" scope="instance" type="Object"/>
      <property name="Rect" scope="instance" type="Object"/>
      <property name="Pencil" scope="instance" type="Object"/>
      <property name="Path" scope="instance" type="Object"/>
      <property name="Line" scope="instance" type="Object"/>
      <property name="Ellipse" scope="instance" type="Object"/>
      <property name="Arrow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Arrow">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See stencil._Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Arrow.setup"/>
  <class type="dojox.drawing.tools.Ellipse">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See stencil._Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Ellipse.setup"/>
  <class type="dojox.drawing.tools.Line">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See stencil._Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Line.setup"/>
  <class type="dojox.drawing.tools.Path">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Path.setup"/>
  <class type="dojox.drawing.tools.Pencil">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Pencil.setup"/>
  <class type="dojox.drawing.tools.Rect">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See stencil._Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Rect.setup"/>
  <class type="dojox.drawing.tools.TextBlock">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See stencil._Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.TextBlock.setup"/>
  <class type="dojox.drawing.tools.custom">
    <properties>
      <property name="Vector" scope="instance" type="Object"/>
      <property name="Equation" scope="instance" type="Object"/>
      <property name="Axes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Axes">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See stencil._Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Axes.setup"/>
  <class type="dojox.drawing.tools.custom.Equation">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See stencil._Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Equation.setup"/>
  <class type="dojox.drawing.tools.custom.Vector">
    <properties>
      <property name="setup" scope="instance" type="Object">
        <description>See stencil._Base ToolsSetup</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup">
    <properties>
      <property name="secondary" scope="instance" type="Object">
        <description>Creates a secondary tool for the Vector Stencil.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary">
    <description>See Toolbar.js makeButtons function.  The toolbar
	checks Vector.setup for a secondary tool and requires
	name, label, and funct.  Currently it doesn't accept icon
	and only uses text from label for the button.  Funct is the
	function that fires when the button is clicked.
	
	Setup and postSetup are optional
	and allow tool specific functions to be added to the
	Toolbar object as if they were written there.</description>
    <methods>
      <method name="setup" scope="instance"/>
      <method name="postSetup" scope="instance">
        <parameters>
          <parameter name="btn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="funct" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary.funct">
    <methods/>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary.funct.drawing.stencils"/>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary.setup">
    <methods>
      <method name="zSelect" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zDeselect" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="vectorTest" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.drawing.ui">
    <methods>
      <method name="Toolbar" scope="instance">
        <description>Creates a GFX-based toobar that holds GFX-based buttons. Can be either created
	within the actual drawing or within a seperate DOM element. When within the
	drawing, the toolbar will cover a portion of the drawing; hence the option.
	
	A Toolbar can be created programmtically or in markup. Currently markup is as
	a separate DOM element and programmtic is within the drawing.
	examples:
		dojo.connect(myDrawing, "onSurfaceReady", function(){
			new dojox.drawing.ui.Toolbar({
				drawing:myDrawing,
				tools:"all",
				plugs:"all",
				selected:"ellipse"
			});
		});
	
	 &lt;div dojoType="dojox.drawing.ui.Toolbar" id="gfxToolbarNode" drawingId="drawingNode"
			class="gfxToolbar" tools="all" plugs="all" selected="ellipse" orient="H"&gt;&lt;/div&gt;</description>
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dom" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.Toolbar">
    <description>Creates a GFX-based toobar that holds GFX-based buttons. Can be either created
	within the actual drawing or within a seperate DOM element. When within the
	drawing, the toolbar will cover a portion of the drawing; hence the option.
	
	A Toolbar can be created programmtically or in markup. Currently markup is as
	a separate DOM element and programmtic is within the drawing.
	examples:
		dojo.connect(myDrawing, "onSurfaceReady", function(){
			new dojox.drawing.ui.Toolbar({
				drawing:myDrawing,
				tools:"all",
				plugs:"all",
				selected:"ellipse"
			});
		});
	
	 &lt;div dojoType="dojox.drawing.ui.Toolbar" id="gfxToolbarNode" drawingId="drawingNode"
			class="gfxToolbar" tools="all" plugs="all" selected="ellipse" orient="H"&gt;&lt;/div&gt;</description>
    <methods>
      <method name="onToolClick" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRenderStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlugClick" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeButtons" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTool" scope="instance"/>
      <method name="addPlugin" scope="instance"/>
      <method name="addBack" scope="instance"/>
      <method name="_mixprops" scope="instance">
        <parameters>
          <parameter name="props" type="Array" usage="required"/>
          <parameter name="objNode" type="Object" usage="required">
            <description>| Node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.ui.dom">
    <methods>
      <method name="Toolbar" scope="instance">
        <description>Currently works in markup only. A class is required with
	either horizontal or vertical as a class (IE prevented using
	either as a default). Assign an attribute of 'drawingId' with
	the id of the DojoX Drawing to which this is assigned.
	The node children will be assigned as the Tools in the toolbar.
	Plugins can also be assigned.
	The Toolbar is largely self contained and has no real public
	methods or events. the Drawing object should be used.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.drawing.Toolbar" drawingId="drawing" class="drawingToolbar vertical"&gt;
			&lt;div tool="dojox.drawing.tools.Line" 				selected="false"&gt;	Line&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.Rect" 				selected="true"&gt;	Rect&lt;/div&gt;
			&lt;div plugin="dojox.drawing.plugins.tools.Zoom" options="{zoomInc:.1,minZoom:.5,maxZoom:2}"&gt;Zoom&lt;/div&gt;
		&lt;/div&gt;
	
	TODO: Toolbar works in markup only. Need programmatic.
	NOTE: There are plans to make the toolbar out of dojox.gfx vectors.
	This may change the APIs in the future.</example>
        </examples>
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="Pan" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.dom.Pan">
    <properties>
      <property name="setup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.dom.Pan.setup"/>
  <class type="dojox.drawing.ui.dom.Toolbar">
    <description>Currently works in markup only. A class is required with
	either horizontal or vertical as a class (IE prevented using
	either as a default). Assign an attribute of 'drawingId' with
	the id of the DojoX Drawing to which this is assigned.
	The node children will be assigned as the Tools in the toolbar.
	Plugins can also be assigned.
	The Toolbar is largely self contained and has no real public
	methods or events. the Drawing object should be used.</description>
    <methods>
      <method name="parse" scope="instance"/>
      <method name="onSetTool" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>Fully qualified name of class. ex:
	dojox.drawing.tools.Ellipse</description>
          </parameter>
        </parameters>
      </method>
      <method name="createTool" scope="instance">
        <parameters>
          <parameter name="node" type="HTMLNode" usage="required">
            <description>The button node.</description>
          </parameter>
        </parameters>
      </method>
      <method name="createIcon" scope="instance">
        <parameters>
          <parameter name="node" type="HTMLNode" usage="required">
            <description>The button node.</description>
          </parameter>
          <parameter name="constr" type="Object" usage="required">
            <description>Function Optional. If not supplied, an icon is not created.
	Information for each icon is derived from
	the ToolsSetup object defined at the end
	of each tool. See: stencil._Base</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.util">
    <properties>
      <property name="typeset" scope="instance" type="Object"/>
      <property name="positioning" scope="instance" type="Object"/>
      <property name="oo" scope="instance" type="Object">
        <description>Inheritance utilities used in DojoX Drawing</description>
      </property>
      <property name="common" scope="instance" type="Object">
        <description>A collection of common methods used for DojoX Drawing.
	This singleton is accessible in most Drawing classes
	as this.util
	
	NOTE:
	A lot of functions use a EventObject
	as an argument. An attempt was made to accept
	either that object or a list of numbers. That wasn't
	finished (it didn't work well in all cases) but is
	likely to happen in the future.
	In cases where you are not sending a Mouse object,
	form your argument like so:
	var obj = {
	start:{
	x:Number,  	// start x
	y:Number	// start y
	},
	x: Number,		// end x
	y:Number		// end y
	}</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.util.common">
    <methods>
      <method name="uid" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required">
            <description>String If provided, kept in a map, incremented
	and used in the id. Otherwise 'shape' is used.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="snapAngle" scope="instance">
        <parameters>
          <parameter name="obj" type="EventObject" usage="required">
            <description>Mouse object (see dojox.drawing.Mouse)</description>
          </parameter>
          <parameter name="ca" type="Float" usage="required">
            <description>Fractional amount to snap to
	A decimal number fraction of a half circle
	.5 would snap to 90 degrees
	.25  would snap to 45 degrees
	.125 would snap to 22.5 degrees, etc.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="slope" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="radians" scope="instance">
        <parameters>
          <parameter name="o" type="EventObject" usage="required"/>
        </parameters>
      </method>
      <method name="radToDeg" scope="instance">
        <parameters>
          <parameter name="n" type="Numer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pointOnCircle" scope="instance">
        <parameters>
          <parameter name="cx" type="Number" usage="required"/>
          <parameter name="cy" type="Number" usage="required"/>
          <parameter name="radius" type="Number" usage="required"/>
          <parameter name="angle" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="oppAngle" scope="instance">
        <parameters>
          <parameter name="ang" type="Angle" usage="required"/>
        </parameters>
      </method>
      <method name="mixin" scope="instance">
        <parameters>
          <parameter name="o1" type="Object" usage="required"/>
          <parameter name="o2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="lineSub" scope="instance">
        <description>x1,y1,x2,y2 represents the Line. 'amt' represents the amount
	to subtract from it.</description>
        <parameters>
          <parameter name="x1" type="Number" usage="required"/>
          <parameter name="y1" type="Number" usage="required"/>
          <parameter name="x2" type="Number" usage="required"/>
          <parameter name="y2" type="Number" usage="required"/>
          <parameter name="amt" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="o" type="EventObject" usage="required"/>
        </parameters>
      </method>
      <method name="idSetStart" scope="instance">
        <parameters>
          <parameter name="num" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="distance" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="degToRad" scope="instance">
        <parameters>
          <parameter name="n" type="Numer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="constrainAngle" scope="instance">
        <parameters>
          <parameter name="obj" type="EventObject" usage="required"/>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="prop" type="property" usage="required"/>
          <parameter name="value" type="Object" usage="required">
            <description>value</description>
          </parameter>
          <parameter name="squelchErrors" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="argsToObj" scope="instance"/>
      <method name="angle" scope="instance">
        <parameters>
          <parameter name="obj" type="EventObject" usage="required">
            <description>Manager.Mouse event.</description>
          </parameter>
          <parameter name="snap" type="Object" usage="required">
            <description>Float Returns nearest angle within snap limits
	
	obj = this.argsToObj.apply(this, arguments);</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="abbr" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.util.oo">
    <description>Inheritance utilities used in DojoX Drawing.
	There were designed in a effort to make Drawing as
	fast as possible - especially in a case where thousands
	of objects are being loaded. Drawing declare performs
	about 3 times faster than Dojo declare and 2 times
	faster than Dojox declare. This is not to say Drawing
	declare is wthout limitations. It doesn't have the same
	syntatic sugar and extensibility of the other two. You
	can't inhert methods. It won't work with Dijit. But it
	is simple and effective.</description>
    <methods>
      <method name="extend" scope="instance">
        <description>Typically not used by itself - it's used as
	part of declare(). Could be used by itself
	however, to mix together two or more
	constructors.
	arguments:
	Function, [ Function...]
	Any number of arguments, all must be
	function constructors. The first is
	considered the base object and its
	constructor will fire first.</description>
        <examples>
          <example>	var A = function(){};
		var B = function(){};
		var C = function(){};
		var D = dojox.drawing.util.oo.extend(A, B, C);
		var e = new D();</example>
        </examples>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="declare" scope="instance">
        <description>Similar in look and feel to Dojo declare as
	far as order and number of arguments, although
	constructed a little closer to prototypical
	inheritance. All arguments passed into the
	constructor are passed into all sub constructors.
	arguments:
	Function, [Object|Function....]
	The first argument is always the base
	constructor. The last argument is always
	an object of methods (or empty object) to
	be mixed in (in the future would like to
	make that object optional). Remaining
	arguments are other constructors mixed in
	using extend() (See below).</description>
        <examples>
          <example>	MyFunction = dojox.drawing.util.oo.declare(
			MyOtherFunction,
			YetAnotherFunction,
			function(options){
				// This is my constructor. It will fire last.
				// The other constructors will fire before this.
			},
			{
				customType:"equation", // mixed in property
				doThing: function(){   // mixed in method
	
				}
			}
		);
	
		var f = new MyFunction();</example>
        </examples>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.util.positioning">
    <methods>
      <method name="label" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="angle" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.util.typeset">
    <methods>
      <method name="convertLaTeX" scope="instance">
        <parameters>
          <parameter name="inText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="convertHTML" scope="instance">
        <parameters>
          <parameter name="inText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl">
    <methods>
      <method name="quickFilter" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_noOpNode" scope="instance"/>
      <method name="_Templated" scope="instance"/>
      <method name="_DomVarNode" scope="instance">
        <description>Will render an object that supports the render function
	and the getRootNode function</description>
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_DomTextNode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_DomTemplated" scope="instance"/>
      <method name="_DomParser" scope="instance">
        <description>This is also used by all tags to move through
	the list of nodes.</description>
        <parameters>
          <parameter name="tokens" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_DomNodeList" scope="instance">
        <description>Any object that's used in the constructor or added
	through the push function much implement the
	render, unrender, and clone functions.</description>
        <parameters>
          <parameter name="nodes" type="Array&lt;Node&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="_DomNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Context" scope="instance">
        <parameters>
          <parameter name="dict" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Token" scope="instance">
        <parameters>
          <parameter name="token_type" type="Object" usage="required"/>
          <parameter name="contents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Template" scope="instance">
        <parameters>
          <parameter name="template" type="String|dojo._Url" usage="required">
            <description>The string or location of the string to
	use as a template</description>
          </parameter>
          <parameter name="isString" type="Boolean" usage="required">
            <description>Indicates whether the template is a string or a url.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Inline" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DomTemplate" scope="instance">
        <parameters>
          <parameter name="obj" type="String|DOMNode|dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="DomInline" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DomBuffer" scope="instance">
        <description>Use this to append a child, change the parent, or
	change the attribute of the current node.</description>
        <parameters>
          <parameter name="parent" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="Context" scope="instance">
        <parameters>
          <parameter name="dict" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ChangeNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="up" type="Boolean" usage="optional"/>
          <parameter name="root" type="Bookean" usage="required"/>
        </parameters>
      </method>
      <method name="AttributeNode" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="utils" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="tag" scope="instance" type="Object"/>
      <property name="render" scope="instance" type="Object"/>
      <property name="register" scope="instance" type="Object"/>
      <property name="filter" scope="instance" type="Object"/>
      <property name="ext-dojo" scope="instance" type="Object"/>
      <property name="dom" scope="instance" type="Object"/>
      <property name="contrib" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="BOOLS" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Context" superclass="dojox.dtl._Context.prototype">
    <methods>
      <method name="setThis" scope="instance">
        <parameters>
          <parameter name="_this" type="Object" usage="required">
            <description>the this ref.</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasKey" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required">
            <description>The key to look up.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getThis" scope="instance"/>
      <method name="getKeys" scope="instance"/>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="filter" type="dojox.dtl.Context|Object|String" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="extend" scope="instance">
        <parameters>
          <parameter name="obj" type="dojox.dtl.Context|Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.Context.setThis">
    <methods/>
  </class>
  <class type="dojox.dtl.DomInline" superclass="dijit._WidgetBase.prototype">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="dojox.dtl.Context" usage="optional"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl.DomInline.render">
    <methods/>
  </class>
  <class type="dojox.dtl.DomInline.buildRendering">
    <methods/>
  </class>
  <class type="dojox.dtl.DomInline.postMixInProperties">
    <methods/>
  </class>
  <class type="dojox.dtl.Inline" superclass="dijit._WidgetBase.prototype">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object|dojox.dtl.Context" usage="optional"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl.Inline.render">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline.render.domNode"/>
  <class type="dojox.dtl.Inline.buildRendering">
    <methods/>
  </class>
  <class type="dojox.dtl.Inline.postMixInProperties">
    <methods/>
  </class>
  <class type="dojox.dtl._DomTemplated">
    <methods>
      <method name="setTemplate" scope="instance">
        <parameters>
          <parameter name="template" type="String|dojo._Url" usage="required">
            <description>The new template.</description>
          </parameter>
          <parameter name="context" type="dojox.dtl.Context" usage="optional">
            <description>The runtime context.</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="dojox.dtl.Context" usage="optional">
            <description>The runtime context.</description>
          </parameter>
          <parameter name="tpl" type="dojox.dtl.DomTemplate" usage="optional">
            <description>The template to render. Optional.</description>
          </parameter>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_getContext" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCachedTemplate" scope="instance">
        <parameters>
          <parameter name="templatePath" type="Object" usage="required"/>
          <parameter name="templateString" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl._DomTemplated.buildRendering">
    <methods/>
  </class>
  <class type="dojox.dtl._DomTemplated.setTemplate">
    <methods/>
  </class>
  <class type="dojox.dtl._DomTemplated.render">
    <methods/>
  </class>
  <class type="dojox.dtl._DomTemplated._getCachedTemplate">
    <methods/>
  </class>
  <class type="dojox.dtl._Templated" superclass="dijit._TemplatedMixin">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="getCachedTemplate" scope="instance">
        <parameters>
          <parameter name="templatePath" type="Object" usage="required"/>
          <parameter name="templateString" type="Object" usage="required"/>
          <parameter name="alwaysUseString" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.string">
    <methods>
      <method name="BidiEngine" scope="instance">
        <description>Bidi stands for support for languages with a bidirectional script.
	
	Usually Unicode Bidi Algorithm used by OS platform (and web browsers) is capable of properly transforming
	Bidi text and as a result it is adequately displayed on the screen. However, in some situations,
	Unicode Bidi Algorithm is not invoked or is not properly applied. This may occur in situation in which software
	responsible for rendering the text is not leveraging Unicode Bidi Algorithm implemented by OS (e.g. dojox.GFX renderers).
	
	Bidi engine provided in this class implements Unicode Bidi Algorithm as specified at:
	http://www.unicode.org/reports/tr9/.
	
	For more information on basic Bidi concepts please read following article:
	"Bidirectional script support - A primer" available from:
	http://www.ibm.com/developerworks/websphere/library/techarticles/bidi/bidigen.html
	
	As of February 2011, Bidi engine has following limitations:
	1. No support for following numeric shaping options:
	H - Hindi,
	C - Contextual,
	N - Nominal.
	2. No support for following shaping options:
	I - Initial shaping,
	M - Middle shaping,
	F - Final shaping,
	B - Isolated shaping.
	3. No support for source-to-target or/and target-to-source maps.
	4. No support for LRE/RLE/LRO/RLO/PDF (they are handled like neutrals).
	5. No support for Windows compatibility.
	6. No support for  insert/remove marks.
	7. No support for code pages (currently only UTF-8 is supported. Ideally we should convert from any code page to UTF-8).</description>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.Token">
    <methods>
      <method name="split_contents" scope="instance">
        <parameters>
          <parameter name="limit" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="split" scope="instance"/>
    </methods>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Token.contents"/>
  <class type="dojox.dtl.text">
    <methods>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplateString" scope="instance">
        <parameters>
          <parameter name="file" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplate" scope="instance">
        <parameters>
          <parameter name="file" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTag" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFilter" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveTemplateArg" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveLazy" scope="instance">
        <parameters>
          <parameter name="location" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
          <parameter name="json" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveContextArg" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseDelims" scope="instance">
        <parameters>
          <parameter name="varr" type="Object" usage="required"/>
          <parameter name="load" type="Object" usage="required"/>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isTemplate" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="module" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.Template">
    <methods>
      <method name="update" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String|dojo.NodeList" usage="required">
            <description>A node reference or set of nodes</description>
          </parameter>
          <parameter name="context" type="dojo._Url|String|Object" usage="required">
            <description>The context object or location</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required">
            <description>The runtime context.</description>
          </parameter>
          <parameter name="buffer" type="StringBuilder" usage="optional">
            <description>A string buffer.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl._noOpNode">
    <methods>
      <method name="unrender" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="clone" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl.register">
    <methods>
      <method name="tags" scope="instance">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributeTags" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="filters" scope="instance">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_any" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="base" type="Object" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_registry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.register._registry"/>
  <class type="dojox.dtl._base">
    <methods>
      <method name="safe" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="escape" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.contrib.data">
    <methods>
      <method name="bind_query" scope="instance">
        <examples>
          <example>You can only use this with data stores that work in a synchronous
	way (meaning that `onComplete` is fired during the `fetch` call).
	A `sync` flag is sent to the fetch call so that stores that usually
	work asynchronously make themselves syncrhonous if possible.
		{% bind_query contextQuery to contextStore as newVariable %}</example>
        </examples>
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bind_data" scope="instance">
        <examples>
          <example>`contextItems` and `contextStore` should be an item list
	and a data store that get assigned to `newVariable`
	
		{% bind_data contextItems to contextStore as newVariable %}</example>
        </examples>
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.contrib">
    <properties>
      <property name="objects" scope="instance" type="Object"/>
      <property name="dijit" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.data._BoundItem.get"/>
  <class type="dojox.dtl.contrib.dijit">
    <methods>
      <method name="on" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dojoType" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dojoAttachPoint" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dojoAttachEvent" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.contrib.objects">
    <methods>
      <method name="key" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.DomTemplate">
    <methods>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setClass" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="dojox.dtl.Context" usage="optional"/>
          <parameter name="buffer" type="concatenable" usage="optional"/>
        </parameters>
      </method>
      <method name="getRootNode" scope="instance"/>
      <method name="getBuffer" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl.DomTemplate.render">
    <methods/>
  </class>
  <class type="dojox.dtl.DomBuffer">
    <description>Use this to append a child, change the parent, or
	change the attribute of the current node.</description>
    <methods>
      <method name="setParent" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="up" type="Boolean" usage="optional"/>
          <parameter name="root" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="setAttribute" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="obj" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onSetParent" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="up" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRemoveNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClone" scope="instance">
        <parameters>
          <parameter name="from" type="DOMNode" usage="required"/>
          <parameter name="to" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="onChangeData" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="old" type="Object" usage="required"/>
          <parameter name="updated" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChangeAttribute" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="old" type="Object" usage="required"/>
          <parameter name="updated" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAddNodeComplete" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAddNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAddEvent" scope="instance">
        <description>String</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="description" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRootNode" scope="instance"/>
      <method name="getParent" scope="instance"/>
      <method name="concat" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="addEvent" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
          <parameter name="args" type="Array|Function" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.DomBuffer.concat">
    <methods/>
    <properties>
      <property name="_parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomBuffer.concat._parent">
    <properties>
      <property name="_cache" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomBuffer.concat._parent._cache"/>
  <class type="dojox.dtl.DomBuffer.remove">
    <methods/>
  </class>
  <class type="dojox.dtl.DomBuffer.setAttribute">
    <methods/>
  </class>
  <class type="dojox.dtl.DomBuffer.setAttribute._parent.style"/>
  <class type="dojox.dtl.DomBuffer.setParent">
    <methods/>
    <properties>
      <property name="_parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomBuffer.setParent._parent">
    <properties>
      <property name="options" scope="instance" type="Object"/>
      <property name="_cache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomBuffer.setParent._parent.options"/>
  <class type="dojox.dtl.DomBuffer.setParent._parent._cache"/>
  <class type="dojox.dtl._DomNode">
    <methods>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl._DomNode.render">
    <methods/>
  </class>
  <class type="dojox.dtl._DomNode.unrender">
    <methods/>
  </class>
  <class type="dojox.dtl._DomNodeList">
    <description>Any object that's used in the constructor or added
	through the push function much implement the
	render, unrender, and clone functions.</description>
    <methods>
      <method name="unshift" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="instance" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rtrim" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="instance" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="push" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dummyRender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="asNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl._DomNodeList.clone">
    <methods/>
  </class>
  <class type="dojox.dtl._DomVarNode">
    <description>Will render an object that supports the render function
	and the getRootNode function</description>
    <methods>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl._DomVarNode.render">
    <methods/>
    <properties>
      <property name="_txt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomVarNode.render._txt"/>
  <class type="dojox.dtl._DomVarNode.unrender">
    <methods/>
    <properties>
      <property name="_html" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomVarNode.unrender._html"/>
  <class type="dojox.dtl.ChangeNode">
    <methods>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl.AttributeNode">
    <methods>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.AttributeNode.render">
    <methods/>
  </class>
  <class type="dojox.dtl.AttributeNode.unrender">
    <methods/>
  </class>
  <class type="dojox.dtl._DomTextNode">
    <methods>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isEmpty" scope="instance"/>
      <method name="clone" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl._DomTextNode.set">
    <methods/>
  </class>
  <class type="dojox.dtl._DomTextNode.render">
    <methods/>
    <properties>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTextNode.render.contents"/>
  <class type="dojox.dtl._DomParser">
    <description>This is also used by all tags to move through
	the list of nodes.</description>
    <methods>
      <method name="skip_past" scope="instance">
        <parameters>
          <parameter name="endtag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="stop_at" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="next_token" scope="instance"/>
      <method name="getTemplate" scope="instance">
        <parameters>
          <parameter name="loc" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="delete_first_token" scope="instance"/>
      <method name="create_variable_node" scope="instance">
        <parameters>
          <parameter name="expr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="create_text_node" scope="instance">
        <parameters>
          <parameter name="expr" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl._DomParser.parse">
    <methods/>
  </class>
  <class type="dojox.dtl.BOOLS"/>
  <class type="dojox.dtl.dom">
    <methods>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="nodes" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplate" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_tokenize" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="tokens" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="__tokenize" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="tokens" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.dom.getTemplate">
    <methods/>
  </class>
  <class type="dojo.Nodelist">
    <methods>
      <method name="dtl" scope="instance">
        <parameters>
          <parameter name="template" type="dojox.dtl.__StringArgs|String" usage="required">
            <description>The template string or location</description>
          </parameter>
          <parameter name="context" type="dojox.dtl.__ObjectArgs|Object" usage="required">
            <description>The context object or location</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.ext-dojo"/>
  <class type="dojox.dtl.filter.dates">
    <methods>
      <method name="timeuntil" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="timesince" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="time" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="date" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter">
    <properties>
      <property name="strings" scope="instance" type="Object"/>
      <property name="misc" scope="instance" type="Object"/>
      <property name="logic" scope="instance" type="Object"/>
      <property name="lists" scope="instance" type="Object"/>
      <property name="integers" scope="instance" type="Object"/>
      <property name="htmlstrings" scope="instance" type="Object"/>
      <property name="dates" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.htmlstrings">
    <methods>
      <method name="striptags" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removetags" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="linebreaksbr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="linebreaks" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.integers">
    <methods>
      <method name="get_digit" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.lists">
    <methods>
      <method name="unordered_list" scope="instance">
        <description>The list is assumed to be in the proper format. For example, if ``var`` contains
	``['States', [['Kansas', [['Lawrence', []], ['Topeka', []]]], ['Illinois', []]]]``,
	then ``{{ var|unordered_list }}`` would return::
	
		&lt;li&gt;States
		&lt;ul&gt;
			&lt;li&gt;Kansas
			&lt;ul&gt;
				&lt;li&gt;Lawrence&lt;/li&gt;
				&lt;li&gt;Topeka&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
			&lt;li&gt;Illinois&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slice" scope="instance">
        <description>Uses the same syntax as Python's list slicing; see
	http://diveintopython.org/native_data_types/lists.html#odbchelper.list.slice
	for an introduction.
	Also uses the optional third value to denote every X item.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="random" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length_is" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="join" scope="instance">
        <description>Django throws a compile error, but JS can't do arg checks
	so we're left with run time errors, which aren't wise for something
	as trivial here as an empty arg.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="first" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dictsortreversed" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dictsort" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unordered_list" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="tabs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dictsort" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.logic">
    <methods>
      <method name="yesno" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="divisibleby" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="default_if_none" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="default_" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.misc">
    <methods>
      <method name="pprint" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pluralize" scope="instance">
        <description>By default, 's' is used as a suffix; if an argument is provided, that string
	is used instead. If the provided argument contains a comma, the text before
	the comma is used for the singular case.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="phone2numeric" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filesizeformat" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_phone2numeric" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.misc._phone2numeric"/>
  <class type="dojox.dtl.filter.strings">
    <methods>
      <method name="wordwrap" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wordcount" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlizetrunc" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="' + middle + '&quot; rel=&quot;nofollow&quot;&gt;' + trimmed + '&lt;/a&gt;'"/>
        </return-types>
      </method>
      <method name="urlize" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlencode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="upper" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="truncatewords_html" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="truncatewords" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Integer" usage="required">
            <description>Number of words to truncate after</description>
          </parameter>
        </parameters>
      </method>
      <method name="title" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stringformat" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slugify" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rjust" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="make_list" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="lower" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ljust" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="linenumbers" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iriencode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="floatformat" scope="instance">
        <description>If called without an argument, displays a floating point
	number as 34.2 -- but only if there's a point to be displayed.
	With a positive numeric argument, it displays that many decimal places
	always.
	With a negative numeric argument, it will display that many decimal
	places -- but only if there's places to be displayed.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fix_ampersands" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cut" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="center" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="capfirst" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addslashes" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_urlquote" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="safe" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_truncate_singlets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.strings._truncate_singlets"/>
  <class type="dojox.dtl.render.dom">
    <methods>
      <method name="Render" scope="instance">
        <parameters>
          <parameter name="attachPoint" type="DOMNode" usage="optional"/>
          <parameter name="tpl" type="dojox.dtl.DomTemplate" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.render.dom.Render">
    <methods>
      <method name="setAttachPoint" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="tpl" type="dojox.dtl.DomTemplate" usage="optional"/>
          <parameter name="buffer" type="dojox.dtl.DomBuffer" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.render.dom.Render.setAttachPoint">
    <methods/>
  </class>
  <class type="dojox.dtl.render.dom.Render.render">
    <methods/>
  </class>
  <class type="dojox.dtl.render">
    <properties>
      <property name="html" scope="instance" type="Object"/>
      <property name="dom" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render.html"/>
  <class type="dojox.dtl.tag.date">
    <methods>
      <method name="now" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="NowNode" scope="instance">
        <parameters>
          <parameter name="format" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.tag.date.NowNode">
    <methods>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.tag">
    <properties>
      <property name="misc" scope="instance" type="Object"/>
      <property name="loop" scope="instance" type="Object"/>
      <property name="logic" scope="instance" type="Object"/>
      <property name="loader" scope="instance" type="Object"/>
      <property name="date" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loader">
    <methods>
      <method name="ssi" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="include" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="extends_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="block" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.tag.logic">
    <methods>
      <method name="ifnotequal" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifequal" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="if_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="for_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ifequal" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
          <parameter name="negate" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.tag.loop">
    <methods>
      <method name="regroup" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifchanged" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cycle" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.tag.misc">
    <methods>
      <method name="with_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="widthratio" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="templatetag" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="spaceless" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="firstof" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="debug" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="comment" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.utils.date">
    <methods>
      <method name="timesince" scope="instance">
        <description>Adapted from http://blog.natbat.co.uk/archive/2003/Jun/14/time_since</description>
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
          <parameter name="now" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="DateFormat" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl.utils.date.DateFormat" superclass="dojox.data.php.DateFormat.prototype">
    <methods>
      <method name="f" scope="instance">
        <description>Examples: '1', '1:30', '2:05', '2'
	Proprietary extension.</description>
      </method>
      <method name="P" scope="instance">
        <description>Examples: '1 a.m.', '1:30 p.m.', 'midnight', 'noon', '12:30 p.m.'
	Proprietary extension.</description>
      </method>
      <method name="N" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl.utils">
    <properties>
      <property name="date" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins">
    <methods>
      <method name="_spellCheckControl" scope="instance"/>
      <method name="_TextColorDropDown" scope="instance"/>
      <method name="_TableHandler" scope="instance"/>
      <method name="_StatusBar" scope="instance"/>
      <method name="_SpellCheckScriptMultiPart" scope="instance"/>
      <method name="_SpellCheckParser" scope="instance"/>
      <method name="_SmileyPalette" scope="instance">
        <description>Grid showing various emoticons.
	Can be used standalone, or as a popup.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.editor.plugins._SmileyPalette"&gt;&lt;/div&gt;</example>
          <example>	var picker = new dojox.editor.plugins._SmileyPalette({ },srcNode);
		picker.startup();</example>
        </examples>
      </method>
      <method name="_FindReplaceToolbar" scope="instance"/>
      <method name="_FindReplaceTextBox" scope="instance"/>
      <method name="_FindReplaceCloseBox" scope="instance"/>
      <method name="_FindReplaceCheckBox" scope="instance"/>
      <method name="_CollapsibleToolbarButton" scope="instance"/>
      <method name="_CellColorDropDown" scope="instance"/>
      <method name="_BreadcrumbMenuTitle" scope="instance"/>
      <method name="_AutoSaveSettingDialog" scope="instance"/>
      <method name="UploadImage" scope="instance"/>
      <method name="ToolbarLineBreak" scope="instance"/>
      <method name="TextColor" scope="instance">
        <description>The commands provided by this plugin are:
	* foreColor - sets the text color
	* hiliteColor - sets the background color</description>
      </method>
      <method name="TablePlugins" scope="instance"/>
      <method name="TableContextMenu" scope="instance"/>
      <method name="StatusBar" scope="instance"/>
      <method name="SpellCheck" scope="instance"/>
      <method name="Smiley" scope="instance">
        <description>The commands provided by this plugin are:
	* smiley - inserts the selected emoticon</description>
      </method>
      <method name="ShowBlockNodes" scope="instance"/>
      <method name="Save" scope="instance"/>
      <method name="SafePaste" scope="instance"/>
      <method name="ResizeTableColumn" scope="instance"/>
      <method name="Preview" scope="instance"/>
      <method name="PrettyPrint" scope="instance"/>
      <method name="PasteFromWord" scope="instance"/>
      <method name="PageBreak" scope="instance"/>
      <method name="NormalizeStyle" scope="instance"/>
      <method name="NormalizeIndentOutdent" scope="instance"/>
      <method name="ModifyTable" scope="instance"/>
      <method name="LocalImage" scope="instance"/>
      <method name="LatinEntity" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="InsertTable" scope="instance"/>
      <method name="InsertEntity" scope="instance">
        <description>The commands provided by this plugin are:
	* insertEntity - inserts the selected HTML entity character</description>
      </method>
      <method name="InsertAnchor" scope="instance">
        <description>The command provided by this plugin is:
	* insertAnchor</description>
      </method>
      <method name="FindReplace" scope="instance"/>
      <method name="EntityPalette" scope="instance">
        <description>Grid showing various entities, so the user can pick a certain entity.
	Can be used standalone, or as a popup.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.editor.plugins.EntityPalette"&gt;&lt;/div&gt;</example>
          <example>	var picker = new dojox.editor.plugins.EntityPalette({ },srcNode);
		picker.startup();</example>
        </examples>
      </method>
      <method name="Emoticon" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="EditorTableDialog" scope="instance"/>
      <method name="EditorModifyTableDialog" scope="instance"/>
      <method name="ColorTableCell" scope="instance"/>
      <method name="CollapsibleToolbar" scope="instance"/>
      <method name="Breadcrumb" scope="instance"/>
      <method name="Blockquote" scope="instance"/>
      <method name="AutoUrlLink" scope="instance"/>
      <method name="AutoSave" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.editor.plugins._AutoSaveSettingDialog" superclass="dijit._Widget">
    <methods>
      <method name="show" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onOk" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required">
            <description>The invertal value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChange" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_isValidValue" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.AutoSave" superclass="dojox.editor.plugins.Save">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSuccess" scope="instance">
        <parameters>
          <parameter name="resp" type="The" usage="required">
            <description>response from the server, if any, in text format.</description>
          </parameter>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_showAutSaveSettingDialog" scope="instance"/>
      <method name="_setSaveInterval" scope="instance">
        <parameters>
          <parameter name="interval" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setIntervalAttr" scope="instance">
        <parameters>
          <parameter name="val" type="The" usage="required">
            <description>interval value.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onStopClick" scope="instance"/>
      <method name="_onDialogOk" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_getIntervalAttr" scope="instance"/>
      <method name="_clearSaveInterval" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.Save" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor">
    <properties>
      <property name="plugins" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.AutoUrlLink" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <description>The editor it belongs to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_recognize" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_keyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="The" usage="required">
            <description>keypress event object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_inLink" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to be examed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_findUrls" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="bm" type="DomNode" usage="required"/>
          <parameter name="bmOff" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_findLastEditingNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The current node that the cursor is at.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.AutoUrlLink.editor"/>
  <class type="dojox.editor.plugins.Blockquote" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_toggleQuote" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isTextElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isRootInline" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to start at.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isInlineFormat" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <description>tag to examine</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_getTagName" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to look at.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_findBlockQuotes" scope="instance">
        <parameters>
          <parameter name="nodeList" type="The" usage="required">
            <description>list of nodes.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins._BreadcrumbMenuTitle" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setMenuTitleAttr" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenuTitleAttr" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._BreadcrumbMenuTitle.title"/>
  <class type="dojox.editor.plugins.Breadcrumb" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_updateBreadcrumb" scope="instance"/>
      <method name="_selectElement" scope="instance"/>
      <method name="_selectContents" scope="instance"/>
      <method name="_moveCToStart" scope="instance"/>
      <method name="_moveCToEnd" scope="instance"/>
      <method name="_deleteElement" scope="instance"/>
      <method name="_deleteContents" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.Breadcrumb.breadcrumbBar.domNode"/>
  <class type="dojox.editor.plugins._CollapsibleToolbarButton" superclass="dijit._Widget">
    <methods>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.CollapsibleToolbar" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_onOpen" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required">
            <description>click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onClose" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required">
            <description>click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_constructContainer" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.CollapsibleToolbar.editor.header"/>
  <class type="dojox.editor.plugins.CollapsibleToolbar.editor.footer"/>
  <class type="dojox.editor.plugins.EntityPalette" superclass="dijit._Widget">
    <description>Grid showing various entities, so the user can pick a certain entity.
	Can be used standalone, or as a popup.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setCurrent" scope="instance">
        <description>Removes highlight of the old entity, and highlights
	the new entity.</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_onCellMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required">
            <description>event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_displayDetails" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="previewNode" scope="instance" type="Object"/>
      <property name="entityNode" scope="instance" type="Object"/>
      <property name="descNode" scope="instance" type="Object"/>
      <property name="codeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette.previewNode"/>
  <class type="dojox.editor.plugins.EntityPalette.codeNode"/>
  <class type="dojox.editor.plugins.EntityPalette.entityNode"/>
  <class type="dojox.editor.plugins.EntityPalette.descNode"/>
  <class type="dojox.editor.plugins.LatinEntity">
    <methods>
      <method name="getValue" scope="instance"/>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.editor.plugins._FindReplaceCloseBox" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onClick" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins._FindReplaceTextBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required">
            <description>The boolean value to indicate if the textbox should be disabled or not</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>object passed to this handler</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins._FindReplaceCheckBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required">
            <description>The flag that indicates if the checkbox is disabled or not.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="checkBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._FindReplaceCheckBox.checkBox">
    <methods>
      <method name="isFocusable" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.editor.plugins._FindReplaceToolbar" superclass="dijit.Toolbar">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_onToolbarEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The Event object
	tages:
	private</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Toolbar" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.FindReplace" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="toggle" scope="instance"/>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="dijit.Toolbar" usage="required">
            <description>The current toolbar of the editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_toggleFindReplace" scope="instance">
        <parameters>
          <parameter name="show" type="Boolean" usage="required">
            <description>Indicate if the toolbar is shown or not</description>
          </parameter>
          <parameter name="ignoreState" type="Boolean" usage="optional">
            <description>Indicate if the status should be ignored or not
	blurEditor:
	Indicate if the focus should be removed from the editor or not</description>
          </parameter>
          <parameter name="buttonDisabled" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_replaceAll" scope="instance">
        <parameters>
          <parameter name="showMessage" type="Boolean" usage="optional">
            <description>Indicate if the prompt message is shown or not when the action is done.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_replace" scope="instance">
        <parameters>
          <parameter name="showMessage" type="Boolean" usage="optional">
            <description>Indicate if the prompt message is shown or not when the replacement
	reaches the end</description>
          </parameter>
        </parameters>
        <return-description>Boolean indicating if the content was replaced or not.</return-description>
      </method>
      <method name="_populateFindField" scope="instance"/>
      <method name="_onReplaceKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFindKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_findText" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <description>The text to locate in the document.</description>
          </parameter>
          <parameter name="caseSensitive" type="Boolean" usage="required">
            <description>Whether or ot to search case-sensitively.</description>
          </parameter>
          <parameter name="backwards" type="Boolean" usage="required">
            <description>Whether or not to search backwards in the document.</description>
          </parameter>
        </parameters>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_find" scope="instance">
        <parameters>
          <parameter name="showMessage" type="Boolean" usage="optional">
            <description>Indicated whether the tooltip is shown or not when the search reaches the end</description>
          </parameter>
        </parameters>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_filterRegexp" scope="instance">
        <description>Returns a regular expression object that conforms to the defined conversion rules.
	For example:
	ca*   -&gt; /^ca.*$/
	*ca*  -&gt; /^.*ca.*$/
	*c\*a*  -&gt; /^.*c\*a.*$/
	*c\*a?*  -&gt; /^.*c\*a..*$/
	and so on.</description>
        <parameters>
          <parameter name="pattern" type="String" usage="required">
            <description>string A simple matching pattern to convert that follows basic rules:
	* Means match anything, so ca* means match anything starting with ca
	? Means match single character.  So, b?b will match to bob and bab, and so on.
	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	represented by \\ to be treated as an ordinary \ character instead of an escape.</description>
          </parameter>
          <parameter name="ignoreCase" type="Boolean" usage="required">
            <description>An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	By default, it is assumed case sensitive.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="RegExp"/>
        </return-types>
      </method>
      <method name="_checkButtons" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="The">
        <description>editor this plugin belongs to</description>
      </property>
    </properties>
  </class>
  <class type="dojox.editor.plugins.FindReplace.editor"/>
  <class type="dojox.editor.plugins.FindReplace._findButton.titleNode"/>
  <class type="dojox.editor.plugins.FindReplace._replaceButton.titleNode"/>
  <class type="dojox.editor.plugins.FindReplace._replaceAllButton.titleNode"/>
  <class type="dojox.editor.plugins.InsertAnchor" superclass="dijit._editor._Plugin">
    <description>The command provided by this plugin is:
	* insertAnchor</description>
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAnchorStyle" scope="instance"/>
      <method name="_setup" scope="instance"/>
      <method name="_preDomFilter" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to search from.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postDomFilter" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to search from.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onOpenDialog" scope="instance"/>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The double-click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onCloseDialog" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_getCurrentValues" scope="instance">
        <parameters>
          <parameter name="a" type="The" usage="required">
            <description>anchor/link to process for data for the dropdown.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_checkValues" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Content being set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkInput" scope="instance"/>
      <method name="_calcBaseUrl" scope="instance">
        <parameters>
          <parameter name="fullUrl" type="String" usage="required">
            <description>The full url to tear down to the base.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_applyStyles" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.InsertAnchor.editor"/>
  <class type="dojox.editor.plugins.InsertEntity" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* insertEntity - inserts the selected HTML entity character</description>
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_preFilterEntities" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="required">
            <description>content passed in</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postFilterEntities" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="required">
            <description>content passed in</description>
          </parameter>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.LocalImage" superclass="LinkDialog.ImgLinkDialog">
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="_setDialogStatus" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isValid" scope="instance"/>
      <method name="_initialFileUploader" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_checkAndSetValue" scope="instance"/>
      <method name="_checkAndFixInput" scope="instance"/>
      <method name="_cancelFileUpload" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="LinkDialog.ImgLinkDialog" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.NormalizeIndentOutdent" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="command" type="The" usage="required">
            <description>command passed in to check enablement.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_outdentList" scope="instance">
        <parameters>
          <parameter name="listItem" type="The" usage="required">
            <description>list item to outdent.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_outdentImpl" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_outdentElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node who's content to outdent.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isTextElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isRootInline" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to start at.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isLtr" scope="instance"/>
      <method name="_isInlineFormat" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <description>tag to examine</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isIndentableElement" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <description>tag to check</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_indentList" scope="instance">
        <parameters>
          <parameter name="listItem" type="The" usage="required">
            <description>list item to indent.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_indentImpl" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_indentElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node who's content to indent.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Return the node that was indented"/>
        </return-types>
      </method>
      <method name="_getTagName" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to look at.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_convertIndent" scope="instance">
        <parameters>
          <parameter name="indent" type="The" usage="required">
            <description>indent amount to convert.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.NormalizeIndentOutdent.editor.document"/>
  <class type="dojox.editor.plugins.NormalizeStyle" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizeTags" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to search from.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isInline" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <description>tag to examine</description>
          </parameter>
        </parameters>
      </method>
      <method name="_inserthtmlImpl" scope="instance">
        <parameters>
          <parameter name="html" type="The" usage="required">
            <description>HTML string to insert.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_convertToSemantic" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node to process.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_convertToCss" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node to process</description>
          </parameter>
        </parameters>
      </method>
      <method name="_condenseSpans" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node (and its children), to process.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.NormalizeStyle.editor"/>
  <class type="dojox.editor.plugins.PageBreak" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_style" scope="instance"/>
      <method name="_insertPageBreak" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_allowBreak" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.PageBreak.editor"/>
  <class type="dojox.editor.plugins.PasteFromWord" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_paste" scope="instance"/>
      <method name="_openDialog" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_clearDialog" scope="instance"/>
      <method name="_cancel" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.PrettyPrint" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.Preview" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_preview" scope="instance"/>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.ResizeTableColumn" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="The" usage="required">
            <description>editor which this plugin belongs to</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ResizeTableColumn.editor"/>
  <class type="dojox.editor.plugins.SafePaste" superclass="dojox.editor.plugins.PasteFromWord">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.PasteFromWord" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.Save" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSuccess" scope="instance">
        <parameters>
          <parameter name="resp" type="The" usage="required">
            <description>response from the server, if any, in text format.</description>
          </parameter>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_save" scope="instance"/>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.ShowBlockNodes" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="toggle" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_showBlocks" scope="instance">
        <parameters>
          <parameter name="show" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_calcBaseUrl" scope="instance">
        <parameters>
          <parameter name="fullUrl" type="String" usage="required">
            <description>The full url to tear down to the base.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ShowBlockNodes.editor"/>
  <class type="dojox.editor.plugins.Smiley" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* smiley - inserts the selected emoticon</description>
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_preFilterEntities" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>content passed in</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postFilterEntities" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>content passed in</description>
          </parameter>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_encode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
          <parameter name="ascii" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins._spellCheckControl" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onSkipAll" scope="instance"/>
      <method name="onSkip" scope="instance"/>
      <method name="onReplaceAll" scope="instance"/>
      <method name="onReplace" scope="instance"/>
      <method name="onEnter" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onAddToDic" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_unfoundTextBoxChange" scope="instance"/>
      <method name="_setUnfoundWordAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value of the Not Found textbox</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setSuggestionListAttr" scope="instance">
        <parameters>
          <parameter name="values" type="Array" usage="required">
            <description>The list of the suggestion items</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setInProgressAttr" scope="instance">
        <parameters>
          <parameter name="show" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getUnfoundWordAttr" scope="instance"/>
      <method name="_getSelectedWordAttr" scope="instance"/>
      <method name="_enter" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_cancel" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="suggestionSelect" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._spellCheckControl.suggestionSelect">
    <methods>
      <method name="removeItems" scope="instance"/>
      <method name="deselectAll" scope="instance"/>
      <method name="addItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required">
            <description>An array of items be added to the select</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.editor.plugins._spellCheckControl.containerNode"/>
  <class type="dojox.editor.plugins._SpellCheckScriptMultiPart">
    <methods>
      <method name="setWaitingTime" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="send" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required">
            <description>The text to be sent</description>
          </parameter>
          <parameter name="action" type="String" usage="optional">
            <description>The action the service should take. Current support actions are
	ACTION_QUERY and ACTION_UPDATE</description>
          </parameter>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_finalizeCollection" scope="instance">
        <parameters>
          <parameter name="action" type="The" usage="required">
            <description>action token</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.editor.plugins.SpellCheck" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_submitContent" scope="instance">
        <parameters>
          <parameter name="delay" type="Boolean" usage="optional">
            <description>Indicate if the action is taken immediately or not</description>
          </parameter>
        </parameters>
      </method>
      <method name="_spellCheckFilter" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The html value of the editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="_skipWordAll" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
          <parameter name="word" type="String" usage="optional">
            <description>If this argument is given, skip all the words that have the same text
	as the word</description>
          </parameter>
        </parameters>
      </method>
      <method name="_skipWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
        </parameters>
      </method>
      <method name="_skipAll" scope="instance"/>
      <method name="_skip" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="optional">
            <description>The event object</description>
          </parameter>
          <parameter name="noUpdate" type="Boolean" usage="optional">
            <description>Indicate whether to update the status of the span list or not</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setNetwork" scope="instance"/>
      <method name="_selectWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
        </parameters>
      </method>
      <method name="_replaceWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
          <parameter name="text" type="The" usage="required">
            <description>text to be replaced with</description>
          </parameter>
        </parameters>
      </method>
      <method name="_replaceAll" scope="instance"/>
      <method name="_replace" scope="instance"/>
      <method name="_query" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The html value of the editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="_populateDialog" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>idex of the span list</description>
          </parameter>
        </parameters>
      </method>
      <method name="_openDialog" scope="instance"/>
      <method name="_moveToBookmark" scope="instance"/>
      <method name="_markIncorrectWords" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The html value of the editor</description>
          </parameter>
          <parameter name="cache" type="Object" usage="required">
            <description>The local word cache</description>
          </parameter>
        </parameters>
      </method>
      <method name="_loadData" scope="instance">
        <parameters>
          <parameter name="data" type="Array" usage="required">
            <description>The result of the query</description>
          </parameter>
        </parameters>
      </method>
      <method name="_keyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_html2Text" scope="instance">
        <parameters>
          <parameter name="html" type="The" usage="required">
            <description>html code</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getBookmark" scope="instance">
        <parameters>
          <parameter name="eValue" type="String" usage="required">
            <description>The html value of the editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="_findText" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <description>The text to locate in the document.</description>
          </parameter>
          <parameter name="caseSensitive" type="Boolean" usage="required">
            <description>Whether or ot to search case-sensitively.</description>
          </parameter>
          <parameter name="backwards" type="Boolean" usage="required">
            <description>Whether or not to search backwards in the document.</description>
          </parameter>
        </parameters>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_enter" scope="instance"/>
      <method name="_disabled" scope="instance">
        <parameters>
          <parameter name="name" type="Command" usage="required">
            <description>name</description>
          </parameter>
          <parameter name="disabled" type="Command" usage="required">
            <description>argument</description>
          </parameter>
        </parameters>
      </method>
      <method name="_connectUp" scope="instance"/>
      <method name="_cancel" scope="instance"/>
      <method name="_addWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
          <parameter name="word" type="String" usage="optional">
            <description>If this argument is given, add the word to the dictionary and
	skip all the words like it</description>
          </parameter>
        </parameters>
      </method>
      <method name="_add" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_spanList" scope="instance-prototype" type="Array"/>
      <property name="_normalIncorrectStyle" scope="instance" type="Object"/>
      <property name="_ignoredIncorrectStyle" scope="instance" type="Object"/>
      <property name="_highlightedIncorrectStyle" scope="instance" type="Object"/>
      <property name="_editor" scope="instance" type="Object"/>
      <property name="_dialogContent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._ignoredIncorrectStyle"/>
  <class type="dojox.editor.plugins.SpellCheck._normalIncorrectStyle"/>
  <class type="dojox.editor.plugins.SpellCheck._highlightedIncorrectStyle"/>
  <class type="dojox.editor.plugins.SpellCheck._dialogContent"/>
  <class type="dojox.editor.plugins.SpellCheck._spanList"/>
  <class type="dojox.editor.plugins.SpellCheck._editor"/>
  <class type="dojox.editor.plugins._StatusBar" superclass="dijit._Widget">
    <methods>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The string to set as the status bar content.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="barContent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._StatusBar.barContent"/>
  <class type="dojox.editor.plugins.StatusBar" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="attr" type="The" usage="required">
            <description>attribute to set.</description>
          </parameter>
          <parameter name="val" type="The" usage="required">
            <description>value to set it to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="attr" type="The" usage="required">
            <description>attribute to get.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The String value to set in the bar.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.StatusBar.editor"/>
  <class type="dojox.editor.plugins._TableHandler" superclass="dijit._editor._Plugin">
    <methods>
      <method name="uninitialize" scope="instance">
        <parameters>
          <parameter name="editor" type="The" usage="required">
            <description>editor to detach from.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance"/>
      <method name="onDragEnd" scope="instance"/>
      <method name="onDisplayChanged" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTimeStamp" scope="instance">
        <return-types>
          <return-type type="Fixed the bug that this method always returns the same timestamp"/>
        </return-types>
      </method>
      <method name="getTableInfo" scope="instance">
        <parameters>
          <parameter name="forceNewData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doMixins" scope="instance"/>
      <method name="disconnectTableKeys" scope="instance"/>
      <method name="connectTableKeys" scope="instance"/>
      <method name="connectDraggable" scope="instance"/>
      <method name="checkAvailable" scope="instance"/>
      <method name="_tempStoreTableData" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_tempAvailability" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareTable" scope="instance">
        <parameters>
          <parameter name="tbl" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editorDomNode" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._TableHandler.editor"/>
  <class type="dojox.editor.plugins._TableHandler.editorDomNode"/>
  <class type="dojox.editor.plugins.TablePlugins" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectTable" scope="instance"/>
      <method name="onEditorLoaded" scope="instance"/>
      <method name="onDisplayChanged" scope="instance">
        <parameters>
          <parameter name="withinTable" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="modTable" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeColumnsEven" scope="instance"/>
      <method name="getTableInfo" scope="instance">
        <parameters>
          <parameter name="forceNewData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedCells" scope="instance"/>
      <method name="endEdit" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="begEdit" scope="instance"/>
      <method name="_makeTitle" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TablePlugins.editor"/>
  <class type="dojox.editor.plugins.TableContextMenu" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_createContextMenu" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.TableContextMenu.button.domNode"/>
  <class type="dojox.editor.plugins.InsertTable" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="modTable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.ModifyTable" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="modTable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins._CellColorDropDown" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setColor" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value from the color picker.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value to set in the color picker</description>
          </parameter>
          <parameter name="priorityChange" type="Value" usage="required">
            <description>to indicate whether or not to trigger an onChange event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.ColorTableCell" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="modTable" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.EditorTableDialog" superclass="dijit.Dialog">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onInsert" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onBuildTable" scope="instance">
        <parameters>
          <parameter name="tableText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.EditorModifyTableDialog" superclass="dijit.Dialog">
    <methods>
      <method name="setBrdColor" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setBkColor" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onSetTable" scope="instance">
        <parameters>
          <parameter name="tableText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins._TextColorDropDown" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value from the color picker.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value to set in the color picker</description>
          </parameter>
          <parameter name="priorityChange" type="Value" usage="required">
            <description>to indicate whether or not to trigger an onChange event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.TextColor" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* foreColor - sets the text color
	* hiliteColor - sets the background color</description>
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.ToolbarLineBreak" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="isFocusable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.UploadImage" superclass="dijit._editor._Plugin">
    <methods>
      <method name="updateState" scope="instance"/>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="ioArgs" type="Object" usage="required"/>
          <parameter name="widgetRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertTempImage" scope="instance"/>
      <method name="createFileInput" scope="instance"/>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins._SmileyPalette" superclass="dijit._Widget">
    <description>Grid showing various emoticons.
	Can be used standalone, or as a popup.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.Emoticon">
    <methods>
      <method name="imgHtml" scope="instance">
        <parameters>
          <parameter name="clazz" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="fromAscii" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
          <parameter name="blankGif" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="ascii" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Emoticon.ascii"/>
  <class type="dojox.editor.plugins._SpellCheckParser">
    <methods>
      <method name="parseIntoWords" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>Plain text without html tags</description>
          </parameter>
        </parameters>
        <return-description>Array holding all the words</return-description>
      </method>
      <method name="getIndices" scope="instance">
        <return-description>Index array</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.embed.Flash">
    <description>Creates a wrapper object around a Flash movie.  Wrapper object will
	insert the movie reference in node; when the browser first starts
	grabbing the movie, onReady will be fired; when the movie has finished
	loading, it will fire onLoad.
	
	If your movie uses ExternalInterface, you should use the onLoad event
	to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
	to be the only consistent time calling EI methods are stable (since the
	Flash movie will shoot several methods into the window object before
	EI callbacks can be used properly).</description>
    <methods>
      <method name="proxy" scope="instance">
        <examples>
          <example>Create "setMessage" and "getMessage" methods on foo.
		var foo = new dojox.embed.Flash(args, someNode);
		dojo.connect(foo, "onLoad", dojo.hitch(foo, function(){
			dojox.embed.Flash.proxy(this, [ "setMessage", "getMessage" ]);
			this.setMessage("dojox.embed.Flash.proxy is pretty cool...");
			console.log(this.getMessage());
		}));</example>
        </examples>
        <parameters>
          <parameter name="obj" type="dojox.embed.Flash" usage="required"/>
          <parameter name="methods" type="Array|String" usage="required"/>
        </parameters>
      </method>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="onInitialize" scope="instance"/>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="dojox.embed.__flashArgs" usage="required"/>
          <parameter name="node" type="DOMNode" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="byId" scope="instance">
        <description>Probably includes methods for outdated
	browsers, but this should catch all cases.
	arguments:</description>
        <examples>
          <example> var movie = dojox.embed.Flash.byId("myId");</example>
        </examples>
        <parameters>
          <parameter name="movieName" type="String" usage="required">
            <description>The name of the SWF</description>
          </parameter>
          <parameter name="doc" type="Object" usage="required">
            <description>The document, if not current window
	(not fully supported)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onload" scope="instance"/>
      <method name="_destroy" scope="instance"/>
      <method name="__ie_markup__" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.embed">
    <methods>
      <method name="__flashArgs" scope="instance">
        <parameters>
          <parameter name="path" type="String" usage="required">
            <description>The URL of the movie to embed.</description>
          </parameter>
          <parameter name="id" type="String" usage="optional">
            <description>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</description>
          </parameter>
          <parameter name="width" type="Number" usage="optional">
            <description>The width of the embedded movie; the default value is 320px.</description>
          </parameter>
          <parameter name="height" type="Number" usage="optional">
            <description>The height of the embedded movie; the default value is 240px</description>
          </parameter>
          <parameter name="style" type="String" usage="optional">
            <description>Any CSS style information (i.e. style=&amp;quot;background-color:transparent&amp;quot;) you want
	to define on the markup.</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <description>A set of key/value pairs that you want to define in the resultant markup.</description>
          </parameter>
          <parameter name="vars" type="Object" usage="optional">
            <description>A set of key/value pairs that the Flash movie will interpret as FlashVars.</description>
          </parameter>
          <parameter name="expressInstall" type="Boolean" usage="optional">
            <description>Whether or not to include any kind of expressInstall info. Default is false.</description>
          </parameter>
          <parameter name="redirect" type="String" usage="optional">
            <description>A url to redirect the browser to if the current Flash version is not supported.</description>
          </parameter>
        </parameters>
      </method>
      <method name="__QTArgs" scope="instance">
        <parameters>
          <parameter name="path" type="String" usage="required">
            <description>The URL of the movie to embed.</description>
          </parameter>
          <parameter name="id" type="String" usage="optional">
            <description>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</description>
          </parameter>
          <parameter name="width" type="Number" usage="optional">
            <description>The width of the embedded movie; the default value is 320px.</description>
          </parameter>
          <parameter name="height" type="Number" usage="optional">
            <description>The height of the embedded movie; the default value is 240px</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <description>A set of key/value pairs that you want to define in the resultant markup.</description>
          </parameter>
          <parameter name="redirect" type="String" usage="optional">
            <description>A url to redirect the browser to if the current QuickTime version is not supported.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Object" scope="instance">
        <examples>
          <example>From markup:
		&lt;div dojoType="dojox.embed.Object" src="path/to/movie.swf"&gt;&lt;/div&gt;</example>
          <example>Programmatic:
		var mov=new dojox.embed.Object({
			src: "path/to/movie.swf"
		}, node);</example>
        </examples>
      </method>
      <method name="Flash" scope="instance">
        <description>Creates a wrapper object around a Flash movie.  Wrapper object will
	insert the movie reference in node; when the browser first starts
	grabbing the movie, onReady will be fired; when the movie has finished
	loading, it will fire onLoad.
	
	If your movie uses ExternalInterface, you should use the onLoad event
	to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
	to be the only consistent time calling EI methods are stable (since the
	Flash movie will shoot several methods into the window object before
	EI callbacks can be used properly).</description>
        <examples>
          <example>Embed a flash movie in a document using the new operator, and get a reference to it.
		var movie = new dojox.embed.Flash({
			path: "path/to/my/movie.swf",
			width: 400,
			height: 300
		}, myWrapperNode, "testLoaded");</example>
          <example>Embed a flash movie in a document without using the new operator.
		var movie = dojox.embed.Flash({
			path: "path/to/my/movie.swf",
			width: 400,
			height: 300,
			style: "position:absolute;top:0;left:0"
		}, myWrapperNode, "testLoaded");
	
	File can only be run from a server, due to SWF dependency.</example>
        </examples>
        <parameters>
          <parameter name="kwArgs" type="dojox.embed.__flashArgs" usage="required">
            <description>The various arguments that will be used to help define the Flash movie.</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>DomNode The node where the embed object will be placed</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="flashVars" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.Flash.init">
    <methods/>
  </class>
  <class type="dojox.embed.Flash._destroy">
    <methods/>
  </class>
  <class type="dojox.embed.__flashArgs">
    <methods/>
  </class>
  <class type="dojox.embed.Object" superclass="_Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.Object.domNode">
    <properties>
      <property name="attributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.Object.domNode.attributes"/>
  <class type="dojox.embed.__QTArgs">
    <methods/>
  </class>
  <class type="dojox.embed.flashVars">
    <description>JSON could be done, but Deft does not yet have a JSON parser, and quotes are
	very problematic since Flash cannot use eval(); JSON parsing was successful
	when it was fully escaped, but that made it very large anyway. flashvar
	serialization at most is 200% larger than JSON.
	
	See:
	Deft/common/flashVars.as</description>
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="n" type="String" usage="required">
            <description>The name for the object, such as: &amp;quot;button&amp;quot;</description>
          </parameter>
          <parameter name="o" type="Object" usage="required">
            <description>The object to serialize</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding">
    <properties>
      <property name="easy64" scope="instance" type="Object"/>
      <property name="digests" scope="instance" type="Object"/>
      <property name="crypto" scope="instance" type="Object"/>
      <property name="compression" scope="instance" type="Object"/>
      <property name="bits" scope="instance" type="Object"/>
      <property name="base64" scope="instance" type="Object"/>
      <property name="ascii85" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.ascii85">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Array" usage="required">
            <description>an array of numbers (0-255) to encode</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="String" usage="required">
            <description>the input string to decode</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.base64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="ba" type="Array&lt;byte&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;byte&gt;"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.bits">
    <methods>
      <method name="OutputStream" scope="instance"/>
      <method name="InputStream" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.bits.OutputStream">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="putBits" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="instance"/>
      <method name="getBuffer" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.encoding.bits.OutputStream.reset">
    <methods/>
  </class>
  <class type="dojox.encoding.bits.OutputStream.putBits">
    <methods/>
  </class>
  <class type="dojox.encoding.bits.OutputStream.getBuffer">
    <methods/>
  </class>
  <class type="dojox.encoding.bits.InputStream">
    <methods>
      <method name="getWidth" scope="instance"/>
      <method name="getBits" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.bits.InputStream.getBits">
    <methods/>
  </class>
  <class type="dojox.encoding.compression.lzw">
    <methods>
      <method name="Encoder" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Decoder" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder">
    <methods>
      <method name="init" scope="instance"/>
      <method name="flush" scope="instance">
        <parameters>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.init">
    <methods/>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.encode">
    <methods/>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.flush">
    <methods/>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder">
    <methods>
      <method name="init" scope="instance"/>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder.init">
    <methods/>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder.decode">
    <methods/>
  </class>
  <class type="dojox.encoding.compression">
    <methods>
      <method name="Splay" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="lzw" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.Splay">
    <methods>
      <method name="splay" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.crypto">
    <methods>
      <method name="RSAKey" scope="instance">
        <parameters>
          <parameter name="rngf" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="outputTypes" scope="instance" type="Object">
        <description>Enumeration for input and output encodings.</description>
      </property>
      <property name="cipherModes" scope="instance" type="Object">
        <description>Enumeration for various cipher modes.</description>
      </property>
    </properties>
  </class>
  <class type="RSAKey">
    <methods>
      <method name="setPrivateEx" scope="instance">
        <parameters>
          <parameter name="N" type="Object" usage="required"/>
          <parameter name="E" type="Object" usage="required"/>
          <parameter name="D" type="Object" usage="required"/>
          <parameter name="P" type="Object" usage="required"/>
          <parameter name="Q" type="Object" usage="required"/>
          <parameter name="DP" type="Object" usage="required"/>
          <parameter name="DQ" type="Object" usage="required"/>
          <parameter name="C" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPrivate" scope="instance">
        <parameters>
          <parameter name="N" type="Object" usage="required"/>
          <parameter name="E" type="Object" usage="required"/>
          <parameter name="D" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="B" type="Object" usage="required"/>
          <parameter name="E" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decrypt" scope="instance">
        <parameters>
          <parameter name="ctext" type="String" usage="required">
            <description>an even-length hex string</description>
          </parameter>
        </parameters>
        <return-description>a plain string.</return-description>
      </method>
    </methods>
  </class>
  <class type="RSAKey.setPrivate">
    <methods/>
  </class>
  <class type="RSAKey.setPrivateEx">
    <methods/>
  </class>
  <class type="RSAKey.generate">
    <methods/>
  </class>
  <class type="dojox.encoding.crypto.RSAKey">
    <methods>
      <method name="setPublic" scope="instance">
        <parameters>
          <parameter name="N" type="Object" usage="required"/>
          <parameter name="E" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encrypt" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rngf" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.crypto.cipherModes"/>
  <class type="dojox.encoding.crypto.outputTypes"/>
  <class type="dojox.encoding.digests">
    <methods>
      <method name="wordToString" scope="instance">
        <parameters>
          <parameter name="wa" type="Array&lt;word&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToHex" scope="instance">
        <parameters>
          <parameter name="wa" type="Array&lt;word&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToBase64" scope="instance">
        <parameters>
          <parameter name="wa" type="Array&lt;word&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="stringToWord" scope="instance">
        <parameters>
          <parameter name="s" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;word&gt;"/>
        </return-types>
      </method>
      <method name="addWords" scope="instance">
        <parameters>
          <parameter name="a" type="word" usage="required"/>
          <parameter name="b" type="word" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="word"/>
        </return-types>
      </method>
      <method name="SHA1" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;word&gt;"/>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="MD5" scope="instance">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;word&gt;"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="outputTypes" scope="instance" type="Object">
        <description>Enumeration for input and output encodings.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.encoding.digests.MD5">
    <methods>
      <method name="_hmac" scope="instance">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;word&gt;"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.digests.SHA1">
    <methods>
      <method name="_hmac" scope="instance">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;word&gt;"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.digests.outputTypes"/>
  <class type="dojox.encoding.easy64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Array" usage="required">
            <description>an array of numbers (0-255) to encode</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="String" usage="required">
            <description>the input string to decode</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.flash">
    <description>The goal of dojox.flash is to make it easy to extend Flash's capabilities
	into an Ajax/DHTML environment.
	
	dojox.flash provides an easy object for interacting with the Flash plugin.
	This object provides methods to determine the current version of the Flash
	plugin (dojox.flash.info); write out the necessary markup to
	dynamically insert a Flash object into the page (dojox.flash.Embed; and
	do dynamic installation and upgrading of the current Flash plugin in
	use (dojox.flash.Install). If you want to call methods on the Flash object
	embedded into the page it is your responsibility to use Flash's ExternalInterface
	API and get a reference to the Flash object yourself.
	
	To use dojox.flash, you must first wait until Flash is finished loading
	and initializing before you attempt communication or interaction.
	To know when Flash is finished use dojo.connect:
	
		dojo.connect(dojox.flash, "loaded", myInstance, "myCallback");
	
	Then, while the page is still loading provide the file name:
	
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"));
	
	If no SWF files are specified, then Flash is not initialized.
	
	Your Flash must use Flash's ExternalInterface to expose Flash methods and
	to call JavaScript.
	
	setSwf can take an optional 'visible' attribute to control whether
	the Flash object is visible or not on the page; the default is visible:
	
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"),
	false);
	
	Once finished, you can query Flash version information:
	
		dojox.flash.info.version
	
	Or can communicate with Flash methods that were exposed:
	
		var f = dojox.flash.get();
		var results = f.sayHello("Some Message");
	
	Your Flash files should use DojoExternalInterface.as to register methods;
	this file wraps Flash's normal ExternalInterface but correct various
	serialization bugs that ExternalInterface has.
	
	Note that dojox.flash is not meant to be a generic Flash embedding
	mechanism; it is as generic as necessary to make Dojo Storage's
	Flash Storage Provider as clean and modular as possible. If you want
	a generic Flash embed mechanism see [SWFObject](http://blog.deconcept.com/swfobject/).
	
	Notes:
	Note that dojox.flash can currently only work with one Flash object
	on the page; it does not yet support multiple Flash objects on
	the same page.
	
	Your code can detect whether the Flash player is installing or having
	its version revved in two ways. First, if dojox.flash detects that
	Flash installation needs to occur, it sets dojox.flash.info.installing
	to true. Second, you can detect if installation is necessary with the
	following callback:
	
		dojo.connect(dojox.flash, "installing", myInstance, "myCallback");
	
	You can use this callback to delay further actions that might need Flash;
	when installation is finished the full page will be refreshed and the
	user will be placed back on your page with Flash installed.
	
	-------------------
	Todo/Known Issues
	-------------------
	
	* On Internet Explorer, after doing a basic install, the page is
	not refreshed or does not detect that Flash is now available. The way
	to fix this is to create a custom small Flash file that is pointed to
	during installation; when it is finished loading, it does a callback
	that says that Flash installation is complete on IE, and we can proceed
	to initialize the dojox.flash subsystem.
	* Things aren't super tested for sending complex objects to Flash
	methods, since Dojo Storage only needs strings
	
	Author- Brad Neuberg, http://codinginparadise.org</description>
    <methods>
      <method name="setSwf" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL to this Flash file.</description>
          </parameter>
          <parameter name="visible" type="boolean" usage="optional">
            <description>Whether the Flash file is visible or not. If it is not visible we hide
	it off the screen. This defaults to true (i.e. the Flash file is
	visible).</description>
          </parameter>
        </parameters>
      </method>
      <method name="loaded" scope="instance">
        <description>A callback when the Flash subsystem is finished loading and can be
	worked with. To be notified when Flash is finished loading, add a
	loaded listener:
	
	dojox.flash.addLoadedListener(loadedListener);</description>
      </method>
      <method name="installing" scope="instance">
        <description>A callback to know if Flash is currently being installed or
	having its version revved. To be notified if Flash is installing, connect
	your callback to this method using the following:
	
	dojo.event.connect(dojox.flash, "installing", myInstance, "myCallback");</description>
      </method>
      <method name="addLoadedListener" scope="instance">
        <parameters>
          <parameter name="listener" type="Function" usage="required">
            <description>A function that will be called when Flash is done loading.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addInstallingListener" scope="instance">
        <parameters>
          <parameter name="listener" type="Function" usage="required">
            <description>A function that will be called if Flash is being
	installed</description>
          </parameter>
        </parameters>
      </method>
      <method name="_initialize" scope="instance"/>
      <method name="Install" scope="instance">
        <description>Figures out the best way to automatically install the Flash plugin
	for this browser and platform. Also determines if installation or
	revving of the current plugin is needed on this platform.</description>
      </method>
      <method name="Info" scope="instance">
        <description>A class that helps us determine whether Flash is available,
	it's major and minor versions, and what Flash version features should
	be used for Flash/JavaScript communication. Parts of this code
	are adapted from the automatic Flash plugin detection code autogenerated
	by the Macromedia Flash 8 authoring environment.
	
	An instance of this class can be accessed on dojox.flash.info after
	the page is finished loading.</description>
      </method>
      <method name="Embed" scope="instance">
        <description>Writes out the necessary tags to embed a Flash file into the page. Note that
	these tags are written out as the page is loaded using document.write, so
	you must call this class before the page has finished loading.</description>
        <parameters>
          <parameter name="visible" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Communicator" scope="instance">
        <description>This class helps mediate Flash and JavaScript communication. Internally
	it uses Flash 8's ExternalInterface API, but adds functionality to fix
	various encoding bugs that ExternalInterface has.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.flash.setSwf">
    <methods/>
  </class>
  <class type="dojox.flash.Info">
    <description>A class that helps us determine whether Flash is available,
	it's major and minor versions, and what Flash version features should
	be used for Flash/JavaScript communication. Parts of this code
	are adapted from the automatic Flash plugin detection code autogenerated
	by the Macromedia Flash 8 authoring environment.
	
	An instance of this class can be accessed on dojox.flash.info after
	the page is finished loading.</description>
    <methods>
      <method name="isVersionOrAbove" scope="instance">
        <description>Asserts that this environment has the given major, minor, and revision
	numbers for the Flash player.
	
	Example- To test for Flash Player 7r14:
	
	dojox.flash.info.isVersionOrAbove(7, 0, 14)</description>
        <parameters>
          <parameter name="reqMajorVer" type="int" usage="required"/>
          <parameter name="reqMinorVer" type="int" usage="required"/>
          <parameter name="reqVer" type="int" usage="required"/>
        </parameters>
        <return-description>Returns true if the player is equal
	or above the given version, false otherwise.</return-description>
      </method>
      <method name="_detectVersion" scope="instance"/>
      <method name="_JSFlashInfo" scope="instance">
        <parameters>
          <parameter name="testVersion" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.flash.Info._detectVersion">
    <methods/>
  </class>
  <class type="dojox.flash.Embed">
    <description>Writes out the necessary tags to embed a Flash file into the page. Note that
	these tags are written out as the page is loaded using document.write, so
	you must call this class before the page has finished loading.</description>
    <methods>
      <method name="write" scope="instance">
        <description>This must be called before the page
	is finished loading.</description>
        <parameters>
          <parameter name="doExpressInstall" type="Boolean" usage="optional">
            <description>Whether to write out Express Install
	information. Optional value; defaults to false.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setVisible" scope="instance">
        <parameters>
          <parameter name="visible" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="protocol" scope="instance"/>
      <method name="get" scope="instance"/>
      <method name="center" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.flash.Embed.center">
    <methods/>
  </class>
  <class type="dojox.flash.Communicator">
    <description>This class helps mediate Flash and JavaScript communication. Internally
	it uses Flash 8's ExternalInterface API, but adds functionality to fix
	various encoding bugs that ExternalInterface has.</description>
    <methods>
      <method name="_execFlash" scope="instance">
        <parameters>
          <parameter name="methodName" type="Object" usage="required"/>
          <parameter name="methodArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encodeData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decodeData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addExternalInterfaceCallback" scope="instance">
        <parameters>
          <parameter name="methodName" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.flash.Install">
    <description>Figures out the best way to automatically install the Flash plugin
	for this browser and platform. Also determines if installation or
	revving of the current plugin is needed on this platform.</description>
    <methods>
      <method name="needed" scope="instance"/>
      <method name="install" scope="instance"/>
      <method name="_onInstallStatus" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form">
    <methods>
      <method name="addUploaderPlugin" scope="instance">
        <parameters>
          <parameter name="plug" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_VerifyPWBox" scope="instance"/>
      <method name="_SelectStackMixin" scope="instance"/>
      <method name="_RangeSliderMixin" scope="instance"/>
      <method name="_OldPWBox" scope="instance"/>
      <method name="_NewPWBox" scope="instance"/>
      <method name="_ListInputInputItem" scope="instance">
        <description>Simple &lt;li&gt; with close button added to ListInputInput when delimiter is found</description>
      </method>
      <method name="_ListInputInputBox" scope="instance">
        <description>Auto sized textbox based on dijit.form.TextBox</description>
      </method>
      <method name="_ChildTextBox" scope="instance"/>
      <method name="_CheckedMultiSelectMenuItem" scope="instance"/>
      <method name="_CheckedMultiSelectMenu" scope="instance"/>
      <method name="_CheckedMultiSelectItem" scope="instance"/>
      <method name="_BusyButtonMixin" scope="instance"/>
      <method name="YearTextBox" scope="instance"/>
      <method name="VerticalRangeSlider" scope="instance"/>
      <method name="Uploader" scope="instance">
        <description>A bare-bones, stylable file-input button, with optional multi-file selection. The list
	of files is not displayed, that is for you to handle by connecting to the onChange
	event, or use the dojox.form.uploader.FileList.
	
	Uploader without plugins does not have any ability to upload - it is for use in forms
	where you handle the upload either by a standard POST or with Ajax using an iFrame. This
	class is for convenience of multiple files only. No progress events are available.
	
	If the browser supports a file-input with the "multiple" attribute, that will be used.
	If the browser does not support "multiple" (ergo, IE) multiple inputs are used,
	one for each selection.</description>
      </method>
      <method name="TriStateCheckBox" scope="instance"/>
      <method name="TimeSpinner" scope="instance">
        <description>This widget is the same as a normal NumberSpinner, but for the time component of a date object instead</description>
      </method>
      <method name="Rating" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="RadioStack" scope="instance"/>
      <method name="PasswordValidator" scope="instance"/>
      <method name="MultiComboBox" scope="instance"/>
      <method name="MonthTextBox" scope="instance"/>
      <method name="Manager" scope="instance">
        <description>This widget hosts dojox.form.manager mixins.
	See _Mixin for more info.</description>
      </method>
      <method name="ListInput" scope="instance">
        <description>you can add value to list with add method.
	you can only remove by clicking close button</description>
      </method>
      <method name="HorizontalRangeSlider" scope="instance"/>
      <method name="FileUploader" scope="instance">
        <description>If the correct version of Flash Player is available (&gt; 9.0) , a SWF
	is used. If Flash Player is not installed or is outdated, a typical
	html fileInput is used. This process can be overridden with</description>
        <examples>
          <example>fileMask = ["Images", "*.jpg;*.jpeg;*.gif;*.png"]
	or
	fileMask = [
	["Jpeg File", 	"*.jpg;*.jpeg"],
	["GIF File", 	"*.gif"],
	["PNG File", 	"*.png"],
	["All Images", 	"*.jpg;*.jpeg;*.gif;*.png"],
	]
	NOTE: MacType is not supported, as it does not work very well.
	fileMask will work on a Mac, but differently than
	Windows.</example>
        </examples>
      </method>
      <method name="FilePickerTextBox" scope="instance"/>
      <method name="FileInputBlind" scope="instance"/>
      <method name="FileInputAuto" scope="instance">
        <description>An extended version of FileInput - when the user focuses away from the input
	the selected file is posted via ioIframe to the url. example implementation
	comes with PHP solution for handling upload, and returning required data.
	
	notes: the return data from the io.iframe is used to populate the input element with
	data regarding the results. it will be a JSON object, like:
	
	results = { size: "1024", filename: "file.txt" }
	
	all the parameters allowed to FileInput apply</description>
      </method>
      <method name="FileInput" scope="instance">
        <description>A input type="file" form widget, with a button for uploading to be styled via css,
	a cancel button to clear selection, and FormWidget mixin to provide standard dijit.form.Form
	support (FIXME: maybe not fully implemented)</description>
      </method>
      <method name="DropDownStack" scope="instance"/>
      <method name="DayTextBox" scope="instance"/>
      <method name="DateTextBox" scope="instance"/>
      <method name="CheckedMultiSelect" scope="instance"/>
      <method name="BusyDropDownButton" scope="instance"/>
      <method name="BusyComboButton" scope="instance"/>
      <method name="BusyButton" scope="instance"/>
    </methods>
    <properties>
      <property name="uploader" scope="instance" type="Object"/>
      <property name="manager" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._BusyButtonMixin">
    <methods>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="resetTimeout" scope="instance">
        <parameters>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="makeBusy" scope="instance"/>
      <method name="cancel" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="titleNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._BusyButtonMixin.containerNode"/>
  <class type="dojox.form._BusyButtonMixin.titleNode"/>
  <class type="dojox.form.BusyButton" superclass="dijit.form.Button">
    <methods/>
    <mixins scope="instance">
      <mixin type="_BusyButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="_BusyButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.BusyComboButton" superclass="dijit.form.ComboButton">
    <methods/>
    <mixins scope="instance">
      <mixin type="_BusyButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboButton" scope="instance"/>
      <mixin type="_BusyButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.BusyDropDownButton" superclass="dijit.form.DropDownButton">
    <methods/>
    <mixins scope="instance">
      <mixin type="_BusyButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.DropDownButton" scope="instance"/>
      <mixin type="_BusyButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_updateBox" scope="instance"/>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_changeBox" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="option" scope="instance" type="dojox.form.__SelectOption">
        <description>The option that is associated with this item</description>
      </property>
      <property name="labelNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem.option"/>
  <class type="dojox.form._CheckedMultiSelectItem.labelNode"/>
  <class type="dojox.form._CheckedMultiSelectMenu" superclass="dijit.Menu">
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="mb" type="Object" usage="required">
            <description>The margin box to set this dropdown to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Menu" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._CheckedMultiSelectMenu.menuTableNode.style"/>
  <class type="dojox.form._CheckedMultiSelectMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_updateBox" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="option" scope="instance" type="dojox.form.__SelectOption">
        <description>The option that is associated with this item</description>
      </property>
      <property name="inputNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._CheckedMultiSelectMenuItem.inputNode"/>
  <class type="dojox.form._CheckedMultiSelectMenuItem.option"/>
  <class type="dojox.form.CheckedMultiSelect" superclass="dijit.form._FormSelectWidget">
    <methods>
      <method name="validator" scope="instance"/>
      <method name="validate" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="selectedValue" type="Object" usage="required"/>
          <parameter name="fetchArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterAddOptionItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="invertSelection" scope="instance">
        <parameters>
          <parameter name="onChange" type="Boolean" usage="required">
            <description>If null, onChange is not fired.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getErrorMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="displayMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelection" scope="instance"/>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildren" scope="instance"/>
      <method name="_fillContent" scope="instance"/>
      <method name="_addOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormSelectWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.CheckedMultiSelect.srcNodeRef"/>
  <class type="dojox.form.DateTextBox" superclass="dijit.form._DateTimeTextBox">
    <methods>
      <method name="openDropDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.DayTextBox" superclass="DateTextBox">
    <methods>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="displayVal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance"/>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="DateTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DayTextBox.dropDown"/>
  <class type="dojox.form.MonthTextBox" superclass="DateTextBox">
    <methods>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance"/>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="DateTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="constraints" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.MonthTextBox.constraints"/>
  <class type="dojox.form.MonthTextBox.dropDown"/>
  <class type="dojox.form.YearTextBox" superclass="DateTextBox">
    <methods>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="openDropDown" scope="instance"/>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="DateTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.YearTextBox.dropDown"/>
  <class type="dojox.form.DropDownStack" superclass="dijit.form.Select">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._SelectStackMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Select" scope="instance"/>
      <mixin type="dojox.form._SelectStackMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._SelectStackMixin">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onStartup" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onAddChild" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="attr" scope="instance">
        <parameters>
          <parameter name="name" type="String|Object" usage="required"/>
          <parameter name="value" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_togglePane" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="shown" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_paneIdFromOption" scope="instance">
        <parameters>
          <parameter name="oVal" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_optionValFromPane" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_handleSelfOnChange" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_connectTitle" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form.FileInput" superclass="dijit.form._FormWidget">
    <description>A input type="file" form widget, with a button for uploading to be styled via css,
	a cancel button to clear selection, and FormWidget mixin to provide standard dijit.form.Form
	support (FIXME: maybe not fully implemented)</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="cssClass" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_matchValue" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="titleNode" scope="instance" type="Object"/>
      <property name="inputNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.inputNode"/>
  <class type="dojox.form.FileInput.cancelNode.style"/>
  <class type="dojox.form.FileInput.titleNode"/>
  <class type="dojox.form.FileInputAuto" superclass="dojox.form.FileInput">
    <description>An extended version of FileInput - when the user focuses away from the input
	the selected file is posted via ioIframe to the url. example implementation
	comes with PHP solution for handling upload, and returning required data.
	
	notes: the return data from the io.iframe is used to populate the input element with
	data regarding the results. it will be a JSON object, like:
	
	results = { size: "1024", filename: "file.txt" }
	
	all the parameters allowed to FileInput apply</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setMessage" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="data" type="the" usage="required">
            <description>raw data found in the first [TEXTAREA] tag of the post url</description>
          </parameter>
          <parameter name="ioArgs" type="the" usage="required">
            <description>Deferred data being passed from the handle: callback</description>
          </parameter>
          <parameter name="widgetRef" type="this" usage="required">
            <description>widget pointer, so you can set this.overlay to a completed/error message easily</description>
          </parameter>
        </parameters>
      </method>
      <method name="onBeforeSend" scope="instance"/>
      <method name="_sendFile" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="_handleSend" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.FileInput" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.FileInputAuto.overlay.style"/>
  <class type="dojox.form.FileInputAuto.fileInput.style"/>
  <class type="dojox.form.FileInputAuto.fakeNodeHolder.style"/>
  <class type="dojox.form.FileInputBlind" superclass="FileInputAuto">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fixPosition" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="FileInputAuto" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.FileInputBlind.inputNode.style"/>
  <class type="dojox.form.FilePickerTextBox" superclass="dijit.form.ValidationTextBox">
    <methods>
      <method name="toggleDropDown" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance"/>
      <method name="_startSearchFromInput" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="string" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="fromWidget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_onWidgetChange" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_focusFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="focusNode" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox.focusNode"/>
  <class type="dojox.form.FilePickerTextBox.dropDown.domNode.style"/>
  <class type="dojox.form.FilePickerTextBox.dropDown"/>
  <class type="dojox.form.FileUploader" superclass="dijit._Widget">
    <description>If the correct version of Flash Player is available (&gt; 9.0) , a SWF
	is used. If Flash Player is not installed or is outdated, a typical
	html fileInput is used. This process can be overridden with</description>
    <methods>
      <method name="urlencode" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uploadHTML" scope="instance"/>
      <method name="uploadFlash" scope="instance"/>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <description>postData to be sent to server</description>
          </parameter>
        </parameters>
      </method>
      <method name="submit" scope="instance">
        <parameters>
          <parameter name="form" type="form" usage="required">
            <description>node ?</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="startup" scope="instance"/>
      <method name="setButtonStyle" scope="instance"/>
      <method name="removeFile" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the file to be removed. Typically the file name,
	such as: picture01.png</description>
          </parameter>
          <parameter name="noListEdit" type="Boolean" usage="required">
            <description>Internal. If true don't remove files from list.</description>
          </parameter>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onProgress" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="evtObject" type="Object" usage="required">
            <description>or String</description>
          </parameter>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="log" scope="instance"/>
      <method name="isButton" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTempNodeStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="_class" type="Object" usage="required"/>
          <parameter name="isDijitButton" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHiddenNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getButtonStyle" scope="instance"/>
      <method name="flashMovie" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="createHtmlUploader" scope="instance"/>
      <method name="createFlashUploader" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_styleContent" scope="instance"/>
      <method name="_setHtmlPostData" scope="instance"/>
      <method name="_setFormStyle" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resetHTML" scope="instance"/>
      <method name="_renumberInputs" scope="instance"/>
      <method name="_progress" scope="instance">
        <parameters>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFlashBlur" scope="instance"/>
      <method name="_getDisabledAttr" scope="instance"/>
      <method name="_error" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doSub" scope="instance">
        <parameters>
          <parameter name="subStr" type="Object" usage="required"/>
          <parameter name="funcStr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayProgress" scope="instance">
        <parameters>
          <parameter name="display" type="Boolean" usage="required">
            <description>or Number</description>
          </parameter>
        </parameters>
      </method>
      <method name="_disconnect" scope="instance"/>
      <method name="_connectInput" scope="instance"/>
      <method name="_connectFlash" scope="instance">
        <description>Sacrificing some readbilty for compactness. this.id
	will be on the beginning of the topic, so more than
	one uploader can be on a page and can have unique calls.</description>
      </method>
      <method name="_complete" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkHtmlCancel" scope="instance">
        <parameters>
          <parameter name="mouseType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildForm" scope="instance"/>
      <method name="_buildFileInput" scope="instance"/>
      <method name="_animateProgress" scope="instance"/>
      <method name="_addToFileList" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="progTextNode" scope="instance" type="Object"/>
      <property name="norm" scope="instance" type="Object"/>
      <property name="insideNode" scope="instance" type="HTMLNode">
        <description>The div that holds the SWF and form/fileInput</description>
      </property>
      <property name="flashObject" scope="instance" type="dojox.embed.Flash">
        <description>The object that creates the SWF embed object. Mostly Internal.</description>
      </property>
      <property name="fhtml" scope="instance" type="Object"/>
      <property name="_formNode" scope="instance" type="Object"/>
      <property name="_fileInput" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.norm"/>
  <class type="dojox.form.FileUploader.progTextNode"/>
  <class type="dojox.form.FileUploader.insideNode"/>
  <class type="dojox.form.FileUploader.fhtml">
    <properties>
      <property name="nr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader._formNode"/>
  <class type="dojox.form.FileUploader._fileInput"/>
  <class type="dojox.form.FileUploader.fhtml.nr"/>
  <class type="dojox.form.FileUploader.flashObject"/>
  <class type="dojox.form.ListInput" superclass="dijit.form._FormValueWidget">
    <description>you can add value to list with add method.
	you can only remove by clicking close button</description>
    <methods>
      <method name="regExpGen" scope="instance">
        <parameters>
          <parameter name="constraints" type="ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="Array" usage="required"/>
          <parameter name="val2" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="values" type="String" usage="required">
            <description>|| Array</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateValues" scope="instance"/>
      <method name="_testItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="Array" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setSelectNode" scope="instance"/>
      <method name="_setReadOnlyWhenMaxItemsReached" scope="instance"/>
      <method name="_setReadOnlyItemAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyInputAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_placeItem" scope="instance">
        <parameters>
          <parameter name="node" type="domNode" usage="required"/>
        </parameters>
      </method>
      <method name="_parseValue" scope="instance">
        <parameters>
          <parameter name="newValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemKeyDown" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemEdit" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemClose" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChange" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandler" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_nullValidator" scope="instance">
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_mismatchValidator" scope="instance">
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_matchValidator" scope="instance">
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_inputOnKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_inputOnBlur" scope="instance"/>
      <method name="_getValues" scope="instance">
        <parameters>
          <parameter name="validator" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_getSomeItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getPreviousItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getMismatchedValueAttr" scope="instance"/>
      <method name="_getMatchedValueAttr" scope="instance"/>
      <method name="_getLastItemAttr" scope="instance"/>
      <method name="_getCursorPos" scope="instance">
        <parameters>
          <parameter name="node" type="domNode" usage="required"/>
        </parameters>
      </method>
      <method name="_focusInput" scope="instance"/>
      <method name="_editBefore" scope="instance">
        <parameters>
          <parameter name="item" type="widget" usage="required"/>
        </parameters>
      </method>
      <method name="_editAfter" scope="instance">
        <parameters>
          <parameter name="item" type="widget" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="updateValue" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_destroyAllItems" scope="instance"/>
      <method name="_createInputBox" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputProperties" scope="instance" type="String">
        <description>|| Object
	Properties used to create input box
	If String, it must be a valid JSON</description>
      </property>
      <property name="_lastAddedItem" scope="instance" type="Widget">
        <description>Contain a reference to the last created item</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form.ListInput.inputProperties"/>
  <class type="dojox.form.ListInput._lastAddedItem"/>
  <class type="dojox.form.ListInput._selectNode.options"/>
  <class type="dojox.form._ListInputInputItem" superclass="dijit._Widget">
    <description>Simple &lt;li&gt; with close button added to ListInputInput when delimiter is found</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onEdit" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="edit" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setReadOnlyItemAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onEdit" scope="instance"/>
      <method name="_onCloseLeave" scope="instance"/>
      <method name="_onCloseEnter" scope="instance"/>
      <method name="_onCloseEdit" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_createInlineEditBox" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="attributeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputItem.attributeMap">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputItem.attributeMap.value"/>
  <class type="dojox.form._ListInputInputBox" superclass="dijit.form.ValidationTextBox">
    <description>Auto sized textbox based on dijit.form.TextBox</description>
    <methods>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="_sizer" scope="instance" type="DomNode">
        <description>Used to get size of textbox content</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputBox._sizer"/>
  <class type="dojox.form.Manager" superclass="dijit._Widget">
    <description>This widget hosts dojox.form.manager mixins.
	See _Mixin for more info.</description>
    <methods>
      <method name="destroyRendering" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.manager._Mixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._NodeMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._FormMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._ValueMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._EnableMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._DisplayMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._ClassMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dojox.form.manager._Mixin" scope="instance"/>
      <mixin type="dojox.form.manager._NodeMixin" scope="instance"/>
      <mixin type="dojox.form.manager._FormMixin" scope="instance"/>
      <mixin type="dojox.form.manager._ValueMixin" scope="instance"/>
      <mixin type="dojox.form.manager._EnableMixin" scope="instance"/>
      <mixin type="dojox.form.manager._DisplayMixin" scope="instance"/>
      <mixin type="dojox.form.manager._ClassMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.manager">
    <methods>
      <method name="_ValueMixin" scope="instance">
        <description>This mixin adds unified access to form widgets and form elements
	in terms of name-value regardless of the underlying type of
	an element. It should be used together with dojox.form.manager.Mixin.</description>
      </method>
      <method name="_NodeMixin" scope="instance">
        <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, and general event
	processing. It complements dojox.form.manager._Mixin
	extending the functionality to DOM nodes.</description>
      </method>
      <method name="_Mixin" scope="instance">
        <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, general event
	processing, I/O orchestration, and common form-related
	functionality. See additional mixins in dojox.form.manager
	namespace.</description>
      </method>
      <method name="_FormMixin" scope="instance">
        <description>This mixin adds automated "onreset", and "onsubmit" event processing
	if we are based on a form node, defines onReset(), onSubmit(),
	reset(), submit(), and isValid() methods like dijit.form.Form.
	It should be used together with dojox.form.manager.Mixin.</description>
      </method>
      <method name="_EnableMixin" scope="instance">
        <description>This mixin provides unified enable/disable functionality for
	form widgets and form elements. It should be used together
	with dojox.form.manager.Mixin.</description>
      </method>
      <method name="_DisplayMixin" scope="instance">
        <description>This mixin provides unified show/hide functionality for
	controlled elements (indicated by dojoAttachPoint attribute).
	Essentially it provides a way to change "style.display"
	parameter of controlled nodes.
	It should be used together with dojox.form.manager.Mixin.</description>
      </method>
      <method name="_ClassMixin" scope="instance">
        <description>This mixin provides unified way to check/add/remove a class
	of controlled elements.
	It should be used together with dojox.form.manager.Mixin.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._Mixin">
    <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, general event
	processing, I/O orchestration, and common form-related
	functionality. See additional mixins in dojox.form.manager
	namespace.</description>
    <methods>
      <method name="unregisterWidgetDescendants" scope="instance">
        <parameters>
          <parameter name="widget" type="String|Node|dijit._Widget" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterWidget" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Name of the to unregister</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="startup" scope="instance"/>
      <method name="registerWidgetDescendants" scope="instance">
        <parameters>
          <parameter name="widget" type="String|Node|dijit._Widget" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="registerWidget" scope="instance">
        <parameters>
          <parameter name="widget" type="String|Node|dijit.form._FormWidget" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="inspectFormWidgets" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function" usage="required">
            <description>A function to be called on a widget. Takes three arguments: a name, a widget object
	or an array of widget objects, and a supplied value. Runs in the context of
	the form manager. Returns a value that will be collected and returned as a state.</description>
          </parameter>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all widgets will be processed with defaultValue.</description>
          </parameter>
          <parameter name="defaultValue" type="Object" usage="optional">
            <description>Optional. The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspectAttachedPoints" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function" usage="required">
            <description>A function to be called on a node. Takes three arguments: a name, a node or
	an array of nodes, and a supplied value. Runs in the context of the form manager.
	Returns a value that will be collected and returned as a state.</description>
          </parameter>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all attached point nodes will be processed with defaultValue.</description>
          </parameter>
          <parameter name="defaultValue" type="Object" usage="optional">
            <description>Optional. The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspect" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function" usage="required">
            <description>A function to be called on a widget, form element, and an attached node.
	Takes three arguments: a name, a node (domNode in the case of widget) or
	an array of such objects, and a supplied value. Runs in the context of
	the form manager. Returns a value that will be collected and returned as a state.</description>
          </parameter>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all controlled elements will be processed with defaultValue.</description>
          </parameter>
          <parameter name="defaultValue" type="Object" usage="optional">
            <description>Optional. The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formWidgetValue" scope="instance">
        <parameters>
          <parameter name="elem" type="String|Object|Array" usage="required">
            <description>Form element's name, widget object, or array or radio widgets.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. The value to set.</description>
          </parameter>
        </parameters>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formPointValue" scope="instance">
        <parameters>
          <parameter name="elem" type="String|Object|Array" usage="required">
            <description>A node.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. The value to set.</description>
          </parameter>
        </parameters>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.form.manager._NodeMixin">
    <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, and general event
	processing. It complements dojox.form.manager._Mixin
	extending the functionality to DOM nodes.</description>
    <methods>
      <method name="unregisterNodeDescendants" scope="instance">
        <parameters>
          <parameter name="node" type="String|Node" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterNode" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Name of the to unregister</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="registerNodeDescendants" scope="instance">
        <parameters>
          <parameter name="node" type="String|Node" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="registerNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|Node" usage="required">
            <description>A node, or its id</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="inspectFormNodes" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function" usage="required">
            <description>A function to be called on a form element. Takes three arguments: a name, a node or
	an array of nodes, and a supplied value. Runs in the context of the form manager.
	Returns a value that will be collected and returned as a state.</description>
          </parameter>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all form elements will be processed with defaultValue.</description>
          </parameter>
          <parameter name="defaultValue" type="Object" usage="optional">
            <description>Optional. The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formNodeValue" scope="instance">
        <parameters>
          <parameter name="elem" type="String|Node|Array" usage="required">
            <description>Form element's name, DOM node, or array or radio nodes.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. The value to set.</description>
          </parameter>
        </parameters>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.form.manager._FormMixin">
    <description>This mixin adds automated "onreset", and "onsubmit" event processing
	if we are based on a form node, defines onReset(), onSubmit(),
	reset(), submit(), and isValid() methods like dijit.form.Form.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="validate" scope="instance"/>
      <method name="submit" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="onSubmit" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onReset" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValid" scope="instance"/>
      <method name="_onSubmit" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onReset" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._ValueMixin">
    <description>This mixin adds unified access to form widgets and form elements
	in terms of name-value regardless of the underlying type of
	an element. It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="setFormValues" scope="instance">
        <parameters>
          <parameter name="values" type="Object" usage="required">
            <description>A dictionary of key-value pairs.</description>
          </parameter>
        </parameters>
      </method>
      <method name="gatherFormValues" scope="instance">
        <parameters>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names of form elements to be collected.
	If it is an object, dictionary keys are names to be collected.
	If it is omitted, all known form elements are to be collected.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="elementValue" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. The value to set.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._EnableMixin">
    <description>This mixin provides unified enable/disable functionality for
	form widgets and form elements. It should be used together
	with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="gatherEnableState" scope="instance">
        <parameters>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="enable" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary, the value is true
	to enable and false to disable. If an array, all names in the
	array will be set to defaultState. If omitted, all form
	elements will be set to defaultState.</description>
          </parameter>
          <parameter name="defaultState" type="Boolean" usage="required">
            <description>The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="disable" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary, the value is true
	to enable and false to disable. If an array, all names in the
	array will be disabled. If omitted, disables all.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._DisplayMixin">
    <description>This mixin provides unified show/hide functionality for
	controlled elements (indicated by dojoAttachPoint attribute).
	Essentially it provides a way to change "style.display"
	parameter of controlled nodes.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary, the value is true
	to show and false to hide. If an array, all names in the
	array will be set to defaultState. If omitted, all form
	elements will be set to defaultState.</description>
          </parameter>
          <parameter name="defaultState" type="Boolean" usage="optional">
            <description>The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary, the value is true
	to show and false to hide. If an array, all names in the
	array will be hidden. If omitted, all form elements
	will be hidden.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="gatherDisplayState" scope="instance">
        <parameters>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known attach point nodes are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._ClassMixin">
    <description>This mixin provides unified way to check/add/remove a class
	of controlled elements.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="removeClass" scope="instance">
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>Class name to remove.</description>
          </parameter>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="gatherClassState" scope="instance">
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>The class name to test for.</description>
          </parameter>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>Class name to add.</description>
          </parameter>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.MultiComboBox" superclass="dijit.form.ValidationTextBox">
    <methods>
      <method name="_startSearch" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupDelimiters" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_autoCompleteText" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_addPreviousMatches" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._ChildTextBox" superclass="dijit.form.ValidationTextBox">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onChildKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._OldPWBox" superclass="_ChildTextBox">
    <methods>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="newVal" type="anything" usage="required"/>
          <parameter name="priority" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_ChildTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._NewPWBox" superclass="_ChildTextBox">
    <methods>
      <method name="onChange" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_ChildTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._VerifyPWBox" superclass="_ChildTextBox">
    <methods>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_ChildTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.PasswordValidator" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="validate" scope="instance">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="pwCheck" scope="instance">
        <parameters>
          <parameter name="password" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttribute" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_createSubWidgets" scope="instance"/>
      <method name="_childValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.RadioStack" superclass="dojox.form.CheckedMultiSelect">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._SelectStackMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.form.CheckedMultiSelect" scope="instance"/>
      <mixin type="dojox.form._SelectStackMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._RangeSliderMixin">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Array" usage="required">
            <description>or Number</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="required">
            <description>optional</description>
          </parameter>
          <parameter name="isMaxVal" type="Boolean" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="instance">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
          <parameter name="isMaxVal" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_printSliderBar" scope="instance">
        <parameters>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="isMaxVal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRemainingBarClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClickMax" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="instance"/>
      <method name="_onBarClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueByPixelValue" scope="instance">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_getBumpValue" scope="instance">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="useMaxValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_bumpValue" scope="instance">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="useMaxValue" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="valueNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._RangeSliderMixin.valueNode"/>
  <class type="dijit.form._SliderMoverMax" superclass="dijit.form._SliderMover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._SliderMover" scope="instance"/>
    </mixins>
    <properties>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SliderMoverMax.widget"/>
  <class type="dijit.form._SliderBarMover" superclass="Mover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="Mover" scope="instance"/>
    </mixins>
    <properties>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SliderBarMover.widget"/>
  <class type="dojox.form.HorizontalRangeSlider" superclass="HorizontalSlider">
    <methods/>
    <mixins scope="instance">
      <mixin type="RangeSliderMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="HorizontalSlider" scope="instance"/>
      <mixin type="RangeSliderMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.VerticalRangeSlider" superclass="VerticalSlider">
    <methods/>
    <mixins scope="instance">
      <mixin type="RangeSliderMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="VerticalSlider" scope="instance"/>
      <mixin type="RangeSliderMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.Rating" superclass="dijit.form._FormWidget">
    <methods>
      <method name="setAttribute" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onStarClick" scope="instance">
        <examples>
          <example>connect(widget, "onStarClick", function(event){ ... })</example>
        </examples>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStars" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="hover" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouse" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.TimeSpinner" superclass="dijit.form._Spinner">
    <description>This widget is the same as a normal NumberSpinner, but for the time component of a date object instead</description>
    <methods>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
          <parameter name="locale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance"/>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
          <parameter name="locale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjust" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._Spinner" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.TriStateCheckBox" superclass="dijit.form.ToggleButton">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setChecked" scope="instance">
        <parameters>
          <parameter name="checked" type="String|Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_setValuesAttr" scope="instance">
        <description>Change the value of the TriStateCheckBox in 'mixed' and true states.</description>
        <parameters>
          <parameter name="newValues" type="Array" usage="required">
            <description>If the length of newValues is 1, it will replace the value of
	the TriStateCheckBox in true state. Otherwise, the values of
	the TriStateCheckBox in true state and 'mixed' state will be
	replaced by the first two values in newValues.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>During initialization, just saves as attribute to the &lt;input type=checkbox&gt;.
	
	After initialization,
	when passed a boolean or the string 'mixed', controls the state of the
	TriStateCheckBox.
	If passed a string except 'mixed', changes the value attribute of the
	TriStateCheckBox. Sets the state of the TriStateCheckBox to checked.</description>
        <parameters>
          <parameter name="newValue" type="String|Boolean" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setCheckedAttr" scope="instance">
        <description>Controls the state of the TriStateCheckBox. Set this.checked,
	this._currentState, value attribute of the &lt;input type=checkbox&gt;
	according to the value of 'checked'.</description>
        <parameters>
          <parameter name="checked" type="String|Boolean" usage="required">
            <description>true, false or 'mixed'</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="user click actions"/>
        </return-types>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_getValueAttr" scope="instance">
        <description>Returns value according to current state of the TriStateCheckBox.</description>
      </method>
      <method name="_getStateType" scope="instance">
        <parameters>
          <parameter name="state" type="String|Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ToggleButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="stateValues" scope="instance-prototype" type="Object">
        <description>The values of the TriStateCheckBox in corresponding states.</description>
      </property>
      <property name="_stateLabels" scope="instance-prototype" type="Object">
        <description>These characters are used to replace the image to show
	current state of TriStateCheckBox in high contrast mode.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form.TriStateCheckBox._stateLabels"/>
  <class type="dojox.form.TriStateCheckBox.stateValues"/>
  <class type="dojox.form.Uploader" superclass="dojox.form.uploader.Base">
    <description>A bare-bones, stylable file-input button, with optional multi-file selection. The list
	of files is not displayed, that is for you to handle by connecting to the onChange
	event, or use the dojox.form.uploader.FileList.
	
	Uploader without plugins does not have any ability to upload - it is for use in forms
	where you handle the upload either by a standard POST or with Ajax using an iFrame. This
	class is for convenience of multiple files only. No progress events are available.
	
	If the browser supports a file-input with the "multiple" attribute, that will be used.
	If the browser does not support "multiple" (ergo, IE) multiple inputs are used,
	one for each selection.</description>
    <methods>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="formData" type="Object" usage="required">
            <description>?</description>
          </parameter>
        </parameters>
      </method>
      <method name="submit" scope="instance">
        <parameters>
          <parameter name="form" type="form" usage="required">
            <description>Node ?</description>
          </parameter>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onProgress" scope="instance">
        <parameters>
          <parameter name="customEvent" type="Object" usage="required">
            <description>bytesLoaded: Number
	Amount of bytes uploaded so far of entire payload (all files)
	bytesTotal: Number
	Amount of bytes of entire payload (all files)
	type: String
	Type of event (progress or load)
	timeStamp: Number
	Timestamp of when event occurred</description>
          </parameter>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="evtObject" type="Object" usage="required">
            <description>or String</description>
          </parameter>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="customEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="onBegin" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onAbort" scope="instance"/>
      <method name="getFileList" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setButtonStyle" scope="instance"/>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_getButtonStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_disconnectButton" scope="instance"/>
      <method name="_createInput" scope="instance"/>
      <method name="_connectButton" scope="instance"/>
      <method name="_buildDisplay" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="Button.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.form.uploader.Base" scope="instance"/>
      <mixin type="Button" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.Uploader.inputNode"/>
  <class type="dojox.form.uploader">
    <methods>
      <method name="FileList" scope="instance">
        <description>There is a required CSS file: resources/UploaderFileList.css.
	This is a very simple widget, and not beautifully styled. It is here mainly for test
	cases, but could very easily be used, extended, modified, or copied.</description>
      </method>
      <method name="Base" scope="instance">
        <description>Should not be used as a standalone. To be mixed in with other classes.</description>
      </method>
    </methods>
    <properties>
      <property name="plugins" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.Base" superclass="dijit._Widget">
    <description>Should not be used as a standalone. To be mixed in with other classes.</description>
    <methods>
      <method name="supports" scope="instance">
        <parameters>
          <parameter name="what" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getUrl" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getMimeType" scope="instance">
        <return-types>
          <return-type type="image/gif"/>
        </return-types>
      </method>
      <method name="getForm" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="getFileType" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="convertBytes" scope="instance">
        <parameters>
          <parameter name="bytes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectForm" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="Widget">
    <methods/>
  </class>
  <class type="dojox.form.uploader.FileList" superclass="dojox.form.uploader.Base">
    <description>There is a required CSS file: resources/UploaderFileList.css.
	This is a very simple widget, and not beautifully styled. It is here mainly for test
	cases, but could very easily be used, extended, modified, or copied.</description>
    <methods>
      <method name="showProgress" scope="instance">
        <parameters>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setUploader" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="hideProgress" scope="instance">
        <parameters>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_progress" scope="instance">
        <parameters>
          <parameter name="customEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUploaderChange" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideShowProgress" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addRow" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.uploader.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="percentTextNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.FileList.sizeHeader.style"/>
  <class type="dojox.form.uploader.FileList.percentTextNode"/>
  <class type="dojox.form.uploader.plugins">
    <methods>
      <method name="IFrame" scope="instance">
        <description>Only supported by IE, due to the specifc iFrame hack used. The
	formUploaderPluginsHTML5 plugin should be used along with this to add HTML5
	capabilities to browsers that support them. Progress events are not supported.
	Inherits all properties from dojox.form.Uploader and formUploaderPluginsHTML5.</description>
      </method>
      <method name="HTML5" scope="instance">
        <description>Add this plugin to have HTML5 capabilities in the Uploader. Note that it does not add
	these capabilities to browsers that don't support them. For IE or older browsers, add
	additional plugins: IFrame or Flash.</description>
      </method>
      <method name="Flash" scope="instance">
        <description>Inherits all properties from dojox.form.Uploader and formUploaderPluginsHTML5.
	All properties and methods listed here are specific to the Flash plugin only.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.form.uploader.plugins.Flash">
    <description>Inherits all properties from dojox.form.Uploader and formUploaderPluginsHTML5.
	All properties and methods listed here are specific to the Flash plugin only.</description>
    <methods>
      <method name="uploadFlash" scope="instance">
        <parameters>
          <parameter name="formData" type="Object" usage="required">
            <description>?</description>
          </parameter>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onFileProgress" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFileChange" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFlashFileList" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="flashReset" scope="instance"/>
      <method name="_progress" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFlashBlur" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCustomEvent" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_error" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createFlashUploader" scope="instance"/>
      <method name="_connectFlash" scope="instance">
        <description>Sacrificing some readbilty for compactness. this.id
	will be on the beginning of the topic, so more than
	one uploader can be on a page and can have unique calls.</description>
      </method>
      <method name="_complete" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="flashObject" scope="instance" type="Object"/>
      <property name="btnSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins.Flash.btnSize"/>
  <class type="dojox.form.uploader.plugins.Flash.flashObject"/>
  <class type="dojox.form.uploader.plugins.HTML5">
    <description>Add this plugin to have HTML5 capabilities in the Uploader. Note that it does not add
	these capabilities to browsers that don't support them. For IE or older browsers, add
	additional plugins: IFrame or Flash.</description>
    <methods>
      <method name="uploadWithFormData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="formData" type="Object" usage="required">
            <description>?</description>
          </parameter>
        </parameters>
      </method>
      <method name="sendAsBinary" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="createXhr" scope="instance"/>
      <method name="addDropTarget" scope="instance">
        <description>If onlyConnectDrop is true, dragenter/dragover/dragleave events
	won't be connected to dojo.stopEvent, and they need to be
	canceled by user code to allow DnD files to happen.
	This API is only available in HTML5 plugin (only HTML5 allows
	DnD files).</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="onlyConnectDrop" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_xhrProgress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_drop" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildRequestBody" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="boundary" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form.uploader.plugins.IFrame">
    <description>Only supported by IE, due to the specifc iFrame hack used. The
	formUploaderPluginsHTML5 plugin should be used along with this to add HTML5
	capabilities to browsers that support them. Progress events are not supported.
	Inherits all properties from dojox.form.Uploader and formUploaderPluginsHTML5.</description>
    <methods>
      <method name="uploadIFrame" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.fx">
    <description>A package of animations, and FX-related code, extending Dojo Core fx.
	Including this package includes all the Base and Core fx packages.</description>
    <methods>
      <method name="_Complex" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Shadow" scope="instance">
        <examples>
          <example>	// add drop shadows to all nodes with class="hasShadow"
		dojo.query(".hasShadow").forEach(function(n){
			var foo = new dojox.fx.Shadow({ node: n });
			foo.startup();
		});</example>
        </examples>
      </method>
    </methods>
    <properties>
      <property name="ext-dojo" scope="instance" type="Object">
        <description>Direct extensions to dojo.fx namespace</description>
      </property>
    </properties>
  </class>
  <class type="dojox.fx.Shadow" superclass="Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setOpacity" scope="instance">
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
          <parameter name="animArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.fx._arg.ShadowResizeArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_makePiece" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="vertAttach" type="Object" usage="required"/>
          <parameter name="vertCoord" type="Object" usage="required"/>
          <parameter name="horzAttach" type="Object" usage="required"/>
          <parameter name="horzCoord" type="Object" usage="required"/>
          <parameter name="sizing" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.fx.Shadow.node.style"/>
  <class type="dojoxFx">
    <methods>
      <method name="animateTimeline" scope="instance">
        <description>The Timeline is a replacement for the default dojo._Line.
	Instead of _Line.getValue returning a float between 0-1,
	_Timeline.getValue returns an object with all properties and
	their current values.
	A property does not have to appear in every keyframe.
	As in the example below, "height" is transitioned from the first
	keyframe to the third. "width" is transitioned from the first
	to the second to the third.
	Each keyframe can accept the following custom properties:
	step: String
	The start, finish or percentage that this keyframe represents.
	Allowed parameters are:
	0%-100%
	from (same as 0%, used to conform with the Webkit animation spec)
	to (same as 100%, used to conform with the Webkit animation spec)
	ease: String
	The string name of a dojo.fx.easing ease. Defaults to "linear". Use
	the suffix name of the ease, like: "quadIn", not: "dojo.fx.quadIn".</description>
        <examples>
          <example>	var keys = [
		{
			step:"0px",
			ease:"quadInOut",
			width:"50px",
			height:"50px",
		},{
			step:"25%",
			width:"190px"
		},{
			step:"100%",
			width:"10px",
			height:"200px",
		}
		];
		ani = dojox.fx.animateTimeline({keys:keys, duration:2000}, "myDiv").play();</example>
        </examples>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>The paramters passed to the timeline animation. Includes:
	keys: Array
	An array of objects, with style properties and values.
	duration:
	Duration of the animation in milliseconds.
	Defaults to 1000.</description>
          </parameter>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>DomNode The DomNode or id to be animated.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="styleFx" scope="instance"/>
    </mixins>
  </class>
  <class type="NodeList">
    <methods>
      <method name="wipeTo" scope="instance">
        <examples>
          <example> dojo.query(".box").wipeTo({ width: 300px }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleClassFx" scope="instance">
        <examples>
          <example> dojo.query(".box").toggleClass("bar").play();</example>
        </examples>
        <parameters>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="force" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideBy" scope="instance">
        <examples>
          <example>	// slide all tables with class "blah" 10 px
		dojo.query("table.blah").slideBy({ top:10, left:10 }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="sizeTo" scope="instance">
        <examples>
          <example>	// size all divs with class "blah"
		dojo.query("div.blah").sizeTo({
			width:50,
			height:50
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="removeClassFx" scope="instance">
        <examples>
          <example> dojo.query(".box").removeClassFx("bar").play();</example>
        </examples>
        <parameters>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="highlight" scope="instance">
        <examples>
          <example>	// highlight all links with class "foo"
		dojo.query("a.foo").hightlight().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeTo" scope="instance">
        <examples>
          <example>	// fade all elements with class "bar" to to 50% opacity
		dojo.query(".bar").fadeTo({ end: 0.5 }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addClassFx" scope="instance">
        <examples>
          <example>	// fade all elements with class "bar" to to 50% opacity
		dojo.query(".bar").addClassFx("bar").play();</example>
        </examples>
        <parameters>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.fx.ext-dojo"/>
  <class type="dojox.fx._Complex">
    <methods>
      <method name="makePropObject" scope="instance">
        <parameters>
          <parameter name="beg" type="String" usage="required"/>
          <parameter name="end" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="r" type="Float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getProps" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getNumAndUnits" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="baseFx">
    <methods>
      <method name="animateProperty" scope="instance">
        <description>The standard animation doesn't know what to do with something like
	rect(...). This class identifies complex properties by they being a
	string and having parenthesis. If so, that property is made into a
	dojox.fx._Complex object and the getValue() is obtained from
	there.</description>
        <examples>
          <example>	var ani = dojo.animateProperty({
			node:dojo.byId("myDiv"),
			duration:600,
			properties:{
				clip:{start:'rect(0px 50px 50px 0px)', end:'rect(10px 30px 30px 10px)'}
			}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="fxExt">
    <methods>
      <method name="smoothScroll" scope="instance">
        <description>This implementation support either horizontal or vertical scroll, as well as
	both. In addition, element in iframe can be scrolled to correctly.
	offset: {x: int, y: int} this will be added to the target position
	duration: Duration of the animation in milliseconds.
	win: a node or window object to scroll</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="flipPage" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a page flip effect.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties.</description>
        <examples>
          <example>See `dojox.fx.flip`</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flipGrid" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a page flip effect.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties and
	
	cols: Integer columns
	rows: Integer rows
	
	duration: the single flip duration</description>
        <examples>
          <example>See `dojox.fx.flip`</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flipCube" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a more 3d-like rotation.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties.</description>
        <examples>
          <example>See `dojox.fx.flip`</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flip" scope="instance">
        <description>Returns an animation that will flip the
	node around a central axis:
	if args.dir is "left" or "right" --&gt; y axis
	if args.dir is "top" or "bottom" --&gt; x axis
	
	This effect is obtained using a border distorsion applied to a helper node.
	
	The user can specify three background colors for the helper node:
	darkColor: the darkest color reached during the animation
	lightColor: the brightest color
	endColor: the final backgroundColor for the node
	
	depth: Float
	0 &lt;= depth &lt;= 1 overrides the computed "depth"
	(0: min distorsion, 1: max distorsion)
	
	whichAnim: String
	"first"			 : the first half animation
	"last"			 : the second one
	"both" (default) : both
	
	axis: String
	"center" (default)	  : the node is flipped around his center
	"shortside"			  : the node is flipped around his "short" (in perspective) side
	"longside"			  : the node is flipped around his "long" (in perspective) side
	"cube"				  : the node flips around the central axis of the cube
	
	shift: Integer
	node translation, perpendicular to the rotation axis</description>
        <examples>
          <example>	var anim = dojox.fx.flip({
			node: dojo.byId("nodeId"),
			dir: "top",
			darkColor: "#555555",
			lightColor: "#dddddd",
			endColor: "#666666",
			depth: .5,
			shift: 50,
			duration:300
		  });</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gantt">
    <methods>
      <method name="contextMenuTab" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="description" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="showOInfo" type="Object" usage="required"/>
          <parameter name="tabMenu" type="Object" usage="required"/>
          <parameter name="withDefaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="TabMenu" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GanttTaskItem" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GanttTaskControl" scope="instance">
        <parameters>
          <parameter name="taskInfo" type="Object" usage="required"/>
          <parameter name="project" type="Object" usage="required"/>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GanttResourceItem" scope="instance">
        <parameters>
          <parameter name="ganttchart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GanttProjectItem" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GanttProjectControl" scope="instance">
        <parameters>
          <parameter name="ganttChart" type="Object" usage="required"/>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GanttChart" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gantt.GanttChart">
    <methods>
      <method name="switchTeleMicroView" scope="instance">
        <parameters>
          <parameter name="dip" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortTasksByStartTime" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortTaskStartTime" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortProjStartDate" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortChildTasks" scope="instance">
        <parameters>
          <parameter name="parenttask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartTimeChild" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPreviousTaskInTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPreviousTask" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saveJSONData" scope="instance">
        <parameters>
          <parameter name="fileName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeCell" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshParams" scope="instance">
        <parameters>
          <parameter name="pixelsPerDay" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshController" scope="instance"/>
      <method name="refresh" scope="instance">
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="current" type="Object" usage="required"/>
          <parameter name="multi" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postLoadData" scope="instance"/>
      <method name="postBindEvents" scope="instance"/>
      <method name="openTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openNode" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadJSONString" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadJSONData" scope="instance">
        <parameters>
          <parameter name="filename" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertProject" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="startDate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="incHeightPanelTasks" scope="instance">
        <parameters>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="incHeightPanelNames" scope="instance">
        <parameters>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidthOnDuration" scope="instance">
        <parameters>
          <parameter name="duration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStartDate" scope="instance"/>
      <method name="getProjectItemById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getProject" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPosOnDate" scope="instance">
        <parameters>
          <parameter name="startTime" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastCloseParent" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getJSONData" scope="instance"/>
      <method name="getCountDays" scope="instance"/>
      <method name="getChildTasksData" scope="instance">
        <parameters>
          <parameter name="childTasks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteProject" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTasks" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createPanelTime" scope="instance"/>
      <method name="createPanelTasks" scope="instance"/>
      <method name="createPanelNamesTasksHeader" scope="instance"/>
      <method name="createPanelNamesTasks" scope="instance"/>
      <method name="createChildItemControls" scope="instance">
        <parameters>
          <parameter name="arrChildTasks" type="Object" usage="required"/>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="correctPosPreviousTask" scope="instance">
        <parameters>
          <parameter name="predTask" type="Object" usage="required"/>
          <parameter name="ctask" type="Object" usage="required"/>
          <parameter name="ctaskObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="correctPosParentTask" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="ctask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearItems" scope="instance"/>
      <method name="clearEvents" scope="instance"/>
      <method name="clearData" scope="instance"/>
      <method name="clearAll" scope="instance"/>
      <method name="checkPosition" scope="instance"/>
      <method name="checkPosPreviousTask" scope="instance">
        <parameters>
          <parameter name="predTask" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosParentTaskInTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosParentTask" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkHeighPanelTasks" scope="instance"/>
      <method name="buildUIContent" scope="instance"/>
      <method name="buildChildTasksData" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="childTaskItems" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustPanelTime" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addYearInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addWeekInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="week" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addProject" scope="instance">
        <parameters>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addMonthInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="month" type="Object" usage="required"/>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addHourInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addDayInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="panelNames" scope="instance-prototype" type="Object"/>
      <property name="contentData" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild.firstChild">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild.firstChild.style"/>
  <class type="dojox.gantt.GanttChart.contentData.firstChild.style"/>
  <class type="dojox.gantt.GanttChart.contentData">
    <methods>
      <method name="onscroll" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gantt.GanttChart.panelNames"/>
  <class type="dojox.gantt.GanttChart.panelNames.firstChild.style"/>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild">
    <properties>
      <property name="style" scope="instance" type="Object"/>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild.style"/>
  <class type="dojox.gantt.GanttProjectControl">
    <methods>
      <method name="showDescrProject" scope="instance"/>
      <method name="shiftTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftProjectItem" scope="instance"/>
      <method name="shiftProject" scope="instance">
        <parameters>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftNextProject" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftNextParentTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftDescrProject" scope="instance"/>
      <method name="shiftChildTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPercentCompleted" scope="instance">
        <parameters>
          <parameter name="percentage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setName" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="searchTaskInTree" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resizeProjectItem" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshProjectItem" scope="instance">
        <parameters>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshDescrProject" scope="instance">
        <parameters>
          <parameter name="divDesc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="postLoadData" scope="instance"/>
      <method name="insertTask" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="startTime" type="Object" usage="required"/>
          <parameter name="duration" type="Object" usage="required"/>
          <parameter name="percentage" type="Object" usage="required"/>
          <parameter name="previousTaskId" type="Object" usage="required"/>
          <parameter name="taskOwner" type="Object" usage="required"/>
          <parameter name="parentTaskId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hideDescrProject" scope="instance"/>
      <method name="getTaskById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPercentCompleted" scope="instance"/>
      <method name="getDuration" scope="instance"/>
      <method name="getDescStr" scope="instance"/>
      <method name="deleteTask" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createProjectNameItem" scope="instance"/>
      <method name="createProjectItem" scope="instance"/>
      <method name="createDescrProject" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="ganttChart" type="Object" usage="required"/>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkWidthProjectNameItem" scope="instance"/>
      <method name="adjustPanelTime" scope="instance"/>
    </methods>
    <properties>
      <property name="projectNameItem" scope="instance-prototype" type="Object"/>
      <property name="projectItem" scope="instance-prototype" type="Object"/>
      <property name="project" scope="instance" type="Object"/>
      <property name="ganttChart" scope="instance" type="Object"/>
      <property name="descrProject" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectNameItem">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.descrProject.style"/>
  <class type="dojox.gantt.GanttProjectControl.ganttChart.contentData"/>
  <class type="dojox.gantt.GanttProjectControl.ganttChart.panelNames"/>
  <class type="dojox.gantt.GanttProjectControl.project"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.style"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.style"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild">
    <properties>
      <property name="style" scope="instance" type="Object"/>
      <property name="rows" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.0.firstChild.style"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.1.firstChild.style"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.lastChild.firstChild"/>
  <class type="dojox.gantt.GanttProjectControl.descrProject">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells">
    <properties>
      <property name="1" scope="instance" type="Object"/>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.0"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.1"/>
  <class type="dojox.gantt.GanttProjectControl.ganttChart">
    <properties>
      <property name="panelNames" scope="instance" type="Object"/>
      <property name="contentData" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectNameItem.style"/>
  <class type="dojox.gantt.GanttProjectItem">
    <methods>
      <method name="getTaskByIdInTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTaskById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteTask" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gantt.GanttResourceItem">
    <methods>
      <method name="styleOwnerItem" scope="instance">
        <parameters>
          <parameter name="tItem" type="Object" usage="required"/>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="displayType" type="Object" usage="required"/>
          <parameter name="topOffset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshTaskItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshOwnerItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshOwnerEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshDetailedTaskEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="reConstruct" scope="instance"/>
      <method name="postAdjustment" scope="instance"/>
      <method name="createTreeImg" scope="instance">
        <parameters>
          <parameter name="ownerNameItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTaskNameItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTaskItem" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createPanelOwners" scope="instance"/>
      <method name="createPanelNamesOwners" scope="instance"/>
      <method name="createOwnerNameItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOwnerItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOwnerEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createDetailedTaskEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="parentNode" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createConnectingLinesPN" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Object" usage="required"/>
          <parameter name="currentNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="ganttchart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearItems" scope="instance"/>
      <method name="clearData" scope="instance"/>
      <method name="clearAll" scope="instance"/>
      <method name="checkWidthTaskNameItem" scope="instance">
        <parameters>
          <parameter name="taskNameItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildResource" scope="instance"/>
      <method name="buildOwnerTimeConsume" scope="instance"/>
    </methods>
    <properties>
      <property name="contentData" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.contentData.firstChild.style"/>
  <class type="dojox.gantt.GanttResourceItem.contentData.style"/>
  <class type="dojox.gantt.GanttResourceItem.contentData">
    <methods>
      <method name="onscroll" scope="instance"/>
    </methods>
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.panelNames.firstChild.style"/>
  <class type="dojox.gantt.GanttTaskControl">
    <methods>
      <method name="startResize" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startMove" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showDescTask" scope="instance"/>
      <method name="showChildTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="isOpen" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftNextTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftCurrentTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTaskOwner" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartTime" scope="instance">
        <parameters>
          <parameter name="startTime" type="Object" usage="required"/>
          <parameter name="shiftChild" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPreviousTask" scope="instance">
        <parameters>
          <parameter name="previousTaskId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPercentCompleted" scope="instance">
        <parameters>
          <parameter name="percentage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setName" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDuration" scope="instance">
        <parameters>
          <parameter name="duration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resizeTaskItem" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resizeItem" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshTaskItem" scope="instance">
        <parameters>
          <parameter name="itemControl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshTaskDesc" scope="instance">
        <parameters>
          <parameter name="divDesc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshConnectingLinesDS" scope="instance">
        <parameters>
          <parameter name="arrLines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="postLoadData" scope="instance"/>
      <method name="objKeyToStr" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="delm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveTaskItem" scope="instance">
        <parameters>
          <parameter name="posX" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveItem" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveDescTask" scope="instance"/>
      <method name="moveCurrentTaskItem" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="moveChild" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveChildTaskItems" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="moveChild" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hideDescTask" scope="instance"/>
      <method name="hideChildTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTaskOwner" scope="instance"/>
      <method name="getResizeInfo" scope="instance"/>
      <method name="getMoveInfo" scope="instance"/>
      <method name="getMaxPosPredChildTaskItemInTree" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMaxPosPredChildTaskItem" scope="instance"/>
      <method name="getDateOnPosition" scope="instance">
        <parameters>
          <parameter name="position" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endResizeItem" scope="instance"/>
      <method name="endMove" scope="instance"/>
      <method name="createTreeImg" scope="instance"/>
      <method name="createTaskNameItem" scope="instance"/>
      <method name="createTaskItem" scope="instance"/>
      <method name="createTaskDescItem" scope="instance"/>
      <method name="createConnectingLinesPN" scope="instance"/>
      <method name="createConnectingLinesDS" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="taskInfo" type="Object" usage="required"/>
          <parameter name="project" type="Object" usage="required"/>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearPredTask" scope="instance"/>
      <method name="checkWidthTaskNameItem" scope="instance"/>
      <method name="checkPosition" scope="instance"/>
      <method name="checkPos" scope="instance">
        <parameters>
          <parameter name="startTime" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildResourceInfo" scope="instance">
        <parameters>
          <parameter name="resourceInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustPanelTime" scope="instance"/>
    </methods>
    <properties>
      <property name="taskItem" scope="instance-prototype" type="Object"/>
      <property name="previousParentTask" scope="instance-prototype" type="Object"/>
      <property name="previousChildTask" scope="instance-prototype" type="Object"/>
      <property name="predTask" scope="instance-prototype" type="Object"/>
      <property name="descrTask" scope="instance-prototype" type="Object"/>
      <property name="cTaskNameItem" scope="instance-prototype" type="Object"/>
      <property name="cTaskItem" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskNameItem">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.parentTask.cTaskNameItem"/>
  <class type="dojox.gantt.GanttTaskControl.ganttChart.contentData"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.1.firstChild.rows.0.cells.0"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.style"/>
  <class type="dojox.gantt.GanttTaskControl.taskItem"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.1.2.style"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.1.1.style"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells">
    <properties>
      <property name="1" scope="instance" type="Object"/>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.0.firstChild.style"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.1.firstChild.style"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild">
    <properties>
      <property name="rows" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.1.firstChild"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.2.childNodes.0.style"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.2.childNodes.1.style"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0">
    <properties>
      <property name="style" scope="instance" type="Object"/>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.descrTask.style"/>
  <class type="dojox.gantt.GanttTaskControl.descrTask">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskNameItem.0">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.ganttChart.panelNames"/>
  <class type="dojox.gantt.GanttTaskControl.previousParentTask"/>
  <class type="dojox.gantt.GanttTaskControl.previousChildTask"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskNameItem.0.style"/>
  <class type="dojox.gantt.GanttTaskControl.predTask"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.0"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.1"/>
  <class type="dojox.gantt.GanttTaskItem">
    <methods>
      <method name="setProject" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gantt.TabMenu">
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="createTabPanel" scope="instance"/>
      <method name="createTab" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="desc" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="showOInfo" type="Object" usage="required"/>
          <parameter name="menu" type="Object" usage="required"/>
          <parameter name="withDefaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createMenuPanel" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="buildContent" scope="instance"/>
      <method name="addItemMenuPanel" scope="instance">
        <parameters>
          <parameter name="tab" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tabPanelDlg" scope="instance-prototype" type="Object"/>
      <property name="paneContentArea" scope="instance-prototype" type="Object"/>
      <property name="menuPanel" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.menuPanel.firstChild"/>
  <class type="dojox.gantt.TabMenu.tabPanelDlg.closeButtonNode.style"/>
  <class type="dojox.gantt.TabMenu.tabPanelDlg"/>
  <class type="dojox.gantt.TabMenu.paneContentArea"/>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.0.cells">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.0.cells.0"/>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.1.cells">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.1.cells.0"/>
  <class type="dojox.gantt.TabMenu.menuPanel.style"/>
  <class type="dojox.gantt.TabMenu.menuPanel">
    <properties>
      <property name="style" scope="instance" type="Object"/>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab">
    <methods>
      <method name="show" scope="instance"/>
      <method name="renameTaskAction" scope="instance"/>
      <method name="renameProjectAction" scope="instance"/>
      <method name="ptUpdateAction" scope="instance"/>
      <method name="preValueValidation" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ownerUpdateAction" scope="instance"/>
      <method name="insertData" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="encodeDate" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="durationUpdateAction" scope="instance"/>
      <method name="deleteProjectAction" scope="instance"/>
      <method name="deleteAction" scope="instance"/>
      <method name="decodeDate" scope="instance">
        <parameters>
          <parameter name="dateStr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cpUpdateAction" scope="instance"/>
      <method name="cpProjectAction" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="description" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="showOInfo" type="Object" usage="required"/>
          <parameter name="tabMenu" type="Object" usage="required"/>
          <parameter name="withDefaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTaskAction" scope="instance"/>
      <method name="addSuccessorTaskAction" scope="instance"/>
      <method name="addProjectAction" scope="instance"/>
      <method name="addItem" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="required" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChildTaskAction" scope="instance"/>
      <method name="addAction" scope="instance">
        <parameters>
          <parameter name="handler" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tabMenu" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.0.control.textbox"/>
  <class type="dojox.gantt.contextMenuTab.arrItems.1.control.textbox"/>
  <class type="dojox.gantt.contextMenuTab.arrItems.3.control.textbox"/>
  <class type="dojox.gantt.contextMenuTab.arrItems.4.control.textbox"/>
  <class type="dojox.gantt.contextMenuTab.arrItems.5.control.textbox"/>
  <class type="dojox.gantt.contextMenuTab.arrItems.6.control.textbox"/>
  <class type="dojox.gantt.contextMenuTab.arrItems.7.control.textbox"/>
  <class type="dojox.gantt.contextMenuTab.object">
    <properties>
      <property name="taskItem" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.object.taskItem"/>
  <class type="dojox.gantt.contextMenuTab.tabMenu">
    <properties>
      <property name="ok" scope="instance" type="Object"/>
      <property name="cancel" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.tabPanelDlg.titleNode"/>
  <class type="dojox.gantt.contextMenuTab.tabMenu.paneContentArea.firstChild.rows.1.cells.0"/>
  <class type="dojox.gantt.contextMenuTab.tabMenu.ok"/>
  <class type="dojox.gantt.contextMenuTab.tabMenu.cancel"/>
  <class type="dojox.gantt.contextMenuTab.tabMenu.paneContentArea.firstChild.rows.1.cells">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gauges">
    <methods>
      <method name="_Indicator" scope="instance">
        <description>An indicator widget, which has given properties.  drawn by a gauge.</description>
        <examples>
          <example>	&lt;script type="text/javascript"&gt;
			require(["dojox/gauges/AnalogGauge","dojox/gauges/Indicator"]);
		&lt;/script&gt;
		...
		&lt;div	dojoType="dojox.gauges.AnalogGauge"
				id="testGauge"
				width="300"
				height="200"
				cx=150
				cy=175
				radius=125
				image="gaugeOverlay.png"
				imageOverlay="false"
				imageWidth="280"
				imageHeight="155"
				imageX="12"
				imageY="38"&gt;
			&lt;div 	dojoType="dojox.gauges.Indicator"
					value=17
					type="arrow"
					length=135
					width=3
					hover="Value: 17"
					onDragMove="handleDragMove"&gt;
			&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="_Gauge" scope="instance">
        <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format.
	This widget is not to be used alone. it is meant to be subclassed, such as
	dojox.gauges.BarGauge or dojox.gauges.AnalogGauge</description>
      </method>
      <method name="TextIndicator" scope="instance"/>
      <method name="Range" scope="instance">
        <description>a range widget, which has given properties.  drawn by a _Gauge.</description>
        <examples>
          <example>	&lt;script type="text/javascript"&gt;
			require(["dojox/gauges/AnalogGauge"]);
		&lt;/script&gt;
		...
		&lt;div	dojoType="dojox.gauges.AnalogGauge"
				id="testGauge"
				width="300"
				height="200"
				cx=150
				cy=175
				radius=125
				image="gaugeOverlay.png"
				imageOverlay="false"
				imageWidth="280"
				imageHeight="155"
				imageX="12"
				imageY="38"&gt;
			&lt;div	dojoType="dojox.gauges.Range"
					low=5
					high=10
					hover="5 - 10"
			&gt;&lt;/div&gt;
			&lt;div	dojoType="dojox.gauges.Range"
					low=10
					high=20
					hover="10 - 20"
			&gt;&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="GlossySemiCircularGauge" scope="instance">
        <examples>
          <example>	&lt;div	dojoType="dojox.gauges.GlossySemiCircularGauge"
			id="testGauge"
			width="300"
			height="300"
			min="0"
			max="100"
			value="0"
			majorTicksInterval="10"
			majorTicksColor="#c4c4c4"
			minorTicksInterval="5"
			minorTicksColor="#c4c4c4"
			color="black"
			needleColor="#c4c4c4"
			font="normal normal normal 10pt sans-serif"
			textIndicatorFont="normal normal normal 20pt sans-serif"
			textIndicatorVisible="true"
			textIndicatorColor="#c4c4c4"
			majorTicksLabelPlacement="inside"|"outside"
			noChange="true"
			title="title"
			scalePrecision="0"
			textIndicatorPrecision="0"
		&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="GlossyHorizontalGaugeMarker" scope="instance">
        <description>This object defines the marker for the dojox.gauges.GlossyHorizontalGauge.
	Since the needle is created by the gauges class, you do not have to use this class directly.</description>
      </method>
      <method name="GlossyHorizontalGauge" scope="instance">
        <examples>
          <example>	&lt;div dojoType="dojox.gauges.GlossyHorizontalGauge"
			id="testGauge"
			width="500"
			height="100"
			min="0"
			max="100"
			value="0"
			majorTicksInterval="10"
			majorTicksColor="#c4c4c4"
			minorTicksInterval="5"
			minorTicksColor="#c4c4c4"
			color="black"
			markerColor="#c4c4c4"
			font="normal normal normal 10pt sans-serif"
			noChange="true"
			title="title"
			scalePrecision="0"
		&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="GlossyCircularGaugeNeedle" scope="instance">
        <description>This object defines the needle for the dojox.gauges.GlossyCircularGauge and
	dojox.gauges.GlossySemiCircularGauge.
	Since the needle is created by the gauges class, you do not have to use this class directly.</description>
      </method>
      <method name="GlossyCircularGaugeBase" scope="instance"/>
      <method name="GlossyCircularGauge" scope="instance">
        <examples>
          <example>	&lt;div	dojoType="dojox.gauges.GlossyCircularGauge"
			id="testGauge"
			width="300"
			height="300"
			min="0"
			max="100"
			value="0"
			majorTicksInterval="10"
			majorTicksColor="#c4c4c4"
			minorTicksInterval="5"
			minorTicksColor="#c4c4c4"
			color="black"
			needleColor="#c4c4c4"
			font="normal normal normal 10pt sans-serif"
			textIndicatorFont="normal normal normal 20pt sans-serif"
			textIndicatorVisible="true"
			textIndicatorColor="#c4c4c4"
			majorTicksLabelPlacement="inside"|"outside"
			noChange="true"
			title="title"
			scalePrecision="0"
			textIndicatorPrecision="0"&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="BarLineIndicator" scope="instance"/>
      <method name="BarIndicator" scope="instance"/>
      <method name="BarGauge" scope="instance">
        <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a bar graph component, used to display numerical data in a familiar format.
	
	usage:
	&lt;script type="text/javascript"&gt;
	require(["dojox/gauges/BarGauge"]);
	&lt;/script&gt;
	...
	&lt;div 	dojoType="dojox.gauges.BarGauge"
	id="testBarGauge"
	barGaugeHeight="55"
	dataY="25"
	dataHeight="25"
	dataWidth="225"&gt;
	&lt;/div&gt;</description>
      </method>
      <method name="BarCircleIndicator" scope="instance"/>
      <method name="AnalogNeedleIndicator" scope="instance"/>
      <method name="AnalogLineIndicator" scope="instance"/>
      <method name="AnalogIndicatorBase" scope="instance"/>
      <method name="AnalogGauge" scope="instance">
        <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format</description>
        <examples>
          <example>	&lt;script type="text/javascript"&gt;
			require(["dojox/gauges/AnalogGauge"]);
		&lt;/script&gt;
	
		&lt;div	dojoType="dojox.gauges.AnalogGauge"
				id="testGauge"
				width="300"
				height="200"
				cx=150
				cy=175
				radius=125
				image="gaugeOverlay.png"
				imageOverlay="false"
				imageWidth="280"
				imageHeight="155"
				imageX="12"
				imageY="38"&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="AnalogCircleIndicator" scope="instance"/>
      <method name="AnalogArrowIndicator" scope="instance"/>
      <method name="AnalogArcIndicator" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gauges.AnalogArcIndicator" superclass="dojox.gauges.AnalogIndicatorBase">
    <methods>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_createArc" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.AnalogIndicatorBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="_gauge" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gauges.AnalogArcIndicator._gauge"/>
  <class type="dojox.gauges.AnalogIndicatorBase" superclass="dojox.gauges._indicator">
    <methods>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required">
            <description>The GFX group when the indicator must be drawn</description>
          </parameter>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (vs. the default of doing an animation)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (vs. the default of doing an animation)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_layoutLabel" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
          <parameter name="txt" type="Object" usage="required"/>
          <parameter name="ox" type="Object" usage="required"/>
          <parameter name="oy" type="Object" usage="required"/>
          <parameter name="lrad" type="Object" usage="required"/>
          <parameter name="angle" type="Object" usage="required"/>
          <parameter name="labelPlacement" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_distance" scope="instance">
        <parameters>
          <parameter name="x1" type="Object" usage="required"/>
          <parameter name="y1" type="Object" usage="required"/>
          <parameter name="x2" type="Object" usage="required"/>
          <parameter name="y2" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges._indicator" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.AnalogArrowIndicator" superclass="dojox.gauges.AnalogIndicatorBase">
    <methods>
      <method name="_getShapes" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.AnalogIndicatorBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.AnalogCircleIndicator" superclass="dojox.gauges.AnalogIndicatorBase">
    <methods>
      <method name="_getShapes" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.AnalogIndicatorBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.AnalogGauge" superclass="dojox.gauges._Gauge">
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="getRangeUnderMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The event object as received by the mouse handling functions below.</description>
          </parameter>
        </parameters>
      </method>
      <method name="drawRange" scope="instance">
        <description>Draws a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required">
            <description>The GFX group where the range must be drawn.</description>
          </parameter>
          <parameter name="range" type="Object" usage="required">
            <description>A range is a dojox.gauges.Range or an object
	with similar parameters (low, high, hover, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_mod360" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isScaleCircular" scope="instance"/>
      <method name="_getValueForAngle" scope="instance">
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>A angle to be converted to a value for this gauge.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getRadians" scope="instance">
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>An angle, in degrees, to be converted to radians.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getDegrees" scope="instance">
        <parameters>
          <parameter name="radians" type="Number" usage="required">
            <description>An angle, in radians, to be converted to degrees.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getAngleRange" scope="instance"/>
      <method name="_getAngle" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>A value to be converted to an angle for this gauge.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dragIndicatorAt" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dragIndicator" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_angleInRange" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges._Gauge" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges._Gauge" superclass="dijit._Widget">
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format.
	This widget is not to be used alone. it is meant to be subclassed, such as
	dojox.gauges.BarGauge or dojox.gauges.AnalogGauge</description>
    <methods>
      <method name="updateTooltip" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <description>The text to put in the tooltip.</description>
          </parameter>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="setMinorTicks" scope="instance">
        <parameters>
          <parameter name="ticks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMajorTicks" scope="instance">
        <parameters>
          <parameter name="ticks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setBackground" scope="instance">
        <description>Sets the background using the given object.  Must be the same 'type' of object
	as the original background argument.</description>
        <parameters>
          <parameter name="background" type="Object" usage="required">
            <description>An object in one of the two forms:
	{'color': 'color-name'}
	OR
	(for a gradient:)
	{'type': 'linear', 'colors': [{offset: 0, color:'#C0C0C0'}, {offset: 1, color: '#E0E0E0'}] }
	If background is null or undefined, this will set the fill to this._backgroundDefault</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeText" scope="instance">
        <parameters>
          <parameter name="t" type="String" usage="required">
            <description>The text to remove.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeIndicator" scope="instance">
        <parameters>
          <parameter name="indicator" type="Object" usage="required">
            <description>dojox.gauges._Indicator The indicator to remove.</description>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="moveIndicatorToFront" scope="instance">
        <parameters>
          <parameter name="indicator" type="Object" usage="required">
            <description>dojox.gauges._Indicator A dojox.gauges._Indicator or an object with similar parameters
	(value, color, offset, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasChildren" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="handleTouchStartIndicator" scope="instance">
        <parameters>
          <parameter name="indicator" type="_Indicator" usage="required">
            <description>The indicator object</description>
          </parameter>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleTouchStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The touch event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleTouchMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The touch event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleTouchEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The touch e object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="drawText" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required">
            <description>The GFX Group where the text will be added.</description>
          </parameter>
          <parameter name="txt" type="String" usage="required">
            <description>The text to be drawn</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>The x coordinate at which to place the text</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>The y coordinate at which to place the text
	align?:	String
	Indicates how to align the text
	Valid value is 'right', otherwise text is left-aligned
	color?:	String
	Indicates the color of the text
	font?:	Object
	A font object, generally of the following format:
	{family: &amp;quot;Helvetica&amp;quot;, style: &amp;quot;italic&amp;quot;, variant: 'small-caps', weight: 'bold', size: &amp;quot;18pt&amp;quot;}</description>
          </parameter>
          <parameter name="align" type="String" usage="optional"/>
          <parameter name="color" type="String" usage="optional"/>
          <parameter name="font" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="drawForeground" scope="instance">
        <description>The method may be used by subclasses to draw (or redraw) the foreground of the gauge.</description>
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="drawBackground" scope="instance">
        <description>The method may be used by subclasses to draw (or redraw) the background of the gauge.</description>
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <description>Draws the gauge by drawing the surface, the ranges, and the indicators.</description>
      </method>
      <method name="createSurface" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="addRanges" scope="instance">
        <description>Creates a range (colored area on the background of the gauge)
	based on the given arguments.
	range: Range
	A range is either a dojox.gauges.Range object, or a object
	with similar parameters (low, high, hover, etc.).</description>
        <parameters>
          <parameter name="ranges" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="addRange" scope="instance">
        <description>Creates a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required">
            <description>A range is either a dojox.gauges.Range object, or a object
	with similar parameters (low, high, hover, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="addIndicator" scope="instance">
        <description>This method adds an indicator, such as a t needle,
	to the gauge.</description>
        <parameters>
          <parameter name="indicator" type="Object" usage="required">
            <description>dojox.gauges._Indicator A dojox.gauges._Indicator or an object with similar parameters
	(value, color, offset, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTicks" scope="instance">
        <parameters>
          <parameter name="oldTicks" type="Object" usage="required"/>
          <parameter name="newTicks" type="Object" usage="required"/>
          <parameter name="major" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_removeScaleTick" scope="instance">
        <parameters>
          <parameter name="indicator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isScaleCircular" scope="instance"/>
      <method name="_hideTooltip" scope="instance"/>
      <method name="_handleMouseOverRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleMouseOverIndicator" scope="instance">
        <parameters>
          <parameter name="indicator" type="_Indicator" usage="required">
            <description>The indicator object</description>
          </parameter>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleMouseOutRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleMouseOutIndicator" scope="instance">
        <parameters>
          <parameter name="indicator" type="_Indicator" usage="required">
            <description>The indicator object</description>
          </parameter>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleMouseDownIndicator" scope="instance">
        <parameters>
          <parameter name="indicator" type="_Indicator" usage="required">
            <description>The indicator object</description>
          </parameter>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleDragInteractionMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleDragInteractionMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getNumberModule" scope="instance"/>
      <method name="_getInteractiveIndicator" scope="instance"/>
      <method name="_addScaleTick" scope="instance">
        <description>This method adds  a tick mark to the gauge</description>
        <parameters>
          <parameter name="indicator" type="Object" usage="required">
            <description>dojox.gauges._Indicator A dojox.gauges._Indicator or an object with similar parameters
	(value, color, offset, etc.).</description>
          </parameter>
          <parameter name="major" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="_backgroundDefault" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gauges.AnalogLineIndicator" superclass="dojox.gauges.AnalogIndicatorBase">
    <methods>
      <method name="_getShapes" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.AnalogIndicatorBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.AnalogNeedleIndicator" superclass="dojox.gauges.AnalogIndicatorBase">
    <methods>
      <method name="_getShapes" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.AnalogIndicatorBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.BarCircleIndicator" superclass="dojox.gauges.BarLineIndicator">
    <methods>
      <method name="_getShapes" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.BarLineIndicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="_gauge" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gauges.BarCircleIndicator._gauge"/>
  <class type="dojox.gauges.BarLineIndicator" superclass="dojox.gauges._Indicator">
    <methods>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required"/>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (vs. the default of doing an animation)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (vs. the default of doing an animation)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getShapes" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges._Indicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="_gauge" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gauges.BarGauge" superclass="dojox.gauges._Gauge">
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a bar graph component, used to display numerical data in a familiar format.
	
	usage:
	&lt;script type="text/javascript"&gt;
	require(["dojox/gauges/BarGauge"]);
	&lt;/script&gt;
	...
	&lt;div 	dojoType="dojox.gauges.BarGauge"
	id="testBarGauge"
	barGaugeHeight="55"
	dataY="25"
	dataHeight="25"
	dataWidth="225"&gt;
	&lt;/div&gt;</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="getRangeUnderMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The event object as received by the mouse handling functions below.</description>
          </parameter>
        </parameters>
      </method>
      <method name="drawRange" scope="instance">
        <description>Draws a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required">
            <description>The GFX group where the range must be drawn.</description>
          </parameter>
          <parameter name="range" type="Object" usage="required">
            <description>A range is either a dojox.gauges.Range or an object
	with similar parameters (low, high, hover, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueForPosition" scope="instance">
        <parameters>
          <parameter name="pos" type="Number" usage="required">
            <description>A position to be converted to a value.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getPosition" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>A value to be converted to a position for this bar graph.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dragIndicatorAt" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dragIndicator" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges._Gauge" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.BarIndicator" superclass="dojox.gauges.BarLineIndicator">
    <methods>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_getShapes" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createShapes" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.BarLineIndicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="_gauge" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gauges.BarIndicator._gauge"/>
  <class type="dojox.gauges.BarLineIndicator._gauge"/>
  <class type="dojox.gauges._Indicator" superclass="dijit._Widget">
    <description>An indicator widget, which has given properties.  drawn by a gauge.</description>
    <methods>
      <method name="valueChanged" scope="instance"/>
      <method name="update" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="animate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="remove" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onDragMove" scope="instance"/>
      <method name="handleTouchStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (rather than teh default, to animate)</description>
          </parameter>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_updateValue" scope="instance">
        <parameters>
          <parameter name="animate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="valueNode" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="Object">
        <description>The font for the indicator. The font is enerally in a format similar to:
	{family: &amp;quot;Helvetica&amp;quot;, weight: &amp;quot;bold&amp;quot;, style: &amp;quot;italic&amp;quot;, size: &amp;quot;18pt&amp;quot;, rotated: true}</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gauges.GlossyCircularGauge" superclass="dojox.gauges.GlossyCircularGaugeBase">
    <methods>
      <method name="drawForeground" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required">
            <description>The GFX group where the foreground must be drawn</description>
          </parameter>
        </parameters>
      </method>
      <method name="drawBackground" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required">
            <description>The GFX group where the background must be drawn</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.GlossyCircularGaugeBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.GlossyCircularGaugeBase" superclass="dojox.gauges.AnalogGauge">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setMinorTicksOffset" scope="instance">
        <parameters>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMinorTicksLength" scope="instance">
        <parameters>
          <parameter name="length" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMajorTicksOffset" scope="instance">
        <parameters>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMajorTicksLength" scope="instance">
        <parameters>
          <parameter name="length" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onValueChanged" scope="instance"/>
      <method name="getMinorTicksOffset" scope="instance"/>
      <method name="getMinorTicksLength" scope="instance"/>
      <method name="getMajorTicksOffset" scope="instance"/>
      <method name="getMajorTicksLength" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_updateNeedle" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The new value for the gauge.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTitleAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>the title</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTextIndicatorVisibleAttr" scope="instance">
        <parameters>
          <parameter name="value" type="boolean" usage="required">
            <description>true to show the indicator, false to hide.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTextIndicatorPrecisionAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The new value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTextIndicatorFontAttr" scope="instance">
        <parameters>
          <parameter name="font" type="String" usage="required">
            <description>An string representing the font such as 'normal normal normal 10pt Helvetica,Arial,sans-serif'</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTextIndicatorColorAttr" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required">
            <description>The color</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setScalePrecisionAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The new value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setOrientationAttr" scope="instance">
        <parameters>
          <parameter name="orientation" type="String" usage="required">
            <description>Either &amp;quot;clockwise&amp;quot; or &amp;quot;cclockwise&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setNoChangeAttr" scope="instance">
        <parameters>
          <parameter name="value" type="boolean" usage="required">
            <description>true indicates that the gauge's value cannot be changed</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setNeedleColorAttr" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required">
            <description>The color</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setMinorTicksProperty" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinorTicksIntervalAttr" scope="instance">
        <parameters>
          <parameter name="interval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinorTicksColorAttr" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinAttr" scope="instance">
        <parameters>
          <parameter name="min" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMaxAttr" scope="instance">
        <parameters>
          <parameter name="max" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMajorTicksProperty" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMajorTicksLabelPlacementAttr" scope="instance">
        <parameters>
          <parameter name="placement" type="String" usage="required">
            <description>'inside' or 'outside'</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setMajorTicksIntervalAttr" scope="instance">
        <parameters>
          <parameter name="interval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMajorTicksColorAttr" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFontAttr" scope="instance">
        <parameters>
          <parameter name="font" type="String" usage="required">
            <description>An string representing the font such as 'normal normal normal 10pt Helvetica,Arial,sans-serif'</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setColorAttr" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required">
            <description>The color</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.AnalogGauge" scope="instance"/>
    </mixins>
    <properties>
      <property name="_textIndicator" scope="instance" type="dojox.gauges.TextIndicator">
        <description>the text displaying the gauge's value</description>
      </property>
      <property name="_needle" scope="instance" type="dojox.gauges.GlossyCircularGaugeNeedle">
        <description>the needle of this circular gauge</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gauges.GlossyCircularGaugeBase._needle"/>
  <class type="dojox.gauges.GlossyCircularGaugeBase._textIndicator"/>
  <class type="dojox.gauges.GlossyCircularGaugeNeedle" superclass="dojox.gauges.AnalogIndicatorBase">
    <description>This object defines the needle for the dojox.gauges.GlossyCircularGauge and
	dojox.gauges.GlossySemiCircularGauge.
	Since the needle is created by the gauges class, you do not have to use this class directly.</description>
    <methods>
      <method name="_getShapes" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.AnalogIndicatorBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.GlossyHorizontalGauge" superclass="dojox.gauges.BarGauge">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setMinorTicksLength" scope="instance">
        <parameters>
          <parameter name="length" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMajorTicksLength" scope="instance">
        <parameters>
          <parameter name="length" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onValueChanged" scope="instance"/>
      <method name="getMinorTicksLength" scope="instance"/>
      <method name="getMajorTicksLength" scope="instance"/>
      <method name="drawBackground" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required">
            <description>The GFX group where the background must be drawn</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The new value for the gauge.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTitleAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>the title</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setScalePrecisionAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The new value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setNoChangeAttr" scope="instance">
        <parameters>
          <parameter name="value" type="boolean" usage="required">
            <description>true indicates that the gauge's value cannot be changed</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setMinorTicksProperty" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinorTicksIntervalAttr" scope="instance">
        <parameters>
          <parameter name="interval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinorTicksColorAttr" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinAttr" scope="instance">
        <parameters>
          <parameter name="min" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMaxAttr" scope="instance">
        <parameters>
          <parameter name="max" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMarkerColorAttr" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required">
            <description>The color</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setMajorTicksProperty" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMajorTicksIntervalAttr" scope="instance">
        <parameters>
          <parameter name="interval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMajorTicksColorAttr" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFontAttr" scope="instance">
        <parameters>
          <parameter name="font" type="String" usage="required">
            <description>An string representing the font such as 'normal normal normal 10pt Helvetica,Arial,sans-serif'</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setColorAttr" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required">
            <description>The color</description>
          </parameter>
        </parameters>
      </method>
      <method name="_layoutGauge" scope="instance"/>
      <method name="_getTextWidth" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderWidth" scope="instance"/>
      <method name="_formatNumber" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_computeDataRectangle" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.BarGauge" scope="instance"/>
    </mixins>
    <properties>
      <property name="_needle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gauges.GlossyHorizontalGauge._needle"/>
  <class type="dojox.gauges.GlossyHorizontalGaugeMarker" superclass="dojox.gauges.BarLineIndicator">
    <description>This object defines the marker for the dojox.gauges.GlossyHorizontalGauge.
	Since the needle is created by the gauges class, you do not have to use this class directly.</description>
    <methods>
      <method name="_getShapes" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.BarLineIndicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="_gauge" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gauges.GlossyHorizontalGaugeMarker._gauge"/>
  <class type="dojox.gauges.GlossySemiCircularGauge" superclass="dojox.gauges.GlossyCircularGaugeBase">
    <methods>
      <method name="drawForeground" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required">
            <description>The GFX group where the foreground must be drawn</description>
          </parameter>
        </parameters>
      </method>
      <method name="drawBackground" scope="instance">
        <parameters>
          <parameter name="group" type="dojox.gfx.Group" usage="required">
            <description>The GFX group where the background must be drawn</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges.GlossyCircularGaugeBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.Range" superclass="dijit._Widget">
    <description>a range widget, which has given properties.  drawn by a _Gauge.</description>
    <methods>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gauges.TextIndicator" superclass="dojox.gauges._Indicator">
    <methods>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gauges._Indicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="_gauge" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gauges.TextIndicator._gauge"/>
  <class type="dojox.gauges._Gauge._backgroundDefault"/>
  <class type="dojox.gauges._Gauge.gaugeContent.style"/>
  <class type="dojox.gauges._Indicator.font"/>
  <class type="dojox.gauges._Indicator.valueNode"/>
  <class type="dojox.gauges._Indicator._gauge.gaugeContent.style"/>
  <class type="dojox.geo.charting">
    <methods>
      <method name="_Marker" scope="instance">
        <parameters>
          <parameter name="markerData" type="Object" usage="required"/>
          <parameter name="map" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="TouchInteractionSupport" scope="instance">
        <parameters>
          <parameter name="map" type="dojox.geo.charting.Map" usage="required">
            <description>the Map widget this class provides touch navigation for.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="MouseInteractionSupport" scope="instance">
        <parameters>
          <parameter name="map" type="Map" usage="required">
            <description>dojox.geo.charting.Map the Map widget this class provides touch navigation for.</description>
          </parameter>
          <parameter name="options" type="boolean" usage="required">
            <description>object to enable panning and mouse wheel zooming</description>
          </parameter>
        </parameters>
      </method>
      <method name="Map" scope="instance">
        <description>Support rendering Americas, AsiaPacific, ContinentalEurope, EuropeMiddleEastAfrica,
	USStates, WorldCountries, and WorldCountriesMercator by default.</description>
        <examples>
          <example>	var usaMap = new dojox.geo.charting.Map(srcNode, "dojotoolkit/dojox/geo/charting/resources/data/USStates.json");
		&lt;div id="map" style="width:600px;height:400px;"&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="container" type="HTML" usage="required">
            <description>map container html node/id</description>
          </parameter>
          <parameter name="shapeData" type="String" usage="required">
            <description>map shape data json object, or url to json file</description>
          </parameter>
        </parameters>
      </method>
      <method name="KeyboardInteractionSupport" scope="instance">
        <parameters>
          <parameter name="map" type="dojox.geo.charting.Map" usage="required">
            <description>the Map widget this class provides touch navigation for.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Feature" scope="instance">
        <parameters>
          <parameter name="parent" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="shapeData" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.Feature">
    <methods>
      <method name="unsetValue" scope="instance"/>
      <method name="unsetColor" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="a" usage="required">
            <description>number</description>
          </parameter>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="selected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="parent" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="shapeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_zoomOut" scope="instance"/>
      <method name="_zoomIn" scope="instance"/>
      <method name="_setStrokeWith" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFillWith" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onmouseoverHandler" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onmouseoutHandler" scope="instance"/>
      <method name="_onmousemoveHandler" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onclickHandler" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeStrokeWeight" scope="instance">
        <parameters>
          <parameter name="weight" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="mapObj" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.Feature.parent"/>
  <class type="dojox.geo.charting.Feature.mapObj"/>
  <class type="dojox.geo.charting.Feature.shape"/>
  <class type="dojox.geo">
    <properties>
      <property name="openlayers" scope="instance" type="Object"/>
      <property name="charting" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.KeyboardInteractionSupport">
    <methods>
      <method name="onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBlur" scope="instance"/>
      <method name="keydownHandler" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="map" type="dojox.geo.charting.Map" usage="required">
            <description>the Map widget this class provides touch navigation for.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
      <method name="_directTo" scope="instance">
        <parameters>
          <parameter name="up" type="Object" usage="required"/>
          <parameter name="down" type="Object" usage="required"/>
          <parameter name="left" type="Object" usage="required"/>
          <parameter name="right" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_map" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.KeyboardInteractionSupport._map"/>
  <class type="dojox.geo.charting.KeyboardInteractionSupport._map.selectedFeature._center"/>
  <class type="dojox.geo.charting.Map">
    <description>Support rendering Americas, AsiaPacific, ContinentalEurope, EuropeMiddleEastAfrica,
	USStates, WorldCountries, and WorldCountriesMercator by default.</description>
    <methods>
      <method name="setMarkerData" scope="instance">
        <parameters>
          <parameter name="markerFile" type="String" usage="required">
            <description>outside marker data url, handled as json style.
	data format: {&amp;quot;NY&amp;quot;:&amp;quot;New York&amp;quot;,.....}</description>
          </parameter>
        </parameters>
      </method>
      <method name="setMapScaleAt" scope="instance">
        <parameters>
          <parameter name="scale" type="Object" usage="required"/>
          <parameter name="fixedMapX" type="float" usage="required">
            <description>the X coordinate (in map coordinates) of the fixed screen point</description>
          </parameter>
          <parameter name="fixedMapY" type="float" usage="required">
            <description>the Y coordinate (in map coordinates) of the fixed screen point</description>
          </parameter>
          <parameter name="animate" type="boolean" usage="required">
            <description>true if the transform change should be animated</description>
          </parameter>
          <parameter name="onAnimationEnd" type="callback" usage="required">
            <description>function a callback function to be executed when the animation completes (if animate set to true).</description>
          </parameter>
        </parameters>
      </method>
      <method name="setMapScale" scope="instance">
        <parameters>
          <parameter name="scale" type="Object" usage="required"/>
          <parameter name="animate" type="boolean" usage="required">
            <description>true if the transform change should be animated</description>
          </parameter>
          <parameter name="onAnimationEnd" type="callback" usage="required">
            <description>function a callback function to be executed when the animation completes (if animate set to true).</description>
          </parameter>
        </parameters>
      </method>
      <method name="setMapCenterAndScale" scope="instance">
        <parameters>
          <parameter name="centerX" type="float" usage="required">
            <description>the X coordinate (in map coordinates) of the new center</description>
          </parameter>
          <parameter name="centerY" type="float" usage="required">
            <description>the Y coordinate (in map coordinates) of the new center</description>
          </parameter>
          <parameter name="scale" type="float" usage="required">
            <description>the scale of the map</description>
          </parameter>
          <parameter name="animate" type="boolean" usage="required">
            <description>true if the transform change should be animated</description>
          </parameter>
          <parameter name="onAnimationEnd" type="callback" usage="required">
            <description>function a callback function to be executed when the animation completes (if animate set to true).</description>
          </parameter>
        </parameters>
      </method>
      <method name="setMapCenter" scope="instance">
        <parameters>
          <parameter name="centerX" type="float" usage="required">
            <description>the X coordinate (in map coordinates) of the new center</description>
          </parameter>
          <parameter name="centerY" type="float" usage="required">
            <description>the Y coordinate (in map coordinates) of the new center</description>
          </parameter>
          <parameter name="animate" type="boolean" usage="required">
            <description>true if the transform change should be animated</description>
          </parameter>
          <parameter name="onAnimationEnd" type="callback" usage="required">
            <description>function a callback function to be executed when the animation completes (if animate set to true).</description>
          </parameter>
        </parameters>
      </method>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="ItemFileReadStore" usage="required">
            <description>the dataStore to fetch the information from</description>
          </parameter>
          <parameter name="dataBindingProp" type="String" usage="required">
            <description>sets the property name of the dataStore items to use as value</description>
          </parameter>
        </parameters>
      </method>
      <method name="setDataBindingValueFunction" scope="instance">
        <parameters>
          <parameter name="valueFunction" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="setDataBindingAttribute" scope="instance">
        <parameters>
          <parameter name="prop" type="String" usage="required">
            <description>the property</description>
          </parameter>
        </parameters>
      </method>
      <method name="screenCoordsToMapCoords" scope="instance">
        <parameters>
          <parameter name="screenX" type="Object" usage="required"/>
          <parameter name="screenY" type="Object" usage="required"/>
        </parameters>
        <return-description>x:,y:}
	the map coordinates corresponding to the specified screen coordinates.</return-description>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="adjustMapCenter" type="*boolean*" usage="required">
            <description>boolean keeps the center of the map when resizing the surface</description>
          </parameter>
          <parameter name="adjustMapScale" type="boolean" usage="required">
            <description>adjusts the map scale to keep the visible portion of the map as much as possible</description>
          </parameter>
          <parameter name="animate" type="*boolean*" usage="required"/>
        </parameters>
      </method>
      <method name="onZoomEnd" scope="instance">
        <parameters>
          <parameter name="feature" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFeatureOver" scope="instance">
        <parameters>
          <parameter name="feature" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFeatureClick" scope="instance">
        <parameters>
          <parameter name="feature" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mapCoordsToScreenCoords" scope="instance">
        <parameters>
          <parameter name="mapX" type="Object" usage="required"/>
          <parameter name="mapY" type="Object" usage="required"/>
        </parameters>
        <return-description>x:,y:}
	the screen coordinates correspondig to the specified map coordinates.</return-description>
      </method>
      <method name="getMapScale" scope="instance">
        <return-description>float
	the scale</return-description>
      </method>
      <method name="getMapCenter" scope="instance">
        <return-description>x:,y:}
	the center in map coordinates</return-description>
      </method>
      <method name="fitToMapContents" scope="instance">
        <parameters>
          <parameter name="pixelMargin" type="int" usage="required">
            <description>a margin (in pixels) from the borders of the Map component.</description>
          </parameter>
          <parameter name="animate" type="boolean" usage="required">
            <description>true if the transform change should be animated</description>
          </parameter>
          <parameter name="onAnimationEnd" type="callback" usage="required">
            <description>function a callback function to be executed when the animation completes (if animate set to true).</description>
          </parameter>
        </parameters>
      </method>
      <method name="fitToMapArea" scope="instance">
        <parameters>
          <parameter name="mapArea" type="bbox" usage="required">
            <description>the map area that needs to fill the component</description>
          </parameter>
          <parameter name="pixelMargin" type="int" usage="required">
            <description>a margin (in pixels) from the borders of the Map component.</description>
          </parameter>
          <parameter name="animate" type="boolean" usage="required">
            <description>true if the transform change should be animated</description>
          </parameter>
          <parameter name="onAnimationEnd" type="callback" usage="required">
            <description>function a callback function to be executed when the animation completes (if animate set to true).</description>
          </parameter>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="container" type="HTML" usage="required">
            <description>map container html node/id</description>
          </parameter>
          <parameter name="shapeData" type="String" usage="required">
            <description>map shape data json object, or url to json file</description>
          </parameter>
        </parameters>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="series" type="url" usage="required">
            <description>array of range objects such as : [{name:'label 1', min:20, max:70, color:'#DDDDDD'},{...},...]</description>
          </parameter>
        </parameters>
      </method>
      <method name="_queryDataStore" scope="instance"/>
      <method name="_onSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="newItem" type="Object" usage="required"/>
          <parameter name="parentItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isMobileDevice" scope="instance"/>
      <method name="_init" scope="instance">
        <parameters>
          <parameter name="shapeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getContainerBounds" scope="instance"/>
      <method name="_createZoomingCursor" scope="instance"/>
      <method name="_createAnimation" scope="instance">
        <parameters>
          <parameter name="onShape" type="Object" usage="required"/>
          <parameter name="fromTransform" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>the start transformation (when animation begins)</description>
          </parameter>
          <parameter name="toTransform" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>the end transormation (when animation ends)</description>
          </parameter>
          <parameter name="onAnimationEnd" type="callback" usage="required">
            <description>function callback function to be executed when the animation completes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_appendMarker" scope="instance">
        <parameters>
          <parameter name="markerData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addSeriesImpl" scope="instance">
        <parameters>
          <parameter name="series" type="Json" usage="required">
            <description>object</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="mapObj" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.Map.mapObj.marker"/>
  <class type="dojox.geo.charting.Map.mapObj">
    <properties>
      <property name="marker" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.MouseInteractionSupport">
    <methods>
      <method name="setEnableZoom" scope="instance">
        <parameters>
          <parameter name="enable" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEnablePan" scope="instance">
        <parameters>
          <parameter name="enable" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="map" type="Map" usage="required">
            <description>dojox.geo.charting.Map the Map widget this class provides touch navigation for.</description>
          </parameter>
          <parameter name="options" type="boolean" usage="required">
            <description>object to enable panning and mouse wheel zooming</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
      <method name="_mouseWheelHandler" scope="instance">
        <parameters>
          <parameter name="mouseEvent" type="the" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_mouseUpHandler" scope="instance">
        <parameters>
          <parameter name="mouseEvent" type="the" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_mouseUpClickHandler" scope="instance">
        <parameters>
          <parameter name="mouseEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseMoveHandler" scope="instance">
        <parameters>
          <parameter name="mouseEvent" type="the" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_mouseDragHandler" scope="instance">
        <parameters>
          <parameter name="mouseEvent" type="the" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_mouseDownHandler" scope="instance">
        <parameters>
          <parameter name="mouseEvent" type="the" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_mouseClickHandler" scope="instance">
        <parameters>
          <parameter name="mouseEvent" type="the" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getFeatureFromMouseEvent" scope="instance">
        <parameters>
          <parameter name="mouseEvent" type="the" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
        <return-description>dojox.geo.charting.Feature
	the feature found if any, null otherwise.</return-description>
      </method>
    </methods>
    <properties>
      <property name="_screenClickLocation" scope="instance-prototype" type="Object"/>
      <property name="_mapClickLocation" scope="instance-prototype" type="Object"/>
      <property name="_map" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.MouseInteractionSupport._map"/>
  <class type="dojox.geo.charting.MouseInteractionSupport._screenClickLocation"/>
  <class type="dojox.geo.charting.MouseInteractionSupport._mapClickLocation"/>
  <class type="dojox.geo.charting.MouseInteractionSupport._map.mapObj.marker"/>
  <class type="dojox.geo.charting.TouchInteractionSupport">
    <methods>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="map" type="dojox.geo.charting.Map" usage="required">
            <description>the Map widget this class provides touch navigation for.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
      <method name="_touchStartHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_touchMoveHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_touchEndTapHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_touchEndHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_singleTapHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isDoubleTap" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
        <return-description>boolean
	true if this event is considered a double tap</return-description>
      </method>
      <method name="_getTouchBarycenter" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
        <return-description>dojox.gfx.Point
	the midpoint</return-description>
      </method>
      <method name="_getFingerSpacing" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
        <return-description>float
	a distance. -1 if less that 2 fingers</return-description>
      </method>
      <method name="_getFeatureFromTouchEvent" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
        <return-description>dojox.geo.charting.Feature
	the feature found if any, null otherwise.</return-description>
      </method>
      <method name="_doubleTapHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="a" usage="required">
            <description>touch event</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_lastTap" scope="instance-prototype" type="Object"/>
      <property name="_centerTouchLocation" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.TouchInteractionSupport._lastTap"/>
  <class type="dojox.geo.charting.TouchInteractionSupport._centerTouchLocation"/>
  <class type="dojox.geo.charting._Marker">
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="featureId" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="markerData" type="Object" usage="required"/>
          <parameter name="map" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toWindowCoords" scope="instance">
        <parameters>
          <parameter name="arround" type="Object" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="containerSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getGroupBoundingBox" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.geo.charting.widget">
    <methods>
      <method name="Map" scope="instance">
        <description>The `dojox.geo.charting.widget.Map` widget combines map display together with charting capabilities.
	It encapsulates  an `dojox.geo.charting.Map` object on which most operations are delegated.
	Parameters can be passed as argument at construction time to specify map data file (json shape format)
	as well as charting data.
	
	The parameters are :
	
	* `shapeData`: The json object containing map data or the name of the file containing map data.
	* `dataStore`: the dataStore to fetch the charting data from
	* `dataBindingAttribute`: property name of the dataStore items to use as value for charting
	* `markerData`: tooltips to display for map features, handled as json style.
	* `adjustMapCenterOnResize`: if true, the center of the map remains the same when resizing the widget
	* `adjustMapScaleOnResize`: if true, the map scale is adjusted to leave the visible portion of the map identical as much as possible</description>
        <examples>
          <example>	var map = new dojox.geo.charting.widget.Map({
			shapeData : 'map.json',
			adjustMapCenterOnresize : true,
			adjustMapScaleOnresize : true,
		});</example>
        </examples>
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
          <parameter name="div" type="HtmlNode" usage="required"/>
        </parameters>
      </method>
      <method name="Legend" scope="instance">
        <description>This widget basically is a table comprising (icon,string) pairs, describing the color scheme
	used for the map and its associated text descriptions.</description>
        <examples>
          <example>	var legend = new dojox.geo.charting.widget.Legend({
			map: map
		});</example>
        </examples>
      </method>
    </methods>
  </class>
  <class type="dojox.geo.charting.widget.Legend" superclass="Widget">
    <description>This widget basically is a table comprising (icon,string) pairs, describing the color scheme
	used for the map and its associated text descriptions.</description>
    <methods>
      <method name="refresh" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_addLabel" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.geo.charting.widget.Map" superclass="Widget">
    <description>The `dojox.geo.charting.widget.Map` widget combines map display together with charting capabilities.
	It encapsulates  an `dojox.geo.charting.Map` object on which most operations are delegated.
	Parameters can be passed as argument at construction time to specify map data file (json shape format)
	as well as charting data.
	
	The parameters are :
	
	* `shapeData`: The json object containing map data or the name of the file containing map data.
	* `dataStore`: the dataStore to fetch the charting data from
	* `dataBindingAttribute`: property name of the dataStore items to use as value for charting
	* `markerData`: tooltips to display for map features, handled as json style.
	* `adjustMapCenterOnResize`: if true, the center of the map remains the same when resizing the widget
	* `adjustMapScaleOnResize`: if true, the map scale is adjusted to leave the visible portion of the map identical as much as possible</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <description>Resize the domNode and the widget to the dimensions of a box of the following form:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	box:
	If passed, denotes the new size of the widget.</description>
        <parameters>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="getInnerMap" scope="instance"/>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="optional"/>
          <parameter name="srcNodeRef" type="DomNode|String" usage="optional"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
          <parameter name="div" type="HtmlNode" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="map" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.widget.Map.map"/>
  <class type="dojox.geo.openlayers">
    <methods>
      <method name="parseDMS" scope="instance">
        <description>Parses the specified string and returns degree minute second or decimal degree.</description>
        <parameters>
          <parameter name="v" type="String" usage="required">
            <description>The string to parse</description>
          </parameter>
          <parameter name="toDecimal" type="Boolean" usage="required">
            <description>Specifies if the result should be returned in decimal degrees or in an array
	containg the degrees, minutes, seconds values.</description>
          </parameter>
        </parameters>
        <return-description>Float | Array
	the parsed value in decimal degrees or an array containing the degrees, minutes, seconds values.</return-description>
      </method>
      <method name="WidgetFeature" scope="instance">
        <description>This class allows to add a widget in a `dojox.geo.openlayers.Layer`.
	Parameters are passed to the constructor. These parameters describe the widget
	and provide geo-localisation of this widget.
	parameters can be:
	* _createWidget_: Function for widget creation. Must return a `dijit._Widget`.
	* _dojoType_: The class of a widget to create;
	* _dijitId_: The digitId of an existing widget.
	* _widget_: An already created widget.
	* _width_: The width of the widget.
	* _height_: The height of the widget.
	* _longitude_: The longitude, in decimal degrees where to place the widget.
	* _latitude_: The latitude, in decimal degrees where to place the widget.
	You must define a least one widget retrieval parameter and the geo-localization parameters.</description>
        <parameters>
          <parameter name="params" type="Object" usage="required">
            <description>The parameters describing the widget.</description>
          </parameter>
        </parameters>
      </method>
      <method name="TouchInteractionSupport" scope="instance">
        <parameters>
          <parameter name="map" type="OpenLayers.Map" usage="required">
            <description>the Map widget this class provides touch navigation for.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Point" scope="instance"/>
      <method name="Map" scope="instance">
        <description>The `dojox.geo.openlayers.Map` object allows to view maps from various map providers.
	It encapsulates  an `OpenLayers.Map` object on which most operations are delegated.
	GFX layers can be added to display GFX georeferenced shapes as well as Dojo widgets.
	Parameters can be passed as argument at construction time to define the base layer
	type and the base layer parameters such as url or options depending on the type
	specified. These parameters can be any of :
	&lt;br /&gt;
	_baseLayerType_: type of the base layer. Can be any of
	
	* `dojox.geo.openlayers.BaseLayerType.OSM`: Open Street Map base layer
	* `dojox.geo.openlayers.BaseLayerType.WMS`: Web Map Service layer
	* `dojox.geo.openlayers.BaseLayerType.GOOGLE`: Google layer
	* `dojox.geo.openlayers.BaseLayerType.VIRTUAL_EARTH`: Virtual Earth layer
	* `dojox.geo.openlayers.BaseLayerType.BING`: Bing layer
	* `dojox.geo.openlayers.BaseLayerType.YAHOO`: Yahoo layer
	* `dojox.geo.openlayers.BaseLayerType.ARCGIS`: ESRI ArgGIS layer
	
	Note that access to commercial server such as Google, Virtual Earth or Yahoo may need specific licencing.
	
	The parameters value also include :
	
	* `baseLayerName`: The name of the base layer.
	* `baseLayerUrl`: Some layer may need an url such as Web Map Server
	* `baseLayerOptions`: Addtional specific options passed to OpensLayers layer,
	such as The list of layer to display, for Web Map Server layer.</description>
        <examples>
          <example>	var map = new dojox.geo.openlayers.widget.Map(div, {
			baseLayerType : dojox.geo.openlayers.BaseLayerType.OSM,
			baseLayerName : 'Open Street Map Layer'
		});</example>
        </examples>
        <parameters>
          <parameter name="div" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Layer" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the layer.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required">
            <description>Options passed to the underlying OpenLayers.Layer object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="JsonImport" scope="instance">
        <description>This class loads JSON formated ShapeFile produced by the JSon Custom Map Converter.
	When loading the JSON file, it calls a iterator function each time a feature is read.
	This iterator function is provided as parameter to the constructor.</description>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GfxLayer" scope="instance">
        <description>A layer class for rendering geometries as dojox.gfx.Shape objects.
	This layer class accepts Features which encapsulates graphic objects to be added to the map.
	All objects should be added to this group.</description>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GeometryFeature" scope="instance">
        <description>This Feature renders a geometry such as a Point or LineString geometry. This Feature
	is responsible for reprojecting the geometry before creating a gfx shape to display it.
	By default the shape created is a circle for a Point geometry and a polyline for a
	LineString geometry. User can change these behavior by overriding the createShape
	method to create the desired shape.</description>
        <examples>
          <example>  var geom = new dojox.geo.openlayers.Point({x:0, y:0});
		var gf = new dojox.geo.openlayers.GeometryFeature(geom);</example>
        </examples>
        <parameters>
          <parameter name="geometry" type="dojox.geo.openlayers.Geometry" usage="required">
            <description>OpenLayer.Geometry The geometry to render.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Geometry" scope="instance">
        <parameters>
          <parameter name="coords" type="x" usage="required">
            <description>y}
	Coordinates of the geometry. {x:&amp;lt;x&amp;gt;, y:&amp;lt;y&amp;gt;} object for a point geometry, array of {x:&amp;lt;x&amp;gt;, y:&amp;lt;y&amp;gt;}
	objects for line string geometry, array of geometries for collection geometry.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Feature" scope="instance"/>
      <method name="Collection" scope="instance">
        <return-description>Array
	The array of geometries defining this collection.</return-description>
      </method>
    </methods>
    <properties>
      <property name="widget" scope="instance" type="Object"/>
      <property name="GreatCircle" scope="instance" type="Object"/>
      <property name="BaseLayerType" scope="instance" type="Object">
        <description>Defines the base layer types to be used at Map construction time or
	with the setBaseLayerType function.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.geo.openlayers.Collection" superclass="dojox.geo.openlayers.Geometry">
    <methods>
      <method name="setGeometries" scope="instance">
        <parameters>
          <parameter name="g" type="Array" usage="required">
            <description>The array of geometries.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getGeometries" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.geo.openlayers.Geometry" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.geo.openlayers.Geometry">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="coords" type="x" usage="required">
            <description>y}
	Coordinates of the geometry. {x:&amp;lt;x&amp;gt;, y:&amp;lt;y&amp;gt;} object for a point geometry, array of {x:&amp;lt;x&amp;gt;, y:&amp;lt;y&amp;gt;}
	objects for line string geometry, array of geometries for collection geometry.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.geo.openlayers.Feature">
    <methods>
      <method name="setCoordinateSystem" scope="instance">
        <parameters>
          <parameter name="cs" type="OpenLayers.Projection" usage="required">
            <description>The coordinate system in which coordinates of this feature are expressed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="remove" scope="instance"/>
      <method name="getLayer" scope="instance">
        <return-description>dojox.geo.openlayers.Layer
	The layer to which this feature belongs.</return-description>
      </method>
      <method name="getCoordinateSystem" scope="instance">
        <return-description>OpenLayers.Projection
	The coordinate system in which coordinates of this feature are expressed.</return-description>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_setLayer" scope="instance">
        <description>Called when the feature is added to the Layer.</description>
        <parameters>
          <parameter name="l" type="dojox.geo.openlayers.Layer" usage="required"/>
        </parameters>
      </method>
      <method name="_getLocalXY" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required">
            <description>Object with x and y fields</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.geo.openlayers.GeometryFeature" superclass="dojox.geo.openlayers.Feature">
    <description>This Feature renders a geometry such as a Point or LineString geometry. This Feature
	is responsible for reprojecting the geometry before creating a gfx shape to display it.
	By default the shape created is a circle for a Point geometry and a polyline for a
	LineString geometry. User can change these behavior by overriding the createShape
	method to create the desired shape.</description>
    <methods>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required">
            <description>The stroke style</description>
          </parameter>
        </parameters>
      </method>
      <method name="setShapeProperties" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required">
            <description>The shape properties to set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required">
            <description>The fill style</description>
          </parameter>
        </parameters>
      </method>
      <method name="renderPoint" scope="instance">
        <parameters>
          <parameter name="g" type="undefined" usage="required">
            <description>| dojox.geo.openlayers.Point
	The geometry to render.</description>
          </parameter>
        </parameters>
      </method>
      <method name="renderLineString" scope="instance">
        <parameters>
          <parameter name="g" type="undefined" usage="required">
            <description>| dojox.geo.openlayers.Geometry
	The geometry to render.</description>
          </parameter>
        </parameters>
      </method>
      <method name="renderCollection" scope="instance">
        <parameters>
          <parameter name="g" type="undefined" usage="required">
            <description>| dojox.geo.openlayers.Geometry
	The geometry to render.</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="g" type="undefined" usage="required">
            <description>|| dojox.geo.openlayer.Geometry
	The geometry to draw</description>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="instance"/>
      <method name="getStroke" scope="instance">
        <return-description>Object
	The stroke style</return-description>
      </method>
      <method name="getShapeProperties" scope="instance">
        <return-description>Object
	The shape properties.</return-description>
      </method>
      <method name="getShape" scope="instance">
        <return-description>Shape
	The shape used to render the geometry.</return-description>
      </method>
      <method name="getFill" scope="instance">
        <return-description>Object
	The fill style</return-description>
      </method>
      <method name="createShape" scope="instance">
        <parameters>
          <parameter name="s" type="Surface" usage="required">
            <description>dojox.gfx.Surface The surface on which the method create the shapes.</description>
          </parameter>
          <parameter name="g" type="dojox.geo.openlayers.Geometry" usage="required">
            <description>The reference geometry</description>
          </parameter>
        </parameters>
        <return-description>dojox.gfx.Shape
	The resulting shape.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="geometry" type="dojox.geo.openlayers.Geometry" usage="required">
            <description>OpenLayer.Geometry The geometry to render.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getPointShape" scope="instance">
        <parameters>
          <parameter name="g" type="dojox.geo.openlayers.Geometry" usage="required"/>
        </parameters>
      </method>
      <method name="_getLineStringShape" scope="instance">
        <parameters>
          <parameter name="g" type="dojox.geo.openlayers.Geometry" usage="required"/>
        </parameters>
      </method>
      <method name="_getCollectionShape" scope="instance">
        <parameters>
          <parameter name="g" type="dojox.geo.openlayers.Geometry" usage="required"/>
        </parameters>
      </method>
      <method name="_createPoint" scope="instance">
        <parameters>
          <parameter name="g" type="dojox.geo.openlayer.Geometry" usage="required"/>
        </parameters>
      </method>
      <method name="_createLineString" scope="instance">
        <parameters>
          <parameter name="g" type="dojox.geo.openlayers.Geometry" usage="required"/>
        </parameters>
      </method>
      <method name="_createCollection" scope="instance">
        <parameters>
          <parameter name="g" type="dojox.geo.openlayers.Geometry" usage="required"/>
        </parameters>
      </method>
      <method name="_applyStyle" scope="instance">
        <parameters>
          <parameter name="g" type="Geometry" usage="required">
            <description>dojox.geo.openlayers.Geometry The geometry.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_applyRecusiveStyle" scope="instance">
        <parameters>
          <parameter name="g" type="dojox.geo.openlayers.Geometry" usage="required">
            <description>The geometry.</description>
          </parameter>
          <parameter name="stroke" type="Object" usage="required">
            <description>The stroke</description>
          </parameter>
          <parameter name="fill" type="Object" usage="required">
            <description>The fill</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.geo.openlayers.Feature" scope="instance"/>
    </mixins>
    <properties>
      <property name="_geometry" scope="instance-prototype" type="Object"/>
      <property name="_defaults" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.openlayers.GeometryFeature._geometry"/>
  <class type="dojox.geo.openlayers.GeometryFeature._defaults">
    <properties>
      <property name="pointShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.openlayers.GeometryFeature._defaults.pointShape"/>
  <class type="dojox.geo.openlayers.GfxLayer" superclass="dojox.geo.openlayers.Layer">
    <description>A layer class for rendering geometries as dojox.gfx.Shape objects.
	This layer class accepts Features which encapsulates graphic objects to be added to the map.
	All objects should be added to this group.</description>
    <methods>
      <method name="setViewport" scope="instance">
        <parameters>
          <parameter name="g" type="dojox.gfx.Group" usage="required"/>
        </parameters>
      </method>
      <method name="setMap" scope="instance">
        <parameters>
          <parameter name="map" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMapResize" scope="instance"/>
      <method name="moveTo" scope="instance">
        <parameters>
          <parameter name="event" type="The" usage="required">
            <description>event</description>
          </parameter>
        </parameters>
      </method>
      <method name="getViewport" scope="instance"/>
      <method name="getSurface" scope="instance">
        <return-description>dojox.gfx.Surface
	The dojox.gfx.Surface this layer uses to draw its GFX rendering.</return-description>
      </method>
      <method name="getDataExtent" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="added" scope="instance"/>
      <method name="_surfaceSize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.geo.openlayers.Layer" scope="instance"/>
    </mixins>
    <properties>
      <property name="olLayer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.openlayers.GfxLayer.olLayer"/>
  <class type="dojox.geo.openlayers.Layer">
    <methods>
      <method name="renderFeature" scope="instance">
        <parameters>
          <parameter name="f" type="Feature" usage="required"/>
        </parameters>
      </method>
      <method name="removeFeatureAt" scope="instance">
        <description>Remove the feature at the specified index.</description>
        <parameters>
          <parameter name="index" type="Number" usage="required">
            <description>The index of the feature to remove.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeFeature" scope="instance">
        <parameters>
          <parameter name="f" type="Feature" usage="required">
            <description>| Array</description>
          </parameter>
        </parameters>
      </method>
      <method name="redraw" scope="instance"/>
      <method name="moveTo" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <description>The event</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-description>Array
	The untouched array of features hold by this layer.</return-description>
      </method>
      <method name="getFeatureCount" scope="instance">
        <return-description>int
	The number of the features contained by this layer.</return-description>
      </method>
      <method name="getFeatureAt" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDojoMap" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the layer.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required">
            <description>Options passed to the underlying OpenLayers.Layer object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="added" scope="instance"/>
      <method name="addFeature" scope="instance">
        <parameters>
          <parameter name="f" type="Feature" usage="required">
            <description>| Array</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.geo.openlayers.GreatCircle">
    <methods>
      <method name="toPointArray" scope="instance">
        <parameters>
          <parameter name="p1" type="Point" usage="required">
            <description>The first point of the geodetic line. x and y fields are longitude and
	latitude in decimal degrees.</description>
          </parameter>
          <parameter name="p2" type="Point" usage="required">
            <description>The second point of the geodetic line. x and y fields are longitude and
	latitude in decimal degrees.</description>
          </parameter>
          <parameter name="increment" type="Float" usage="required">
            <description>The value at which a new point is computed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toLineString" scope="instance">
        <parameters>
          <parameter name="p1" type="Point" usage="required">
            <description>The first point of the geodetic line. x and y fields are longitude and
	latitude in decimal degrees.</description>
          </parameter>
          <parameter name="p2" type="Point" usage="required">
            <description>The second point of the geodetic line. x and y fields are longitude and
	latitude in decimal degrees.</description>
          </parameter>
          <parameter name="increment" type="Float" usage="required">
            <description>The value at which a new point is computed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toGeometryFeature" scope="instance">
        <description>Create a geodetic line as a dojox.geo.openlayers.GeometryFeature between the point p1
	ant the point p2. Result is a polyline approximation for which a new point is
	calculated every &lt;em&gt;increment&lt;/em&gt; degrees.</description>
        <parameters>
          <parameter name="p1" type="Point" usage="required">
            <description>The first point of the geodetic line. x and y fields are longitude and
	latitude in decimal degrees.</description>
          </parameter>
          <parameter name="p2" type="Point" usage="required">
            <description>The second point of the geodetic line. x and y fields are longitude and
	latitude in decimal degrees.</description>
          </parameter>
          <parameter name="increment" type="Float" usage="required">
            <description>The value at which a new point is computed.</description>
          </parameter>
        </parameters>
        <return-description>GeometryFeature
	The geodetic line as a GeometryFeature</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.geo.openlayers.GreatCircle.toPointArray">
    <methods/>
  </class>
  <class type="dojox.geo.openlayers.JsonImport">
    <description>This class loads JSON formated ShapeFile produced by the JSon Custom Map Converter.
	When loading the JSON file, it calls a iterator function each time a feature is read.
	This iterator function is provided as parameter to the constructor.</description>
    <methods>
      <method name="loadData" scope="instance"/>
      <method name="constructor" scope="instance">
        <description>Construct a new JSON importer with the specified parameters. These parameters are
	passed through an Object and include:
	&lt;ul&gt;
	&lt;li&gt; url : &lt;em&gt;url&lt;/em&gt; &lt;/li&gt; The url pointing to the JSON file to load.
	&lt;li&gt; nextFeature : &lt;em&gt;function&lt;/em&gt; &lt;/li&gt; The function called each time a feature is read.
	The function is called with a GeometryFeature as argument.
	&lt;li&gt; error : &lt;em&gt;function&lt;/em&gt; &lt;/li&gt; Error function called if something goes wrong.
	&lt;/ul&gt;</description>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeGeometry" scope="instance">
        <parameters>
          <parameter name="s" type="Array" usage="required"/>
          <parameter name="ulx" type="Float" usage="required"/>
          <parameter name="uly" type="Float" usage="required"/>
          <parameter name="lrx" type="Float" usage="required"/>
          <parameter name="lry" type="Float" usage="required"/>
          <parameter name="ulxLL" type="Float" usage="required"/>
          <parameter name="ulyLL" type="Float" usage="required"/>
          <parameter name="lrxLL" type="Float" usage="required"/>
          <parameter name="lryLL" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_makeFeature" scope="instance">
        <parameters>
          <parameter name="s" type="Array" usage="required"/>
          <parameter name="ulx" type="Float" usage="required"/>
          <parameter name="uly" type="Float" usage="required"/>
          <parameter name="lrx" type="Float" usage="required"/>
          <parameter name="lry" type="Float" usage="required"/>
          <parameter name="ulxLL" type="Float" usage="required"/>
          <parameter name="ulyLL" type="Float" usage="required"/>
          <parameter name="lrxLL" type="Float" usage="required"/>
          <parameter name="lryLL" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_loadError" scope="instance"/>
      <method name="_gotData" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_params" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.openlayers.JsonImport._params"/>
  <class type="dojox.geo.openlayers.Map">
    <description>The `dojox.geo.openlayers.Map` object allows to view maps from various map providers.
	It encapsulates  an `OpenLayers.Map` object on which most operations are delegated.
	GFX layers can be added to display GFX georeferenced shapes as well as Dojo widgets.
	Parameters can be passed as argument at construction time to define the base layer
	type and the base layer parameters such as url or options depending on the type
	specified. These parameters can be any of :
	&lt;br /&gt;
	_baseLayerType_: type of the base layer. Can be any of
	
	* `dojox.geo.openlayers.BaseLayerType.OSM`: Open Street Map base layer
	* `dojox.geo.openlayers.BaseLayerType.WMS`: Web Map Service layer
	* `dojox.geo.openlayers.BaseLayerType.GOOGLE`: Google layer
	* `dojox.geo.openlayers.BaseLayerType.VIRTUAL_EARTH`: Virtual Earth layer
	* `dojox.geo.openlayers.BaseLayerType.BING`: Bing layer
	* `dojox.geo.openlayers.BaseLayerType.YAHOO`: Yahoo layer
	* `dojox.geo.openlayers.BaseLayerType.ARCGIS`: ESRI ArgGIS layer
	
	Note that access to commercial server such as Google, Virtual Earth or Yahoo may need specific licencing.
	
	The parameters value also include :
	
	* `baseLayerName`: The name of the base layer.
	* `baseLayerUrl`: Some layer may need an url such as Web Map Server
	* `baseLayerOptions`: Addtional specific options passed to OpensLayers layer,
	such as The list of layer to display, for Web Map Server layer.</description>
    <methods>
      <method name="transformXY" scope="instance">
        <description>Transforms the coordinates passed as argument. The coordinate are supposed to be expressed
	in the &lt;em&gt;from&lt;/em&gt; coordinate system and are transformed to the map coordinate system.
	x : Number
	The longitude coordinate to transform.
	y : Number
	The latitude coordinate to transform.</description>
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
          <parameter name="from" type="OpenLayers.Projection" usage="required">
            <description>The projection in which the point is expressed.</description>
          </parameter>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="transform" scope="instance">
        <description>Transforms the point passed as argument without modifying it. The point is supposed to be expressed
	in the &lt;em&gt;from&lt;/em&gt; coordinate system and is transformed to the map coordinate system.
	p : Object {x, y}
	The point to transform</description>
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="from" type="OpenLayers.Projection" usage="required">
            <description>The projection in which the point is expressed.</description>
          </parameter>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setBaseLayerType" scope="instance">
        <parameters>
          <parameter name="type" type="dojox.geo.openlayers.Map.BaseLayerType" usage="required">
            <description>dojox.geo.openlayers.BaseLayerType base layer type</description>
          </parameter>
        </parameters>
        <return-description>OpenLayers.Layer
	The newly created layer.</return-description>
      </method>
      <method name="removeLayer" scope="instance">
        <parameters>
          <parameter name="layer" type="dojox.geo.openlayers.Layer" usage="required">
            <description>The layer to remove from the map.</description>
          </parameter>
        </parameters>
      </method>
      <method name="layerIndex" scope="instance">
        <description>Set or get the layer index, that is the z-order of the layer.
	if the index parameter is provided, the layer index is set to
	this value. If the index parameter is not provided, the index of
	the layer is returned.</description>
        <parameters>
          <parameter name="layer" type="dojox.geo.openlayers.Layer" usage="required"/>
          <parameter name="index" type="undefined" usage="required">
            <description>| int
	index of the layer</description>
          </parameter>
        </parameters>
        <return-description>int
	the index of the layer.</return-description>
      </method>
      <method name="initialFit" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getScale" scope="instance">
        <parameters>
          <parameter name="geodesic" type="Boolean" usage="required">
            <description>Tell if geodesic calculation should be performed. If set to
	true, the scale will be calculated based on the horizontal size of the
	pixel in the center of the map viewport.</description>
          </parameter>
        </parameters>
        <return-description>Number
	The current scale.</return-description>
      </method>
      <method name="getOLMap" scope="instance"/>
      <method name="getLayerCount" scope="instance">
        <return-description>int
	The number of layers of this map.</return-description>
      </method>
      <method name="getLayer" scope="instance">
        <examples>
          <example>var layers = map.getLayer("name", "Layer Name");</example>
        </examples>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>The property to check</description>
          </parameter>
          <parameter name="value" type="Object" usage="required">
            <description>The value to match</description>
          </parameter>
        </parameters>
        <return-description>dojox.geo.openlayer.Layer | Array
	The layer(s) matching the property's value. Since multiple layers
	match the property's value the return value is an array.</return-description>
      </method>
      <method name="getBaseLayerType" scope="instance">
        <return-description>dojox.geo.openlayers.BaseLayerType
	The current base layer type.</return-description>
      </method>
      <method name="fitTo" scope="instance">
        <description>Fits the map on the point or extent specified as parameter.</description>
        <examples>
          <example>Examples of arguments passed to the fitTo function :
		null
	The map is fit on full extent
	
		{
		bounds : [ulx, uly, lrx, lry]
		}
	The map is fit on the specified bounds expressed as decimal degrees latitude and longitude.
	The bounds are defined with their upper left and lower right corners coordinates.
	
		{
		position : [longitude, latitude],
		extent : degrees
		}
	The map is fit on the specified position showing the extent &lt;extent&gt; around
	the specified center position.</example>
        </examples>
        <parameters>
          <parameter name="o" type="Object" usage="required">
            <description>Object with key values fit parameters or a JSON string.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="div" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addLayer" scope="instance">
        <parameters>
          <parameter name="layer" type="dojox.geo.openlayers.Layer" usage="required">
            <description>dojox.geo.openlayer.Layer The layer to add to the map.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getLayer" scope="instance">
        <parameters>
          <parameter name="ol" type="OpenLayer.Layer" usage="required"/>
        </parameters>
      </method>
      <method name="_createBaseLayer" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="olMap" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.openlayers.Map.olMap"/>
  <class type="dojox.geo.openlayers.BaseLayerType">
    <description>This object defines the base layer types to be used at Map construction
	time or with the setBaseLayerType function.</description>
  </class>
  <class type="dojox.geo.openlayers.Point" superclass="dojox.geo.openlayers.Geometry">
    <methods>
      <method name="setPoint" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPoint" scope="instance">
        <return-description>x, y} Object
	The point defining this geometry.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.geo.openlayers.Geometry" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.geo.openlayers.TouchInteractionSupport">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="map" type="OpenLayers.Map" usage="required">
            <description>the Map widget this class provides touch navigation for.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_touchStartHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="Event" usage="required">
            <description>a touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_touchMoveHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="Event" usage="required">
            <description>a touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_touchEndHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="Event" usage="required">
            <description>a touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isDoubleTap" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="Event" usage="required">
            <description>a touch event</description>
          </parameter>
        </parameters>
        <return-description>boolean
	true if this event is considered a double tap</return-description>
      </method>
      <method name="_getTouchBarycenter" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="Event" usage="required">
            <description>a touch event</description>
          </parameter>
        </parameters>
        <return-description>dojox.gfx.Point
	the midpoint</return-description>
      </method>
      <method name="_getFingerSpacing" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="Event" usage="required">
            <description>a touch event</description>
          </parameter>
        </parameters>
        <return-description>float
	a distance. -1 if less that 2 fingers</return-description>
      </method>
      <method name="_doubleTapHandler" scope="instance">
        <parameters>
          <parameter name="touchEvent" type="Event" usage="required">
            <description>a touch event</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_map" scope="instance-prototype" type="Object"/>
      <property name="_lastTap" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.openlayers.TouchInteractionSupport._lastTap"/>
  <class type="dojox.geo.openlayers.TouchInteractionSupport._map"/>
  <class type="dojox.geo.openlayers.WidgetFeature" superclass="dojox.geo.openlayers.Feature">
    <description>This class allows to add a widget in a `dojox.geo.openlayers.Layer`.
	Parameters are passed to the constructor. These parameters describe the widget
	and provide geo-localisation of this widget.
	parameters can be:
	* _createWidget_: Function for widget creation. Must return a `dijit._Widget`.
	* _dojoType_: The class of a widget to create;
	* _dijitId_: The digitId of an existing widget.
	* _widget_: An already created widget.
	* _width_: The width of the widget.
	* _height_: The height of the widget.
	* _longitude_: The longitude, in decimal degrees where to place the widget.
	* _latitude_: The latitude, in decimal degrees where to place the widget.
	You must define a least one widget retrieval parameter and the geo-localization parameters.</description>
    <methods>
      <method name="setParameters" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required">
            <description>The parameters describing the widget.</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="remove" scope="instance">
        <description>Remove this feature by disconnecting the widget from the dom.</description>
      </method>
      <method name="getParameters" scope="instance">
        <return-description>Object
	The parameters describing the widget.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required">
            <description>The parameters describing the widget.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateWidgetPosition" scope="instance">
        <parameters>
          <parameter name="box" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getWidgetWidth" scope="instance"/>
      <method name="_getWidgetHeight" scope="instance"/>
      <method name="_getWidget" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.geo.openlayers.Feature" scope="instance"/>
    </mixins>
    <properties>
      <property name="_widget" scope="instance" type="Object"/>
      <property name="_params" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.openlayers.WidgetFeature._params">
    <properties>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.openlayers.WidgetFeature._params.widget"/>
  <class type="dojox.geo.openlayers.WidgetFeature._widget"/>
  <class type="dojox.geo.openlayers.widget">
    <methods>
      <method name="Map" scope="instance">
        <description>Tells if the touch handler should be attached to the map or not.
	Touch handler handles touch events so that the widget can be used
	on mobile applications.</description>
        <examples>
          <example> &lt;div id="map" dojoType="dojox.geo.openlayers.widget.Map" baseLayerType="Google" initialLocation="{
		 position : [7.154126, 43.651748],
		 extent : 0.2 }"
	 style="background-color: #b5d0d0; width: 100%; height: 100%;"&gt;</example>
        </examples>
      </method>
    </methods>
  </class>
  <class type="dojox.geo.openlayers.widget.Map" superclass="dijit.Widget">
    <description>Tells if the touch handler should be attached to the map or not.
	Touch handler handles touch events so that the widget can be used
	on mobile applications.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <description>Resize the domNode and the widget to the dimensions of a box of the following form:
	`{ l: 50, t: 200, w: 300: h: 150 }`</description>
        <parameters>
          <parameter name="b" type="undefined" usage="required">
            <description>| Box | width, height
	If passed, denotes the new size of the widget.
	Can be either nothing (widget adapts to the div),
	a box, or a width and a height.</description>
          </parameter>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_makeLayers" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gesture">
    <methods>
      <method name="tap" scope="instance">
        <examples>
          <example>A. Used with dojo.connect()
		dojo.connect(node, dojox.gesture.tap, function(e){});
		dojo.connect(node, dojox.gesture.tap.hold, function(e){});
		dojo.connect(node, dojox.gesture.tap.doubletap, function(e){});
	
	B. Used with dojo.on
		define(['dojo/on', 'dojox/gesture/tap'], function(on, tap){
			on(node, tap, function(e){});
			on(node, tap.hold, function(e){});
			on(node, tap.doubletap, function(e){});
	
	C. Used with dojox.gesture.tap.* directly
		dojox.gesture.tap(node, function(e){});
		dojox.gesture.tap.hold(node, function(e){});
		dojox.gesture.tap.doubletap(node, function(e){});
	
	Though there is always a default gesture instance after being required, e.g
		require(['dojox/gesture/tap'], function(){...});
	
	It's possible to create a new one with different parameter setting:
		var myTap = new dojox.gesture.tap.Tap({holdThreshold: 300});
		dojo.connect(node, myTap, function(e){});
		dojo.connect(node, myTap.hold, function(e){});
		dojo.connect(node, myTap.doubletap, function(e){});</example>
        </examples>
      </method>
      <method name="swipe" scope="instance">
        <examples>
          <example>A. Used with dojo.connect()
		dojo.connect(node, dojox.gesture.swipe, function(e){});
		dojo.connect(node, dojox.gesture.swipe.end, function(e){});
	
	B. Used with dojo.on
		define(['dojo/on', 'dojox/gesture/swipe'], function(on, swipe){
			on(node, swipe, function(e){});
			on(node, swipe.end, function(e){});
	
	C. Used with dojox.gesture.swipe.* directly
		dojox.gesture.swipe(node, function(e){});
		dojox.gesture.swipe.end(node, function(e){});</example>
        </examples>
      </method>
      <method name="Base" scope="instance">
        <examples>
          <example>1. A typical gesture implementation.
	
	Suppose we have dojox/gesture/a which provides 3 gesture events:"a", "a.x", "a.y" to be used as:
		dojo.connect(node, dojox.gesture.a, function(e){});
		dojo.connect(node, dojox.gesture.a.x, function(e){});
		dojo.connect(node, dojox.gesture.a.y, function(e){});
	
	The definition of the gesture "a" may look like:
		define([..., "./Base"], function(..., Base){
			var clz = declare(Base, {
				defaultEvent: "a",
	
				subEvents: ["x", "y"],
	
				press: function(data, e){
					this.fire(node, {type: "a.x", ...});
				},
				move: function(data, e){
					this.fire(node, {type: "a.y", ...});
				},
				release: function(data, e){
					this.fire(node, {type: "a", ...});
				},
				cancel: function(data, e){
					// clean up
				}
			});
	
			// in order to have a default instance for handy use
			dojox.gesture.a = new clz();
	
			// so that we can create new instances like
			// var mine = new dojox.gesture.a.A({...})
			dojox.gesture.a.A = clz;
	
			return dojox.gesture.a;
		});
	
	2. A gesture can be used in the following ways(taking dojox.gestre.tap for example):
	
	A. Used with dojo.connect()
		dojo.connect(node, dojox.gesture.tap, function(e){});
		dojo.connect(node, dojox.gesture.tap.hold, function(e){});
		dojo.connect(node, dojox.gesture.tap.doubletap, function(e){});
	
	B. Used with dojo.on
		define(["dojo/on", "dojox/gesture/tap"], function(on, tap){
			on(node, tap, function(e){});
			on(node, tap.hold, function(e){});
			on(node, tap.doubletap, function(e){});
	
	C. Used with dojox.gesture.tap directly
		dojox.gesture.tap(node, function(e){});
		dojox.gesture.tap.hold(node, function(e){});
		dojox.gesture.tap.doubletap(node, function(e){});
	
	Though there is always a default gesture instance after being required, e.g
		require(["dojox/gesture/tap"], function(){...});
	
	It's possible to create a new one with different parameter setting:
		var myTap = new dojox.gesture.tap.Tap({holdThreshold: 300});
		dojo.connect(node, myTap, function(e){});
		dojo.connect(node, myTap.hold, function(e){});
		dojo.connect(node, myTap.doubletap, function(e){});
	
	Please refer to dojox/gesture/ for more gesture usages</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gesture.Base">
    <methods>
      <method name="unLock" scope="instance"/>
      <method name="release" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="press" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="lock" scope="instance">
        <parameters>
          <parameter name="node" type="Dom" usage="required"/>
        </parameters>
      </method>
      <method name="isLocked" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="fire" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>Target node to fire the gesture</description>
          </parameter>
          <parameter name="event" type="Object" usage="required">
            <description>An object containing specific gesture info e.g {type: 'tap.hold'|'swipe.left'), ...}
	all these properties will be put into a simulated GestureEvent when fired.
	Note - Default properties in a native Event won't be overwritten, see on.emit() for more details.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="node" type="Dom" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_process" scope="instance">
        <description>1. e._locking is used to make sure only the most inner node
	will be processed for the same gesture, suppose we have:
		on(inner, dojox.gesture.tap, func1);
		on(outer, dojox.gesture.tap, func2);
	only the inner node will be processed by tap gesture, once matched,
	the 'tap' event will be bubbled up from inner to outer, dojo.StopEvent(e)
	can be used at any level to stop the 'tap' event.
	
	2. Once a node starts being processed, all it's descendant nodes will be locked.
	The same gesture won't be processed on its descendant nodes until the lock is released.</description>
        <parameters>
          <parameter name="element" type="Object" usage="required">
            <description>Gesture element</description>
          </parameter>
          <parameter name="phase" type="String" usage="required">
            <description>Phase of a gesture to be processed, might be 'press'|'move'|'release'|'cancel'</description>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <description>Native event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handle" scope="instance">
        <parameters>
          <parameter name="eventType" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getGestureElement" scope="instance">
        <parameters>
          <parameter name="node" type="Dom" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanHandles" scope="instance">
        <parameters>
          <parameter name="handles" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="node" type="Dom" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="listener" type="function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="handle"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gesture.swipe" superclass="Base">
    <methods>
      <method name="release" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="press" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_recognize" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getSwipeInfo" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Base" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gesture.tap" superclass="Base">
    <methods>
      <method name="release" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="press" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_isTap" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_initTap" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Base" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx">
    <description>dojox.gfx is an advanced API providing normalized vector drawing
	in a variety of browsers. It has individual renderers for SVG, VML,
	Canvas, and Silverlight.</description>
    <methods>
      <method name="switchTo" scope="instance">
        <parameters>
          <parameter name="renderer" type="String|Object" usage="required">
            <description>Either the string name of a renderer (eg. 'canvas', 'svg, ...) or the renderer
	object to switch to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="splitFontString" scope="instance">
        <description>Converts a CSS font string to a gfx font object. The CSS font
	string components should follow the W3C specified order
	(see http://www.w3.org/TR/CSS2/fonts.html#font-shorthand):
	style, variant, weight, size, optional line height (will be
	ignored), and family.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a CSS font string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="px_in_pt" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="px2pt" scope="instance">
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pt2px" scope="instance">
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in points</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="normalizedLength" scope="instance">
        <parameters>
          <parameter name="len" type="String" usage="required">
            <description>a length, e.g., '12pc'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="normalizeParameters" scope="instance">
        <parameters>
          <parameter name="existed" type="Object" usage="required">
            <description>the target object to be updated</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the 'update' object, whose properties will be used to update
	the existed object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="normalizeColor" scope="instance">
        <parameters>
          <parameter name="color" type="dojo.Color|Array|string|Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="makeParameters" scope="instance">
        <parameters>
          <parameter name="defaults" type="Object" usage="required">
            <description>the object to be cloned before updating</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the object, which properties are to be cloned during updating</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="makeFontString" scope="instance">
        <parameters>
          <parameter name="font" type="Object" usage="required">
            <description>font object (see dojox.gfx.defaultFont)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getVectorFont" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="formatNumber" scope="instance">
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>number to be converted</description>
          </parameter>
          <parameter name="addSpace" type="Boolean" usage="required">
            <description>whether to add a space before a positive number</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="equalSources" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required">
            <description>first event source</description>
          </parameter>
          <parameter name="b" type="Object" usage="required">
            <description>event source to compare against a</description>
          </parameter>
        </parameters>
      </method>
      <method name="decompose" scope="instance">
        <description>This function decompose a matrix into four logical components:
	translation, rotation, scaling, and one more rotation using SVD.
	The components should be applied in following order:
	 [translate, rotate(angle2), scale, rotate(angle1)]</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix-like object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="createSurface" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="textDir" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_hasClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_addClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="VectorFont" scope="instance">
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="TextPath" scope="instance"/>
      <method name="Text" scope="instance"/>
      <method name="Rectangle" scope="instance">
        <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2, width: 100, height: 200}.</description>
      </method>
      <method name="Point" scope="instance">
        <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2}.</description>
      </method>
      <method name="Mover" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a shape object to be moved</description>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event, which started the move;
	only clientX and clientY properties are used</description>
          </parameter>
          <parameter name="host" type="Object" usage="optional">
            <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
          </parameter>
        </parameters>
      </method>
      <method name="Moveable" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a shape object to be moved</description>
          </parameter>
          <parameter name="params" type="Object" usage="required">
            <description>an optional object with additional parameters;
	following parameters are recognized:</description>
          </parameter>
        </parameters>
      </method>
      <method name="Group" scope="instance"/>
    </methods>
    <properties>
      <property name="vml" scope="instance" type="Object">
        <description>This the default graphics rendering bridge for IE6-7.
	This renderer is very slow.  For best performance on IE6-8, use Silverlight plugin.
	IE9+ defaults to the standard W3C SVG renderer.</description>
      </property>
      <property name="vectorFontFitting" scope="instance" type="Object"/>
      <property name="utils" scope="instance" type="Object"/>
      <property name="svg" scope="instance" type="Object">
        <description>This the graphics rendering bridge for browsers compliant with W3C SVG1.0.
	This is the preferred renderer to use for interactive and accessible graphics.</description>
      </property>
      <property name="silverlight" scope="instance" type="Object">
        <description>This the graphics rendering bridge for the Microsoft Silverlight plugin.
	Silverlight is a faster implementation on IE6-8 than the default 2d graphics, VML</description>
      </property>
      <property name="shape" scope="instance" type="Object">
        <description>This module contains the core graphics Shape API.
	Different graphics renderer implementation modules (svg, canvas, vml, silverlight, etc.) extend this
	basic api to provide renderer-specific implementations for each shape.</description>
      </property>
      <property name="path" scope="instance" type="Object">
        <description>This module contains the core graphics Path API.
	Path command format follows the W3C SVG 1.0 Path api.</description>
      </property>
      <property name="matrix" scope="instance" type="Object">
        <description>class constants, and methods of dojox.gfx.matrix</description>
      </property>
      <property name="gradutils" scope="instance" type="Object"/>
      <property name="gradient" scope="instance" type="Object"/>
      <property name="fx" scope="instance" type="Object"/>
      <property name="defaultVectorText" scope="instance" type="Object"/>
      <property name="defaultVectorFont" scope="instance" type="Object"/>
      <property name="defaultTextPath" scope="instance" type="Object">
        <description>Defines the default TextPath prototype.</description>
      </property>
      <property name="defaultText" scope="instance" type="Object">
        <description>Defines the default Text prototype.</description>
      </property>
      <property name="defaultStroke" scope="instance" type="Object">
        <description>A stroke defines stylistic properties that are used when drawing a path.
	This object defines the default Stroke prototype.</description>
      </property>
      <property name="defaultRect" scope="instance" type="Object">
        <description>Defines the default Rect prototype.</description>
      </property>
      <property name="defaultRadialGradient" scope="instance" type="Object">
        <description>An object specifying the default properties for RadialGradients using in fills patterns.</description>
      </property>
      <property name="defaultPolyline" scope="instance" type="Object">
        <description>Defines the default PolyLine prototype.</description>
      </property>
      <property name="defaultPattern" scope="instance" type="Object">
        <description>An object specifying the default properties for a Pattern using in fill operations.</description>
      </property>
      <property name="defaultPath" scope="instance" type="Object">
        <description>Defines the default Path prototype object.</description>
      </property>
      <property name="defaultLinearGradient" scope="instance" type="Object">
        <description>An object defining the default stylistic properties used for Linear Gradient fills.
	Linear gradients are drawn along a virtual line, which results in appearance of a rotated pattern in a given direction/orientation.</description>
      </property>
      <property name="defaultLine" scope="instance" type="Object">
        <description>An pbject defining the default Line prototype.</description>
      </property>
      <property name="defaultImage" scope="instance" type="Object">
        <description>Defines the default Image prototype.</description>
      </property>
      <property name="defaultFont" scope="instance" type="Object">
        <description>An object specifying the default properties for a Font used in text operations.</description>
      </property>
      <property name="defaultEllipse" scope="instance" type="Object">
        <description>Defines the default Ellipse prototype.</description>
      </property>
      <property name="defaultCircle" scope="instance" type="Object">
        <description>An object defining the default Circle prototype.</description>
      </property>
      <property name="canvasWithEvents" scope="instance" type="Object">
        <description>This the graphics rendering bridge for W3C Canvas compliant browsers which extends
	the basic canvas drawing renderer bridge to add additional support for graphics events
	on Shapes.
	Since Canvas is an immediate mode graphics api, with no object graph or
	eventing capabilities, use of the canvas module alone will only add in drawing support.
	This additional module, canvasWithEvents extends this module with additional support
	for handling events on Canvas.  By default, the support for events is now included
	however, if only drawing capabilities are needed, canvas event module can be disabled
	using the dojoConfig option, canvasEvents:true|false.
	The id of the Canvas renderer is 'canvasWithEvents'.  This id can be used when switch Dojo's
	graphics context between renderer implementations.  See dojox.gfx._base switchRenderer
	API.</description>
      </property>
      <property name="canvas" scope="instance" type="Object">
        <description>This the graphics rendering bridge for W3C Canvas compliant browsers.
	Since Canvas is an immediate mode graphics api, with no object graph or
	eventing capabilities, use of this module alone will only add in drawing support.
	The additional module, canvasWithEvents extends this module with additional support
	for handling events on Canvas.  By default, the support for events is now included
	however, if only drawing capabilities are needed, canvas event module can be disabled
	using the dojoConfig option, canvasEvents:true|false.
	The id of the Canvas renderer is 'canvas'.  This id can be used when switch Dojo's
	graphics context between renderer implementations.  See dojox.gfx._base switchRenderer
	API.</description>
      </property>
      <property name="arc" scope="instance" type="Object">
        <description>This module contains the core graphics Arc functions.</description>
      </property>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Moveable">
    <methods>
      <method name="onMoving" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStart" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a shape object to be moved</description>
          </parameter>
          <parameter name="params" type="Object" usage="required">
            <description>an optional object with additional parameters;
	following parameters are recognized:</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.Mover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a shape object to be moved</description>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event, which started the move;
	only clientX and clientY properties are used</description>
          </parameter>
          <parameter name="host" type="Object" usage="optional">
            <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.vectorFontFitting"/>
  <class type="dojox.gfx.defaultVectorText"/>
  <class type="dojox.gfx.defaultVectorFont"/>
  <class type="dojox.gfx.VectorFont">
    <methods>
      <method name="onLoadBegin" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="font" type="dojox.gfx.VectorFont" usage="required"/>
        </parameters>
      </method>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.VectorFont"/>
        </return-types>
      </method>
      <method name="initialized" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getWidth" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getLineHeight" scope="instance">
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="getCenterline" scope="instance">
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getBaseline" scope="instance">
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="draw" scope="instance">
        <description>The main method of a VectorFont, draw() will take a text fragment
	and render it in a set of groups and paths based on the parameters
	passed.
	
	The basics of drawing text are simple enough: pass it your text as
	part of the textArgs object, pass size and family info as part of
	the fontArgs object, pass at least a color as the fillArgs object,
	and if you are looking to create an outline, pass the strokeArgs
	object as well. fillArgs and strokeArgs are the same as any other
	gfx fill and stroke arguments; they are simply applied to any path
	object generated by this method.
	
	Resulting GFX structure
	-----------------------
	
	The result of this function is a set of gfx objects in the following
	structure:
	
		dojox.gfx.Group 			//	the parent group generated by this function
		+	dojox.gfx.Group[]		//	a group generated for each line of text
			+	dojox.gfx.Path[]	//	each glyph/character in the text
	
	Scaling transformations (i.e. making the generated text the correct size)
	are always applied to the parent Group that is generated (i.e. the top
	node in the above example).  In theory, if you are looking to do any kind
	of other transformations (such as a translation), you should apply it to
	the group reference you pass to this method.  If you find that you need
	to apply transformations to the group that is returned by this method,
	you will need to reapply the scaling transformation as the *last* transform,
	like so:
	
		textGroup.setTransform(new dojox.gfx.Matrix2D([
			dojox.gfx.matrix.translate({ dx: dx, dy: dy }),
			textGroup.getTransform()
		]));
	
	In general, this should never be necessary unless you are doing advanced
	placement of your text.
	
	Advanced Layout Functionality
	-----------------------------
	
	In addition to straight text fragments, draw() supports a few advanced
	operations not normally available with vector graphics:
	
	* Flow operations (i.e. wrap to a given width)
	* Fitting operations (i.e. find a best fit to a given rectangle)
	
	To enable either, pass a `fitting` property along with the textArgs object.
	The possible values are contained in the dojox.gfx.vectorFontFitting enum
	(NONE, FLOW, FIT).
	
	`Flow fitting`
	Flow fitting requires both a passed size (in the fontArgs object) and a
	width (passed with the textArgs object).  draw() will attempt to split the
	passed text up into lines, at the closest whitespace according to the
	passed width.  If a width is missing, it will revert to NONE.
	
	`Best fit fitting`
	Doing a "best fit" means taking the passed text, and finding the largest
	size and line breaks so that it is the closest fit possible.  With best
	fit, any size arguments are ignored; if a height is missing, it will revert
	to NONE.
	
	Other notes
	-----------
	
	`a11y`
	Since the results of this method are rendering using pure paths (think
	"convert to outlines" in Adobe Illustrator), any text rendered by this
	code is NOT considered a11y-friendly.  If a11y is a requirement, we
	suggest using other, more a11y-friendly methods.
	
	`Font sources`
	Always make sure that you are legally allowed to use any fonts that you
	convert to SVG format; we claim no responsibility for any licensing
	infractions that may be caused by the use of this code.</description>
        <parameters>
          <parameter name="group" type="dojox.gfx.Container" usage="required"/>
          <parameter name="textArgs" type="dojox.gfx.__TextArgs" usage="required"/>
          <parameter name="fontArgs" type="dojox.gfx.__FontArgs" usage="required"/>
          <parameter name="fillArgs" type="dojox.gfx.__FillArgs" usage="required"/>
          <parameter name="strokeArgs" type="dojox.gfx.__StrokeArgs" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Group"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="_trim" scope="instance">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_split" scope="instance">
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="nLines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_round" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="svg" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_normalize" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_leading" scope="instance">
        <parameters>
          <parameter name="unit" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getWidth" scope="instance">
        <parameters>
          <parameter name="glyphs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getSizeFactor" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLongestLine" scope="instance">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFitFactor" scope="instance">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
          <parameter name="l" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFlow" scope="instance">
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="scale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFit" scope="instance">
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
          <parameter name="ldng" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decodeEntitySequence" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_clean" scope="instance"/>
    </methods>
    <properties>
      <property name="viewbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.VectorFont.viewbox"/>
  <class type="dojox.gfx.defaultPath"/>
  <class type="dojox.gfx.defaultPolyline"/>
  <class type="dojox.gfx.defaultRect"/>
  <class type="dojox.gfx.defaultEllipse"/>
  <class type="dojox.gfx.defaultCircle"/>
  <class type="dojox.gfx.defaultLine"/>
  <class type="dojox.gfx.defaultImage"/>
  <class type="dojox.gfx.defaultText"/>
  <class type="dojox.gfx.defaultTextPath"/>
  <class type="dojox.gfx.defaultStroke"/>
  <class type="dojox.gfx.defaultLinearGradient"/>
  <class type="dojox.gfx.defaultRadialGradient"/>
  <class type="dojox.gfx.defaultPattern"/>
  <class type="dojox.gfx.defaultFont"/>
  <class type="dojox.gfx._base">
    <methods>
      <method name="_getUniqueId" scope="instance"/>
      <method name="_getTextBox" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
          <parameter name="className" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getFontMeasurements" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getCachedFontMeasurements" scope="instance">
        <parameters>
          <parameter name="recalculate" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.shape">
    <methods>
      <method name="Text" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="Surface" scope="instance"/>
      <method name="Shape" scope="instance"/>
      <method name="Rect" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>The underlying graphics system object (typically a DOM Node)</description>
          </parameter>
        </parameters>
      </method>
      <method name="Polyline" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="Line" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="Image" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="Ellipse" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="Circle" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.shape.Surface">
    <methods>
      <method name="whenLoaded" scope="instance">
        <parameters>
          <parameter name="context" type="Object|Null" usage="required"/>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
      </method>
      <method name="setTextDir" scope="instance">
        <parameters>
          <parameter name="newTextDir" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="surface" type="dojox.gfx.Surface" usage="required"/>
        </parameters>
      </method>
      <method name="getTextDir" scope="instance"/>
      <method name="getEventSource" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_parent" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Group">
    <methods>
      <method name="setTextDir" scope="instance">
        <parameters>
          <parameter name="newTextDir" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getTextDir" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx.Text">
    <methods>
      <method name="formatText" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>the string for manipulation, by default return value.</description>
          </parameter>
          <parameter name="textDir" type="String" usage="required">
            <description>Text direction.
	Can be:
	1. &amp;quot;ltr&amp;quot; - for left to right layout.
	2. &amp;quot;rtl&amp;quot; - for right to left layout
	3. &amp;quot;auto&amp;quot; - for contextual layout: the first strong letter decides the direction.
	discription:
	Finds the right transformation that should be applied on the text, according to renderer.
	Was tested in:
	Renderers (browser for testing):
	canvas (FF, Chrome, Safari),
	vml (IE),
	svg (FF, Chrome, Safari, Opera),
	silverlight (IE, Chrome, Safari, Opera),
	svgWeb(FF, Chrome, Safari, Opera, IE).
	Browsers [browser version that was tested]:
	IE [6,7,8], FF [3.6],
	Chrome (latest for March 2011),
	Safari [5.0.3],
	Opera [11.01].</description>
          </parameter>
        </parameters>
      </method>
      <method name="bidiPreprocess" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.TextPath">
    <methods>
      <method name="formatText" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>the string for manipulation, by default return value.</description>
          </parameter>
          <parameter name="textDir" type="String" usage="required">
            <description>text direction direction.
	Can be:
	1. &amp;quot;ltr&amp;quot; - for left to right layout.
	2. &amp;quot;rtl&amp;quot; - for right to left layout
	3. &amp;quot;auto&amp;quot; - for contextual layout: the first strong letter decides the direction.
	discription:
	Finds the right transformation that should be applied on the text, according to renderer.
	Was tested in:
	Renderers:
	canvas (FF, Chrome, Safari), vml (IE), svg (FF, Chrome, Safari, Opera), silverlight (IE8), svgWeb(FF, Chrome, Safari, Opera, IE).
	Browsers:
	IE [6,7,8], FF [3.6], Chrome (latest for February 2011), Safari [5.0.3], Opera [11.01].</description>
          </parameter>
        </parameters>
      </method>
      <method name="bidiPreprocess" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.TextPath.bidiPreprocess">
    <methods/>
  </class>
  <class type="dojox.gfx.arc">
    <methods>
      <method name="unitArcAsBezier" scope="instance">
        <parameters>
          <parameter name="alpha" type="Number" usage="required">
            <description>angle in radians, the arc will be 2 * angle size</description>
          </parameter>
        </parameters>
      </method>
      <method name="arcAsBezier" scope="instance">
        <parameters>
          <parameter name="last" type="Object" usage="required">
            <description>a point-like object as a start of the arc</description>
          </parameter>
          <parameter name="rx" type="Number" usage="required">
            <description>a horizontal radius for the virtual ellipse</description>
          </parameter>
          <parameter name="ry" type="Number" usage="required">
            <description>a vertical radius for the virtual ellipse</description>
          </parameter>
          <parameter name="xRotg" type="Number" usage="required">
            <description>a rotation of an x axis of the virtual ellipse in degrees</description>
          </parameter>
          <parameter name="large" type="Boolean" usage="required">
            <description>which part of the ellipse will be used (the larger arc if true)</description>
          </parameter>
          <parameter name="sweep" type="Boolean" usage="required">
            <description>direction of the arc (CW if true)</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>the x coordinate of the end point of the arc</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>the y coordinate of the end point of the arc</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.canvas">
    <methods>
      <method name="TextPath" scope="instance"/>
      <method name="Text" scope="instance"/>
      <method name="Surface" scope="instance"/>
      <method name="Shape" scope="instance"/>
      <method name="Rect" scope="instance"/>
      <method name="Polyline" scope="instance"/>
      <method name="Path" scope="instance"/>
      <method name="Line" scope="instance"/>
      <method name="Image" scope="instance"/>
      <method name="Group" scope="instance"/>
      <method name="Ellipse" scope="instance"/>
      <method name="Circle" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx.canvas.Shape" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="getEventSource" scope="instance"/>
      <method name="disconnect" scope="instance"/>
      <method name="connect" scope="instance"/>
      <method name="_renderTransform" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStroke" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderFill" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_render" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="canvasFillImage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Shape.fillStyle"/>
  <class type="dojox.gfx.canvas.Shape.canvasFillImage"/>
  <class type="dojox.gfx.canvas.Group" superclass="canvas.Shape">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_render" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Rect" superclass="canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Rect.shape"/>
  <class type="dojox.gfx.canvas.Ellipse" superclass="canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Circle" superclass="canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Line" superclass="canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Polyline" superclass="canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Polyline.shape">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Polyline.shape.points"/>
  <class type="dojox.gfx.canvas.Image" superclass="canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Text" superclass="canvas.Shape">
    <methods>
      <method name="getTextWidth" scope="instance"/>
      <method name="_setFont" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_render" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Path" superclass="canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_vLineToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_closePath" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_arcTo" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="pathLib.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
      <mixin type="pathLib.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="lastControl" scope="instance-prototype" type="Object"/>
      <property name="last" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Path.last"/>
  <class type="dojox.gfx.canvas.Path.lastControl"/>
  <class type="dojox.gfx.canvas.TextPath" superclass="canvas.Shape">
    <methods>
      <method name="_setText" scope="instance"/>
      <method name="_setFont" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="pathLib.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
      <mixin type="pathLib.TextPath" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Surface" superclass="dojox.gfx.shape.Surface">
    <methods>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="onImageLoad" scope="instance"/>
      <method name="makeDirty" scope="instance"/>
      <method name="getEventSource" scope="instance"/>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="downloadImage" scope="instance">
        <parameters>
          <parameter name="img" type="Image" usage="required">
            <description>the image object</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>the url of the image</description>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="connect" scope="instance"/>
      <method name="_render" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Surface.rawNode"/>
  <class type="pathLib"/>
  <class type="dojox.gfx.shape.Shape">
    <methods>
      <method name="setTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)
	COULD BE RE-IMPLEMENTED BY THE RENDERER!</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)
	COULD BE RE-IMPLEMENTED BY THE RENDERER!</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required">
            <description>a shape object
	(see dojox.gfx.defaultPath,
	dojox.gfx.defaultPolyline,
	dojox.gfx.defaultRect,
	dojox.gfx.defaultEllipse,
	dojox.gfx.defaultCircle,
	dojox.gfx.defaultLine,
	or dojox.gfx.defaultImage)
	COULD BE RE-IMPLEMENTED BY THE RENDERER!</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)
	COULD BE RE-IMPLEMENTED BY THE RENDERER!</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="removeShape" scope="instance">
        <parameters>
          <parameter name="silently" type="Boolean" usage="required">
            <description>if true, do not redraw a picture yet</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToFront" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToBack" scope="instance"/>
      <method name="getUID" scope="instance"/>
      <method name="getTransformedBoundingBox" scope="instance">
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getTransform" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="getStroke" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getShape" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getParent" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getNode" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="getFill" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getEventSource" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="applyTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyRightTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateParentMatrix" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a 2D matrix or a matrix-like object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setParent" scope="instance">
        <parameters>
          <parameter name="parent" type="Object" usage="required">
            <description>a parent or null
	(see dojox.gfx.Surface,
	dojox.gfx.shape.VirtualGroup,
	or dojox.gfx.Group)</description>
          </parameter>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a 2D matrix or a matrix-like object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToFront" scope="instance"/>
      <method name="_moveToBack" scope="instance"/>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.shape.Rect" superclass="shape.Shape">
    <methods>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>The underlying graphics system object (typically a DOM Node)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="shape.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.shape.Ellipse" superclass="shape.Shape">
    <methods>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="shape.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.shape.Circle" superclass="shape.Shape">
    <methods>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="shape.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.shape.Line" superclass="shape.Shape">
    <methods>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="shape.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.shape.Image" superclass="shape.Shape">
    <methods>
      <method name="setStroke" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="shape.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.shape.Text" superclass="shape.Shape">
    <methods>
      <method name="setFont" scope="instance">
        <parameters>
          <parameter name="newFont" type="Object" usage="required">
            <description>a font object (see dojox.gfx.defaultFont) or a font string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getFont" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="shape.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="m"/>
  <class type="dojox.gfx.canvasWithEvents">
    <methods>
      <method name="TextPath" scope="instance"/>
      <method name="Text" scope="instance"/>
      <method name="Surface" scope="instance"/>
      <method name="Shape" scope="instance"/>
      <method name="Rect" scope="instance"/>
      <method name="Polyline" scope="instance"/>
      <method name="Path" scope="instance"/>
      <method name="Line" scope="instance"/>
      <method name="Image" scope="instance"/>
      <method name="Group" scope="instance"/>
      <method name="Ellipse" scope="instance"/>
      <method name="Circle" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Shape" superclass="canvas.Shape">
    <methods>
      <method name="touchstart" scope="instance"/>
      <method name="touchmove" scope="instance"/>
      <method name="touchend" scope="instance"/>
      <method name="ontouchstart" scope="instance"/>
      <method name="ontouchmove" scope="instance"/>
      <method name="ontouchend" scope="instance"/>
      <method name="onmouseup" scope="instance"/>
      <method name="onmouseover" scope="instance"/>
      <method name="onmouseout" scope="instance"/>
      <method name="onmousemove" scope="instance"/>
      <method name="onmouseleave" scope="instance"/>
      <method name="onmouseenter" scope="instance"/>
      <method name="onmousedown" scope="instance"/>
      <method name="onkeyup" scope="instance"/>
      <method name="onkeydown" scope="instance"/>
      <method name="ondblclick" scope="instance"/>
      <method name="oncontextmenu" scope="instance"/>
      <method name="onclick" scope="instance"/>
      <method name="getEventSource" scope="instance"/>
      <method name="disconnect" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_testInputs" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="pos" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStroke" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required">
            <description>a canvas context object</description>
          </parameter>
          <parameter name="apply" type="Boolean" usage="required">
            <description>whether ctx.stroke() shall be called</description>
          </parameter>
        </parameters>
      </method>
      <method name="_renderFill" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required">
            <description>a canvas context object</description>
          </parameter>
          <parameter name="apply" type="Boolean" usage="required">
            <description>whether ctx.fill() shall be called</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hitTestPixel" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="pos" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_hitTestGeometry" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="canvas.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="strokeStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Shape.strokeStyle"/>
  <class type="dojox.gfx.canvasWithEvents.Group" superclass="canvasEvent.Shape">
    <methods>
      <method name="_testInputs" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="pos" type="Array" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="canvas.Group.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.Group" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Image" superclass="canvasEvent.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required">
            <description>a canvas context object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hitTestGeometry" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="canvas.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.Image" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Text" superclass="canvasEvent.Shape">
    <methods>
      <method name="_testInputs" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="canvas.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.Text" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Rect" superclass="canvasEvent.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="canvas.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.Rect" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Circle" superclass="canvasEvent.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="canvas.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.Circle" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Ellipse" superclass="canvasEvent.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="canvas.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.Ellipse" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Line" superclass="canvasEvent.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="canvas.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.Line" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Polyline" superclass="canvasEvent.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="canvas.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.Polyline" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Path" superclass="canvasEvent.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="canvas.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.Path" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.TextPath" superclass="canvasEvent.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="canvas.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="canvasEvent.Shape" scope="instance"/>
      <mixin type="canvas.TextPath" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Surface" superclass="canvas.Surface">
    <methods>
      <method name="getEventSource" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="object" type="Object" usage="required">
            <description>The object that method will receive as &amp;quot;this&amp;quot;.</description>
          </parameter>
          <parameter name="method" type="Function|String" usage="required">
            <description>Function A function reference, or name of a function in context.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_whatsUnderEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="mouse" usage="required">
            <description>event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setupEvents" scope="instance">
        <parameters>
          <parameter name="eventName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ontouchstartImpl_" scope="instance"/>
      <method name="_ontouchstart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ontouchmoveImpl_" scope="instance"/>
      <method name="_ontouchmove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ontouchendImpl_" scope="instance"/>
      <method name="_ontouchend" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onmouseup" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onmousemove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onmousedown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onkeyup" scope="instance"/>
      <method name="_onkeydown" scope="instance"/>
      <method name="_ondblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_oncontextmenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_invokeHandler" scope="instance">
        <parameters>
          <parameter name="base" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initMirrorCanvas" scope="instance"/>
      <method name="_fireTouchEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="canvas.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="_eventsH" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvasWithEvents.Surface._eventsH"/>
  <class type="canvas">
    <methods>
      <method name="attachSurface" scope="instance"/>
      <method name="attachNode" scope="instance">
        <return-types>
          <return-type type="for now"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="canvasEvent"/>
  <class type="dojox.gfx.fx">
    <methods>
      <method name="animateTransform" scope="instance">
        <examples>
          <example>	dojox.gfx.fx.animateTransform{{
			shape: shape,
			duration: 500,
			transform: [
				{name: "translate", start: [0, 0], end: [200, 200]},
				{name: "original"}
			]
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateStroke" scope="instance">
        <examples>
          <example>	dojox.gfx.fx.animateStroke{{
			shape: shape,
			duration: 500,
			color: {start: "red", end: "green"},
			width: {end: 15},
			join:  {values: ["miter", "bevel", "round"]}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateFont" scope="instance">
        <examples>
          <example>	dojox.gfx.fx.animateFont{{
			shape: shape,
			duration: 500,
			variant: {values: ["normal", "small-caps"]},
			size:  {end: 10, units: "pt"}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateFill" scope="instance">
        <examples>
          <example>	dojox.gfx.fx.animateFill{{
			shape: shape,
			duration: 500,
			color: {start: "red", end: "green"}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.gradient">
    <methods>
      <method name="rescale" scope="instance">
        <parameters>
          <parameter name="stops" type="Array" usage="required">
            <description>input gradient as a list of colors with offsets
	(see dojox.gfx.defaultLinearGradient and dojox.gfx.defaultRadialGradient)</description>
          </parameter>
          <parameter name="from" type="Number" usage="required">
            <description>the beginning of the window, should be less than &amp;quot;to&amp;quot;</description>
          </parameter>
          <parameter name="to" type="Number" usage="required">
            <description>the end of the window, should be more than &amp;quot;from&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="project" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D|Null" usage="required">
            <description>matrix to apply to a shape and its gradient</description>
          </parameter>
          <parameter name="gradient" type="Object" usage="required">
            <description>a linear gradient object to be transformed</description>
          </parameter>
          <parameter name="tl" type="dojox.gfx.Point" usage="required">
            <description>top-left corner of shape's bounding box</description>
          </parameter>
          <parameter name="rb" type="dojox.gfx.Point" usage="required">
            <description>right-bottom corner of shape's bounding box</description>
          </parameter>
          <parameter name="ttl" type="dojox.gfx.Point" usage="required">
            <description>top-left corner of shape's transformed bounding box</description>
          </parameter>
          <parameter name="trb" type="dojox.gfx.Point" usage="required">
            <description>right-bottom corner of shape's transformed bounding box</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.gradutils">
    <methods>
      <method name="reverse" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>fill object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getColor" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>fill object</description>
          </parameter>
          <parameter name="pt" type="dojox.gfx.Point" usage="required">
            <description>point where to sample a color</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.matrix">
    <methods>
      <method name="translate" scope="instance">
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>an x coordinate value</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y coordinate value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYgAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewYg().</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>Number: an skewing angle in degrees</description>
          </parameter>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="optional">
            <description>Number: a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYg" scope="instance">
        <description>The resulting matrix is used to skew points in the y dimension
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.skewY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an skewing angle in degrees</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewY().</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an skewing angle in radians</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewY" scope="instance">
        <description>The resulting matrix is used to skew points in the y dimension
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an skewing angle in radians</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXgAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewXg().</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an skewing angle in degrees</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXg" scope="instance">
        <description>The resulting matrix is used to skew points in the x dimension
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.skewX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an skewing angle in degrees</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewX().</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an skewing angle in radians</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewX" scope="instance">
        <description>The resulting matrix is used to skew points in the x dimension
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an skewing angle in radians</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="scaleAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.scale().</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>a scaling factor used for the x coordinate</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a scaling factor used for the y coordinate</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="d" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <description>The resulting matrix is used to scale (magnify) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>a scaling factor used for the x coordinate</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a scaling factor used for the y coordinate</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotategAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.rotateg().</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotateg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.rotate() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotateAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.rotate().</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotate" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="reflect" scope="instance">
        <description>The resulting matrix is used to reflect points around a vector,
	which goes through the origin.</description>
        <parameters>
          <parameter name="a" type="dojox.gfx.Point" usage="required">
            <description>a point-like object, which specifies a vector of reflection</description>
          </parameter>
          <parameter name="b" type="null" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="project" scope="instance">
        <description>The resulting matrix is used to project points orthogonally on a vector,
	which goes through the origin.</description>
        <parameters>
          <parameter name="a" type="dojox.gfx.Point" usage="required">
            <description>a point-like object, which specifies a vector of projection</description>
          </parameter>
          <parameter name="b" type="null" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <description>Converts any 2D matrix-like object or an array of
	such objects to a valid dojox.gfx.matrix.Matrix2D object.</description>
        <parameters>
          <parameter name="matrix" type="Object" usage="required">
            <description>an object, which is converted to a matrix, if necessary</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="multiplyPoint" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix object to be applied</description>
          </parameter>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number" usage="optional">
            <description>Number: a y coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Point"/>
        </return-types>
      </method>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="one-or-more">
            <description>a 2D matrix-like object,
	all subsequent arguments are matrix-like objects too</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="invert" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix-like object to be inverted</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix-like object to be cloned</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_sandwich" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix-like object, which is applied at a central point</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>an x component of the central point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y component of the central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_radToDeg" scope="instance">
        <parameters>
          <parameter name="radian" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_multiplyPoint" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix object to be applied</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Point"/>
        </return-types>
      </method>
      <method name="_degToRad" scope="instance">
        <parameters>
          <parameter name="degree" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Matrix2D" scope="instance">
        <description>Normalizes a 2D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
        <parameters>
          <parameter name="arg" type="Object" usage="required">
            <description>a 2D matrix-like object, a number, or an array of such objects</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.matrix.Matrix2D">
    <description>Normalizes a 2D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
    <methods/>
  </class>
  <class type="dojox.gfx.path">
    <methods>
      <method name="TextPath" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM node to be used by this TextPath object</description>
          </parameter>
        </parameters>
      </method>
      <method name="Path" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM node to be used by this path object</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.path.Path" superclass="shapeLib.Shape">
    <methods>
      <method name="vLineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="smoothCurveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setAbsoluteMode" scope="instance">
        <parameters>
          <parameter name="mode" type="Boolean" usage="required">
            <description>true/false or &amp;quot;absolute&amp;quot;/&amp;quot;relative&amp;quot; to specify the mode</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qSmoothCurveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qCurveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="hLineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getLastPosition" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="getAbsoluteMode" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="curveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM node to be used by this path object</description>
          </parameter>
        </parameters>
      </method>
      <method name="closePath" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="arcTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
          <parameter name="matrix" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateBBox" scope="instance">
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate</description>
          </parameter>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPath" scope="instance">
        <parameters>
          <parameter name="path" type="String" usage="required">
            <description>an SVG path string</description>
          </parameter>
        </parameters>
      </method>
      <method name="_pushSegment" scope="instance">
        <parameters>
          <parameter name="action" type="String" usage="required">
            <description>valid SVG code for a segment's type</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>a list of parameters for this segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getRealBBox" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_confirmSegmented" scope="instance"/>
      <method name="_collectArgs" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required">
            <description>an output argument (array of numbers)</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>an input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_applyTransform" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="shapeLib.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="segments" scope="instance-prototype" type="Array"/>
      <property name="last" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="_validSegments" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.segments"/>
  <class type="dojox.gfx.path.Path.bbox"/>
  <class type="dojox.gfx.path.Path.last"/>
  <class type="dojox.gfx.path.Path._validSegments"/>
  <class type="dojox.gfx.path.Path.shape"/>
  <class type="dojox.gfx.path.TextPath" superclass="Path">
    <methods>
      <method name="setText" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFont" scope="instance">
        <parameters>
          <parameter name="newFont" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getText" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getFont" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM node to be used by this TextPath object</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Path" scope="instance"/>
    </mixins>
  </class>
  <class type="shape"/>
  <class type="dojox.gfx.shape.Surface._parent"/>
  <class type="dojox.gfx.Point">
    <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2}.</description>
    <methods/>
  </class>
  <class type="dojox.gfx.Rectangle">
    <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2, width: 100, height: 200}.</description>
    <methods/>
  </class>
  <class type="dojox.gfx.shape.Polyline" superclass="shape.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Boolean" usage="required">
            <description>close the polyline to make a polygon</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizePoints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Polyline.shape">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Polyline.shape.points"/>
  <class type="g"/>
  <class type="dojox.gfx.silverlight">
    <methods>
      <method name="TextPath" scope="instance"/>
      <method name="Text" scope="instance"/>
      <method name="Surface" scope="instance"/>
      <method name="Shape" scope="instance"/>
      <method name="Rect" scope="instance"/>
      <method name="Polyline" scope="instance"/>
      <method name="Path" scope="instance"/>
      <method name="Line" scope="instance"/>
      <method name="Image" scope="instance"/>
      <method name="Group" scope="instance"/>
      <method name="Ellipse" scope="instance"/>
      <method name="Circle" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx.silverlight.Shape" superclass="gs.Shape">
    <methods>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFillAttr" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToFront" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToBack" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getParentSurface" scope="instance"/>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Shape.rawNode"/>
  <class type="dojox.gfx.silverlight.Shape.parent.rawNode"/>
  <class type="dojox.gfx.silverlight.Group" superclass="sl.Shape">
    <methods>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>an Silverlight node</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Group.rawNode"/>
  <class type="dojox.gfx.silverlight.Rect" superclass="sl.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a rectangle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
      <mixin type="gs.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Rect.rawNode"/>
  <class type="dojox.gfx.silverlight.Ellipse" superclass="sl.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an ellipse shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
      <mixin type="gs.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Ellipse.rawNode"/>
  <class type="dojox.gfx.silverlight.Circle" superclass="sl.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a circle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
      <mixin type="gs.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Circle.rawNode"/>
  <class type="dojox.gfx.silverlight.Line" superclass="sl.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a line shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
      <mixin type="gs.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Line.rawNode"/>
  <class type="dojox.gfx.silverlight.Polyline" superclass="sl.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
      <mixin type="gs.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Polyline.shape"/>
  <class type="dojox.gfx.silverlight.Polyline.rawNode"/>
  <class type="dojox.gfx.silverlight.Image" superclass="sl.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an image shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
      <mixin type="gs.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Image.rawNode"/>
  <class type="dojox.gfx.silverlight.Text" superclass="sl.Shape">
    <methods>
      <method name="setStroke" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a text shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextWidth" scope="instance"/>
      <method name="_setFillAttr" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAdjustedMatrix" scope="instance"/>
      <method name="_delayAlignment" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
      <mixin type="gs.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Text.rawNode">
    <properties>
      <property name="Canvas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Text.rawNode.Canvas"/>
  <class type="dojox.gfx.silverlight.Text.shape"/>
  <class type="dojox.gfx.silverlight.Path" superclass="sl.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="pathLib.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
      <mixin type="pathLib.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Path.shape"/>
  <class type="dojox.gfx.silverlight.Path.rawNode"/>
  <class type="dojox.gfx.silverlight.TextPath" superclass="sl.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="pathLib.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="sl.Shape" scope="instance"/>
      <mixin type="pathLib.TextPath" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.silverlight.Surface" superclass="gs.Surface">
    <methods>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Surface.rawNode"/>
  <class type="sl">
    <methods>
      <method name="attachSurface" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an Silverlight node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an Silverlight node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="not implemented"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="gs"/>
  <class type="dojox.gfx.svg">
    <methods>
      <method name="TextPath" scope="instance"/>
      <method name="Text" scope="instance"/>
      <method name="Surface" scope="instance"/>
      <method name="Shape" scope="instance"/>
      <method name="Rect" scope="instance"/>
      <method name="Polyline" scope="instance"/>
      <method name="Path" scope="instance"/>
      <method name="Line" scope="instance"/>
      <method name="Image" scope="instance"/>
      <method name="Group" scope="instance"/>
      <method name="Ellipse" scope="instance"/>
      <method name="Circle" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx.svg.Shape" superclass="gs.Shape">
    <methods>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object (see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a shape object
	(see dojox.gfx.defaultPath,
	dojox.gfx.defaultPolyline,
	dojox.gfx.defaultRect,
	dojox.gfx.defaultEllipse,
	dojox.gfx.defaultCircle,
	dojox.gfx.defaultLine,
	or dojox.gfx.defaultImage)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFillObject" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="nodeType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToFront" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToBack" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getParentSurface" scope="instance"/>
      <method name="_applyTransform" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.svg.Group" superclass="svg.Shape">
    <methods>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>an SVG node</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Group.rawNode"/>
  <class type="dojox.gfx.svg.Rect" superclass="svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a rectangle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
      <mixin type="gs.Rect" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.svg.Ellipse" superclass="svg.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="gs.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
      <mixin type="gs.Ellipse" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.svg.Circle" superclass="svg.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="gs.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
      <mixin type="gs.Circle" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.svg.Line" superclass="svg.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="gs.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
      <mixin type="gs.Line" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.svg.Polyline" superclass="svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
      <mixin type="gs.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Polyline.shape"/>
  <class type="dojox.gfx.svg.Image" superclass="svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an image shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
      <mixin type="gs.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Image.rawNode"/>
  <class type="dojox.gfx.svg.Text" superclass="svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a text shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getTextWidth" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
      <mixin type="gs.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Text.rawNode.firstChild"/>
  <class type="dojox.gfx.svg.Text.rawNode">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Path" superclass="svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="pathLib.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
      <mixin type="pathLib.Path" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.svg.TextPath" superclass="svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTextPath" scope="instance"/>
      <method name="_setText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="pathLib.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="svg.Shape" scope="instance"/>
      <mixin type="pathLib.TextPath" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.svg.Surface" superclass="gs.Surface">
    <methods>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Surface" scope="instance"/>
    </mixins>
  </class>
  <class type="svg">
    <methods>
      <method name="attachSurface" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an SVG node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an SVG node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.utils">
    <methods>
      <method name="toSvg" scope="instance">
        <description>Function to serialize a GFX surface to SVG text.  The value of this output
	is that there are numerous serverside parser libraries that can render
	SVG into images in various formats.  This provides a way that GFX objects
	can be captured in a known format and sent serverside for serialization
	into an image.</description>
        <parameters>
          <parameter name="surface" type="GFX" usage="required">
            <description>The GFX surface to serialize.</description>
          </parameter>
        </parameters>
        <return-description>Deferred object that will be called when SVG serialization is complete.</return-description>
        <return-types>
          <return-type type="dojo.Deferred that will be called when serialization finishes"/>
        </return-types>
      </method>
      <method name="toJson" scope="instance">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface|dojox.gfx.Shape" usage="required"/>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface|dojox.gfx.Shape" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="fromJson" scope="instance">
        <parameters>
          <parameter name="parent" type="dojox.gfx.Surface|dojox.gfx.Shape" usage="required"/>
          <parameter name="json" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface|dojox.gfx.Shape" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="deserialize" scope="instance">
        <parameters>
          <parameter name="parent" type="dojox.gfx.Surface|dojox.gfx.Shape" usage="required"/>
          <parameter name="object" type="dojox.gfx.Shape|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="_svgSerializerInitialized" scope="instance"/>
      <method name="_innerXML" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node from which to generate the XML text representation.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_initSvgSerializer" scope="instance"/>
      <method name="_cleanSvg" scope="instance">
        <parameters>
          <parameter name="svg" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Cleaned SVG text"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.vml">
    <methods>
      <method name="TextPath" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Text" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Surface" scope="instance"/>
      <method name="Shape" scope="instance"/>
      <method name="Rect" scope="instance"/>
      <method name="Polyline" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Path" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Line" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Image" scope="instance"/>
      <method name="Group" scope="instance"/>
      <method name="Ellipse" scope="instance"/>
      <method name="Circle" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx.vml.Shape" superclass="gs.Shape">
    <methods>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_translate" scope="instance">
        <parameters>
          <parameter name="dict" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width in pixels</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToFront" scope="instance"/>
      <method name="_moveToBack" scope="instance"/>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="_capMapReversed" scope="instance" type="Object"/>
      <property name="_capMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="parentNode" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.fill"/>
  <class type="dojox.gfx.vml.Shape.rawNode.filters.DXImageTransform.Microsoft">
    <properties>
      <property name="Alpha" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.filters.DXImageTransform.Microsoft.Alpha"/>
  <class type="dojox.gfx.vml.Shape.rawNode.stroke"/>
  <class type="dojox.gfx.vml.Shape._capMap"/>
  <class type="dojox.gfx.vml.Shape._capMapReversed"/>
  <class type="dojox.gfx.vml.Shape.rawNode.parentNode"/>
  <class type="dojox.gfx.vml.Group" superclass="vml.Shape">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width in pixels</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="vml.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="bgNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group.rawNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group.bgNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group.rawNode.style"/>
  <class type="dojox.gfx.vml.Group.bgNode.style"/>
  <class type="dojox.gfx.vml.Rect" superclass="vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a rectangle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="vml.Shape" scope="instance"/>
      <mixin type="gs.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Rect.rawNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Rect.rawNode.style"/>
  <class type="dojox.gfx.vml.Ellipse" superclass="vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an ellipse shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="vml.Shape" scope="instance"/>
      <mixin type="gs.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Ellipse.rawNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Ellipse.rawNode.style"/>
  <class type="dojox.gfx.vml.Circle" superclass="vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a circle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="vml.Shape" scope="instance"/>
      <mixin type="gs.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Circle.rawNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Circle.rawNode.style"/>
  <class type="dojox.gfx.vml.Line" superclass="vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a line shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="vml.Shape" scope="instance"/>
      <mixin type="gs.Line" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.vml.Line.rawNode.path"/>
  <class type="dojox.gfx.vml.Polyline" superclass="vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Boolean" usage="optional">
            <description>if true, close the polyline explicitely</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="vml.Shape" scope="instance"/>
      <mixin type="gs.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Polyline.shape"/>
  <class type="dojox.gfx.vml.Polyline.rawNode.path"/>
  <class type="dojox.gfx.vml.Image" superclass="vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an image shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width in pixels</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="vml.Shape" scope="instance"/>
      <mixin type="gs.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode.firstChild"/>
  <class type="dojox.gfx.vml.Image.rawNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
      <property name="parentNode" scope="instance" type="Object"/>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode.style"/>
  <class type="dojox.gfx.vml.Image.rawNode.parentNode"/>
  <class type="dojox.gfx.vml.Image.rawNode.filters.DXImageTransform.Microsoft">
    <properties>
      <property name="Matrix" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode.filters.DXImageTransform.Microsoft.Matrix"/>
  <class type="dojox.gfx.vml.Text" superclass="vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a text shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getTextWidth" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFont" scope="instance"/>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="vml.Shape" scope="instance"/>
      <mixin type="gs.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="_alignment" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text._alignment"/>
  <class type="dojox.gfx.vml.Text.shape"/>
  <class type="dojox.gfx.vml.Text.rawNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text.rawNode.style"/>
  <class type="dojox.gfx.vml.Path" superclass="vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an VML path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="skip transfomed bbox calculations"/>
        </return-types>
      </method>
      <method name="_smoothCurveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_closePath" scope="instance"/>
      <method name="_arcTo" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelPos" scope="instance">
        <parameters>
          <parameter name="last" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelCrd" scope="instance">
        <parameters>
          <parameter name="last" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addArgs" scope="instance">
        <parameters>
          <parameter name="path" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="upto" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="pathLib.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="vml.Shape" scope="instance"/>
      <mixin type="pathLib.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="renderers" scope="instance" type="Object"/>
      <property name="lastControl" scope="instance-prototype" type="Object"/>
      <property name="_pathVmlToSvgMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path.rawNode.path"/>
  <class type="dojox.gfx.vml.Path.lastControl"/>
  <class type="dojox.gfx.vml.Path._pathVmlToSvgMap"/>
  <class type="dojox.gfx.vml.Path.renderers"/>
  <class type="dojox.gfx.vml.TextPath" superclass="vml.Path">
    <methods>
      <method name="setText" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFont" scope="instance">
        <parameters>
          <parameter name="newFont" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance"/>
      <method name="_setFont" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="pathLib.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="vml.Path" scope="instance"/>
      <mixin type="pathLib.TextPath" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.TextPath.rawNode"/>
  <class type="dojox.gfx.vml.Surface" superclass="gs.Surface">
    <methods>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gs.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="clipNode" scope="instance" type="Object"/>
      <property name="bgNode" scope="instance" type="Object"/>
      <property name="_parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.clipNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.rawNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.bgNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface._parent">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface._parent.style"/>
  <class type="dojox.gfx.vml.Surface.clipNode.style"/>
  <class type="dojox.gfx.vml.Surface.rawNode.style"/>
  <class type="dojox.gfx.vml.Surface.bgNode.style"/>
  <class type="vml">
    <methods>
      <method name="attachSurface" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an VML node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an VML node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d">
    <methods>
      <method name="Viewport" scope="instance"/>
      <method name="Triangles" scope="instance"/>
      <method name="Scene" scope="instance"/>
      <method name="Quads" scope="instance"/>
      <method name="Polygon" scope="instance"/>
      <method name="Path3d" scope="instance"/>
      <method name="Orbit" scope="instance"/>
      <method name="Object" scope="instance"/>
      <method name="Edges" scope="instance"/>
      <method name="Cylinder" scope="instance"/>
      <method name="Cube" scope="instance"/>
    </methods>
    <properties>
      <property name="scheduler" scope="instance" type="Object"/>
      <property name="lighting" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting">
    <methods>
      <method name="Model" scope="instance">
        <parameters>
          <parameter name="incident" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
          <parameter name="ambient" type="Object" usage="required"/>
          <parameter name="specular" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.lighting.Model">
    <methods>
      <method name="plastic" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="npr" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="metal" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="matte" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="incident" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
          <parameter name="ambient" type="Object" usage="required"/>
          <parameter name="specular" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constant" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="specular" scope="instance" type="Object"/>
      <property name="ambient" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.Model.ambient"/>
  <class type="dojox.gfx3d.lighting.Model.specular"/>
  <class type="gfx3d.lighting">
    <methods>
      <method name="white" scope="instance"/>
      <method name="toStdColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="specular" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="roughness" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scaleColor" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scale" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saturateColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saturate" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reflect" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="phong" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalize" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="multiplyColor" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mixColor" scope="instance">
        <parameters>
          <parameter name="c1" type="Object" usage="required"/>
          <parameter name="c2" type="Object" usage="required"/>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length2Color" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fromStdColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="faceforward" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dot" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="diffuse" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="diff2Color" scope="instance">
        <parameters>
          <parameter name="c1" type="Object" usage="required"/>
          <parameter name="c2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="black" scope="instance"/>
      <method name="addColor" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="finish" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="gfx3d.lighting.finish">
    <properties>
      <property name="shiny" scope="instance" type="Object"/>
      <property name="phong_shiny" scope="instance" type="Object"/>
      <property name="phong_glossy" scope="instance" type="Object"/>
      <property name="phong_dull" scope="instance" type="Object"/>
      <property name="metalE" scope="instance" type="Object"/>
      <property name="metalD" scope="instance" type="Object"/>
      <property name="metalC" scope="instance" type="Object"/>
      <property name="metalB" scope="instance" type="Object"/>
      <property name="metalA" scope="instance" type="Object"/>
      <property name="luminous" scope="instance" type="Object"/>
      <property name="glossy" scope="instance" type="Object"/>
      <property name="dull" scope="instance" type="Object"/>
      <property name="defaults" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="gfx3d.lighting.finish.defaults"/>
  <class type="gfx3d.lighting.finish.dull"/>
  <class type="gfx3d.lighting.finish.shiny"/>
  <class type="gfx3d.lighting.finish.glossy"/>
  <class type="gfx3d.lighting.finish.phong_dull"/>
  <class type="gfx3d.lighting.finish.phong_shiny"/>
  <class type="gfx3d.lighting.finish.phong_glossy"/>
  <class type="gfx3d.lighting.finish.luminous"/>
  <class type="gfx3d.lighting.finish.metalA"/>
  <class type="gfx3d.lighting.finish.metalB"/>
  <class type="gfx3d.lighting.finish.metalC"/>
  <class type="gfx3d.lighting.finish.metalD"/>
  <class type="gfx3d.lighting.finish.metalE"/>
  <class type="gfx3d.matrix">
    <methods>
      <method name="translate" scope="instance">
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>an x coordinate value</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y coordinate value</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>a z coordinate value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <description>The resulting matrix is used to scale (magnify) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>a scaling factor used for the x coordinate</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a scaling factor used for the y coordinate</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>a scaling factor used for the z coordinate</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateZ() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZ" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateYg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateY" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateXg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateX" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="project" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="required">
            <description>a 3D matrix object to be applied</description>
          </parameter>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <description>Converts any 3D matrix-like object or an array of
	such objects to a valid dojox.gfx3d.matrix.Matrix3D object.</description>
        <parameters>
          <parameter name="matrix" type="Object" usage="required">
            <description>an object, which is converted to a matrix, if necessary</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="multiplyPoint" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="required">
            <description>a 3D matrix object to be applied</description>
          </parameter>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="one-or-more">
            <description>a 3D matrix-like object,
	all subsequent arguments are matrix-like objects too</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="invert" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix3D" usage="required">
            <description>a 2D matrix-like object to be inverted</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="required">
            <description>a 3D matrix-like object to be cloned</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraTranslate" scope="instance">
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>an x coordinate value</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y coordinate value</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>a z coordinate value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateZ() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZ" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateYg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateY" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateXg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateX" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="_radToDeg" scope="instance">
        <parameters>
          <parameter name="radian" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_project" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_multiplyPoint" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_degToRad" scope="instance">
        <parameters>
          <parameter name="degree" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Matrix3D" scope="instance">
        <description>Normalizes a 3D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
        <parameters>
          <parameter name="arg" type="Object" usage="required">
            <description>a 3D matrix-like object, a number, or an array of such objects</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="gfx3d.matrix.Matrix3D">
    <description>Normalizes a 3D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
    <methods/>
  </class>
  <class type="gfx3d.Viewport" superclass="gfx3d._creators">
    <methods/>
  </class>
  <class type="gfx3d.Scene" superclass="gfx3d._creators">
    <methods/>
  </class>
  <class type="gfx.Surface">
    <methods>
      <method name="createViewport" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx3d.Object">
    <methods>
      <method name="toStdFill" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
          <parameter name="normal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
      </method>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	dojo.Color
	or dojox.gfx.MODEL)</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="getZOrder" scope="instance"/>
      <method name="getOutline" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="applyTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyRightTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.Scene" superclass="gfx3d.Object">
    <methods>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
          <parameter name="deep" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="getZOrder" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="addTodo" scope="instance">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx3d.Object" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx3d.Edges" superclass="gfx3d.Object">
    <methods>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
          <parameter name="style" type="String" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="draw" scope="instance"/>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx3d.Object" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx3d.Orbit" superclass="gfx3d.Object">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx3d.Object" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx3d.Path3d" superclass="gfx3d.Object">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="closePath" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_pushSegment" scope="instance">
        <parameters>
          <parameter name="action" type="String" usage="required">
            <description>valid SVG code for a segment's type</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>a list of parameters for this segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="_draw" scope="instance"/>
      <method name="_collectArgs" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required">
            <description>an output argument (array of numbers)</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>an input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="_validSegments" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Path3d._validSegments"/>
  <class type="dojox.gfx3d.Triangles" superclass="gfx3d.Object">
    <methods>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
          <parameter name="style" type="String" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx3d.Object" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx3d.Quads" superclass="gfx3d.Object">
    <methods>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
          <parameter name="style" type="String" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx3d.Object" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx3d.Polygon" superclass="gfx3d.Object">
    <methods>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="getOutline" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx3d.Object" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx3d.Cube" superclass="gfx3d.Object">
    <methods>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx3d.Object" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx3d.Cube.cache.0"/>
  <class type="dojox.gfx3d.Cube.cache.1"/>
  <class type="dojox.gfx3d.Cylinder" superclass="gfx3d.Object">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance"/>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cylinder.object"/>
  <class type="dojox.gfx3d.Viewport" superclass="gfx.Group">
    <methods>
      <method name="setLights" scope="instance">
        <parameters>
          <parameter name="lights" type="Array" usage="required">
            <description>Array: an array of light object
	or lights object</description>
          </parameter>
          <parameter name="ambient" type="Color" usage="required">
            <description>Color: an ambient object</description>
          </parameter>
          <parameter name="specular" type="Color" usage="required">
            <description>Color: an specular object</description>
          </parameter>
        </parameters>
      </method>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setCameraTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="render" scope="instance"/>
      <method name="invalidate" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="applyCameraTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraRightTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraLeftTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="addTodo" scope="instance">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addLights" scope="instance">
        <parameters>
          <parameter name="lights" type="Array" usage="required">
            <description>|| light object: light object(s)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gfx.Group" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Viewport.rawNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Viewport.rawNode.style"/>
  <class type="schedulerExtensions"/>
  <class type="gfx3d._creators">
    <methods>
      <method name="setScheduler" scope="instance">
        <parameters>
          <parameter name="scheduler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDrawer" scope="instance">
        <parameters>
          <parameter name="drawer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTriangles" scope="instance">
        <parameters>
          <parameter name="tris" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createScene" scope="instance">
        <return-types>
          <return-type type="dojox.gfx3d.Scene"/>
        </return-types>
      </method>
      <method name="createQuads" scope="instance">
        <parameters>
          <parameter name="quads" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createPolygon" scope="instance">
        <parameters>
          <parameter name="points" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Polygon"/>
        </return-types>
      </method>
      <method name="createPath3d" scope="instance">
        <parameters>
          <parameter name="path" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createOrbit" scope="instance">
        <parameters>
          <parameter name="orbit" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createEdges" scope="instance">
        <parameters>
          <parameter name="edges" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createCylinder" scope="instance">
        <parameters>
          <parameter name="cylinder" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createCube" scope="instance">
        <parameters>
          <parameter name="cube" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="create3DObject" scope="instance">
        <parameters>
          <parameter name="objectType" type="Object" usage="required"/>
          <parameter name="rawObject" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Object"/>
        </return-types>
      </method>
      <method name="adopt" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="abandon" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, do not redraw a picture yet</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="gfx3d._creators.setScheduler">
    <methods/>
  </class>
  <class type="gfx3d._creators.setDrawer">
    <methods/>
  </class>
  <class type="dojox.gfx3d.scheduler">
    <methods>
      <method name="BinarySearchTree" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required">
            <description>dojox.gfx3d.Object</description>
          </parameter>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.scheduler.BinarySearchTree">
    <methods>
      <method name="iterate" scope="instance">
        <parameters>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required">
            <description>dojox.gfx3d.Object</description>
          </parameter>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="gfx3d.scheduler">
    <methods>
      <method name="zOrder" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="order" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="outline" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="order" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bsp" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="gfx3d.drawer">
    <methods>
      <method name="conservative" scope="instance">
        <parameters>
          <parameter name="todos" type="Object" usage="required"/>
          <parameter name="objects" type="Object" usage="required"/>
          <parameter name="viewport" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="chart" scope="instance">
        <parameters>
          <parameter name="todos" type="Object" usage="required"/>
          <parameter name="objects" type="Object" usage="required"/>
          <parameter name="viewport" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="gfx3d.vector">
    <methods>
      <method name="sum" scope="instance"/>
      <method name="substract" scope="instance">
        <parameters>
          <parameter name="a" type="Pointer" usage="required"/>
          <parameter name="b" type="Pointer" usage="required"/>
        </parameters>
      </method>
      <method name="normalize" scope="instance">
        <parameters>
          <parameter name="a" type="Point|Array" usage="required">
            <description>Object: a point</description>
          </parameter>
          <parameter name="b" type="Point" usage="required">
            <description>Object: a point</description>
          </parameter>
          <parameter name="c" type="Point" usage="required">
            <description>Object: a point</description>
          </parameter>
        </parameters>
      </method>
      <method name="dotProduct" scope="instance">
        <parameters>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number|Point" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
          <parameter name="d" type="Number" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="e" type="Number" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="f" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="crossProduct" scope="instance">
        <parameters>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number|Point" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
          <parameter name="d" type="Number" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="e" type="Number" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="f" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="center" scope="instance"/>
      <method name="_dotProduct" scope="instance">
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
          <parameter name="u" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="v" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="w" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_crossProduct" scope="instance">
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
          <parameter name="u" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="v" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="w" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.grid">
    <methods>
      <method name="__ViewDef" scope="instance"/>
      <method name="__DataViewDef" scope="instance"/>
      <method name="__DataCellDef" scope="instance"/>
      <method name="__CellDef" scope="instance"/>
      <method name="_ViewManager" scope="instance">
        <description>Grid creates views automatically based on grid's layout structure.
	Users should typically not need to access individual views or the views collection directly.</description>
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_View" scope="instance"/>
      <method name="_TreeView" scope="instance"/>
      <method name="_TreeLayout" scope="instance"/>
      <method name="_TreeGridView" scope="instance"/>
      <method name="_TreeGridContentBuilder" scope="instance"/>
      <method name="_TreeFocusManager" scope="instance"/>
      <method name="_TreeContentBuilder" scope="instance"/>
      <method name="_TreeAggregator" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_SelectorContentBuilder" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Selector" scope="instance"/>
      <method name="_SelectionPreserver" scope="instance">
        <description>When this feature is turned on, Grid will try to preserve selections across actions, e.g. sorting, filtering etc.
	
	Precondition - Identifier(id) is required for store since id is the only way for differentiating row items.
	Known issue - The preserved selections might be inaccurate if some unloaded rows are previously selected by range(e.g.SHIFT + click)</description>
        <examples>
          <example>	//To turn on this - please set 'keepSelection' attribute to true
		&lt;div dojoType="dojox.grid.DataGrid" keepSelection = true .../&gt;
		&lt;div dojoType="dojox.grid.TreeGrid" keepSelection = true .../&gt;
		&lt;div dojoType="dojox.grid.LazyTreeGrid" keepSelection = true .../&gt;</example>
        </examples>
        <parameters>
          <parameter name="selection" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Scroller" scope="instance">
        <parameters>
          <parameter name="inContentNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_RowSelector" scope="instance"/>
      <method name="_RowManager" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_RadioSelector" scope="instance"/>
      <method name="_LazyTreeLayout" scope="instance"/>
      <method name="_LazyTreeGridCache" scope="instance">
        <examples>
          <example> [{opened: true, treePath: []},
		{opened: false, treePath: ["root0"]},
		{opened: false, treePath: ["root0"]},
		{opened: false, treePath: []},
		...]</example>
        </examples>
      </method>
      <method name="_LazyExpando" scope="instance"/>
      <method name="_Layout" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_InputSelectorHeaderBuilder" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_InputSelectorContentBuilder" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_GridAvatar" scope="instance"/>
      <method name="_Grid" scope="instance">
        <description>_Grid provides the full set of grid features without any
	direct connection to a data store.
	
	The grid exposes a get function for the grid, or optionally
	individual columns, to populate cell contents.
	
	The grid is rendered based on its structure, an object describing
	column and cell layout.</description>
        <examples>
          <example>A quick sample:
	
	define a get function
		function get(inRowIndex){ // called in cell context
			return [this.index, inRowIndex].join(', ');
		}
	
	define the grid structure:
		var structure = [ // array of view objects
			{ cells: [// array of rows, a row is an array of cells
				[
					{ name: "Alpha", width: 6 },
					{ name: "Beta" },
					{ name: "Gamma", get: get }]
			]}
		];
	
		&lt;div id="grid"
			rowCount="100" get="get"
			structure="structure"
			dojoType="dojox.grid._Grid"&gt;&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="_FocusManager" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Expando" scope="instance"/>
      <method name="_Events" scope="instance">
        <description>Default synthetic events dispatched for _Grid. dojo.connect to events to
	retain default implementation or override them for custom handling.</description>
      </method>
      <method name="_EditManager" scope="instance">
        <parameters>
          <parameter name="inGrid" type="dojox.Grid" usage="required">
            <description>The dojox.Grid this editor should be attached to</description>
          </parameter>
        </parameters>
      </method>
      <method name="_DeferredTextWidget" scope="instance"/>
      <method name="_CheckBoxSelector" scope="instance"/>
      <method name="TreeSelection" scope="instance"/>
      <method name="TreePath" scope="instance">
        <parameters>
          <parameter name="path" type="String|Array&lt;Integer&gt;|Integer|dojox.grid.TreePath" usage="required"/>
          <parameter name="grid" type="dojox.grid.TreeGrid" usage="required"/>
        </parameters>
      </method>
      <method name="TreeGrid" scope="instance">
        <description>TreeGrid currently only works on "simple" structures.  That is,
	single-view structures with a single row in them.
	
	The TreeGrid works using the concept of "levels" - level 0 are the
	top-level items.</description>
      </method>
      <method name="Selection" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="LazyTreeGridStoreModel" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="LazyTreeGrid" scope="instance">
        <description>LazyTreeGrid inherits from dojo.grid.TreeGrid and applies virtual scrolling mechanism
	to nested children rows so that it's possible to deal with complex tree structure data set
	with nested and huge children rows. It's also compatible with dijit.tree.ForestStoreModel
	
	Most methods and properties pertaining to dojox.grid.DataGrid
	and dojox.grid.TreeGrid also apply here
	
	LazyTreeGrid does not support summary row/items aggregate due to the lazy-loading rationale.</description>
        <examples>
          <example>	colSpans = {
		0:	[
				{start: 0, end: 1, primary: 0},
				{start: 2, end: 4, primary: 3}
			],
		1:	[
				{start: 0, end: 3, primary: 1}
			]
		};</example>
        </examples>
      </method>
      <method name="EnhancedGrid" scope="instance">
        <description>EnhancedGrid features are implemented as plugins that could be loaded on demand.
	Explicit dojo.require() is needed to use these feature plugins.</description>
        <examples>
          <example>A quick sample to use EnhancedGrid features:
	
	Step 1. Load EnhancedGrid and required features
		 &lt;script type="text/javascript"&gt;
			dojo.require("dojox.grid.EnhancedGrid");
			dojo.require("dojox.grid.enhanced.plugins.DnD");
			dojo.require("dojox.grid.enhanced.plugins.Menu");
			dojo.require("dojox.grid.enhanced.plugins.NestedSorting");
			dojo.require("dojox.grid.enhanced.plugins.IndirectSelection");
		&lt;/script&gt;
	
	Step 2. Use EnhancedGrid
	- Via HTML markup
		&lt;div dojoType="dojox.grid.EnhancedGrid" ...
			plugins="{nestedSorting: true, dnd: true, indirectSelection: true,
			menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",
			selectedRegionMenu:"selectedRegionMenuId"}}"&gt;
				...
		&lt;/div&gt;
	
	- Or via JavaScript
		&lt;script type="text/javascript"&gt;
			var grid = new dojox.grid.EnhancedGrid({plugins : {nestedSorting: true, dnd: true, indirectSelection: true,
		               menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",selectedRegionMenu:"selectedRegionMenuId"}},
				       ... }, dojo.byId('gridDiv'));
			grid.startup();
		&lt;/script&gt;
	
	
	Plugin Support
	[Note: Plugin support is still experimental]
	
	You can either customize the default plugins or add new ones, more details please see
	- dojox.grid.enhanced._PluginManager
	- dojox.grid.enhanced._Plugin
	- dojox.grid.enhanced.plugins.*</example>
        </examples>
      </method>
      <method name="DataSelection" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DataGrid" scope="instance"/>
    </methods>
    <properties>
      <property name="enhanced" scope="instance" type="Object"/>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.__DataCellDef" superclass="dojox.grid.__CellDef">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.__CellDef" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.__DataViewDef" superclass="dojox.grid.__ViewDef">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.__ViewDef" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.DataGrid" superclass="_Grid">
    <methods>
      <method name="styleRowState" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sort" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setItems" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeSelectedRows" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSortProps" scope="instance"/>
      <method name="getItemIndex" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <description>Provides data to display in a grid cell. Called in grid cell context.
	So this.cell.index is the column index.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Row for which to provide data</description>
          </parameter>
          <parameter name="inItem" type="Object" usage="required"/>
        </parameters>
        <return-description>Data to display for a given grid cell.</return-description>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="reRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inDataAttr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="canSort" scope="instance"/>
      <method name="canEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_rowToPage" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_requestsPending" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_requestPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_render" scope="instance"/>
      <method name="_refresh" scope="instance">
        <parameters>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_preparePage" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pageToRow" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRevert" scope="instance"/>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemIndex" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isDeleted" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemAttr" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_copyAttr" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clearData" scope="instance"/>
      <method name="_checkUpdateStatus" scope="instance"/>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="noUpdate" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Grid" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="_by_idx" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.DataGrid.grid"/>
  <class type="dojox.grid.DataGrid._by_idx"/>
  <class type="dojox.grid.DataSelection" superclass="Selection">
    <methods>
      <method name="getSelected" scope="instance"/>
      <method name="getNextSelected" scope="instance">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="deselectAll" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Selection" scope="instance"/>
    </mixins>
    <properties>
      <property name="selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.DataSelection.selected"/>
  <class type="dojox.grid.EnhancedGrid" superclass="DataGrid">
    <description>EnhancedGrid features are implemented as plugins that could be loaded on demand.
	Explicit dojo.require() is needed to use these feature plugins.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="plugin" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mixin" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellByField" scope="instance">
        <parameters>
          <parameter name="field" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="createView" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="canSort" scope="instance">
        <parameters>
          <parameter name="colIndex" type="Object" usage="required"/>
          <parameter name="field" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_storeLayerFetch" scope="instance">
        <parameters>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getHeaderHeight" scope="instance"/>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_copyAttr" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="DataGrid" scope="instance"/>
    </mixins>
    <properties>
      <property name="focus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.EnhancedGrid.focus"/>
  <class type="dojox.grid.enhanced">
    <methods>
      <method name="_PluginManager" scope="instance">
        <description>Plugin manager is responsible for
	1. Loading required plugins
	2. Handling collaborat	ion and dependencies among plugins
	
	Some plugin dependencies:
	- "columnReordering" attribute won't work when either DnD or Indirect Selections plugin is on.</description>
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Plugin" scope="instance">
        <description>Provides common plugin functionality and basic life cycle management.
	
	Each concrete plugin must have a name field and is responsible for registering itself to the global plugin registry
	e.g. for dnd plugin:
			dojox.grid.EnhancedGrid.registerPlugin("dnd" /*plugin name*/,
													dojox.grid.enhanced.plugins.DnD /*full class name of a plugin
													{"preInit": false, "dependency": ["nestedSorting"]} /*properties*/);
	
	[Keywords] of plugin properties(case sensitive)
	- "preInit": boolean, whether a plugin should be created before EnhancedGrid.postCreate(),
	false by default(plugins are created after EnhancedGrid.postCreate()).
	- "dependency": array or string, plugin(s) indicated by "dependency" will be created before the current one.
	Note: recursive cycle dependencies are not supported e.g. following dependency is invalid:
	pluginA -&gt; pluginB -&gt; pluginA</description>
        <examples>
          <example>1. Customize default DnD plugin
		dojo.declare("mygrid.MyDnD", dojox.grid.enhanced.plugins.DnD, {
			name:"dnd" //still reuse the plugin name
			constructor: function(inGrid, option){ ... }
		});
		dojox.grid.EnhancedGrid.registerPlugin("dnd", mygrid.MyDnD);
	
	2. Add new plugin - PluginA
		dojo.declare("mygrid.PluginA", dojox.grid.enhanced._Plugin, {
			name: "pA",
			constructor: function(inGrid, option){ ... }
		});
		dojox.grid.EnhancedGrid.registerPlugin("pA",mygrid.PluginA);
	
	3. Use plugins
		dojo.require("mygrid.MyDnD");
		dojo.require("mygrid.PluginA");</example>
        </examples>
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_FocusManager" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_FocusArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
          <parameter name="focusManager" type="Object" usage="required"/>
        </parameters>
        <return-description>Array of dom nodes.</return-description>
      </method>
      <method name="_Events" scope="instance">
        <description>Methods are copied or replaced for overwriting, this might be refined once
	an overall plugin architecture is set up for DataGrid.</description>
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DataSelection" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="plugins" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.DataSelection" superclass="DataSelection">
    <methods>
      <method name="deselectAll" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="DataSelection" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.DataSelection.grid"/>
  <class type="dojox.grid._LazyExpando" superclass="_widget">
    <methods>
      <method name="setRowNode" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOpen" scope="instance">
        <parameters>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onToggle" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateOpenState" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_templatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_widget" scope="instance"/>
      <mixin type="_templatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="expandoInner" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._LazyExpando.expandoInner"/>
  <class type="dojox.grid._TreeGridContentBuilder" superclass="_Builder._ContentBuilder">
    <methods>
      <method name="generateHtml" scope="instance">
        <parameters>
          <parameter name="inDataIndex" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getColSpans" scope="instance">
        <parameters>
          <parameter name="level" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCellWidth" scope="instance">
        <parameters>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Builder._ContentBuilder" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeGridContentBuilder.view.structure"/>
  <class type="dojox.grid._TreeGridContentBuilder.grid"/>
  <class type="dojox.grid._TreeGridView" superclass="_View">
    <methods>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onAfterRow" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_View" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid._LazyTreeLayout" superclass="_Layout">
    <methods>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="structure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="cellIndex" type="Object" usage="required"/>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Layout" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid._LazyTreeGridCache">
    <methods>
      <method name="removeChildren" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSiblingIndex" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="treePath" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.LazyTreeGrid" superclass="TreeGrid">
    <description>LazyTreeGrid inherits from dojo.grid.TreeGrid and applies virtual scrolling mechanism
	to nested children rows so that it's possible to deal with complex tree structure data set
	with nested and huge children rows. It's also compatible with dijit.tree.ForestStoreModel
	
	Most methods and properties pertaining to dojox.grid.DataGrid
	and dojox.grid.TreeGrid also apply here
	
	LazyTreeGrid does not support summary row/items aggregate due to the lazy-loading rationale.</description>
    <methods>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSortIndex" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inAsc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setModel" scope="instance">
        <parameters>
          <parameter name="treeModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="refresh" scope="instance">
        <parameters>
          <parameter name="keepState" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetState" scope="instance"/>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getState" scope="instance"/>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="reRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="expandoFetch" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="expand" scope="instance">
        <parameters>
          <parameter name="itemId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="createManagers" scope="instance"/>
      <method name="collapse" scope="instance">
        <parameters>
          <parameter name="itemId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateRenderedRows" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleLoadingClass" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="flag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setState" scope="instance"/>
      <method name="_setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refresh" scope="instance">
        <parameters>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onExpandoComplete" scope="instance">
        <parameters>
          <parameter name="childItems" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fold" scope="instance">
        <parameters>
          <parameter name="itemId" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="TreeGrid" scope="instance"/>
    </mixins>
    <properties>
      <property name="views" scope="instance" type="Object"/>
      <property name="treeModel" scope="instance" type="dijit.tree.ForestStoreModel">
        <description>| dojox.grid.LazyTreeGridStoreModel
	A tree store model object.</description>
      </property>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_treeCache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.treeModel">
    <properties>
      <property name="root" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.treeModel.root"/>
  <class type="dojox.grid.LazyTreeGrid.selection.preserver"/>
  <class type="dojox.grid.LazyTreeGrid.selection">
    <properties>
      <property name="preserver" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid._treeCache"/>
  <class type="dojox.grid.LazyTreeGrid.views"/>
  <class type="dojox.grid.LazyTreeGridStoreModel" superclass="ForestStoreModel">
    <methods>
      <method name="onNewItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="Function(items)" usage="required">
            <description>size)</description>
          </parameter>
          <parameter name="onError" type="function" usage="required"/>
          <parameter name="queryObj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isChildrenLoaded" scope="instance">
        <parameters>
          <parameter name="parentItem" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="ForestStoreModel" scope="instance"/>
    </mixins>
    <properties>
      <property name="root" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGridStoreModel.root"/>
  <class type="dojox.grid.Selection">
    <methods>
      <method name="toggleSelect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMode" scope="instance">
        <parameters>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectRange" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChanging" scope="instance"/>
      <method name="onChanged" scope="instance"/>
      <method name="onCanSelect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanDeselect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedCount" scope="instance"/>
      <method name="getSelected" scope="instance"/>
      <method name="getNextSelected" scope="instance">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="instance"/>
      <method name="deselectRange" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance">
        <parameters>
          <parameter name="inExcept" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelectEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inCtrlKey" type="Object" usage="required"/>
          <parameter name="inShiftKey" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="addToSelection" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_endUpdate" scope="instance"/>
      <method name="_beginUpdate" scope="instance"/>
    </methods>
    <properties>
      <property name="selected" scope="instance-prototype" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.Selection.selected"/>
  <class type="dojox.grid._TreeAggregator">
    <methods>
      <method name="value" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sum" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getForCell" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cnt" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearSubtotalCache" scope="instance"/>
      <method name="_cacheValue" scope="instance">
        <parameters>
          <parameter name="cache" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="store" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeAggregator.store"/>
  <class type="dojox.grid._TreeLayout" superclass="_Layout">
    <methods>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getInternalStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Layout" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeLayout.grid">
    <properties>
      <property name="scroller" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeLayout.grid.scroller"/>
  <class type="dojox.grid.TreePath">
    <methods>
      <method name="toString" scope="instance"/>
      <method name="previous" scope="instance"/>
      <method name="parent" scope="instance"/>
      <method name="next" scope="instance"/>
      <method name="lastChild" scope="instance">
        <parameters>
          <parameter name="traverse" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="item" scope="instance"/>
      <method name="isOpen" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="path" type="String|Array&lt;Integer&gt;|Integer|dojox.grid.TreePath" usage="required"/>
          <parameter name="grid" type="dojox.grid.TreeGrid" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="path" type="dojox.grid.TreePath|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="children" scope="instance">
        <parameters>
          <parameter name="alwaysReturn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="childPaths" scope="instance"/>
    </methods>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreePath.grid">
    <properties>
      <property name="treeModel" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreePath.grid.treeModel"/>
  <class type="dojox.grid._TreeFocusManager" superclass="_FocusManager">
    <methods>
      <method name="setFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="previous" scope="instance"/>
      <method name="next" scope="instance"/>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="inRowDelta" type="Object" usage="required"/>
          <parameter name="inColDelta" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLastFocusCell" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_FocusManager" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="cell" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeFocusManager.grid"/>
  <class type="dojox.grid._TreeFocusManager.cell"/>
  <class type="dojox.grid.TreeGrid" superclass="DataGrid">
    <description>TreeGrid currently only works on "simple" structures.  That is,
	single-view structures with a single row in them.
	
	The TreeGrid works using the concept of "levels" - level 0 are the
	top-level items.</description>
    <methods>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setModel" scope="instance">
        <parameters>
          <parameter name="treeModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanSelect" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="idx" type="integer|Array|String" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultOpenState" scope="instance">
        <parameters>
          <parameter name="cellDef" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createSelection" scope="instance"/>
      <method name="createScroller" scope="instance"/>
      <method name="createManagers" scope="instance"/>
      <method name="canEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setModel" scope="instance">
        <parameters>
          <parameter name="treeModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemIndex" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isDeleted" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_childItemSorter" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="descending" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="noUpdate" type="Object" usage="required"/>
          <parameter name="dontUpdateRoot" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="DataGrid" scope="instance"/>
    </mixins>
    <properties>
      <property name="treeModel" scope="instance" type="dijit.tree.ForestStoreModel">
        <description>A dijit.Tree model that will be used instead of using aggregates.
	Setting this value will make the TreeGrid behave like a columnar
	tree.  When setting this value, defaultOpen will default to false,
	and openAtLevels will be ignored.</description>
      </property>
      <property name="scroller" scope="instance" type="Object"/>
      <property name="aggregator" scope="instance" type="Object">
        <description>The aggregator class - it will be populated automatically if we
	are a collapsable grid</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.treeModel">
    <properties>
      <property name="root" scope="instance" type="Object"/>
      <property name="childrenAttrs" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.treeModel.childrenAttrs"/>
  <class type="dojox.grid.TreeGrid.scroller"/>
  <class type="dojox.grid.TreeGrid.treeModel.root"/>
  <class type="dojox.grid.TreeGrid.aggregator"/>
  <class type="dojox.grid.TreeSelection" superclass="DataSelection">
    <methods>
      <method name="setMode" scope="instance">
        <parameters>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedCount" scope="instance"/>
      <method name="getSelected" scope="instance"/>
      <method name="getNextSelected" scope="instance">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="instance"/>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeSortedSelection" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_insertSortedSelection" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_comparePaths" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_bsearch" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="DataSelection" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeSelection.grid.layout"/>
  <class type="dojox.grid.TreeSelection.grid">
    <properties>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="util"/>
  <class type="dojox.grid._CheckBoxSelector" superclass="_Selector">
    <methods>
      <method name="renderHeader" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onSelectionChanged" scope="instance"/>
      <method name="_updateVisibility" scope="instance">
        <parameters>
          <parameter name="rowCount" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._EditManager">
    <methods>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="start" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inEditing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
          <parameter name="inView" type="Object" usage="required">
            <description>Grid view</description>
          </parameter>
        </parameters>
      </method>
      <method name="rowClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="restore" scope="instance">
        <parameters>
          <parameter name="inView" type="Object" usage="required">
            <description>Grid view</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="isEditing" scope="instance">
        <return-description>Boolean
	True if grid is actively editing</return-description>
      </method>
      <method name="isEditRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if given row is being edited</return-description>
      </method>
      <method name="isEditCell" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
          <parameter name="inCellIndex" type="Integer" usage="required">
            <description>Grid cell index</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if given cell is being edited</return-description>
      </method>
      <method name="focusEditor" scope="instance"/>
      <method name="editorCancel" scope="instance"/>
      <method name="editorApply" scope="instance"/>
      <method name="dispatchEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="dojox.Grid" usage="required">
            <description>The dojox.Grid this editor should be attached to</description>
          </parameter>
        </parameters>
      </method>
      <method name="cellFocus" scope="instance">
        <parameters>
          <parameter name="inCell" type="cell" usage="required">
            <description>object
	Grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="cancel" scope="instance"/>
      <method name="applyRowEdit" scope="instance"/>
      <method name="applyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance"/>
      <method name="_shouldCatchBoomerang" scope="instance"/>
      <method name="_isValidInput" scope="instance"/>
      <method name="_focusEditor" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_editorDo" scope="instance">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doCatchBoomerang" scope="instance"/>
      <method name="_boomerangFocus" scope="instance"/>
    </methods>
    <properties>
      <property name="info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._EditManager.info"/>
  <class type="dojox.grid._Events">
    <description>Default synthetic events dispatched for _Grid. dojo.connect to events to
	retain default implementation or override them for custom handling.</description>
    <methods>
      <method name="onStyleRow" scope="instance">
        <examples>
          <example>onStyleRow({ selected: true, over:true, odd:false })</example>
        </examples>
        <parameters>
          <parameter name="inRow" type="Object" usage="required">
            <description>Object containing row state information: selected, true if the row is selcted; over:
	true of the mouse is over the row; odd: true if the row is odd. Use customClasses and
	customStyles to control row css classes and styles; both properties are strings.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onStartEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Cell object containing properties of the grid column.</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectionChanged" scope="instance"/>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOverRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOutRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDownRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellFocus" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Cell object containing properties of the grid column.</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCanSelect" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true if the row can be selected</return-description>
      </method>
      <method name="onCanDeselect" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true if the row can be deselected</return-description>
      </method>
      <method name="onApplyEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="String" usage="required">
            <description>Value from cell editor</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
          <parameter name="inFieldIndex" type="Integer" usage="required">
            <description>Index in the grid's data store</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="focus" scope="instance" type="Object"/>
      <property name="_click" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Events.focus"/>
  <class type="dojox.grid._Events._click"/>
  <class type="dojox.grid._FocusManager">
    <methods>
      <method name="tabOut" scope="instance">
        <parameters>
          <parameter name="inFocusNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusIndex" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inCellIndex" type="int" usage="required">
            <description>grid cell index</description>
          </parameter>
        </parameters>
      </method>
      <method name="setFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <description>grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance"/>
      <method name="previousKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="previous" scope="instance"/>
      <method name="nextKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="instance"/>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="inRowDelta" type="int" usage="required">
            <description>vertical distance from current focus</description>
          </parameter>
          <parameter name="inColDelta" type="int" usage="required">
            <description>horizontal distance from current focus</description>
          </parameter>
        </parameters>
      </method>
      <method name="isNoFocusCell" scope="instance"/>
      <method name="isNavHeader" scope="instance">
        <return-description>true if focus is on a column header; false otherwise.</return-description>
      </method>
      <method name="isLastFocusCell" scope="instance"/>
      <method name="isFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <description>grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>true of the given grid cell is focused</return-description>
      </method>
      <method name="isFirstFocusCell" scope="instance"/>
      <method name="initFocusView" scope="instance"/>
      <method name="getHeaderIndex" scope="instance">
        <return-description>index of the focused column header, or -1 if none have focus.</return-description>
      </method>
      <method name="focusHeader" scope="instance"/>
      <method name="focusGridView" scope="instance"/>
      <method name="focusGrid" scope="instance">
        <parameters>
          <parameter name="inSkipFocusCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findAndFocusGridCell" scope="instance">
        <return-description>Boolean
	true if focus was set to a cell
	false if no cell found to set focus onto</return-description>
      </method>
      <method name="doLastNodeFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doLastNodeBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="colSizeAdjust" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="colIdx" type="Object" usage="required"/>
          <parameter name="delta" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="can't adjust single col. grid"/>
        </return-types>
      </method>
      <method name="blurHeader" scope="instance"/>
      <method name="_setActiveColHeader" scope="instance">
        <parameters>
          <parameter name="colHeaderNode" type="Node" usage="required"/>
          <parameter name="colFocusIdx" type="Integer" usage="required"/>
          <parameter name="prevColFocusIdx" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollInfo" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="domNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollHeader" scope="instance">
        <parameters>
          <parameter name="currentIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isHeaderHidden" scope="instance">
        <return-description>Boolean
	true if headers are hidden
	false if headers are not hidden</return-description>
      </method>
      <method name="_initColumnHeaders" scope="instance"/>
      <method name="_focusifyCellNode" scope="instance">
        <parameters>
          <parameter name="inBork" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_findHeaderCells" scope="instance"/>
      <method name="_delayedHeaderFocus" scope="instance"/>
      <method name="_delayedCellFocus" scope="instance"/>
    </methods>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="cell" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager.cell.view.scrollboxNode"/>
  <class type="dojox.grid._FocusManager.grid"/>
  <class type="dojox.grid._FocusManager.cell"/>
  <class type="dojox.grid._Grid" superclass="_Widget">
    <description>_Grid provides the full set of grid features without any
	direct connection to a data store.
	
	The grid exposes a get function for the grid, or optionally
	individual columns, to populate cell contents.
	
	The grid is rendered based on its structure, an object describing
	column and cell layout.</description>
    <methods>
      <method name="updateRows" scope="instance">
        <parameters>
          <parameter name="startIndex" type="Integer" usage="required">
            <description>Index of the starting row to render</description>
          </parameter>
          <parameter name="howMany" type="Integer" usage="required">
            <description>How many rows to update.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowCount" scope="instance">
        <parameters>
          <parameter name="inRowCount" type="int" usage="required">
            <description>Number of rows in the grid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the row to render</description>
          </parameter>
        </parameters>
      </method>
      <method name="update" scope="instance"/>
      <method name="textSizeChanged" scope="instance"/>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="sort" scope="instance"/>
      <method name="sizeChange" scope="instance"/>
      <method name="showMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setupHeaderMenu" scope="instance"/>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="dojox.grid.__ViewDef|Array&lt;dojox.grid.__ViewDef&gt;|Array&lt;dojox.grid.__CellDef&gt;|Array&lt;Array[dojox.grid.__CellDef&gt;]" usage="required"/>
        </parameters>
      </method>
      <method name="setSortInfo" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSortIndex" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <description>Column index on which to sort.</description>
          </parameter>
          <parameter name="inAsc" type="Boolean" usage="required">
            <description>If true, sort the grid in ascending order, otherwise in descending order</description>
          </parameter>
        </parameters>
      </method>
      <method name="setScrollTop" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setHeaderMenu" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="setCellWidth" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inUnitWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scrollToRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollTo" scope="instance">
        <parameters>
          <parameter name="inTop" type="Integer" usage="required">
            <description>vertical position of the grid in pixels</description>
          </parameter>
        </parameters>
      </method>
      <method name="rowRemoved" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>index of the row that has changed height</description>
          </parameter>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="removeSelectedRows" scope="instance"/>
      <method name="prerender" scope="instance"/>
      <method name="postresize" scope="instance"/>
      <method name="postrender" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onResizeColumn" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveColumn" scope="instance"/>
      <method name="hasLayout" scope="instance"/>
      <method name="getSortIndex" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getSortAsc" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnTogglingItems" scope="instance"/>
      <method name="getCellName" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getCell" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <description>Grid column index of cell to retrieve</description>
          </parameter>
        </parameters>
        <return-description>a grid cell</return-description>
      </method>
      <method name="finishScrollJob" scope="instance"/>
      <method name="endUpdate" scope="instance"/>
      <method name="dokeydown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderdblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheadercontextmenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dodblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="docontextmenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inFieldIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="defaultUpdate" scope="instance"/>
      <method name="createViews" scope="instance"/>
      <method name="createView" scope="instance">
        <parameters>
          <parameter name="inClass" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createSelection" scope="instance"/>
      <method name="createScroller" scope="instance"/>
      <method name="createManagers" scope="instance"/>
      <method name="createLayout" scope="instance"/>
      <method name="canSort" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Integer" usage="required">
            <description>Sort information, 1-based index of column on which to sort, positive for an ascending sort
	and negative for a descending sort</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if grid can be sorted on the given column in the given direction</return-description>
      </method>
      <method name="buildViews" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="beginUpdate" scope="instance"/>
      <method name="addRow" scope="instance"/>
      <method name="adaptWidth" scope="instance"/>
      <method name="adaptHeight" scope="instance">
        <parameters>
          <parameter name="inHeaderHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_structureChanged" scope="instance"/>
      <method name="_setStructureAttr" scope="instance">
        <parameters>
          <parameter name="structure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setHeaderMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setAutoHeightAttr" scope="instance">
        <parameters>
          <parameter name="ah" type="Object" usage="required"/>
          <parameter name="skipRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_render" scope="instance"/>
      <method name="_mouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowCountAttr" scope="instance"/>
      <method name="_getPadBorder" scope="instance"/>
      <method name="_getHeaderHeight" scope="instance"/>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dispatch" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
      <mixin type="_Events.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
      <mixin type="_Events" scope="instance"/>
    </mixins>
    <properties>
      <property name="viewsHeaderNode" scope="instance" type="Object"/>
      <property name="views" scope="instance" type="Object"/>
      <property name="scroller" scope="instance" type="Object"/>
      <property name="messagesNode" scope="instance" type="Object"/>
      <property name="layout" scope="instance" type="Object"/>
      <property name="invalidated" scope="instance" type="Array"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.domNode.style"/>
  <class type="dojox.grid._Grid.scroller"/>
  <class type="dojox.grid._Grid.views"/>
  <class type="dojox.grid._Grid.layout"/>
  <class type="dojox.grid._Grid.focus"/>
  <class type="dojox.grid._Grid.messagesNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.messagesNode.style"/>
  <class type="dojox.grid._Grid.viewsHeaderNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.viewsHeaderNode.style"/>
  <class type="dojox.grid._Grid.viewsNode.style"/>
  <class type="dojox.grid._Grid.invalidated"/>
  <class type="dojox.grid.__CellDef">
    <methods>
      <method name="get" scope="instance"/>
      <method name="formatter" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.__ViewDef">
    <methods>
      <method name="onBeforeRow" scope="instance"/>
      <method name="onAfterRow" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid._Layout">
    <methods>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColumnVisibility" scope="instance">
        <parameters>
          <parameter name="columnIndex" type="Object" usage="required"/>
          <parameter name="visible" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveColumn" scope="instance">
        <parameters>
          <parameter name="sourceViewIndex" type="Object" usage="required"/>
          <parameter name="destViewIndex" type="Object" usage="required"/>
          <parameter name="cellIndex" type="Object" usage="required"/>
          <parameter name="targetIndex" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addViewDef" scope="instance">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowsDef" scope="instance">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Layout.grid"/>
  <class type="dojox.grid._RadioSelector" superclass="_Selector">
    <methods>
      <method name="renderHeader" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Selector" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid._RowManager">
    <methods>
      <method name="updateStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOverRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="prepareStylingRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isOver" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyStyles" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid._RowSelector" superclass="_View">
    <methods>
      <method name="updateRow" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="renderHeader" scope="instance"/>
      <method name="getWidth" scope="instance"/>
      <method name="domouseover" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRowContent" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="adaptWidth" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_View" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid._RowSelector.scrollboxNode.style"/>
  <class type="dojox.grid._RowSelector.headerNode.style"/>
  <class type="dojox.grid._Scroller">
    <methods>
      <method name="updateRowCount" scope="instance">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updatePageHeight" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="fromBuild" type="Object" usage="required"/>
          <parameter name="fromAsynRendering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateContentHeight" scope="instance">
        <parameters>
          <parameter name="inDh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startPacify" scope="instance"/>
      <method name="setPacifying" scope="instance">
        <parameters>
          <parameter name="inPacifying" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setKeepInfo" scope="instance">
        <parameters>
          <parameter name="inKeepRows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setContentNodes" scope="instance">
        <parameters>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scroll" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="fromAsynRendering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="repositionPages" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inPageNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pushPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processNodeEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preparePage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPageNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popPage" scope="instance"/>
      <method name="pageExists" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pacify" scope="instance">
        <parameters>
          <parameter name="inShouldPacify" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onscroll" scope="instance"/>
      <method name="needPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measurePage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidatePageNode" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidateNodes" scope="instance"/>
      <method name="invalidate" scope="instance"/>
      <method name="installPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
          <parameter name="inKeepRows" type="Object" usage="required"/>
          <parameter name="inRowsPerPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getScrollBottom" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageNodePosition" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageHeight" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastVisibleRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inBottom" type="Object" usage="required"/>
          <parameter name="inScrollBottom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastPageRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstVisibleRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inPageTop" type="Object" usage="required"/>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultPageNode" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultNodes" scope="instance"/>
      <method name="findTopRow" scope="instance">
        <parameters>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findScrollTop" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findPage" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endPacify" scope="instance"/>
      <method name="doPacify" scope="instance"/>
      <method name="destroyPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="createPageNode" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inContentNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calcLastPageHeight" scope="instance"/>
      <method name="buildPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageCount" scope="instance">
        <parameters>
          <parameter name="rowCount" type="Object" usage="required"/>
          <parameter name="rowsPerPage" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="scrollboxNode" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.scrollboxNode"/>
  <class type="dojox.grid._Scroller.grid.viewsNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.grid.viewsNode.style"/>
  <class type="dojox.grid._Scroller.grid">
    <properties>
      <property name="viewsNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._SelectionPreserver">
    <description>When this feature is turned on, Grid will try to preserve selections across actions, e.g. sorting, filtering etc.
	
	Precondition - Identifier(id) is required for store since id is the only way for differentiating row items.
	Known issue - The preserved selections might be inaccurate if some unloaded rows are previously selected by range(e.g.SHIFT + click)</description>
    <methods>
      <method name="reset" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="selection" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectById" scope="instance">
        <parameters>
          <parameter name="toSelect" type="Object" usage="required"/>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_reSelectById" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder" superclass="_Builder._HeaderBuilder.prototype">
    <methods>
      <method name="generateHtml" scope="instance"/>
      <method name="doclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.generateHtml">
    <methods/>
    <properties>
      <property name="view" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.generateHtml.view"/>
  <class type="dojox.grid._InputSelectorHeaderBuilder.doclick">
    <methods/>
    <properties>
      <property name="view" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.doclick.view"/>
  <class type="dojox.grid._SelectorContentBuilder" superclass="_Builder._ContentBuilder.prototype">
    <methods>
      <method name="getCellContent" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generateHtml" scope="instance">
        <parameters>
          <parameter name="inDataIndex" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTarget" scope="instance"/>
      <method name="domouseover" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.generateHtml">
    <methods/>
    <properties>
      <property name="view" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.generateHtml.view"/>
  <class type="dojox.grid._SelectorContentBuilder.doclick">
    <methods/>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.doclick.view.grid.selection"/>
  <class type="dojox.grid._InputSelectorContentBuilder" superclass="_SelectorContentBuilder.prototype">
    <methods>
      <method name="getCellContent" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid._InputSelectorContentBuilder.getCellContent">
    <methods/>
  </class>
  <class type="dojox.grid._Selector" superclass="_View">
    <methods>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="instance"/>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="adaptWidth" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_View" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid._Selector.grid.selection"/>
  <class type="dojox.grid._Selector.scrollboxNode.style"/>
  <class type="dojox.grid._RadioSelector.headerNode.style"/>
  <class type="dojox.grid._CheckBoxSelector.headerNode.style"/>
  <class type="dojox.grid._CheckBoxSelector.grid"/>
  <class type="dojox.grid._Expando" superclass="_Widget">
    <methods>
      <method name="setRowNode" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOpen" scope="instance">
        <parameters>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onToggle" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleRows" scope="instance">
        <parameters>
          <parameter name="toggleClass" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setOpen" scope="instance">
        <parameters>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="view" scope="instance" type="Object"/>
      <property name="expandoInner" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Expando.view">
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Expando.view.grid"/>
  <class type="dojox.grid._Expando.expandoInner"/>
  <class type="dojox.grid._TreeContentBuilder" superclass="_Builder._ContentBuilder">
    <methods>
      <method name="getCellNode" scope="instance">
        <parameters>
          <parameter name="inRowNode" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generateHtml" scope="instance">
        <parameters>
          <parameter name="inDataIndex" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="findTarget" scope="instance">
        <parameters>
          <parameter name="inSource" type="Object" usage="required"/>
          <parameter name="inTag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decorateEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Builder._ContentBuilder" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeContentBuilder.view.structure.cells"/>
  <class type="dojox.grid._TreeContentBuilder.grid"/>
  <class type="dojox.grid._TreeView" superclass="_View">
    <methods>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onBeforeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_View" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid._View" superclass="_Widget">
    <methods>
      <method name="updateStructure" scope="instance"/>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="instance"/>
      <method name="testFlexCells" scope="instance"/>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSize" scope="instance">
        <parameters>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColumnsWidth" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColWidth" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onBeforeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasVScrollbar" scope="instance">
        <parameters>
          <parameter name="reset" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasHScrollbar" scope="instance">
        <parameters>
          <parameter name="reset" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getWidth" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getScrollbarWidth" scope="instance">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeaderCellNode" scope="instance">
        <parameters>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getContentWidth" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getColumnsWidth" scope="instance">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getCellNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="doscroll" scope="instance">
        <parameters>
          <parameter name="inEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="createRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="convertColPctToFixed" scope="instance"/>
      <method name="buildRowContent" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="instance"/>
      <method name="adaptHeight" scope="instance">
        <parameters>
          <parameter name="minusScroll" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDndDropBefore" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBeforeRow" scope="instance"/>
      <method name="_onAfterRow" scope="instance"/>
      <method name="_hide" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getHeaderContent" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupRowWidgets" scope="instance">
        <parameters>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="source" scope="instance" type="Object"/>
      <property name="scrollboxNode" scope="instance" type="Object"/>
      <property name="headerNode" scope="instance" type="Object"/>
      <property name="headerContentNode" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerNodeContainer.style"/>
  <class type="dojox.grid._View.scrollboxNode.style"/>
  <class type="dojox.grid._View.headerContentNode.firstChild.style"/>
  <class type="dojox.grid._View.grid.layout"/>
  <class type="dojox.grid._View.source"/>
  <class type="dojox.grid._View.grid.views"/>
  <class type="dojox.grid._View.grid">
    <properties>
      <property name="views" scope="instance" type="Object"/>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerContentNode"/>
  <class type="dojox.grid._View.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.contentNode.style"/>
  <class type="dojox.grid._View.headerNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.domNode.style"/>
  <class type="dojox.grid._View.headerNode.style"/>
  <class type="dojox.grid._View.scrollboxNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._GridAvatar" superclass="Avatar">
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="construct" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="Avatar" scope="instance"/>
    </mixins>
    <properties>
      <property name="manager" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._GridAvatar.manager"/>
  <class type="dojox.grid._ViewManager">
    <description>Grid creates views automatically based on grid's layout structure.
	Users should typically not need to access individual views or the views collection directly.</description>
    <methods>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="skipRenorm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="resetHeaderNodeHeight" scope="instance"/>
      <method name="renormalizeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
          <parameter name="skipRenorm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="onEach" scope="instance">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
          <parameter name="inArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeRowNodeHeights" scope="instance">
        <parameters>
          <parameter name="inRowNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeHeaderNodeHeight" scope="instance"/>
      <method name="measureHeader" scope="instance"/>
      <method name="measureContent" scope="instance"/>
      <method name="getViewWidth" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstScrollingView" scope="instance"/>
      <method name="getContentNodes" scope="instance"/>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="inCallback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findClient" scope="instance">
        <parameters>
          <parameter name="inAutoWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyViews" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrange" scope="instance">
        <parameters>
          <parameter name="l" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addView" scope="instance">
        <parameters>
          <parameter name="inView" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="views" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid._ViewManager.views"/>
  <class type="dojox.grid._DeferredTextWidget" superclass="_Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells">
    <methods>
      <method name="_Widget" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Base" scope="instance">
        <parameters>
          <parameter name="inProps" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="SingleRowSelector" scope="instance"/>
      <method name="Select" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="RowSelector" scope="instance"/>
      <method name="RowIndex" scope="instance"/>
      <method name="MultipleRowSelector" scope="instance"/>
      <method name="Editor" scope="instance"/>
      <method name="DateTextBox" scope="instance"/>
      <method name="ComboBox" scope="instance"/>
      <method name="CheckBox" scope="instance"/>
      <method name="Cell" scope="instance"/>
      <method name="Bool" scope="instance"/>
      <method name="AlwaysEdit" scope="instance"/>
    </methods>
    <properties>
      <property name="TreeCell" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base">
    <methods>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inValue" type="anything" usage="required">
            <description>value of editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="restore" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="registerOnBlur" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="needFormatNode" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isFlex" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>value of editor</return-description>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>dom node for a given grid cell</return-description>
      </method>
      <method name="getHeaderNode" scope="instance"/>
      <method name="getEditNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="dom" usage="required">
            <description>node
	dom node for the editor</description>
          </parameter>
          <parameter name="inDatum" type="anything" usage="required">
            <description>cell data to edit</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="anything" usage="required">
            <description>cell data to edit</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>string of html to place in grid cell</return-description>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inItem" type="Object" usage="required"/>
        </parameters>
        <return-description>html for a given grid cell</return-description>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inNode" type="dom" usage="required">
            <description>node
	editor node</description>
          </parameter>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inProps" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelFormatNode" scope="instance"/>
      <method name="cancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="canResize" scope="instance"/>
      <method name="applyEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onEditBlur" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_formatNode" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_defaultFormat" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="callArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base.grid">
    <properties>
      <property name="edit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base.grid.edit"/>
  <class type="dojox.grid.cells.Cell" superclass="BaseCell">
    <methods>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_finish" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="BaseCell" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.RowIndex" superclass="Cell">
    <methods>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Cell" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.Select" superclass="Cell">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultFormat" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="callArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Cell" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.AlwaysEdit" superclass="Cell">
    <methods>
      <method name="applyStaticValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_formatNode" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Cell" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.AlwaysEdit.grid"/>
  <class type="dojox.grid.cells.Bool" superclass="AlwaysEdit">
    <methods>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="AlwaysEdit" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells._Widget" superclass="BaseCell">
    <methods>
      <method name="sizeWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attachWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHTML" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="BaseCell" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.ComboBox" superclass="_Widget">
    <methods>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.DateTextBox" superclass="_Widget">
    <methods>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.CheckBox" superclass="_Widget">
    <methods>
      <method name="sizeWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.Editor" superclass="_Widget">
    <methods>
      <method name="populateEditor" scope="instance"/>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.TreeCell">
    <methods>
      <method name="getOpenState" scope="instance">
        <parameters>
          <parameter name="itemId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatIndexes" scope="instance">
        <parameters>
          <parameter name="inRowIndexes" type="Object" usage="required"/>
          <parameter name="inItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatAtLevel" scope="instance">
        <parameters>
          <parameter name="inRowIndexes" type="Object" usage="required"/>
          <parameter name="inItem" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="summaryRow" type="Object" usage="required"/>
          <parameter name="toggleClass" type="Object" usage="required"/>
          <parameter name="cellClasses" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatAggregate" scope="instance">
        <parameters>
          <parameter name="inItem" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="inRowIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatAggregate">
    <methods/>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatAggregate.grid.edit"/>
  <class type="dojox.grid.cells.TreeCell.formatIndexes">
    <methods/>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatIndexes.grid.edit"/>
  <class type="dojox.grid.cells.TreeCell.getOpenState">
    <methods/>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.getOpenState.grid"/>
  <class type="dojox.grid.cells.TreeCell.formatAtLevel">
    <methods/>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatAtLevel.grid"/>
  <class type="dojox.grid.enhanced._Events">
    <description>Methods are copied or replaced for overwriting, this might be refined once
	an overall plugin architecture is set up for DataGrid.</description>
    <methods>
      <method name="onSelectedRegionContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid and info of selected
	regions(selection type - row|column, selected index - [...])</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowSelectorMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowSelectorMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUpRow" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseup" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domousedown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dokeyup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Un-decorated event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_click" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._Events._click"/>
  <class type="dojox.grid.enhanced._FocusArea">
    <methods>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="keyup" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="keydown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="headerMouseEventPlanner" scope="instance"/>
      <method name="contentMouseEventPlanner" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
          <parameter name="focusManager" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="funcName" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_evtStack" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusArea._evtStack"/>
  <class type="dojox.grid.enhanced._FocusManager" superclass="_FocusManager">
    <methods>
      <method name="tab" scope="instance">
        <parameters>
          <parameter name="step" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="removeArea" scope="instance">
        <parameters>
          <parameter name="areaName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="previousKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeArea" scope="instance">
        <examples>
          <example>placeArea("myarea","before"|"after",...)
	placeArea("myarea","below"|"above",...)</example>
        </examples>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="otherAreaName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isNavHeader" scope="instance"/>
      <method name="initFocusView" scope="instance"/>
      <method name="ignoreArea" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="headerMouseEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getArea" scope="instance">
        <parameters>
          <parameter name="areaName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusArea" scope="instance">
        <parameters>
          <parameter name="areaId" type="int|string|areaObj" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findAndFocusGridCell" scope="instance"/>
      <method name="doLastNodeFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="currentArea" scope="instance">
        <parameters>
          <parameter name="areaName" type="String" usage="required"/>
          <parameter name="toBlurOld" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="contentMouseEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stopEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setActiveColHeader" scope="instance"/>
      <method name="_onMouseEvent" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEditableCellMouseEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEditableCellKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onContentKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_navHeader" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_navContent" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initNavigatableElems" scope="instance"/>
      <method name="_focusEditableCell" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_focusContent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doBlur" scope="instance"/>
      <method name="_delayedHeaderFocus" scope="instance"/>
      <method name="_delayedCellFocus" scope="instance"/>
      <method name="_changeMenuBindNode" scope="instance">
        <parameters>
          <parameter name="oldBindNode" type="Object" usage="required"/>
          <parameter name="newBindNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurEditableCell" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurContent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_bindAreaEvents" scope="instance"/>
      <method name="_applyEditableCell" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_FocusManager" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="_navElems" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager.grid">
    <properties>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager._navElems"/>
  <class type="dojox.grid.enhanced._FocusManager.grid.layout"/>
  <class type="dojox.grid.enhanced._Plugin">
    <description>Provides common plugin functionality and basic life cycle management.
	
	Each concrete plugin must have a name field and is responsible for registering itself to the global plugin registry
	e.g. for dnd plugin:
			dojox.grid.EnhancedGrid.registerPlugin("dnd" /*plugin name*/,
													dojox.grid.enhanced.plugins.DnD /*full class name of a plugin
													{"preInit": false, "dependency": ["nestedSorting"]} /*properties*/);
	
	[Keywords] of plugin properties(case sensitive)
	- "preInit": boolean, whether a plugin should be created before EnhancedGrid.postCreate(),
	false by default(plugins are created after EnhancedGrid.postCreate()).
	- "dependency": array or string, plugin(s) indicated by "dependency" will be created before the current one.
	Note: recursive cycle dependencies are not supported e.g. following dependency is invalid:
	pluginA -&gt; pluginB -&gt; pluginA</description>
    <methods>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <examples>
          <example>	var plugin = new dojox.grid.enhanced._Plugin(grid,"myPlugin",{...});
		// when /my/topic is published, call the subscriber in the scope of plugin
		// with passed parameter - "v"
		plugin.subscribe("/my/topic", function(v){
			console.debug(this.xxx(v));//"this" - plugin scope
		});</example>
        </examples>
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStartUp" scope="instance"/>
      <method name="onSetStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPreInit" scope="instance"/>
      <method name="onPostInit" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="disconnect" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <examples>
          <example>	var plugin = new dojox.grid.enhanced._Plugin(grid,"myPlugin",{...});
		// when foo.bar() is called, call the listener in the scope of plugin
		plugin.connect(foo, "bar", function(){
			console.debug(this.xxx());//"this" - plugin scope
		});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced._PluginManager">
    <description>Plugin manager is responsible for
	1. Loading required plugins
	2. Handling collaborat	ion and dependencies among plugins
	
	Some plugin dependencies:
	- "columnReordering" attribute won't work when either DnD or Indirect Selections plugin is on.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="preInit" scope="instance"/>
      <method name="postInit" scope="instance"/>
      <method name="pluginExisted" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plugin name
	return: Boolean
	True - existed | False - not existed</description>
          </parameter>
        </parameters>
      </method>
      <method name="loadPlugin" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plugin name
	return: Object
	The newly loaded plugin</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="return if no plugin option"/>
          <return-type type="return if plugin(&quot;name&quot;) already existed"/>
        </return-types>
      </method>
      <method name="isFixedCell" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required">
            <description>Target cell(column)
	return: Boolean
	True - fixed| False - not fixed</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPluginClazz" scope="instance">
        <parameters>
          <parameter name="clazz" type="class" usage="required">
            <description>| String
	Plugin class</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="return if it's already a clazz"/>
        </return-types>
      </method>
      <method name="getPlugin" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plugin name
	return: Object
	Plugin instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="func" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseProps" scope="instance">
        <parameters>
          <parameter name="plugins" type="Object" usage="required">
            <description>Plugin properties defined by user</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalize" scope="instance">
        <parameters>
          <parameter name="p" type="String" usage="required">
            <description>Plugin name</description>
          </parameter>
          <parameter name="plugins" type="Object" usage="required">
            <description>Plugin properties set by user</description>
          </parameter>
          <parameter name="registry" type="Object" usage="required">
            <description>The global plugin registry</description>
          </parameter>
          <parameter name="loading" type="Object" usage="required">
            <description>Map for checking process state</description>
          </parameter>
        </parameters>
      </method>
      <method name="_initView" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_init" scope="instance">
        <parameters>
          <parameter name="pre" type="Boolean" usage="required">
            <description>True - preInit | False - postInit(by default)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="_plugins" scope="instance-prototype" type="Array">
        <description>Plugin list</description>
      </property>
      <property name="_options" scope="instance-prototype" type="Object">
        <description>Normalized plugin options</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager.grid">
    <properties>
      <property name="edit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager.grid.edit">
    <methods>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced._PluginManager._options"/>
  <class type="dojox.grid.enhanced._PluginManager._plugins"/>
  <class type="dojox.grid.enhanced.plugins">
    <methods>
      <method name="_StoreLayer" scope="instance"/>
      <method name="_ServerSideLayer" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_SelectionPreserver" scope="instance">
        <description>Extends dojox.grid._SelectionPreserver adding a bit more support to make selection persistence working well
	with various EnhancedGrid features, e.g. filtering, nested sorting, pagination, select all etc.
	
	Precondition - Identifier(id) is required for store, as id is used for differentiating row items.
	Known issue - The preserved selections might be inaccurate if some unloaded rows are previously selected by range(e.g.SHIFT + click)</description>
        <examples>
          <example>	//To turn on this - set 'keepSelection' attribute to true
		&lt;div dojoType="dojox.grid.EnhancedGrid" keepSelection = true .../&gt;</example>
        </examples>
        <parameters>
          <parameter name="selection" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_RowMapLayer" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Paginator" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ForcedPageStoreLayer" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Selector" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Search" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Rearrange" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Printer" scope="instance">
        <examples>
          <example>	dojo.require("dojox.grid.enhanced.plugins.Printer");
		dijit.byId("grid1").printGrid("my grid",					//A title for the grid,optional
									["cssfile1.css","cssfile2.css"],//An array of css files to decorate the printed gird,optional
									{table:"border='border'"}		//tagName:"attrbuteList" pairs, optional,
																	//control the html tags in the generated html
		);</example>
        </examples>
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Pagination" scope="instance">
        <description>boolean
	Whether the description information will be displayed, true by default.</description>
      </method>
      <method name="NestedSorting" scope="instance">
        <description>A flexible way to control multiple column sorting, including
	1. Set default sorting order
	2. Disable sorting for certain columns
	3. Set sorting order dynamically with JS API</description>
        <examples>
          <example>	&lt;script type="text/javascript"&gt;
			var grid = new dojox.grid.EnhancedGrid({plugins : {nestedSorting: true}},
		               sortFields: [{attribute: 'col4', descending: false},...],//set default sorting order
				       canSort: function(index, field){ return true},//disable sorting for a column
					   ... }, dojo.byId('gridDiv'));
			grid.startup();
			//set new sorting order
			grid.setSortIndex([{attribute: 'col3', descending: true},...])
		&lt;/script&gt;</example>
        </examples>
      </method>
      <method name="Menu" scope="instance">
        <examples>
          <example>&lt;div dojoType="dojox.grid.EnhancedGrid"
	plugins="{menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",
	selectedRegionMenu:"selectedRegionMenuId"}}" ...&gt;
	&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="IndirectSelection" scope="instance">
        <description>For better rendering performance, div(images) are used to simulate radio button|check boxes</description>
        <examples>
          <example>&lt;div dojoType="dojox.grid.EnhancedGrid" plugins="{indirectSelection: true}" ...&gt;&lt;/div&gt;
	or &lt;div dojoType="dojox.grid.EnhancedGrid" plugins="{indirectSelection: {name: 'xxx', width:'30px', styles:'text-align: center;'}}" ...&gt;&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="GridSource" scope="instance"/>
      <method name="GridDnDSource" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="param" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GridDnDElement" scope="instance">
        <parameters>
          <parameter name="dndPlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="GridDnDAvatar" scope="instance"/>
      <method name="Filter" scope="instance">
        <examples>
          <example>	&lt;div dojoType="dojox.grid.EnhancedGrid" plugins="{GridFilter: true}" ...&gt;&lt;/div&gt;
		or provide some parameters:
		&lt;div dojoType="dojox.grid.EnhancedGrid" plugins="{GridFilter: {itemsName: 'songs'}}" ...&gt;&lt;/div&gt;
		Customize columns for filter:
		var layout = [
			...
			//define a column to be un-filterable in layout/structure
			{field: "Genre", filterable: false, ...}
			//define a column of type string and supports autoComplete when you type in filter conditions.
			{field: "Writer", datatype: "string", autoCommplete: true, ...}
			//define a column of type date and the data in store has format: "yyyy/M/d"
			{field: "Publish Date", datatype: "date", dataTypeArgs: {datePattern: "yyyy/M/d"}, ...}
			//disable some conditions for a column
			{field: "Track", disabledConditions: ["equalto","notequalto"], ...}
			...
		];</example>
        </examples>
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Exporter" scope="instance">
        <examples>
          <example>	function onExported(exported_text){
			//custom code here...
		}
		dijit.byId("my_grid_id").exportTo("csv",	//registered export format, mandatory
			{										//the whole object is optional.
				fetchArgs: {start:0,count:1000},	//keywordArgs for fetch, optional
				writerArgs: {separator:';'},		//export writer specific arguments, optional
			},
			function(str){
				//call back function, mandatory
		});
		var result = dijit.byId("my_grid_id").exportSelectedTo("table",     //registered export format, mandatory
															{separator:'|'} //export writer specific arguments, optional
		);</example>
        </examples>
        <parameters>
          <parameter name="grid" type="EnhancedGrid" usage="required">
            <description>The grid to plug in to.</description>
          </parameter>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DnD" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Dialog" scope="instance"/>
      <method name="Cookie" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="CellMerge" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="AutoScroll" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="pagination" scope="instance" type="Object"/>
      <property name="filter" scope="instance" type="Object"/>
      <property name="exporter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.AutoScroll" superclass="_Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollColumn" scope="instance">
        <parameters>
          <parameter name="isForward" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_manageAutoScroll" scope="instance">
        <parameters>
          <parameter name="toStop" type="Object" usage="required"/>
          <parameter name="isVertical" type="Object" usage="required"/>
          <parameter name="isForward" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initEvents" scope="instance"/>
      <method name="_fireEvent" scope="instance">
        <parameters>
          <parameter name="eventName" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScroll" scope="instance">
        <parameters>
          <parameter name="isVertical" type="Object" usage="required"/>
          <parameter name="isForward" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.AutoScroll.grid">
    <methods>
      <method name="onStartAutoScroll" scope="instance"/>
      <method name="onEndAutoScroll" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge" superclass="_Plugin">
    <methods>
      <method name="unmergeCells" scope="instance">
        <parameters>
          <parameter name="mergeHandler" type="object" usage="required">
            <description>A handler for the merged cells created by a call of function mergeCells.</description>
          </parameter>
        </parameters>
      </method>
      <method name="mergeCells" scope="instance">
        <parameters>
          <parameter name="rowTester" type="Function(Integer))|Integer" usage="required">
            <description>If it's a function, it's a predicate to decide which rows are to be merged.
	It takes an integer (the row index), and should return true or false;</description>
          </parameter>
          <parameter name="startColumnIndex" type="Integer" usage="required">
            <description>The column index of the left most cell that shall be merged.</description>
          </parameter>
          <parameter name="endColumnIndex" type="Integer" usage="required">
            <description>The column index of the right most cell that shall be merged.</description>
          </parameter>
          <parameter name="majorColumnIndex" type="Integer" usage="optional">
            <description>The column index of the cell whose content should be used as the content of the merged cell.
	It must be larger than or equal to the startColumnIndex, and less than or equal to the endColumnIndex.
	If it is omitted, the content of the leading edge (left-most for ltr, right most for rtl) cell will be used.
	return: Object | null
	A handler for the merged cells created by a call of this function.
	This handler can be used later to unmerge cells using the function unmergeCells
	If the merge is not valid, returns null;</description>
          </parameter>
        </parameters>
      </method>
      <method name="getMergedCellsByRow" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMergedCells" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateRows" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setupConfig" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onAfterRow" scope="instance">
        <parameters>
          <parameter name="viewIdx" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="subrows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_isValid" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initEvents" scope="instance"/>
      <method name="_getWidth" scope="instance">
        <parameters>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRecord" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="_records" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge.grid">
    <properties>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge._records"/>
  <class type="dojox.grid.enhanced.plugins.CellMerge.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge.grid.layout.cells"/>
  <class type="dojox.grid.enhanced.plugins.Cookie" superclass="_Plugin">
    <methods>
      <method name="setCookieEnabled" scope="instance">
        <parameters>
          <parameter name="cookieName" type="String" usage="optional">
            <description>Name of a cookie handler if provided, otherwise for all cookies.</description>
          </parameter>
          <parameter name="enabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="removeCookie" scope="instance"/>
      <method name="onPreInit" scope="instance"/>
      <method name="getCookieEnabled" scope="instance">
        <parameters>
          <parameter name="cookieName" type="String" usage="optional">
            <description>Name of a cookie handler if provided, otherwise for all cookies.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCookieHandler" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An object with the following structure:
		{
			name: &amp;quot;some-string&amp;quot;,
			onLoad: /* void */ function(/* object */partOfCookie, /* EDG */grid){...},
			onSave: /* object */ function(/* EDG */grid){...}
		}</description>
          </parameter>
        </parameters>
      </method>
      <method name="_saveCookie" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Cookie.grid"/>
  <class type="dojox.grid.enhanced.plugins.Dialog" superclass="Dialog">
    <methods>
      <method name="_position" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="Dialog" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDElement">
    <methods>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="nodeId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDnDNodes" scope="instance"/>
      <method name="destroyDnDNodes" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="createDnDNodes" scope="instance">
        <parameters>
          <parameter name="dndRegion" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="dndPlugin" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDSource" superclass="Source">
    <methods>
      <method name="onDraggingOver" scope="instance"/>
      <method name="onDraggingOut" scope="instance"/>
      <method name="onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="nodeId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="param" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Source" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDAvatar" superclass="Avatar">
    <methods>
      <method name="construct" scope="instance"/>
      <method name="_getItemCount" scope="instance"/>
      <method name="_getGridDnDIconClass" scope="instance"/>
      <method name="_generateText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="Avatar" scope="instance"/>
    </mixins>
    <properties>
      <property name="manager" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDAvatar.manager"/>
  <class type="dojox.grid.enhanced.plugins.GridDnDAvatar.manager._dndPlugin.grid.layout"/>
  <class type="dojox.grid.enhanced.plugins.DnD" superclass="_Plugin">
    <methods>
      <method name="setupConfig" scope="instance">
        <examples>
          <example>The following code disables row DnD within grid,
	but still can drag rows out of grid or drag rows from other gird.
		setUpConfig({
			"row": {
				"within": false
			}
		});
	
	The opposite way is also okay:
		setUpConfig({
			"within": {
				"row": false
			}
		});
	
	And if you'd like to disable/enable a whole set, here's a shortcut:
		setUpConfig({
			"cell", true,
			"out": false
		});
	
	Because mode has higher priority than type, the following will disable row dnd within grid:
		setUpConfig({
			"within", {
				"row": false;
			},
			"row", {
				"within": true
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="config" type="Object" usage="required">
            <description>DnD configuration object.
	See the examples below.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraggingOut" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragOut" scope="instance">
        <parameters>
          <parameter name="isMove" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragIn" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
          <parameter name="isCopy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="copyOnly" scope="instance">
        <parameters>
          <parameter name="isCopyOnly" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_startDnd" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_rearrange" scope="instance"/>
      <method name="_onMouseUp" scope="instance"/>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_markTargetAnchor" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mapRegion" scope="instance">
        <parameters>
          <parameter name="srcGrid" type="Object" usage="required"/>
          <parameter name="dndRegion" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isOutOfGrid" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initEvents" scope="instance"/>
      <method name="_getVisibleHeaders" scope="instance"/>
      <method name="_getDnDRegion" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_endDnd" scope="instance">
        <parameters>
          <parameter name="destroySource" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroySource" scope="instance"/>
      <method name="_destroyMoveable" scope="instance"/>
      <method name="_destroyDnDUI" scope="instance">
        <parameters>
          <parameter name="isMovingOut" type="Object" usage="required"/>
          <parameter name="destroySource" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createSource" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createMoveable" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createDnDUI" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="isMovingIn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clear" scope="instance"/>
      <method name="_canAccept" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcRowTargetAnchorPos" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="containerPos" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="position of the insert bar"/>
        </return-types>
      </method>
      <method name="_calcColTargetAnchorPos" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="containerPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcCellTargetAnchorPos" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="containerPos" type="Object" usage="required"/>
          <parameter name="targetAnchor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_allDnDItemsLoaded" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="selector" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="_dndRegion" scope="instance" type="Object"/>
      <property name="_config" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._config">
    <properties>
      <property name="row" scope="instance" type="Object"/>
      <property name="col" scope="instance" type="Object"/>
      <property name="cell" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._config.row"/>
  <class type="dojox.grid.enhanced.plugins.DnD._config.col"/>
  <class type="dojox.grid.enhanced.plugins.DnD._config.cell"/>
  <class type="dojox.grid.enhanced.plugins.DnD.grid">
    <properties>
      <property name="scroller" scope="instance" type="Object"/>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.selector"/>
  <class type="dojox.grid.enhanced.plugins.DnD.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.grid.layout.cells"/>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion">
    <properties>
      <property name="selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion.selected"/>
  <class type="dojox.grid.enhanced.plugins.DnD.grid.scroller"/>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion.selected.0.min"/>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion.selected.0.max"/>
  <class type="dojox.grid.enhanced.plugins.Exporter" superclass="_Plugin">
    <methods>
      <method name="setExportFormatter" scope="instance">
        <parameters>
          <parameter name="formatter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="exportSelected" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required">
            <description>A registered export format name</description>
          </parameter>
          <parameter name="writerArgs" type="object" usage="optional">
            <description>Arguments for the given format writer</description>
          </parameter>
        </parameters>
        <return-description>string
	The exported string</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="exportGrid" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required">
            <description>A registered export format name</description>
          </parameter>
          <parameter name="args" type="object" usage="optional">
            <description>includes:
	{
	fetchArgs: object?
	Any arguments for store.fetch
	writerArgs: object?
	Arguments for the given format writer
	}</description>
          </parameter>
          <parameter name="onExported" type="Function(string))" usage="required">
            <description>Call back function when export result is ready</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="EnhancedGrid" usage="required">
            <description>The grid to plug in to.</description>
          </parameter>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_isSpecialCol" scope="instance">
        <parameters>
          <parameter name="header_cell" type="dojox.grid.__CellDef" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_goThroughGridData" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="writer" type="ExportWriter" usage="required"/>
        </parameters>
      </method>
      <method name="_getExportWriter" scope="instance">
        <parameters>
          <parameter name="fileType" type="string" usage="required"/>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="ExportWriter"/>
        </return-types>
      </method>
      <method name="_buildRow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
          <parameter name="writer" type="ExportWriter" usage="required"/>
        </parameters>
        <return-description>undefined</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="EnhancedGrid">
        <description>The grid to plug in to.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Exporter.grid"/>
  <class type="dojox.grid.enhanced.plugins.Filter" superclass="_Plugin">
    <methods>
      <method name="onSetStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_wrapStore" scope="instance"/>
      <method name="_clientFilterGetter" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="cell" type="cell" usage="required"/>
          <parameter name="rowIndex" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridSource" superclass="Source">
    <methods>
      <method name="onDropGridRows" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="rowIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropGridColumns" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="colIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropGridCells" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="leftTopCell" type="Object" usage="required"/>
          <parameter name="rightBottomCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropExternal" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="instance"/>
      <method name="onDraggingOut" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRowContent" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="rowIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnContent" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="colIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellContent" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="leftTopCell" type="Object" usage="required"/>
          <parameter name="rightBottomCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="sourcePlugin" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridSource.sourcePlugin"/>
  <class type="dojox.grid.cells.RowSelector" superclass="gridCells._Widget">
    <methods>
      <method name="toggleRow" scope="instance">
        <parameters>
          <parameter name="index" type="Integer" usage="required">
            <description>Row index</description>
          </parameter>
          <parameter name="value" type="Boolean" usage="required">
            <description>True - checked | False - unchecked</description>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="disabled" type="Boolean" usage="required">
            <description>True - disabled | False - enabled</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatter" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>Target row</description>
          </parameter>
        </parameters>
      </method>
      <method name="disabled" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_toggleDisabledStyle" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleCheckedStyle" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pageDestroyed" scope="instance">
        <parameters>
          <parameter name="pageIndex" type="Integer" usage="required">
            <description>Index of destroyed page</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onUpdateRow" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSelected" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDeselected" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_nativeSelect" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getSelector" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_focusEndingCell" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>Row index</description>
          </parameter>
          <parameter name="cellIndex" type="Integer" usage="required">
            <description>Column index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dokeyup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Key up event</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="gridCells._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.RowSelector.grid.scroller"/>
  <class type="dojox.grid.cells.SingleRowSelector" superclass="RowSelector">
    <methods>
      <method name="_selectRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event fired on the target row</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="RowSelector" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.cells.MultipleRowSelector" superclass="RowSelector">
    <methods>
      <method name="toggleAllSelection" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required">
            <description>True - select all, False - deselect all</description>
          </parameter>
        </parameters>
      </method>
      <method name="inSwipeSelection" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_updateSelection" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event of the current row,</description>
          </parameter>
          <parameter name="delta" type="Integer" usage="required">
            <description>Row index delta, used for swipe selection via Shift + Arrow key
	0: not via key, -1 : Shift +  Up, 1 : Shift + Down</description>
          </parameter>
        </parameters>
      </method>
      <method name="_toggletHeader" scope="instance"/>
      <method name="_toggleDisabledStyle" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_swipeByKey" scope="instance">
        <parameters>
          <parameter name="rowOffset" type="Integer" usage="required">
            <description>Row offset, used for swipe selection via Shift + Cursor
	-1 : Shift +  Up, 1 : Shift + Down</description>
          </parameter>
          <parameter name="colOffset" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required">
            <description>Event of the current row,</description>
          </parameter>
        </parameters>
      </method>
      <method name="_startSelection" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>Index of the start row</description>
          </parameter>
        </parameters>
      </method>
      <method name="_selectRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event fired on the target row</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onSelectionChanged" scope="instance"/>
      <method name="_onRowMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_nativeSelect" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finishSelect" scope="instance"/>
      <method name="_domouseup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse up event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dokeyup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Key up event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addHeaderSelector" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="RowSelector" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.MultipleRowSelector.grid"/>
  <class type="dojox.grid.enhanced.plugins.IndirectSelection" superclass="_Plugin">
    <description>For better rendering performance, div(images) are used to simulate radio button|check boxes</description>
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="addRowSelectCell" scope="instance">
        <parameters>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.IndirectSelection.grid"/>
  <class type="dojox.grid.enhanced.plugins.Menu" superclass="_Plugin">
    <methods>
      <method name="showMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onStartUp" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_setSelectedRegionMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="_setRowMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="_setMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
          <parameter name="menuType" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setCellMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="_initMenu" scope="instance">
        <parameters>
          <parameter name="menuType" type="String" usage="required"/>
          <parameter name="menu" type="String" usage="required">
            <description>| Widget(dijit.Menu)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getMenuWidget" scope="instance">
        <parameters>
          <parameter name="menu" type="String|dijit.Menu" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Menu.grid"/>
  <class type="dojox.grid.enhanced.plugins.NestedSorting" superclass="_Plugin">
    <description>A flexible way to control multiple column sorting, including
	1. Set default sorting order
	2. Disable sorting for certain columns
	3. Set sorting order dynamically with JS API</description>
    <methods>
      <method name="setSortData" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeSortData" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStartUp" scope="instance"/>
      <method name="isDesc" scope="instance">
        <parameters>
          <parameter name="cellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isAsc" scope="instance">
        <parameters>
          <parameter name="cellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initCookieHandler" scope="instance"/>
      <method name="getSortProps" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="clearSort" scope="instance"/>
      <method name="_updateSortDef" scope="instance"/>
      <method name="_updateHeaderNodeUI" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setGridSortIndex" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inAsc" type="Object" usage="required"/>
          <parameter name="noRefresh" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="header click from base DataGrid"/>
        </return-types>
      </method>
      <method name="_saveNestedSortingProps" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareSingleSort" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareNestedSort" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSortBtnClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMove" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderCellMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onColumnDnD" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="mapping" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadNestedSortingProps" scope="instance">
        <parameters>
          <parameter name="sortInfo" type="Object" usage="required"/>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initSort" scope="instance">
        <parameters>
          <parameter name="postSort" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initHeaderNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initFocus" scope="instance"/>
      <method name="_getRegions" scope="instance"/>
      <method name="_getRegionView" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRegionHeader" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentRegion" scope="instance"/>
      <method name="_getCellByNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_focusRegion" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_focusHeader" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doSort" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurRegion" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurHeader" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="_sortDef" scope="instance-prototype" type="Array"/>
      <property name="_a11yText" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting._a11yText"/>
  <class type="dojox.grid.enhanced.plugins.NestedSorting.grid">
    <methods>
      <method name="setSortInfo" scope="instance"/>
      <method name="getSortIndex" scope="instance"/>
    </methods>
    <properties>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting._sortDef"/>
  <class type="dojox.grid.enhanced.plugins.NestedSorting.grid.layout"/>
  <class type="dojox.grid.enhanced.plugins.pagination">
    <methods>
      <method name="_GotoPagePane" scope="instance"/>
      <method name="_GotoPageDialog" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Focus" scope="instance">
        <parameters>
          <parameter name="paginator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPagePane" superclass="_Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onConfirm" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCancel" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_mainMsgNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPagePane._mainMsgNode"/>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPageDialog">
    <methods>
      <method name="showDialog" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePageCount" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPageDialog.dlgPane._pageInputBox"/>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPageDialog.dlgPane._pageLabelNode"/>
  <class type="dojox.grid.enhanced.plugins._ForcedPageStoreLayer" superclass="layers._StoreLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="layers._StoreLayer" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination._Focus">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="paginator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMove" scope="instance">
        <parameters>
          <parameter name="rowDelta" type="Object" usage="required"/>
          <parameter name="colDelta" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onActive" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveFocus" scope="instance"/>
      <method name="_focus" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator" superclass="_Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onSwitchPageSize" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onShowGotoPageDialog" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onPageStep" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSwitchNodesStyle" scope="instance"/>
      <method name="_updateSizeSwitch" scope="instance"/>
      <method name="_updatePageStepper" scope="instance"/>
      <method name="_updatePageStepNodesStyle" scope="instance"/>
      <method name="_updateGotoButton" scope="instance"/>
      <method name="_updateDescription" scope="instance"/>
      <method name="_update" scope="instance"/>
      <method name="_styleMsgNode" scope="instance">
        <parameters>
          <parameter name="top" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showGotoButton" scope="instance">
        <parameters>
          <parameter name="flag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resetPageStepNodes" scope="instance"/>
      <method name="_resetGridHeight" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_registerFocus" scope="instance">
        <parameters>
          <parameter name="isTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeSelf" scope="instance"/>
      <method name="_openGotopageDialog" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSwitchPageSize" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onPageStep" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getStepPageSize" scope="instance"/>
      <method name="_getStartPage" scope="instance"/>
      <method name="_createWardBtns" scope="instance"/>
      <method name="_createSizeSwitchNodes" scope="instance"/>
      <method name="_createPageStepNodes" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="plugin" scope="instance" type="Object"/>
      <property name="pageStepperDiv" scope="instance" type="Object"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="descriptionDiv" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.grid">
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.plugin"/>
  <class type="dojox.grid.enhanced.plugins._Paginator.descriptionDiv"/>
  <class type="dojox.grid.enhanced.plugins._Paginator.pageStepperDiv"/>
  <class type="dojox.grid.enhanced.plugins.Pagination" superclass="_Plugin">
    <description>boolean
	Whether the description information will be displayed, true by default.</description>
    <methods>
      <method name="showGotoPageButton" scope="instance">
        <parameters>
          <parameter name="flag" type="boolean" usage="required">
            <description>Show the go to page button when flag is true, otherwise hide it</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollToRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="integer" usage="required">
            <description>The row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeSelectedRows" scope="instance"/>
      <method name="prevPage" scope="instance"/>
      <method name="nextPage" scope="instance"/>
      <method name="lastPage" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="gotoPage" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="gotoLastPage" scope="instance"/>
      <method name="gotoFirstPage" scope="instance"/>
      <method name="getTotalRowCount" scope="instance"/>
      <method name="getTotalPageNum" scope="instance"/>
      <method name="firstPage" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="currentPageSize" scope="instance">
        <parameters>
          <parameter name="size" type="Integer" usage="required">
            <description>|| null
	An integer identifying the number of rows per page. If the size
	is an Infinity, all rows will be displayed; if an invalid value pssed
	in, the current page size will be returned.
	return
	Current size of items per page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="currentPage" scope="instance">
        <parameters>
          <parameter name="page" type="Integer" usage="required">
            <description>The page to go to, starting at 1.
	return:
	Current page number</description>
          </parameter>
        </parameters>
      </method>
      <method name="changePageSize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_regApis" scope="instance"/>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance"/>
      <method name="_initOptions" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="option" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
      <property name="_paginator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Pagination.grid"/>
  <class type="dojox.grid.enhanced.plugins.Pagination._paginator"/>
  <class type="dojox.grid.enhanced.plugins.Pagination.option"/>
  <class type="dojox.grid.enhanced.plugins.Printer" superclass="_Plugin">
    <methods>
      <method name="printSelected" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional">
            <description>Arguments for print.</description>
          </parameter>
        </parameters>
      </method>
      <method name="printGrid" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional">
            <description>Arguments for print.</description>
          </parameter>
        </parameters>
      </method>
      <method name="normalizeRowHeight" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="exportToHTML" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional">
            <description>Arguments for print.</description>
          </parameter>
          <parameter name="onExported" type="Function(string))" usage="required">
            <description>call back function</description>
          </parameter>
        </parameters>
      </method>
      <method name="exportSelectedToHTML" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional">
            <description>Arguments for print.</description>
          </parameter>
          <parameter name="onExported" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_wrapHTML" scope="instance">
        <parameters>
          <parameter name="title" type="string" usage="required">
            <description>String A title for the html page.</description>
          </parameter>
          <parameter name="cssFiles" type="Array" usage="required">
            <description>css file pathes.</description>
          </parameter>
          <parameter name="body_content" type="string" usage="required">
            <description>String Content to print, not including &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt; part and &amp;lt;html&amp;gt; tags</description>
          </parameter>
        </parameters>
        <return-description>the wrapped HTML string ready for print</return-description>
      </method>
      <method name="_print" scope="instance">
        <parameters>
          <parameter name="htmlStr" type="string" usage="required">
            <description>String The html content string to be printed.</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_loadCSSFiles" scope="instance">
        <parameters>
          <parameter name="cssFiles" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_formalizeArgs" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Printer.grid"/>
  <class type="dojox.grid.enhanced.plugins.Rearrange" superclass="_Plugin">
    <methods>
      <method name="setArgs" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRows" scope="instance">
        <parameters>
          <parameter name="rowsToRemove" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveRows" scope="instance">
        <parameters>
          <parameter name="rowsToMove" type="Array&lt;Integer&gt;" usage="required">
            <description>Array of row indexes.</description>
          </parameter>
          <parameter name="targetPos" type="Integer" usage="required">
            <description>The target position</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveColumns" scope="instance">
        <parameters>
          <parameter name="colsToMove" type="Array&lt;Integer&gt;" usage="required">
            <description>Array of column indexes.</description>
          </parameter>
          <parameter name="targetPos" type="Integer" usage="required">
            <description>The target position</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveCells" scope="instance">
        <parameters>
          <parameter name="cellsToMove" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertRows" scope="instance">
        <parameters>
          <parameter name="sourceGrid" type="Object" usage="required"/>
          <parameter name="rowsToMove" type="Object" usage="required"/>
          <parameter name="targetPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="copyCells" scope="instance">
        <parameters>
          <parameter name="cellsToMove" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearCells" scope="instance">
        <parameters>
          <parameter name="cellsToClear" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changeCells" scope="instance">
        <parameters>
          <parameter name="sourceGrid" type="Object" usage="required"/>
          <parameter name="cellsToMove" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hasIdentity" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageInfo" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="args" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.args">
    <methods>
      <method name="setIdentifierForNewItem" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid">
    <properties>
      <property name="selection" scope="instance" type="Object"/>
      <property name="scroller" scope="instance" type="Object"/>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.layout"/>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.selection"/>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.scroller">
    <properties>
      <property name="pageNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.scroller.pageNodes"/>
  <class type="dojox.grid.enhanced.plugins.Search" superclass="_Plugin">
    <methods>
      <method name="searchRow" scope="instance">
        <parameters>
          <parameter name="searchArgs" type="Object|RegExp|String" usage="required"/>
          <parameter name="onSearched" type="Function(Integer)" usage="required">
            <description>item)</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_search" scope="instance">
        <parameters>
          <parameter name="searchArgs" type="Object|RegExp" usage="required"/>
          <parameter name="start" type="Integer" usage="required"/>
          <parameter name="onSearched" type="Function(Integer)" usage="required">
            <description>item)</description>
          </parameter>
          <parameter name="isGlobal" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_checkRow" scope="instance">
        <parameters>
          <parameter name="item" type="store" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="searchArgs" type="Object|RegExp" usage="required"/>
          <parameter name="isGlobal" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Search.grid"/>
  <class type="__SelectCellItem" superclass="__SelectItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="__SelectItem" scope="instance"/>
    </mixins>
  </class>
  <class type="__SelectRowItem" superclass="__SelectItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="__SelectItem" scope="instance"/>
    </mixins>
  </class>
  <class type="__SelectColItem" superclass="__SelectItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="__SelectItem" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector" superclass="_Plugin">
    <methods>
      <method name="toggleSelect" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setupConfig" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required">
            <description>An object with the following structure (all properties are optional):
	{
	//Default is &amp;quot;multi&amp;quot;, all other values are same as &amp;quot;multi&amp;quot;.
	row: false|&amp;quot;disabled&amp;quot;|&amp;quot;single&amp;quot;,
	col: false|&amp;quot;disabled&amp;quot;|&amp;quot;single&amp;quot;,
	cell: false|&amp;quot;disabled&amp;quot;|&amp;quot;single&amp;quot;
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="selectRange" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="start" type="Integer" usage="required">
            <description>| Object
	If type is &amp;quot;row&amp;quot; or &amp;quot;col&amp;quot;, this is the index of the starting row or column.
	If type if &amp;quot;cell&amp;quot;, this is the left-top cell of the range.</description>
          </parameter>
          <parameter name="end" type="Integer" usage="required">
            <description>| Object
	If type is &amp;quot;row&amp;quot; or &amp;quot;col&amp;quot;, this is the index of the ending row or column.
	If type if &amp;quot;cell&amp;quot;, this is the right-bottom cell of the range.</description>
          </parameter>
          <parameter name="toSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectEnabled" scope="instance">
        <parameters>
          <parameter name="toEnable" type="Boolean" usage="optional">
            <description>To enable or not. Optional.
	return: Boolean | undefined
	Enabled or not.</description>
          </parameter>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>If type is &amp;quot;row&amp;quot; or &amp;quot;cell&amp;quot;, this is the row index.
	If type if &amp;quot;col&amp;quot;, this is the column index.</description>
          </parameter>
          <parameter name="colIndex" type="Integer" usage="optional">
            <description>Only valid when type is &amp;quot;cell&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSetStore" scope="instance"/>
      <method name="isSelecting" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;
	return: Boolean
	true if is selection, false otherwise.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>If type is &amp;quot;row&amp;quot; or &amp;quot;cell&amp;quot;, this is the row index.
	If type if &amp;quot;col&amp;quot;, this is the column index.</description>
          </parameter>
          <parameter name="colIndex" type="Integer" usage="optional">
            <description>Only valid when type is &amp;quot;cell&amp;quot;
	return: Boolean
	true if selected, false if not. If cell is covered by a selected column, it's selected.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSelectedType" scope="instance"/>
      <method name="getSelectedCount" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="includeExceptions" type="Boolean" usage="required">
            <description>Only meaningful for rows/columns. If true, all selected rows/cols, even they are partly selected, are all returned.
	return: Integer
	The number of selected items.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSelected" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="includeExceptions" type="Boolean" usage="required">
            <description>Only meaningful for rows/columns. If true, all selected rows/cols, even they are partly selected, are all returned.
	return: __SelectItem[]</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLastSelectedRange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="optional">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;. If omitted, clear all.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_startSelect" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot;, &amp;quot;col&amp;quot;, or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="start" type="__SelectItem" usage="required">
            <description>The start point</description>
          </parameter>
          <parameter name="extending" type="Boolean" usage="required">
            <description>Whether this is a multi selection</description>
          </parameter>
          <parameter name="isRange" type="Boolean" usage="required">
            <description>Whether this is a range selection (i.e. select from the last end point to this point)</description>
          </parameter>
          <parameter name="mandatarySelect" type="Boolean" usage="required">
            <description>If true, toSelect will be same as the original selection status.</description>
          </parameter>
          <parameter name="toSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshSelected" scope="instance"/>
      <method name="_refresh" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSelectedById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="newIndex" type="Object" usage="required"/>
          <parameter name="isSelected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onInternalRearrange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="mapping" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onExternalChange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_makeupForExceptions" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="newCellItems" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeupForCells" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="newItems" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isValid" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="allowNotSelectable" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isSelected" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isInLastRange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isSelected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isCellNotInExcept" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initEvents" scope="instance"/>
      <method name="_initAreas" scope="instance"/>
      <method name="_highlightSingle" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="toSelect" type="Object" usage="required"/>
          <parameter name="isRefresh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightRowSelector" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightHeader" scope="instance">
        <parameters>
          <parameter name="colIdx" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlight" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="toSelect" type="Boolean" usage="required">
            <description>Whether we are selecting or deselecting.
	This function is time critical!!</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hacks" scope="instance"/>
      <method name="_forEach" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
          <parameter name="halfClose" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_focusPoint" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="point" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fireEvent" scope="instance">
        <parameters>
          <parameter name="evtName" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_endSelect" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot;, &amp;quot;col&amp;quot;, or &amp;quot;cell&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="_clearSelection" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot;, &amp;quot;col&amp;quot;, or &amp;quot;cell</description>
          </parameter>
          <parameter name="reservedItem" type="__SelectItem" usage="required">
            <description>The item to retain highlight.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_calcToHighlight" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
          <parameter name="toSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurPoint" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="point" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addToSelected" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addException" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addCellException" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="_config" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid">
    <methods>
      <method name="onStartSelect" scope="instance"/>
      <method name="onStartDeselect" scope="instance"/>
      <method name="onSelectCleared" scope="instance"/>
      <method name="onEndSelect" scope="instance"/>
      <method name="onEndDeselect" scope="instance"/>
    </methods>
    <properties>
      <property name="selection" scope="instance" type="Object"/>
      <property name="layout" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.selection">
    <methods>
      <method name="selectRange" scope="instance">
        <parameters>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectRange" scope="instance">
        <parameters>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance"/>
      <method name="clickSelect" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.views.views">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.views.views.0">
    <methods>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.layout"/>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.focus"/>
  <class type="dojox.grid.enhanced.plugins.Selector._config"/>
  <class type="dojox.grid.enhanced.plugins._RowMapLayer" superclass="layers._StoreLayer">
    <methods>
      <method name="uninitialize" scope="instance"/>
      <method name="setMapping" scope="instance">
        <parameters>
          <parameter name="mapping" type="Object" usage="required">
            <description>keys are original rowIndexes, values are new rowIndexes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearMapping" scope="instance"/>
      <method name="_subFetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="Object" usage="required"/>
          <parameter name="rowArrays" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="map" type="Object" usage="required"/>
          <parameter name="oldOnComplete" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowArrays" scope="instance">
        <parameters>
          <parameter name="rows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="layers._StoreLayer" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._RowMapLayer.grid"/>
  <class type="dojox.grid.enhanced.plugins._SelectionPreserver" superclass="_SelectionPreserver">
    <description>Extends dojox.grid._SelectionPreserver adding a bit more support to make selection persistence working well
	with various EnhancedGrid features, e.g. filtering, nested sorting, pagination, select all etc.
	
	Precondition - Identifier(id) is required for store, as id is used for differentiating row items.
	Known issue - The preserved selections might be inaccurate if some unloaded rows are previously selected by range(e.g.SHIFT + click)</description>
    <methods>
      <method name="reset" scope="instance"/>
      <method name="onSelectedById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="selection" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateMapping" scope="instance">
        <parameters>
          <parameter name="trustSelection" type="Object" usage="required"/>
          <parameter name="isSelect" type="Object" usage="required"/>
          <parameter name="isForAll" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectById" scope="instance">
        <parameters>
          <parameter name="toSelect" type="Object" usage="required"/>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_reSelectById" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_SelectionPreserver" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._SelectionPreserver.grid">
    <methods>
      <method name="_clearData" scope="instance-prototype"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="uninitialize" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="originFetch" scope="instance"/>
      <method name="name" scope="instance">
        <return-description>The name of this layer.</return-description>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="instance">
        <parameters>
          <parameter name="toEnable" type="bool" usage="optional">
            <description>Boolean If given, is a setter, otherwise, it's getter.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_wrap" scope="instance">
        <parameters>
          <parameter name="store" type="Read-store" usage="required">
            <description>The store to be wrapped.</description>
          </parameter>
          <parameter name="funcName" type="Object" usage="required"/>
          <parameter name="layerFuncName" type="Object" usage="required"/>
          <parameter name="nextLayer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unwrap" scope="instance">
        <parameters>
          <parameter name="nextLayer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins._ServerSideLayer" superclass="_StoreLayer">
    <methods>
      <method name="useCommands" scope="instance">
        <parameters>
          <parameter name="toUse" type="bool" usage="optional">
            <description>Boolean If provided, it's a setter, otherwise, it's a getter</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onCommandLoad" scope="instance">
        <parameters>
          <parameter name="response" type="string" usage="required">
            <description>server response</description>
          </parameter>
          <parameter name="userRequest" type="keywordArgs" usage="required">
            <description>in|out] dojo.data.api.Request
	The request object for *fetch*. You can modify this object according to the *response*
	so as to change the behavior of *fetch*</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCommandError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="instance">
        <parameters>
          <parameter name="toEnable" type="bool" usage="optional"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="command" scope="instance">
        <parameters>
          <parameter name="cmdName" type="string" usage="required">
            <description>The name of the command</description>
          </parameter>
          <parameter name="cmdContent" type="(string|number|bool|)" usage="optional">
            <description>anything The content of the command</description>
          </parameter>
        </parameters>
        <return-description>The content of the command if cmdContent is undefined</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_onUserCommandLoad" scope="instance"/>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="keywordArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.data.api.Request"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_StoreLayer" scope="instance"/>
    </mixins>
    <properties>
      <property name="__cmds" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._ServerSideLayer.__cmds"/>
  <class type="dojox.grid.enhanced.plugins.exporter">
    <methods>
      <method name="_ExportWriter" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional">
            <description>Any implementation of this class might accept a writerArgs object (optional),
	which contains some writer-specific arguments given by the user.</description>
          </parameter>
        </parameters>
      </method>
      <method name="TableWriter" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="CSVWriter" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional">
            <description>{separator:'...'}</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter.CSVWriter" superclass="_ExportWriter">
    <methods>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="handleCell" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional">
            <description>{separator:'...'}</description>
          </parameter>
        </parameters>
      </method>
      <method name="beforeContentRow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_formatCSVCell" scope="instance">
        <parameters>
          <parameter name="cellValue" type="string" usage="required">
            <description>The value in a cell.</description>
          </parameter>
        </parameters>
        <return-description>The formatted content of a cell</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_ExportWriter" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter.TableWriter" superclass="_ExportWriter">
    <methods>
      <method name="toString" scope="instance"/>
      <method name="handleCell" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="beforeView" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="beforeSubrow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterView" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="afterSubrow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="afterContent" scope="instance"/>
      <method name="_getTableAttrs" scope="instance">
        <parameters>
          <parameter name="tagName" type="string" usage="required">
            <description>An html tag name</description>
          </parameter>
        </parameters>
        <return-description>The well formatted attributes for the given html table.tag</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getRowClass" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getColumnClass" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_ExportWriter" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter._ExportWriter">
    <methods>
      <method name="toString" scope="instance">
        <return-description>The exported result string.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="handleCell" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	view,viewIdx,
	subrow,subrowIdx,
	cell,cellIdx,
	spCols(if isHeader==false)
	}</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional">
            <description>Any implementation of this class might accept a writerArgs object (optional),
	which contains some writer-specific arguments given by the user.</description>
          </parameter>
        </parameters>
      </method>
      <method name="beforeView" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	view,viewIdx,
	spCols(if isHeader==false)
	}
	return:
	true: go on handling the current view and then call afterView.
	false: skip the current view, won't call afterView.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="beforeSubrow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	view,viewIdx,
	subrow,subrowIdx,
	spCols(if isHeader==false)
	}
	return:
	true: go on handling the current subrow and then call afterSubrow.
	false: skip the current subrow, won't call afterSubrow.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="beforeHeader" scope="instance">
        <parameters>
          <parameter name="grid" type="EnhancedGrid" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="beforeContentRow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	spCols
	}
	return:
	true: go on handling the current data row and then call afterContentRow.
	false: skip the current data row, won't call afterContentRow.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="beforeContent" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required">
            <description>All the items fetched from the store
	return:
	true: go on handling the contents and then call afterContent.
	false: skip all the contents, won't call afterContent.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterView" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	view,viewIdx,
	spCols(if isHeader==false)
	}</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="afterSubrow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	view,viewIdx,
	subrow,subrowIdx,
	spCols(if isHeader==false)
	}</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="afterHeader" scope="instance">
        <return-description>undefined</return-description>
      </method>
      <method name="afterContentRow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	spCols
	}</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="afterContent" scope="instance">
        <return-description>undefined</return-description>
      </method>
      <method name="_getExportDataForCell" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="rowItem" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="argObj" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter._ExportWriter.argObj"/>
  <class type="dojox.grid.enhanced.plugins.filter">
    <methods>
      <method name="_UniOpExpr" scope="instance"/>
      <method name="_OperatorExpr" scope="instance"/>
      <method name="_FilterLayerMixin" scope="instance"/>
      <method name="_DataExpr" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required">
            <description>If *isColumn* is a boolean true, then it should be a kind of column information, like field name
	or column index. Otherwise, it is regarded as a pure value, and the getValue method will simply
	return it.</description>
          </parameter>
          <parameter name="isColumn" type="bool" usage="optional">
            <description>boolean Optional. To specify whether this _DataExpr represents a column or a pure value.</description>
          </parameter>
          <parameter name="convertArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_ConditionExpr" scope="instance"/>
      <method name="_BiOpExpr" scope="instance"/>
      <method name="UniqueComboBox" scope="instance"/>
      <method name="TimeExpr" scope="instance"/>
      <method name="StringExpr" scope="instance"/>
      <method name="StartsWith" scope="instance"/>
      <method name="ServerSideFilterLayer" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="NumberExpr" scope="instance"/>
      <method name="Matches" scope="instance"/>
      <method name="LogicXOR" scope="instance"/>
      <method name="LogicOR" scope="instance"/>
      <method name="LogicNOT" scope="instance"/>
      <method name="LogicANY" scope="instance"/>
      <method name="LogicAND" scope="instance"/>
      <method name="LogicALL" scope="instance"/>
      <method name="LessThanOrEqualTo" scope="instance"/>
      <method name="LessThan" scope="instance"/>
      <method name="LargerThanOrEqualTo" scope="instance"/>
      <method name="LargerThan" scope="instance"/>
      <method name="IsEmpty" scope="instance"/>
      <method name="FilterStatusTip" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="FilterStatusPane" scope="instance"/>
      <method name="FilterDefPane" scope="instance"/>
      <method name="FilterDefDialog" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="FilterBuilder" scope="instance"/>
      <method name="FilterBar" scope="instance"/>
      <method name="EqualTo" scope="instance"/>
      <method name="EndsWith" scope="instance"/>
      <method name="DateExpr" scope="instance"/>
      <method name="CriteriaBox" scope="instance"/>
      <method name="Contains" scope="instance"/>
      <method name="ClientSideFilterLayer" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ClearFilterConfirm" scope="instance"/>
      <method name="BooleanValueBox" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="BooleanExpr" scope="instance"/>
      <method name="AccordionContainer" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClearFilterConfirm" superclass="_Widget">
    <methods>
      <method name="uninitialize" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onClear" scope="instance"/>
      <method name="_onCancel" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="plugin" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClearFilterConfirm.plugin"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar" superclass="_Widget">
    <methods>
      <method name="uninitialize" scope="instance"/>
      <method name="toggleFilterBar" scope="instance">
        <parameters>
          <parameter name="useAnim" type="Object" usage="required"/>
          <parameter name="animArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleClearFilterBtn" scope="instance">
        <parameters>
          <parameter name="toHide" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showFilterBar" scope="instance">
        <parameters>
          <parameter name="toShow" type="Object" usage="required"/>
          <parameter name="useAnim" type="Object" usage="required"/>
          <parameter name="animArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="isFilterBarShown" scope="instance"/>
      <method name="getColumnIdx" scope="instance">
        <parameters>
          <parameter name="coordX" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_updateTipPosition" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showStatusTooltip" scope="instance"/>
      <method name="_showFilterDefDialog" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStatusTipTimeout" scope="instance"/>
      <method name="_onShowFilterDefDialog" scope="instance">
        <parameters>
          <parameter name="colIdx" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_onMoveButton" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseLeave" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_onLeaveButton" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusFilterBar" scope="instance">
        <parameters>
          <parameter name="highlightOnly" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFiltered" scope="instance">
        <parameters>
          <parameter name="filteredSize" type="int" usage="required"/>
          <parameter name="originSize" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_onEnterButton" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCloseFilterDefDialog" scope="instance"/>
      <method name="_onClickFilterBar" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlurFilterBar" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isInColumn" scope="instance">
        <parameters>
          <parameter name="mousePos_x" type="int" usage="required"/>
          <parameter name="headerNode" type="domNode" usage="required"/>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_initAriaInfo" scope="instance"/>
      <method name="_highlightHeader" scope="instance">
        <parameters>
          <parameter name="colIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_closeFilterBar" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clearStatusTipTimeout" scope="instance"/>
      <method name="_clearHeaderHighlight" scope="instance"/>
      <method name="_clearFilterDefDialog" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="statusBarNode" scope="instance" type="Object"/>
      <property name="plugin" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin">
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="args" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin.args"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin.grid">
    <methods>
      <method name="_getHeaderHeight" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.defineFilterButton.domNode"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin.grid.views.views.0.domNode"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.statusBarNode"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder">
    <methods>
      <method name="buildExpression" scope="instance">
        <parameters>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="supportedTypes" scope="instance" type="Object"/>
      <property name="supportedOps" scope="instance" type="Object">
        <description>The builders of all supported operations</description>
      </property>
      <property name="defaultArgs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.supportedOps">
    <methods>
      <method name="range" scope="instance">
        <parameters>
          <parameter name="operands" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.supportedTypes"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.defaultArgs">
    <properties>
      <property name="boolean" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.defaultArgs.boolean">
    <methods>
      <method name="convert" scope="instance">
        <parameters>
          <parameter name="dataValue" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.AccordionContainer" superclass="AccordionContainer">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="selectChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="_setupTitleDom" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="fromTitle" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_modifyChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="isFirst" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hackHeight" scope="instance">
        <parameters>
          <parameter name="toGrow" type="bool" usage="required"/>
          <parameter name="heightDif" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="AccordionContainer" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.AccordionContainer.domNode.style"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefPane" superclass="_Widget">
    <methods>
      <method name="uninitialize" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onRelSelectChange" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFilter" scope="instance"/>
      <method name="_onClearFilter" scope="instance"/>
      <method name="_onCancel" scope="instance"/>
      <method name="_onAddCBox" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="plugin" scope="instance" type="Object"/>
      <property name="dlg" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefPane.plugin"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefPane.dlg"/>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox" superclass="_Widget">
    <methods>
      <method name="updateRuleTitle" scope="instance">
        <parameters>
          <parameter name="isEmpty" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRuleIndex" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance"/>
      <method name="setAriaInfo" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onRemove" scope="instance"/>
      <method name="onMoveColumn" scope="instance"/>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isEmpty" scope="instance"/>
      <method name="getExpr" scope="instance"/>
      <method name="formatValue" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="curValue" scope="instance"/>
      <method name="curCondition" scope="instance"/>
      <method name="curColumn" scope="instance"/>
      <method name="changeCurrentColumn" scope="instance">
        <parameters>
          <parameter name="selectCurCol" type="bool" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValueBox" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showSelectOrLabel" scope="instance">
        <parameters>
          <parameter name="sel" type="Object" usage="required"/>
          <parameter name="alt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueBoxByType" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_setConditionsByType" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_onChangeCondition" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChangeColumn" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueBoxClsInfo" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int|string" usage="required"/>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueBoxArgByType" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_getUsableConditions" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getColumnOptions" scope="instance"/>
      <method name="_createValueBox" scope="instance">
        <parameters>
          <parameter name="cls" type="widget" usage="required">
            <description>constructor</description>
          </parameter>
          <parameter name="arg" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRangeBox" scope="instance">
        <parameters>
          <parameter name="cls" type="widget" usage="required">
            <description>constructor</description>
          </parameter>
          <parameter name="arg" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkValidCriteria" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="plugin" scope="instance" type="Object"/>
      <property name="dlg" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox.plugin"/>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox.dlg"/>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox._pane._buttonWidget">
    <properties>
      <property name="titleTextNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox._pane._buttonWidget.titleTextNode"/>
  <class type="dojox.grid.enhanced.plugins.filter.UniqueComboBox" superclass="ComboBox">
    <methods>
      <method name="_openResultList" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="ComboBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.BooleanValueBox" superclass="_Widget">
    <methods>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog">
    <methods>
      <method name="showDialog" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="setFilter" scope="instance">
        <parameters>
          <parameter name="rules" type="Object" usage="required"/>
          <parameter name="ruleRelation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeCriteriaBoxes" scope="instance">
        <parameters>
          <parameter name="cnt" type="int|CriteriaBox|Array&lt;int&gt;" usage="required"/>
          <parameter name="isIdx" type="bool" usage="optional"/>
        </parameters>
      </method>
      <method name="onRendered" scope="instance">
        <parameters>
          <parameter name="cbox" type="Current" usage="required">
            <description>visible criteria box</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMoveColumn" scope="instance">
        <parameters>
          <parameter name="sourceViewIndex" type="Object" usage="required"/>
          <parameter name="destViewIndex" type="Object" usage="required"/>
          <parameter name="cellIndex" type="Object" usage="required"/>
          <parameter name="targetIndex" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFilter" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClearFilter" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFilter" scope="instance"/>
      <method name="getExprForCriteria" scope="instance">
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getExprForColumn" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="colIdx" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCriteria" scope="instance">
        <parameters>
          <parameter name="idx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="getConditionLabelByValue" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnType" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnLabelByValue" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeDialog" scope="instance"/>
      <method name="clearFilter" scope="instance">
        <parameters>
          <parameter name="noRefresh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canFilter" scope="instance"/>
      <method name="addCriteriaBoxes" scope="instance">
        <parameters>
          <parameter name="cnt" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePane" scope="instance"/>
      <method name="_updateCBoxTitles" scope="instance"/>
      <method name="_setupData" scope="instance"/>
      <method name="_prepareDialog" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetFilter" scope="instance">
        <parameters>
          <parameter name="filterDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defineFilter" scope="instance"/>
      <method name="_closeDlgAndUpdateGrid" scope="instance"/>
    </methods>
    <properties>
      <property name="plugin" scope="instance-prototype" type="Object"/>
      <property name="filterDefPane" scope="instance-prototype" type="Object"/>
      <property name="_cboxes" scope="instance-prototype" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.plugin">
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="args" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.plugin.grid"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.filterDefPane">
    <properties>
      <property name="criteriaPane" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.plugin.args"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog._cboxes"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.filterDefPane.criteriaPane"/>
  <class type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin">
    <methods>
      <method name="onFiltered" scope="instance">
        <parameters>
          <parameter name="filteredSize" type="Integer" usage="required">
            <description>The number of remaining fetched items after filtering.</description>
          </parameter>
          <parameter name="totalSize" type="Integer" usage="required">
            <description>The number of original fetched items.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFilterDefined" scope="instance">
        <parameters>
          <parameter name="filter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="name" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="filterDef" scope="instance">
        <parameters>
          <parameter name="filter" type="_ConditionExpr|null)" usage="optional">
            <description>null: clear filter definition
	undefined: it's getter</description>
          </parameter>
        </parameters>
        <return-description>A filter definition if it's getter.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ServerSideFilterLayer" superclass="layers._ServerSideLayer">
    <methods>
      <method name="onCommandLoad" scope="instance">
        <parameters>
          <parameter name="responce" type="string" usage="required"/>
          <parameter name="userRequest" type="(in|out)keywordArgs" usage="required"/>
        </parameters>
      </method>
      <method name="filterDef" scope="instance">
        <parameters>
          <parameter name="filter" type="(_ConditionExpr|null)" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_FilterLayerMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="layers._ServerSideLayer" scope="instance"/>
      <mixin type="_FilterLayerMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClientSideFilterLayer" superclass="layers._StoreLayer">
    <methods>
      <method name="setGetter" scope="instance">
        <parameters>
          <parameter name="getter" type="function" usage="required">
            <description>function(datarow, colArg, rowIndex, store);</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMappingChange" scope="instance">
        <parameters>
          <parameter name="mapping" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="filterDef" scope="instance">
        <parameters>
          <parameter name="filter" type="(_ConditionExpr|null)" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="fetchAllOnFirstFilter" scope="instance">
        <parameters>
          <parameter name="toFetchAll" type="bool" usage="optional">
            <description>boolean If provided, it's a set function, otherwise it's a get function.</description>
          </parameter>
        </parameters>
        <return-description>Whether fetch all on first filter if this is a getter</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="instance">
        <parameters>
          <parameter name="size" type="Integer" usage="required"/>
          <parameter name="req" type="request" usage="required">
            <description>object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hasReachedStoreEnd" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="Object" usage="required"/>
          <parameter name="filterRequest" type="dojo.data.api.Request" usage="required">
            <description>The actual request used in store.fetch.
	This function is called recursively to fill the result store items
	until the user specified item count is reached. Only in recursive calls,
	this parameter is valid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_doFilter" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="startIdx" type="Integer" usage="required"/>
          <parameter name="userRequest" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultGetter" scope="instance">
        <parameters>
          <parameter name="datarow" type="Object" usage="required"/>
          <parameter name="colName" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_completeQuery" scope="instance">
        <parameters>
          <parameter name="userRequest" type="request" usage="required">
            <description>object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_applyFilter" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="rowIndex" type="Integer" usage="required"/>
        </parameters>
        <return-description>whether this row survived the filter.</return-description>
      </method>
      <method name="_addCachedItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required">
            <description>Data items to add.</description>
          </parameter>
          <parameter name="filterStartIdx" type="Integer" usage="required">
            <description>The start point to insert in the cache.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_FilterLayerMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="layers._StoreLayer" scope="instance"/>
      <mixin type="_FilterLayerMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_items" scope="instance" type="Array">
        <description>Cached items (may contain holes)</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClientSideFilterLayer._items"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusPane" superclass="_Widget">
    <methods/>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip">
    <methods>
      <method name="showDialog" scope="instance">
        <parameters>
          <parameter name="pos_x" type="int" usage="required"/>
          <parameter name="pos_y" type="int" usage="required"/>
          <parameter name="columnIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeDialog" scope="instance"/>
      <method name="_updateStatus" scope="instance">
        <parameters>
          <parameter name="columnIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_modifyFilter" scope="instance"/>
      <method name="_getCriteriaStr" scope="instance">
        <parameters>
          <parameter name="c" type="object" usage="required"/>
          <parameter name="rowIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_createStatusDetail" scope="instance"/>
      <method name="_addButtonForRules" scope="instance"/>
    </methods>
    <properties>
      <property name="plugin" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.plugin"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusTitle"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusRel"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusDetailNode"/>
  <class type="dojox.grid.enhanced.plugins.filter._ConditionExpr">
    <methods>
      <method name="toObject" scope="instance">
        <return-description>An object for serialization.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getName" scope="instance">
        <return-description>the name of this kind of expression</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>object A data item of a store.</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required">
            <description>function(datarow, colArg)
	A user defined function that extract cell data from *datarow*.
	*colArg* is an argument that provides a kind of column information.
	It is defined by user in the constructor of a _DataExpr object.</description>
          </parameter>
        </parameters>
        <return-description>MUST return a _ConditionExpr object</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._DataExpr" superclass="_ConditionExpr">
    <methods>
      <method name="toObject" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <return-description>the value of this data expression.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required">
            <description>If *isColumn* is a boolean true, then it should be a kind of column information, like field name
	or column index. Otherwise, it is regarded as a pure value, and the getValue method will simply
	return it.</description>
          </parameter>
          <parameter name="isColumn" type="bool" usage="optional">
            <description>boolean Optional. To specify whether this _DataExpr represents a column or a pure value.</description>
          </parameter>
          <parameter name="convertArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_ConditionExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._OperatorExpr" superclass="_ConditionExpr">
    <methods>
      <method name="toObject" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_ConditionExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._UniOpExpr" superclass="_OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required"/>
        </parameters>
        <return-description>MUST return a _ConditionExpr object.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_OperatorExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._BiOpExpr" superclass="_OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required"/>
        </parameters>
      </method>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required"/>
        </parameters>
        <return-description>MUST return a _ConditionExpr object.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_OperatorExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.BooleanExpr" superclass="exprs._DataExpr">
    <methods>
      <method name="_convertData" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._DataExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.StringExpr" superclass="exprs._DataExpr">
    <methods>
      <method name="_convertData" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._DataExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.NumberExpr" superclass="exprs._DataExpr">
    <methods>
      <method name="_convertDataToExpr" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._DataExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.DateExpr" superclass="exprs._DataExpr">
    <methods>
      <method name="toObject" scope="instance"/>
      <method name="_convertData" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._DataExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.TimeExpr" superclass="DateExpr">
    <methods/>
    <mixins scope="instance">
      <mixin type="DateExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicAND" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicOR" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicXOR" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicNOT" superclass="exprs._UniOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._UniOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicALL" superclass="exprs._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._OperatorExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicANY" superclass="exprs._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._OperatorExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.EqualTo" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LessThan" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LessThanOrEqualTo" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LargerThan" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LargerThanOrEqualTo" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.Contains" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.StartsWith" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.EndsWith" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.Matches" superclass="exprs._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._BiOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.IsEmpty" superclass="exprs._UniOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="exprs._UniOpExpr" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.help">
    <methods>
      <method name="refresh" scope="instance">
        <parameters>
          <parameter name="namespace" type="String" usage="optional">
            <description>The string-representation of a namespace.</description>
          </parameter>
          <parameter name="recursive" type="Boolean" usage="optional">
            <description>Whether to recurse through the namespace.</description>
          </parameter>
        </parameters>
      </method>
      <method name="noConflict" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="optional">
            <description>If you pass an item, only that item will be cleaned</description>
          </parameter>
        </parameters>
      </method>
      <method name="locate" scope="instance">
        <description>Search for locally available data; variable names and any cached
	documentation results for matches containing our search parameter
	searchFor
	The string to search for.</description>
        <parameters>
          <parameter name="searchFor" type="String" usage="required"/>
          <parameter name="searchIn" type="String|Object|Array&lt;String&gt;|Array&lt;Object&gt;" usage="required">
            <description>The namespaces to search in. Defaults to dojox.help._namespaces</description>
          </parameter>
          <parameter name="maxResults" type="Number" usage="required">
            <description>The maximum number of results.</description>
          </parameter>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="namespaces" type="Array&lt;String&gt;" usage="required">
            <description>Any namespaces to add to the default (dojox.help._namespaces)</description>
          </parameter>
          <parameter name="noConflict" type="Boolen" usage="optional">
            <description>Whether to start in noConflict mode</description>
          </parameter>
        </parameters>
      </method>
      <method name="_toString" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stripPrototype" scope="instance">
        <parameters>
          <parameter name="original" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_recurse" scope="instance">
        <parameters>
          <parameter name="namespace" type="String" usage="optional"/>
          <parameter name="recursive" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_plainText" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_noConflict" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_help" scope="instance"/>
      <method name="_displayLocated" scope="instance">
        <parameters>
          <parameter name="located" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayHelp" scope="instance">
        <parameters>
          <parameter name="loading" type="Object" usage="required"/>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clean" scope="instance">
        <parameters>
          <parameter name="self" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addVersion" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__toString" scope="instance"/>
      <method name="__recurse" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
          <parameter name="root" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="recursive" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.help._help">
    <methods/>
  </class>
  <class type="dojox.help._parse">
    <methods/>
  </class>
  <class type="dojox.help._toString">
    <methods/>
  </class>
  <class type="dojox.highlight">
    <description>This project parses pre &gt; code nodes, and applies syntax highlighting for
	a wide variety of languages. Simply dojo.require() in all the
	dojox.highlight.languages you wish to include in your highlighingting,
	and customize colors in the highlight.css.
	
	It is provided as a dojo package, contributed under CLA
	by Ivan Sagalaev and is available originally from:
	http://softwaremaniacs.org/soft/highlight/en/</description>
    <methods>
      <method name="processString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="lang" type="String" usage="optional"/>
        </parameters>
        <return-description>Object containing:
	result - string of html with spans to apply formatting
	partialResult - if the formating failed: string of html
	up to the point of the failure, otherwise: undefined
	langName - the language used to do the formatting</return-description>
      </method>
      <method name="init" scope="instance">
        <description>Syntax highlight a passed DomNode or String ID of a DomNode</description>
        <examples>
          <example>	dojox.highlight.init("someId");</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="stop iterations"/>
          <return-type type="continue iterations"/>
        </return-types>
      </method>
      <method name="Code" scope="instance">
        <examples>
          <example>	&lt;pre&gt;&lt;code dojoType="dojox.highlight.Code"&gt;for(var i in obj){ ... }&lt;/code&gt;&lt;/pre&gt;</example>
          <example>	var inst = new dojox.highlight.Code({}, "someId");</example>
        </examples>
        <parameters>
          <parameter name="props" type="Object" usage="optional">
            <description>Unused. Pass 'null' or {}. Positional usage to allow `dojo.parser` to instantiate
	this class as other Widgets would be.</description>
          </parameter>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>A String ID or DomNode reference to use as the root node of this instance.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widget" scope="instance" type="Object"/>
      <property name="languages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.Code">
    <methods/>
  </class>
  <class type="dojox.highlight.languages">
    <properties>
      <property name="xquery" scope="instance" type="Object"/>
      <property name="xml" scope="instance" type="Object"/>
      <property name="sql" scope="instance" type="Object">
        <description>SQL highlight definitions</description>
      </property>
      <property name="python" scope="instance" type="Object">
        <description>Python highlight definitions</description>
      </property>
      <property name="pygments" scope="instance" type="Object"/>
      <property name="javascript" scope="instance" type="Object"/>
      <property name="java" scope="instance" type="Object">
        <description>Java highlight definitions</description>
      </property>
      <property name="html" scope="instance" type="Object"/>
      <property name="groovy" scope="instance" type="Object">
        <description>Groovy highlight definitions
	
	
	exporting constants</description>
      </property>
      <property name="django" scope="instance" type="Object"/>
      <property name="delphi" scope="instance" type="Object">
        <description>Delphi highlight definitions</description>
      </property>
      <property name="css" scope="instance" type="Object"/>
      <property name="cpp" scope="instance" type="Object">
        <description>C++ highlight definitions</description>
      </property>
    </properties>
  </class>
  <class type="dojox.highlight.languages.cpp">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.cpp.defaultMode">
    <properties>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.cpp.defaultMode.keywords"/>
  <class type="dh">
    <properties>
      <property name="languages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dh.languages">
    <properties>
      <property name="css" scope="instance" type="Object">
        <description>CSS Language definition file.</description>
      </property>
    </properties>
  </class>
  <class type="dh.languages.css">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dh.languages.css.defaultMode"/>
  <class type="dojox.highlight.languages.delphi">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.delphi.defaultMode"/>
  <class type="dojox.highlight.languages.django">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.django.defaultMode"/>
  <class type="dojox.highlight.languages.groovy">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.groovy.defaultMode"/>
  <class type="dojox.highlight.languages.html">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.html.defaultMode"/>
  <class type="dojox.highlight.languages.java">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.java.defaultMode"/>
  <class type="dojox.highlight.languages.javascript">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode">
    <properties>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords">
    <properties>
      <property name="name builtin pseudo" scope="instance" type="Object"/>
      <property name="name builtin" scope="instance" type="Object"/>
      <property name="literal" scope="instance" type="Object"/>
      <property name="keyword constant" scope="instance" type="Object"/>
      <property name="keyword" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.keyword"/>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.literal"/>
  <class type="dojox.highlight.languages.pygments._html">
    <properties>
      <property name="tags" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments._html.tags"/>
  <class type="dojox.highlight.languages.pygments">
    <properties>
      <property name="_html" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css.defaultMode">
    <properties>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css.defaultMode.keywords">
    <properties>
      <property name="keyword" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css.defaultMode.keywords.keyword"/>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.keyword constant"/>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.name builtin"/>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.name builtin pseudo"/>
  <class type="dojox.highlight.languages.xml">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xml.defaultMode"/>
  <class type="dojox.highlight.languages.python">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.python.defaultMode">
    <properties>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.python.defaultMode.keywords"/>
  <class type="dojox.highlight.languages.sql">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql.defaultMode">
    <properties>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql.defaultMode.keywords">
    <properties>
      <property name="aggregate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql.defaultMode.keywords.aggregate"/>
  <class type="dojox.highlight.languages.xquery">
    <properties>
      <property name="defaultMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xquery.defaultMode">
    <properties>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xquery.defaultMode.keywords"/>
  <class type="dojox.highlight.widget">
    <methods>
      <method name="Code" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.highlight.widget.Code" superclass="dijit._Widget">
    <methods>
      <method name="setRange" scope="instance">
        <parameters>
          <parameter name="range" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_updateView" scope="instance"/>
      <method name="_populate" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadError" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.widget.Code.containerNode"/>
  <class type="dojox.html">
    <methods>
      <method name="_ContentSetter" scope="instance"/>
    </methods>
    <properties>
      <property name="ext-dojo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html._ContentSetter" superclass="htmlUtil._ContentSetter">
    <methods>
      <method name="tearDown" scope="instance"/>
      <method name="onEnd" scope="instance"/>
      <method name="onBegin" scope="instance"/>
      <method name="empty" scope="instance"/>
      <method name="_renderStyles" scope="instance">
        <parameters>
          <parameter name="styles" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="htmlUtil._ContentSetter" scope="instance"/>
    </mixins>
    <properties>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html._ContentSetter.node"/>
  <class type="d"/>
  <class type="dojox.html.ext-dojo"/>
  <class type="dojox.image">
    <methods>
      <method name="preload" scope="instance">
        <examples>
          <example>Load two images into cache:
		dojox.image.preload(["foo.png", "bar.gif"]);</example>
          <example>Using djConfig:
		var djConfig = {
			preloadImages:["bar.png", "baz.png", "http://example.com/icon.gif"]
		};</example>
        </examples>
        <parameters>
          <parameter name="urls" type="Array" usage="required">
            <description>The list of urls to load. Can be any valid .src attribute.</description>
          </parameter>
        </parameters>
        <return-description>Array
	An Array of DomNodes that have been cached.</return-description>
      </method>
      <method name="ThumbnailPicker" scope="instance"/>
      <method name="SlideShow" scope="instance"/>
      <method name="MagnifierLite" scope="instance">
        <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	
	The logic behind requiring the src image to be large is
	"it's going to be downloaded, anyway" so this method avoids
	having to make thumbnails and 2 http requests among other things.</description>
      </method>
      <method name="Magnifier" scope="instance">
        <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	
	over-ride the _createGlass method to create your custom surface,
	being sure to create an img node on that surface.</description>
      </method>
      <method name="LightboxNano" scope="instance">
        <description>Very lightweight lightbox which only displays a larger image.  There is
	no support for a caption or description.  The lightbox can be closed by
	clicking any where or pressing any key.  This widget is intended to be
	used on &lt;a&gt; and &lt;img&gt; tags.  Upon creation, if the domNode is &lt;img&gt; tag,
	then it is wrapped in an &lt;a&gt; tag, then a &lt;div class="enlarge"&gt; is placed
	inside the &lt;a&gt; and can be styled to display an icon that the original
	can be enlarged.</description>
        <examples>
          <example>	&lt;a dojoType="dojox.image.LightboxNano" href="/path/to/largeimage.jpg"&gt;&lt;img src="/path/to/thumbnail.jpg"&gt;&lt;/a&gt;</example>
          <example>	&lt;img dojoType="dojox.image.LightboxNano" src="/path/to/thumbnail.jpg" href="/path/to/largeimage.jpg"&gt;</example>
        </examples>
        <parameters>
          <parameter name="p" type="Object" usage="optional"/>
          <parameter name="n" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="LightboxDialog" scope="instance">
        <description>A widget that intercepts anchor links (typically around images)
	and displays a modal Dialog. this is the actual Dialog, which you can
	create and populate manually, though should use simple Lightbox's
	unless you need the direct access.
	
	There should only be one of these on a page, so all dojox.image.Lightbox's will us it
	(the first instance of a Lightbox to be show()'n will create me If i do not exist)</description>
        <examples>
          <example>	// show a single image from a url
		var url = "http://dojotoolkit.org/logo.png";
		var dialog = new dojox.image.LightboxDialog().startup();
		dialog.show({ href: url, title:"My Remote Image"});</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Lightbox" scope="instance">
        <description>An Elegant, keyboard accessible, markup and store capable Lightbox widget to show images
	in a modal dialog-esque format. Can show individual images as Modal dialog, or can group
	images with multiple entry points, all using a single "master" Dialog for visualization
	
	key controls:
	ESC - close
	Down Arrow / Rt Arrow / N - Next Image
	Up Arrow / Lf Arrow / P - Previous Image</description>
        <examples>
          <example>	&lt;a href="image1.jpg" dojoType="dojox.image.Lightbox"&gt;show lightbox&lt;/a&gt;</example>
          <example>	&lt;a href="image2.jpg" dojoType="dojox.image.Lightbox" group="one"&gt;show group lightbox&lt;/a&gt;
		&lt;a href="image3.jpg" dojoType="dojox.image.Lightbox" group="one"&gt;show group lightbox&lt;/a&gt;</example>
          <example>	not implemented fully yet, though works with basic datastore access. need to manually call
		widget._attachedDialog.addImage(item,"fromStore") for each item in a store result set.
		&lt;div dojoType="dojox.image.Lightbox" group="fromStore" store="storeName"&gt;&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="Gallery" scope="instance"/>
      <method name="FlickrBadge" scope="instance"/>
      <method name="Badge" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.image.Badge" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_loadUnder" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_init" scope="instance"/>
      <method name="_getImage" scope="instance"/>
      <method name="_getCell" scope="instance">
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_enbiggen" scope="instance">
        <parameters>
          <parameter name="e" type="Event|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_disenbiggen" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cycle" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_nl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Badge._nl"/>
  <class type="dojox.image.FlickrBadge" superclass="dojox.image.Badge">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.image.Badge" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.image.Gallery" superclass="dijit._Widget">
    <methods>
      <method name="toggleSlideshow" scope="instance"/>
      <method name="toggleSlideShow" scope="instance"/>
      <method name="showNextImage" scope="instance">
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required">
            <description>If true, a slideshow is active, otherwise the slideshow is inactive.</description>
          </parameter>
        </parameters>
      </method>
      <method name="showImage" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="callback" type="optional" usage="required">
            <description>Function Optional callback function to call when the image has finished displaying.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <description>implementation of the dojo.data.api.Read API. This accesses the image
	data.</description>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <description>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</description>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <description>An object defining the names of the item attributes to fetch from the
	data store.  The four attributes allowed are 'linkAttr', 'imageLargeAttr',
	'imageThumbAttr' and 'titleAttr'</description>
          </parameter>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_centerChildren" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.image.Lightbox" superclass="dijit._Widget">
    <description>An Elegant, keyboard accessible, markup and store capable Lightbox widget to show images
	in a modal dialog-esque format. Can show individual images as Modal dialog, or can group
	images with multiple entry points, all using a single "master" Dialog for visualization
	
	key controls:
	ESC - close
	Down Arrow / Rt Arrow / N - Next Image
	Up Arrow / Lf Arrow / P - Previous Image</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="enable" scope="instance"/>
      <method name="disable" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_handleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_addSelf" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.image.LightboxDialog" superclass="dijit.Dialog">
    <description>A widget that intercepts anchor links (typically around images)
	and displays a modal Dialog. this is the actual Dialog, which you can
	create and populate manually, though should use simple Lightbox's
	unless you need the direct access.
	
	There should only be one of these on a page, so all dojox.image.Lightbox's will us it
	(the first instance of a Lightbox to be show()'n will create me If i do not exist)</description>
    <methods>
      <method name="startup" scope="instance">
        <return-description>dijit._Widget
	Perhaps the only `dijit._Widget` that returns itself to allow
	'chaining' or var referencing with .startup()</return-description>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="groupData" type="Object" usage="required">
            <description>needs href and title attributes. the values for this image.</description>
          </parameter>
        </parameters>
      </method>
      <method name="resizeTo" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="forceTitle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeImage" scope="instance">
        <parameters>
          <parameter name="child" type="Widget" usage="required">
            <description>Object A reference to the Lightbox child that was added (or an object literal)
	only the .href member is compared for uniqueness. The object may contain
	a .group member as well.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeGroup" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="groupData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addImage" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required">
            <description>The image information to add.
	href: String - link to image (required)
	title: String - title to display</description>
          </parameter>
          <parameter name="group" type="String" usage="optional">
            <description>attach to group of similar tag or null for individual image instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="_size" scope="instance"/>
      <method name="_showNav" scope="instance"/>
      <method name="_showImage" scope="instance"/>
      <method name="_setImageSize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scaleToFit" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required">
            <description>The 'size' object passed around for this image</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_ready" scope="instance">
        <parameters>
          <parameter name="src" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prevImage" scope="instance"/>
      <method name="_prepNodes" scope="instance"/>
      <method name="_position" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onImageClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_nextImage" scope="instance"/>
      <method name="_makeAnims" scope="instance"/>
      <method name="_loadImage" scope="instance"/>
      <method name="_handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_calcTitleSize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="imgNode" scope="instance" type="Object"/>
      <property name="_groups" scope="instance-prototype" type="Object">
        <description>an object of arrays, each array (of objects) being a unique 'group'</description>
      </property>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog._groups"/>
  <class type="dojox.image.LightboxDialog.imgNode"/>
  <class type="dojox.image.LightboxNano">
    <description>Very lightweight lightbox which only displays a larger image.  There is
	no support for a caption or description.  The lightbox can be closed by
	clicking any where or pressing any key.  This widget is intended to be
	used on &lt;a&gt; and &lt;img&gt; tags.  Upon creation, if the domNode is &lt;img&gt; tag,
	then it is wrapped in an &lt;a&gt; tag, then a &lt;div class="enlarge"&gt; is placed
	inside the &lt;a&gt; and can be styled to display an icon that the original
	can be enlarged.</description>
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>An object with optional members of `href` and `origin`.
	`origin` can be be a String|Id of a DomNode to use when
	animating the openeing of the image (the 'box' effect starts
	from this origin point. eg: { origin: e.target })
	If there's no origin, it will use the center of the viewport.
	The `href` member is a string URL for the image to be
	displayed. Omiting either of these members will revert to
	the default href (which could be absent in some cases) and
	the original srcNodeRef for the widget.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="optional"/>
          <parameter name="n" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="_sizeBg" scope="instance"/>
      <method name="_show" scope="instance"/>
      <method name="_reset" scope="instance"/>
      <method name="_load" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_key" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_hideLoading" scope="instance"/>
      <method name="_hide" scope="instance"/>
      <method name="_createDiv" scope="instance">
        <parameters>
          <parameter name="cssClass" type="String" usage="required"/>
          <parameter name="refNode" type="DomNode" usage="required"/>
          <parameter name="display" type="boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="_coords" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_anim" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="onEnd" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.image.Magnifier" superclass="MagnifierLite">
    <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	
	over-ride the _createGlass method to create your custom surface,
	being sure to create an img node on that surface.</description>
    <methods>
      <method name="_setImage" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createGlass" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="MagnifierLite" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.image.MagnifierLite" superclass="_Widget">
    <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	
	The logic behind requiring the src image to be large is
	"it's going to be downloaded, anyway" so this method avoids
	having to make thumbnails and 2 http requests among other things.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="finalize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createGlass" scope="instance"/>
      <method name="_adjustScale" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.image.SlideShow" superclass="dijit._Widget">
    <methods>
      <method name="toggleSlideShow" scope="instance"/>
      <method name="showNextImage" scope="instance">
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required">
            <description>If true, a slideshow is active, otherwise the slideshow is inactive.</description>
          </parameter>
          <parameter name="forceLoop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showImage" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required">
            <description>The position of the image in the data store to display</description>
          </parameter>
          <parameter name="callback" type="Function" usage="optional">
            <description>Optional callback function to call when the image has finished displaying.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <description>implementation of the dojo.data.api.Read API. This accesses the image
	data.</description>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <description>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</description>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <description>An object defining the names of the item attributes to fetch from the
	data store.  The three attributes allowed are 'linkAttr', 'imageLargeAttr' and 'titleAttr'</description>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="instance">
        <description>Removes all previously loaded images, and clears all caches.</description>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="moveImageLoadingPointer" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>number index in the data store to start loading images from.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isImageLoaded" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>number index in the data store to check if it is loaded.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getShowTopicName" scope="instance">
        <description>The information published is: index, title and url</description>
      </method>
      <method name="getLoadTopicName" scope="instance">
        <description>The information published is the index position of the image loaded.</description>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_stop" scope="instance"/>
      <method name="_startTimer" scope="instance"/>
      <method name="_showNav" scope="instance">
        <parameters>
          <parameter name="force" type="Boolean" usage="required">
            <description>If true, the navigation controls are repositioned even if they are
	currently visible.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required">
            <description>The String title of the image</description>
          </parameter>
        </parameters>
      </method>
      <method name="_prev" scope="instance"/>
      <method name="_overElement" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_next" scope="instance"/>
      <method name="_loadNextImage" scope="instance"/>
      <method name="_loadImage" scope="instance">
        <description>This function loads the image at position 'index' into the
	internal cache of images.  This does not cause the image to be displayed.</description>
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>position in the data store to load an image from.</description>
          </parameter>
          <parameter name="callbackFn" type="An" usage="required">
            <description>optional function to execute when the image has finished loading.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hideNav" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The DOM Event that triggered this function</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>An Event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getTopPadding" scope="instance"/>
      <method name="_fitSize" scope="instance">
        <parameters>
          <parameter name="force" type="Boolean" usage="required">
            <description>If true, the widget is always resized, regardless of the value of 'fixedHeight'</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fitImage" scope="instance">
        <parameters>
          <parameter name="img" type="Node" usage="required">
            <description>The image DOM node to optionally resize</description>
          </parameter>
        </parameters>
      </method>
      <method name="_calcNavDimensions" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="titleNode" scope="instance" type="Object"/>
      <property name="navPrev" scope="instance" type="Object"/>
      <property name="navPlay" scope="instance" type="Object"/>
      <property name="navNext" scope="instance" type="Object"/>
      <property name="_request" scope="instance" type="Object">
        <description>Implementation of the dojo.data.api.Request API, which defines the query
	parameters for accessing the store.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.outerNode.style"/>
  <class type="dojox.image.SlideShow._request">
    <methods>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.image.SlideShow.navPlay"/>
  <class type="dojox.image.SlideShow.navPrev"/>
  <class type="dojox.image.SlideShow.navNext"/>
  <class type="dojox.image.SlideShow.titleNode"/>
  <class type="dojox.image.ThumbnailPicker" superclass="dijit._Widget">
    <methods>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <description>implementation of the dojo.data.api.Read API. This accesses the image
	data.</description>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <description>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</description>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <description>An object defining the names of the item attributes to fetch from the
	data store.  The four attributes allowed are 'linkAttr', 'imageLargeAttr',
	'imageThumbAttr' and 'titleAttr'</description>
          </parameter>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="markImageLoaded" scope="instance">
        <description>If 'useLoadNotifier' is set to true, then a visual cue is
	given to state whether the image is loaded or not.	Calling this function
	marks an image as loaded.</description>
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isVisible" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="getShowTopicName" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getClickTopicName" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_updateNavControls" scope="instance"/>
      <method name="_showThumbs" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required">
            <description>The index of the first thumbnail</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setThumbClass" scope="instance">
        <parameters>
          <parameter name="thumb" type="DomNode" usage="required">
            <description>The thumbnail DOM node to set the class on</description>
          </parameter>
          <parameter name="className" type="String" usage="required">
            <description>The CSS class to add to the DOM node.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_prev" scope="instance"/>
      <method name="_next" scope="instance"/>
      <method name="_loadNextPage" scope="instance"/>
      <method name="_loadImage" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkLoad" scope="instance">
        <parameters>
          <parameter name="img" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="thumbScroller" scope="instance" type="Object"/>
      <property name="request" scope="instance" type="Object">
        <description>A dojo.data Read API Request object.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker.request"/>
  <class type="dojox.image.ThumbnailPicker.thumbScroller"/>
  <class type="dojox.io">
    <methods>
      <method name="xhrWindowNamePlugin" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>Url prefix of the site which can handle windowName requests.</description>
          </parameter>
          <parameter name="httpAdapter" type="Function" usage="optional">
            <description>This allows for adapting HTTP requests that could not otherwise be
	sent with window.name, so you can use a convention for headers and PUT/DELETE methods.</description>
          </parameter>
          <parameter name="trusted" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="xhrScriptPlugin" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>Url prefix of the site which can handle JSONP requests.</description>
          </parameter>
          <parameter name="callbackParamName" type="String" usage="required"/>
          <parameter name="httpAdapter" type="Function" usage="optional">
            <description>This allows for adapting HTTP requests that could not otherwise be
	sent with JSONP, so you can use a convention for headers and PUT/DELETE methods.</description>
          </parameter>
        </parameters>
      </method>
      <method name="xhrMultiPart" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.io.__xhrMultiArgs" usage="required"/>
        </parameters>
      </method>
      <method name="httpParse" scope="instance">
        <parameters>
          <parameter name="httpStream" type="String" usage="required">
            <description>HTTP stream to parse</description>
          </parameter>
          <parameter name="topHeaders" type="String" usage="optional">
            <description>Extra header information to add to each HTTP request (kind of HTTP inheritance)</description>
          </parameter>
          <parameter name="partial" type="Boolean" usage="optional">
            <description>A true value indicates that the stream may not be finished, it may end arbitrarily in mid stream.
	The last XHR object will have a special property _lastIndex that indicates the how far along
	the httpStream could be successfully parsed into HTTP messages.
	return:
	Returns an array of XHR-like object for reading the headers for each message</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="the content is not finished"/>
        </return-types>
      </method>
      <method name="__xhrMultiArgs" scope="instance"/>
      <method name="__xhrContentArgs" scope="instance"/>
    </methods>
    <properties>
      <property name="xhrPlugins" scope="instance" type="Object"/>
      <property name="windowName" scope="instance" type="Object"/>
      <property name="scriptFrame" scope="instance" type="Object"/>
      <property name="proxy" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip">
    <description>Do not use this object directly. See the Dojo Book page
	on XMLHttpRequest IFrame Proxying:
	http://dojotoolkit.org/book/dojo-book-0-4/part-5-connecting-pieces/i-o/cross-domain-xmlhttprequest-using-iframe-proxy
	Usage of XHR IFrame Proxying does not work from local disk in Safari.</description>
    <methods>
      <method name="unpackMessage" scope="instance">
        <parameters>
          <parameter name="encodedMessage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setServerUrl" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestStart" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestPart" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequest" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="encodedData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="send" scope="instance">
        <parameters>
          <parameter name="facade" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="receive" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
          <parameter name="urlEncodedData" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="makeServerUrl" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="frameLoaded" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceivedEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceived" scope="instance">
        <parameters>
          <parameter name="frag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyState" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="createFacade" scope="instance"/>
      <method name="_realSend" scope="instance">
        <parameters>
          <parameter name="facade" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="XhrIframeFacade" scope="instance">
        <description>Do not use this object directly. See the Dojo Book page
	on XMLHttpRequest IFrame Proxying:
	http://dojotoolkit.org/book/dojo-book-0-4/part-5-connecting-pieces/i-o/cross-domain-xmlhttprequest-using-iframe-proxy</description>
        <parameters>
          <parameter name="ifpServerUrl" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade">
    <description>Do not use this object directly. See the Dojo Book page
	on XMLHttpRequest IFrame Proxying:
	http://dojotoolkit.org/book/dojo-book-0-4/part-5-connecting-pieces/i-o/cross-domain-xmlhttprequest-using-iframe-proxy</description>
    <methods>
      <method name="setRequestHeader" scope="instance">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="send" scope="instance">
        <parameters>
          <parameter name="stringData" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="uri" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getResponseHeader" scope="instance">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getAllResponseHeaders" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="abort" scope="instance"/>
      <method name="_setResponseHeaders" scope="instance">
        <parameters>
          <parameter name="allHeaders" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade.open">
    <methods/>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade.send">
    <methods/>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade._setResponseHeaders">
    <methods/>
  </class>
  <class type="dojox.io.proxy">
    <properties>
      <property name="xip" scope="instance" type="Object">
        <description>Object that implements the iframe handling for XMLHttpRequest
	IFrame Proxying.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.send">
    <methods/>
  </class>
  <class type="dojox.io.scriptFrame">
    <methods>
      <method name="_loaded" scope="instance">
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getWaiters" scope="instance">
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fixAttachUrl" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="ioScript">
    <methods>
      <method name="_canAttach" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.io.windowName">
    <methods>
      <method name="send" scope="instance">
        <description>In order to provide a windowname transport accessible resources/web services, a server
	should check for the presence of a parameter window.name=true and if a request includes
	such a parameter, it should respond to the request with an HTML
	document that sets it's window.name to the string that is to be
	delivered to the client. For example, if a client makes a window.name request like:
		http://othersite.com/greeting?windowname=true
	And server wants to respond to the client with "Hello", it should return an html page:
		&lt;html&gt;&lt;script type="text/javascript"&gt;
		window.name="Hello";
		&lt;/script&gt;&lt;/html&gt;
	One can provide XML or JSON data by simply quoting the data as a string, and parsing the data
	on the client.
	If you use the authorization window.name protocol, the requester should include an
	authElement element in the args, and a request will be created like:
		http://othersite.com/greeting?windowname=auth
	And the server can respond like this:
		&lt;html&gt;&lt;script type="text/javascript"&gt;
		var loc = window.name;
		authorizationButton.onclick = function(){
			window.name="Hello";
			location = loc;
		};
		&lt;/script&gt;&lt;/html&gt;
	When using windowName from a XD Dojo build, make sure to set the
	dojo.dojoBlankHtmlUrl property to a local URL.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>The method to use to send the request, GET or POST</description>
          </parameter>
          <parameter name="args" type="dojo.__IoArgs" usage="required">
            <description>See dojo.xhr
	
	args.authElement: DOMNode?
	By providing an authElement, this indicates that windowName should use the
	authorized window.name protocol, relying on
	the loaded XD resource to return to the provided return URL on completion
	of authorization/authentication. The provided authElement will be used to place
	the iframe in, so the user can interact with the server resource for authentication
	and/or authorization to access the resource.
	
	args.onAuthLoad: Function?
	When using authorized access to resources, this function will be called when the
	authorization page has been loaded. (When authorization is actually completed,
	the deferred callback function is called with the result). The primary use for this
	is to make the authElement visible to the user once the resource has loaded
	(this can be preferable to showing the iframe while the resource is loading
	since it may not require authorization, it may simply return the resource).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_send" scope="instance">
        <parameters>
          <parameter name="dfd" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="authTarget" type="Object" usage="required"/>
          <parameter name="onAuthLoad" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.io.__xhrContentArgs">
    <methods/>
  </class>
  <class type="dojox.io.__xhrMultiArgs">
    <methods>
      <method name="load" scope="instance"/>
      <method name="handle" scope="instance"/>
      <method name="error" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.io.xhrPlugins">
    <methods>
      <method name="register" scope="instance">
        <return-types>
          <return-type type="or check to see if we have the same path"/>
        </return-types>
      </method>
      <method name="fullHttpAdapter" scope="instance">
        <description>The following convention is used:
	method name -&gt; ?http-method=PUT
	Header -&gt; http-Header-Name=header-value
	X-Header -&gt; header_name=header-value</description>
        <examples>
          <example>dojox.io.xhrPlugins.addXdr("http://somesite.com", dojox.io.xhrPlugins.fullHttpAdapter);</example>
        </examples>
        <parameters>
          <parameter name="plainXhr" type="Object" usage="required"/>
          <parameter name="noRawBody" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addProxy" scope="instance">
        <examples>
          <example>Define a proxy:
		dojox.io.xhrPlugins.addProxy("/proxy?url=");
	And then when you call:
		dojo.xhr("GET",{url:"http://othersite.com/file"});
	It would result in the request (to your origin server):
		GET /proxy?url=http%3A%2F%2Fothersite.com%2Ffile HTTP/1.1</example>
        </examples>
        <parameters>
          <parameter name="proxyUrl" type="This" usage="required">
            <description>is URL to send the requests to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addCrossSiteXhr" scope="instance">
        <description>This can be used for servers that support W3C cross-site XHR. In order for
	a server to allow a client to make cross-site XHR requests,
	it should respond with the header like:
		Access-Control: allow &lt;*&gt;
	see: http://www.w3.org/TR/access-control/</description>
        <parameters>
          <parameter name="url" type="Requests" usage="required">
            <description>that start with this URL will be considered for using
	cross-site XHR.</description>
          </parameter>
          <parameter name="httpAdapter" type="This" usage="required">
            <description>allows for adapting HTTP requests that could not otherwise be
	sent with XDR, so you can use a convention for headers and PUT/DELETE methods.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.query.pseudos">
    <methods>
      <method name="visible" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selected" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="input" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hidden" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="header" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="has" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disabled" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checked" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="button" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="inputPseudos" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.global">
    <methods>
      <method name="jQuery" scope="instance"/>
      <method name="$" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.json">
    <methods>
      <method name="query" scope="instance">
        <description>JSONQuery provides a comprehensive set of data querying tools including filtering,
	recursive search, sorting, mapping, range selection, and powerful expressions with
	wildcard string comparisons and various operators. JSONQuery generally supersets
	JSONPath and provides syntax that matches and behaves like JavaScript where
	possible.
	
	JSONQuery evaluations begin with the provided object, which can referenced with
	$. From
	the starting object, various operators can be successively applied, each operating
	on the result of the last operation.
	
	Supported Operators:
	--------------------
	* .property - This will return the provided property of the object, behaving exactly
	like JavaScript.
	* [expression] - This returns the property name/index defined by the evaluation of
	the provided expression, behaving exactly like JavaScript.
	* [?expression] - This will perform a filter operation on an array, returning all the
	items in an array that match the provided expression. This operator does not
	need to be in brackets, you can simply use ?expression, but since it does not
	have any containment, no operators can be used afterwards when used
	without brackets.
	* [^?expression] - This will perform a distinct filter operation on an array. This behaves
	as [?expression] except that it will remove any duplicate values/objects from the
	result set.
	* [/expression], [\expression], [/expression, /expression] - This performs a sort
	operation on an array, with sort based on the provide expression. Multiple comma delimited sort
	expressions can be provided for multiple sort orders (first being highest priority). /
	indicates ascending order and \ indicates descending order
	* [=expression] - This performs a map operation on an array, creating a new array
	with each item being the evaluation of the expression for each item in the source array.
	* [start:end:step] - This performs an array slice/range operation, returning the elements
	from the optional start index to the optional end index, stepping by the optional step number.
	* [expr,expr] - This a union operator, returning an array of all the property/index values from
	the evaluation of the comma delimited expressions.
	* .* or [*] - This returns the values of all the properties of the current object.
	* $ - This is the root object, If a JSONQuery expression does not being with a $,
	it will be auto-inserted at the beginning.
	* @ - This is the current object in filter, sort, and map expressions. This is generally
	not necessary, names are auto-converted to property references of the current object
	in expressions.
	*	..property - Performs a recursive search for the given property name, returning
	an array of all values with such a property name in the current object and any subobjects
	* expr = expr - Performs a comparison (like JS's ==). When comparing to
	a string, the comparison string may contain wildcards * (matches any number of
	characters) and ? (matches any single character).
	* expr ~ expr - Performs a string comparison with case insensitivity.
	* ..[?expression] - This will perform a deep search filter operation on all the objects and
	subobjects of the current data. Rather than only searching an array, this will search
	property values, arrays, and their children.
	* $1,$2,$3, etc. - These are references to extra parameters passed to the query
	function or the evaluator function.
	* +, -, /, *, &amp;, |, %, (, ), &lt;, &gt;, &lt;=, &gt;=, != - These operators behave just as they do
	in JavaScript.
	
	
	
		dojox.json.query(queryString,object)
	and
		dojox.json.query(queryString)(object)
	always return identical results. The first one immediately evaluates, the second one returns a
	function that then evaluates the object.</description>
        <examples>
          <example>	dojox.json.query("foo",{foo:"bar"})
	This will return "bar".</example>
          <example>	evaluator = dojox.json.query("?foo='bar'&amp;rating&gt;3");
	This creates a function that finds all the objects in an array with a property
	foo that is equals to "bar" and with a rating property with a value greater
	than 3.
		evaluator([{foo:"bar",rating:4},{foo:"baz",rating:2}])
	This returns:
		{foo:"bar",rating:4}</example>
          <example>	evaluator = dojox.json.query("$[?price&lt;15.00][\rating][0:10]");
	This finds objects in array with a price less than 15.00 and sorts then
	by rating, highest rated first, and returns the first ten items in from this
	filtered and sorted list.</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <description>Query string</description>
          </parameter>
          <parameter name="obj" type="Object" usage="optional">
            <description>Target of the JSONQuery</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="we mark all the inner brackets as skippable"/>
        </return-types>
      </method>
      <method name="_slice" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_find" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_distinctFilter" scope="instance">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="schema" scope="instance" type="Object"/>
      <property name="ref" scope="instance" type="Object">
        <description>Adds advanced JSON {de}serialization capabilities to the base json library.
	This enhances the capabilities of dojo.toJson and dojo.fromJson,
	adding referencing support, date handling, and other extra format handling.
	On parsing, references are resolved. When references are made to
	ids/objects that have been loaded yet, the loader function will be set to
	_loadObject to denote a lazy loading (not loaded yet) object.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.json.ref.resolveJson">
    <description>A JSON Schema object that can be used to advise the handling of the JSON (defining ids, date properties, urls, etc)</description>
    <methods/>
  </class>
  <class type="dojox.json.ref.toJson">
    <methods/>
  </class>
  <class type="dojox.json.schema">
    <methods>
      <method name="validate" scope="instance">
        <description>The validate method will return an object with two properties:
	valid: A boolean indicating if the instance is valid by the schema
	errors: An array of validation errors. If there are no errors, then an
	empty list will be returned. A validation error will have two properties:
	property: which indicates which property had the error
	message: which indicates what the error was</description>
        <parameters>
          <parameter name="instance" type="Any" usage="required">
            <description>The instance value/object to validate</description>
          </parameter>
          <parameter name="schema" type="Object" usage="required">
            <description>The schema to use to validate</description>
          </parameter>
        </parameters>
      </method>
      <method name="mustBeValid" scope="instance">
        <parameters>
          <parameter name="result" type="the" usage="required">
            <description>result returned from checkPropertyChange or validate</description>
          </parameter>
        </parameters>
      </method>
      <method name="checkPropertyChange" scope="instance">
        <parameters>
          <parameter name="value" type="Any" usage="required">
            <description>The new instance value/object to check</description>
          </parameter>
          <parameter name="schema" type="Object" usage="required">
            <description>The schema to use to validate
	return:
	see dojox.validate.jsonSchema.validate</description>
          </parameter>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_validate" scope="instance">
        <parameters>
          <parameter name="instance" type="Any" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
          <parameter name="_changing" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.jsonPath">
    <methods>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="expr" type="String" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang">
    <methods>
      <method name="observable" scope="instance">
        <parameters>
          <parameter name="wrapped" type="Object" usage="required">
            <description>The object to be wrapped and monitored for property access and modification</description>
          </parameter>
          <parameter name="onRead" type="function" usage="required">
            <description>See dojox.lang.makeObservable.onRead</description>
          </parameter>
          <parameter name="onWrite" type="function" usage="required">
            <description>See dojox.lang.makeObservable.onWrite</description>
          </parameter>
          <parameter name="onInvoke" type="function" usage="required">
            <description>See dojox.lang.makeObservable.onInvoke</description>
          </parameter>
        </parameters>
      </method>
      <method name="makeObservable" scope="instance">
        <examples>
          <example>The following could be used to create a wrapper that would
	prevent functions from being accessed on an object:
		function onRead(obj,prop){
			return typeof obj[prop] == 'function' ? null : obj[prop];
		}
		var observable = dojox.lang.makeObservable(onRead,onWrite);
		var obj = {foo:1,bar:function(){}};
		obj = observable(obj);
		obj.foo -&gt; 1
		obj.bar -&gt; null</example>
        </examples>
        <parameters>
          <parameter name="onRead" type="function" usage="required">
            <description>This is called whenever one of the wrapper objects created
	from the constructor has a property that is accessed. onRead
	will be called with two arguments, the first being the wrapped object,
	and the second is the name of property that is being accessed.
	The value that onRead returns will be used as the value returned
	by the property access</description>
          </parameter>
          <parameter name="onWrite" type="function" usage="required">
            <description>This is called whenever one of the wrapper objects created
	from the constructor has a property that is modified. onWrite
	will be called with three arguments, the first being the wrapped object,
	the second is the name of property that is being modified, and the
	third is the value that is being set on the property.</description>
          </parameter>
          <parameter name="onInvoke" type="function" usage="required">
            <description>This is called when a method on the object is invoked. The first
	argument is the wrapper object, the second is the original wrapped object,
	the third is the method name, and the fourth is the arguments.</description>
          </parameter>
          <parameter name="hiddenFunctions" type="Object" usage="required">
            <description>allows you to define functions that should be delegated
	but may not be enumerable on the wrapped objects, so they must be
	explicitly included</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="do it with getters and setters"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="oo" scope="instance" type="Object"/>
      <property name="functional" scope="instance" type="Object">
        <description>Functional language constructs, including currying and lambda.</description>
      </property>
      <property name="docs" scope="instance" type="Object"/>
      <property name="async" scope="instance" type="Object"/>
      <property name="aspect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.aspect">
    <methods>
      <method name="unadvise" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required">
            <description>The object returned by dojox.lang.aspect.advise().</description>
          </parameter>
        </parameters>
      </method>
      <method name="tracer" scope="instance">
        <parameters>
          <parameter name="grouping" type="Boolean" usage="required">
            <description>The flag to group output. If true, indents embedded console messages.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="timer" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <description>The optional unique name of the timer.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="profiler" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="optional">
            <description>The optional name of the profile section.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="proceed" scope="instance">
        <description>Calls the original function (or the next level around advice).
	Accepts and passes on any number of arguments, and returns a value.
	This function is valid only in the content of around calls.</description>
      </method>
      <method name="memoizerGuard" scope="instance">
        <parameters>
          <parameter name="method" type="String|Array" usage="optional">
            <description>Optional method's name to be guarded: only cache for
	this method will be invalidated on call. Can be a string
	or an array of method names. If omitted the whole cache
	will be invalidated.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="memoizer" scope="instance">
        <parameters>
          <parameter name="keyMaker" type="Function" usage="optional">
            <description>the function, which takes method's arguments and returns a key,
	which can be used to index the result.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getContextStack" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getContext" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="counter" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="cflow" scope="instance">
        <parameters>
          <parameter name="instance" type="Object" usage="required">
            <description>An instance to be matched. If null, any context will be examined.
	Otherwise the context should belong to this instance.</description>
          </parameter>
          <parameter name="method" type="String|RegExp|Array" usage="optional">
            <description>An optional pattern to be matched against a method name. Can be a string,
	a RegExp object or an array of strings and RegExp objects.
	If it is omitted, any name will satisfy the criteria.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="adviseRaw" scope="instance">
        <description>Attaches AOP-style advices to object's methods. Can attach several
	advices at once and operate on several methods of the object.
	The latter is achieved when a RegExp is specified as
	a method name. In this case all functional methods that
	satisfy the RegExp condition are processed. This function
	returns a handle, which can be used to unadvise, or null,
	if advising has failed.</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>A source object for the advised function.
	Cannot be a DOM node.</description>
          </parameter>
          <parameter name="methods" type="Array" usage="required">
            <description>An array of method names (strings) to be advised.</description>
          </parameter>
          <parameter name="advices" type="Array" usage="required">
            <description>An array of advices represented by objects or functions that
	return such objects on demand during the event processing.
	The advice object can define following member functions:
	before, around, afterReturning, afterThrowing, after.
	If the function is supplied, it is called with a context
	object once per call to create a temporary advice object, which
	is destroyed after the processing. The temporary advice object
	can implement a destroy() method, if it wants to be called when
	not needed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="advise" scope="instance">
        <description>Attaches AOP-style advices to a method. Can attach several
	advices at once and operate on several methods of an object.
	The latter is achieved when a RegExp is specified as
	a method name, or an array of strings and regular expressions
	is used. In this case all functional methods that
	satisfy the RegExp condition are processed. This function
	returns a handle, which can be used to unadvise, or null,
	if advising has failed.
	
	This function is a convenience wrapper for
	dojox.lang.aspect.adviseRaw().</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>A source object for the advised function. Cannot be a DOM node.
	If this object is a constructor, its prototype is advised.</description>
          </parameter>
          <parameter name="method" type="String|RegExp|Array" usage="required">
            <description>A string name of the function in obj. In case of RegExp all
	methods of obj matching the regular expression are advised.</description>
          </parameter>
          <parameter name="advice" type="Object|Function|Array" usage="required">
            <description>An object, which defines advises, or a function, which
	returns such object, or an array of previous items.
	The advice object can define following member functions:
	before, around, afterReturning, afterThrowing, after.
	If the function is supplied, it is called with a context
	object once per call to create a temporary advice object, which
	is destroyed after the processing. The temporary advice object
	can implement a destroy() method, if it wants to be called when
	not needed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async">
    <methods>
      <method name="seq" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="par" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loop" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifThen" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="ifTrue" type="Object" usage="required"/>
          <parameter name="ifFalse" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="any" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="topic" scope="instance" type="Object"/>
      <property name="timeout" scope="instance" type="Object"/>
      <property name="event" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.async.event">
    <methods>
      <method name="from" scope="instance">
        <parameters>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="failOn" scope="instance">
        <parameters>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async.timeout">
    <methods>
      <method name="from" scope="instance">
        <parameters>
          <parameter name="ms" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="failOn" scope="instance">
        <parameters>
          <parameter name="ms" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async.topic">
    <methods>
      <method name="from" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="failOn" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.docs">
    <methods>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="async" type="Boolean" usage="required">
            <description>If true, the documentation will be loaded asynchronously</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.functional">
    <methods>
      <method name="zip" scope="instance">
        <description>This is the venerable zip combiner (for example,
	see Python documentation for general details). The returned
	array is truncated to match the length of the shortest input
	array.</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="values" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="unzip" scope="instance">
        <description>This function is similar to dojox.lang.functional.zip()
	and can be used to unzip objects packed by
	dojox.lang.functional.zip(). It is here mostly to provide
	a short-cut for the different method signature.</description>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="until" scope="instance">
        <parameters>
          <parameter name="pr" type="Function|String|Array" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="unfold" scope="instance">
        <parameters>
          <parameter name="pr" type="Function|String|Array" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="g" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="tailrec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</description>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself,
	and returns an array of arguments for the next recursive call of
	the generated function.</description>
          </parameter>
        </parameters>
      </method>
      <method name="someRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="repeat" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="reduceRight" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="reduce" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="partial" scope="instance">
        <description>This method is used to produce partially bound
	functions. If you want to change the order of arguments, use
	dojox.lang.functional.mixer() or dojox.lang.functional.flip().</description>
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="numrec" scope="instance">
        <description>This is a simplification of the linear recursion combinator:
	- the generated function takes one numeric parameter "x",
	- the "cond" is fixed and checks for 0.
	- the "before" is fixed and the generated function is called with "x - 1".
	- the "above is called with two parameters: the return from the generated
	function, and with "x".
	- as you can see the recursion is done by decreasing the parameter,
	and calling itself until it reaches 0.</description>
        <parameters>
          <parameter name="then" type="Object" usage="required">
            <description>The value, which is used upon termination of the recursion.
	It will be returned as the value of the generated function.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts two parameters: the returned value from the recursive step, and
	the original parameter. The returned value will be returned as the value of
	the generated function.</description>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="multirec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</description>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself.
	The returned value should be an array, which is used to call
	the generated function recursively. Each member of the array should be
	an array of parameters. The length of it defines how many times
	the generated function is called recursively.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts two parameters: the array of returned values from recursive steps,
	and the original array of parameters used with all other functions.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="mixer" scope="instance">
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="mix" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="mapRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="mapIn" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="listcomp" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="linrec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</description>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself.
	The returned value should be an array, which is used to call
	the generated function recursively.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts two parameters: the returned value from the recursive step, and
	the original array of parameters used with all other functions.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="keys" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="inlineLambda" scope="instance">
        <parameters>
          <parameter name="lambda" type="String" usage="required">
            <description>The String variable representing the lambda function.</description>
          </parameter>
          <parameter name="init" type="String|Array" usage="required">
            <description>Conveys how to initialize parameters. If it is a String, then the apply() method
	would be emulated treating &amp;quot;init&amp;quot; as a list of input parameters.
	It it is an Array, then the call() method is emulated treating array members
	as input parameters.</description>
          </parameter>
          <parameter name="add2dict" type="Function" usage="optional">
            <description>The optional function, which is used to record names of lambda parameters.
	If supplied, this function is called with a name of every parameter.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="forIn" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="forEachRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldr1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldr" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldl1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldl" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="flip" scope="instance">
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="filterRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="filterIn" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="everyRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="curry" scope="instance">
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="arity" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="compileListcomp" scope="instance">
        <description>This method returns a function built from the list
	comprehension text snippet (conformant to JS 1.7). It is meant to be
	reused several times.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="buildListcomp" scope="instance">
        <description>This method returns a textual representation of a function
	built from the list comprehension text snippet (conformant to JS 1.7).
	It is meant to be evaled in the proper context, so local variable can be
	pulled from the environment.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="binrec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</description>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself.
	The returned value should be an array of two variable, which are used to call
	the generated function recursively twice in row starting from the first item.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts three parameters: two returned values from recursive steps, and
	the original array of parameters used with all other functions.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="frame.style"/>
  <class type="frame.contentWindow"/>
  <class type="dojox.lang.oo">
    <methods>
      <method name="rearrange" scope="instance">
        <description>Properties of an object are to be renamed or removed specified
	by "map" argument. Only own properties of "map" are processed.</description>
        <examples>
          <example>	oo.rearrange(bag, {
			abc: "def",	// rename "abc" attribute to "def"
			ghi: null	// remove/hide "ghi" attribute
		});</example>
        </examples>
        <parameters>
          <parameter name="bag" type="Object" usage="required">
            <description>the object to be processed</description>
          </parameter>
          <parameter name="map" type="Object" usage="required">
            <description>the dictionary for renaming (false value indicates removal of the named property)</description>
          </parameter>
        </parameters>
        <return-description>Object:
	the original object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="mixin" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>target to receive new/updated properties</description>
          </parameter>
          <parameter name="source" type="Object" usage="one-or-more">
            <description>source of properties, more than one source is allowed</description>
          </parameter>
        </parameters>
        <return-description>Object:
	target</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="makeDecorator" scope="instance">
        <parameters>
          <parameter name="decorator" type="Function|Object" usage="required">
            <description>a function to handle the custom assignment,
	or an object with exec() method</description>
          </parameter>
        </parameters>
        <return-description>Function:
	new decorator constructor</return-description>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="bag" type="Object" usage="required">
            <description>object to be filtered</description>
          </parameter>
          <parameter name="map" type="Object" usage="required">
            <description>the dictionary for renaming/removing while copying</description>
          </parameter>
        </parameters>
        <return-description>new dojox.lang.oo.Filter object</return-description>
      </method>
      <method name="applyDecorator" scope="instance">
        <parameters>
          <parameter name="decorator" type="Function" usage="required">
            <description>top-level decorator to apply</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>name of the property</description>
          </parameter>
          <parameter name="newValue" type="Object" usage="required">
            <description>new value of the property</description>
          </parameter>
          <parameter name="oldValue" type="Object" usage="required">
            <description>old value of the property</description>
          </parameter>
        </parameters>
        <return-description>Object:
	returns the final value of the property</return-description>
      </method>
      <method name="__mixin" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>target to receive new/updated properties</description>
          </parameter>
          <parameter name="source" type="Object" usage="required">
            <description>source of properties
	defaults: dojox.lang.oo.__MixinDefaults?:
	default functions for various aspects of mixing</description>
          </parameter>
          <parameter name="decorator" type="Object" usage="required"/>
          <parameter name="filter" type="Object" usage="required"/>
          <parameter name="mixer" type="Object" usage="required"/>
        </parameters>
        <return-description>Object:
	target</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="__MixinDefaults" scope="instance"/>
      <method name="Filter" scope="instance">
        <description>This object is used as a holder of an original object
	(whose properites are to be copied), and a filter
	function used while copying by dojox.lang.oo.mixin.</description>
        <parameters>
          <parameter name="bag" type="Object" usage="required">
            <description>object to be filtered</description>
          </parameter>
          <parameter name="filter" type="Function|Object" usage="required">
            <description>a function to handle the name filtering,
	or an object with exec() method</description>
          </parameter>
        </parameters>
      </method>
      <method name="Decorator" scope="instance">
        <description>This object holds an original function or another decorator
	object, and implements a special mixin algorithm to be used
	by dojox.lang.oo.mixin.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required">
            <description>a payload to be processed by the decorator.</description>
          </parameter>
          <parameter name="decorator" type="Function|Object" usage="required">
            <description>a function to handle the custom assignment, or an object with exec()
	method. The signature is:
	decorator(/*String*/ name, /*Function*/ newValue, /*Function*/ oldValue).</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="general" scope="instance" type="Object"/>
      <property name="aop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.oo.Decorator">
    <description>This object holds an original function or another decorator
	object, and implements a special mixin algorithm to be used
	by dojox.lang.oo.mixin.</description>
    <methods/>
  </class>
  <class type="dojox.lang.oo.Filter">
    <description>This object is used as a holder of an original object
	(whose properites are to be copied), and a filter
	function used while copying by dojox.lang.oo.mixin.</description>
    <methods/>
  </class>
  <class type="dojox.lang.oo.aop"/>
  <class type="dojox.lang.oo.general"/>
  <class type="dojo._extraNames"/>
  <class type="dojox.lang.oo.__MixinDefaults">
    <methods/>
  </class>
  <class type="JSONSchema"/>
  <class type="dojox.layout">
    <methods>
      <method name="_ResizeHelper" scope="instance"/>
      <method name="_RadioButton" scope="instance">
        <description>A private widget used to manipulate the StackContainer (RadioGroup*). Don't create directly.</description>
      </method>
      <method name="_DockNode" scope="instance"/>
      <method name="ToggleSplitter" scope="instance">
        <description>This is instantiated by `dijit.layout.BorderContainer. Users should not
	create it directly.</description>
      </method>
      <method name="TableContainer" scope="instance">
        <description>The TableContainer lays out child widgets in a Table layout.
	Each widget can specify a "label" or a "title" parameter.
	This label is displayed either above or to the left of
	a widget depending on whether the "orientation" attribute
	is "horiz" or "vert", for horizontal and vertical respectively.
	The number of columns is configured using the "cols" attribute.
	The width of labels can be configured using the "labelWidth" parameter.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.layout.TableContainer" orientation="vert" cols="3&gt;
			&lt;div dojoType="dijit.form.TextInput" value="John" label="First Name:"&gt;&lt;/div&gt;
			&lt;div dojoType="dijit.form.CheckBox" label="Is Student?:"&gt;&lt;/div&gt;
			&lt;div dojoType="dojox.form.DateTextBox" label="Date Of Birth:"&gt;&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="ScrollPane" scope="instance">
        <description>A sizable container that takes it's content's natural size and creates
	a scroll effect based on the relative mouse position. It is an interesting
	way to display lists of data, or blocks of content, within a confined
	space.
	
	Horizontal scrolling is supported. Combination scrolling is not.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.layout.ScrollPane" style="width:150px height:300px;"&gt;
			&lt;!-- any height content --&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="RotatorPager" scope="instance">
        <description>A pager can be defined one of two ways:
	* Externally of the RotatorContainer's template and tell the
	RotatorPager the rotatorId of the RotatorContainer
	* As a direct descendant of the RotatorContainer (i.e. inside the
	RotatorContainer's template)
	
	The pager can contain the following components:
	* Previous button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "previous"
	* Next button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "next"
	* Play/Pause toggle button
	- Must be a dijit.form.ToggleButton
	- dojoAttachPoint must be named "playPause"
	- Use iconClass to specify toggled state
	* Current child #
	- dojoAttachPoint must be named "current"
	* Total # of children
	- dojoAttachPoint must be named "total"
	
	You can choose to exclude specific controls as well as add elements
	for styling.
	
	Should you need a pager, but don't want to use Dijit buttons, you can
	write your own pager widget and just wire it into the topics.  The
	topic names are prefixed with the widget ID of the RotatorContainer.
	Notifications are received from and sent to the RotatorContainer as
	well as other RotatorPagers.
	
	published topics:
	[widgetId]-cycle - Notify that the next or previous button was pressed.
	Parameters:
	/*boolean*/ next - true if next, false if previous
	[widgetId]-state - Notify that the play/pause button was toggled.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused</description>
        <examples>
          <example>A pager with the current/total children and previous/next buttons.
		&lt;div dojoType="dojox.layout.RotatorPager" rotatorId="myRotator"&gt;
			&lt;button dojoType="dijit.form.Button" dojoAttachPoint="previous"&gt;Prev&lt;/button&gt;
			&lt;span dojoAttachPoint="current"&gt;&lt;/span&gt; / &lt;span dojoAttachPoint="total"&gt;&lt;/span&gt;
			&lt;button dojoType="dijit.form.Button" dojoAttachPoint="next"&gt;Next&lt;/button&gt;
		&lt;/div&gt;</example>
          <example>A pager with only a play/pause toggle button.
		&lt;div dojoType="dojox.layout.RotatorPager" rotatorId="myRotator"&gt;
			&lt;button dojoType="dijit.form.ToggleButton" dojoAttachPoint="playPause"&gt;&lt;/button&gt;
		&lt;/div&gt;</example>
          <example>A pager styled with iconClass.
		&lt;div dojoType="dojox.layout.RotatorPager" class="rotatorIcons" rotatorId="myRotator"&gt;
			&lt;button dojoType="dijit.form.Button" iconClass="previous" dojoAttachPoint="previous"&gt;Prev&lt;/button&gt;
			&lt;button dojoType="dijit.form.ToggleButton" iconClass="playPause" dojoAttachPoint="playPause"&gt;&lt;/button&gt;
			&lt;button dojoType="dijit.form.Button" iconClass="next" dojoAttachPoint="next"&gt;Next&lt;/button&gt;
			&lt;span dojoAttachPoint="current"&gt;&lt;/span&gt; / &lt;span dojoAttachPoint="total"&gt;&lt;/span&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="RotatorContainer" scope="instance">
        <description>The RotatorContainer cycles through the children with a transition.
	
	published topics:
	[widgetId]-update - Notifies pager(s) that a child has changed.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused
	/*int*/ current     - current selected child
	/*int*/ total       - total number of children</description>
        <examples>
          <example>	&lt;div dojoType="dojox.layout.RotatorContainer" id="myRotator" showTabs="true" autoStart="true" transitionDelay="5000"&gt;
			&lt;div id="pane1" dojoType="dijit.layout.ContentPane" title="1"&gt;
				Pane 1!
			&lt;/div&gt;
			&lt;div id="pane2" dojoType="dijit.layout.ContentPane" title="2"&gt;
				Pane 2!
			&lt;/div&gt;
			&lt;div id="pane3" dojoType="dijit.layout.ContentPane" title="3" transitionDelay="10000"&gt;
				Pane 3 with overrided transitionDelay!
			&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="ResizeHandle" scope="instance">
        <description>The handle on the bottom-right corner of FloatingPane or other widgets that allows
	the widget to be resized.
	Typically not used directly.</description>
      </method>
      <method name="RadioGroupSlide" scope="instance">
        <description>An extension on a stock RadioGroup widget, sliding the pane
	into view from being hidden. The entry direction is randomized
	on each view</description>
      </method>
      <method name="RadioGroupFade" scope="instance"/>
      <method name="RadioGroup" scope="instance"/>
      <method name="GridContainerLite" scope="instance">
        <description>GridContainerLite displays the child elements by column
	(ie: the children widths are fixed by the column width of the grid but
	the children heights are free).
	Each child is movable by drag and drop inside the GridContainer.
	The position of other children is automatically calculated when a child is moved.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.layout.GridContainerLite" nbZones="3" isAutoOrganized="true"&gt;
			&lt;div dojoType="dijit.layout.ContentPane"&gt;Content Pane 1 : Drag Me !&lt;/div&gt;
			&lt;div dojoType="dijit.layout.ContentPane"&gt;Content Pane 2 : Drag Me !&lt;/div&gt;
			&lt;div dojoType="dijit.layout.ContentPane"&gt;Content Pane 3 : Drag Me !&lt;/div&gt;
		&lt;/div&gt;</example>
          <example>	dojo.ready(function(){
			var cpane1 = new dijit.layout.ContentPane({
				title:"cpane1", content: "Content Pane 1 : Drag Me !"
			}),
			cpane2 = new dijit.layout.ContentPane({
				title:"cpane2",
				content: "Content Pane 2 : Drag Me !"
			}),
			cpane3 = new dijit.layout.ContentPane({
				title:"cpane3",
				content: "Content Pane 3 : Drag Me !"
			});
	
			var widget = new dojox.layout.GridContainerLite({
				nbZones: 3,
				isAutoOrganized: true
			}, dojo.byId("idNode"));
			widget.addChild(cpane1, 0, 0);
			widget.addChild(cpane2, 1, 0);
			widget.addChild(cpane3, 2, 1);
			widget.startup();
		});</example>
        </examples>
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="GridContainer" scope="instance">
        <description>This component inherits of all features of gridContainerLite plus :
	- Resize colums
	- Add / remove columns
	- Fix columns at left or at right.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.layout.GridContainer" nbZones="3" isAutoOrganized="true"&gt;
			&lt;div dojoType="dijit.layout.ContentPane"&gt;Content Pane 1 : Drag Me !&lt;/div&gt;
			&lt;div dojoType="dijit.layout.ContentPane"&gt;Content Pane 2 : Drag Me !&lt;/div&gt;
			&lt;div dojoType="dijit.layout.ContentPane"&gt;Content Pane 3 : Drag Me !&lt;/div&gt;
		&lt;/div&gt;</example>
          <example>	dojo.ready(function(){
			var cpane1 = new dijit.layout.ContentPane({ title:"cpane1", content: "Content Pane 1 : Drag Me !" }),
				cpane2 = new dijit.layout.ContentPane({ title:"cpane2", content: "Content Pane 2 : Drag Me !" }),
				cpane3 = new dijit.layout.ContentPane({ title:"cpane3", content: "Content Pane 3 : Drag Me !" });
	
			var widget = new dojox.layout.GridContainer({
				nbZones: 3,
				isAutoOrganized: true
			}, dojo.byId("idNode"));
			widget.addChild(cpane1, 0, 0);
			widget.addChild(cpane2, 1, 0);
			widget.addChild(cpane3, 2, 1);
			widget.startup();
		});</example>
        </examples>
      </method>
      <method name="FloatingPane" scope="instance">
        <description>Makes a `dojox.layout.ContentPane` float and draggable by it's title [similar to TitlePane]
	and over-rides onClick to onDblClick for wipeIn/Out of containerNode
	provides minimize(dock) / show() and hide() methods, and resize [almost]</description>
      </method>
      <method name="ExpandoPane" scope="instance">
        <description>Works just like a ContentPane inside of a borderContainer. Will expand/collapse on
	command, and supports having Layout Children as direct descendants</description>
      </method>
      <method name="DragPane" scope="instance">
        <description>A small widget which takes a node with overflow:auto and
	allows dragging to position the content. Useful with images,
	or for just adding "something" to a overflow-able div.</description>
      </method>
      <method name="Dock" scope="instance"/>
      <method name="ContentPane" scope="instance">
        <description>useful if you send ContentPane a complete page, instead of a html fragment
	scans for
	
	* title Node, remove
	* DOCTYPE tag, remove</description>
      </method>
    </methods>
    <properties>
      <property name="ext-dijit" scope="instance" type="Object"/>
      <property name="dnd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ContentPane" superclass="dijit.layout.ContentPane">
    <description>useful if you send ContentPane a complete page, instead of a html fragment
	scans for
	
	* title Node, remove
	* DOCTYPE tag, remove</description>
    <methods>
      <method name="onExecError" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="cont" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.DragPane" superclass="dijit._Widget">
    <description>A small widget which takes a node with overflow:auto and
	allows dragging to position the content. Useful with images,
	or for just adding "something" to a overflow-able div.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_up" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_down" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.ExpandoPane" superclass="dijit.layout.ContentPane">
    <description>Works just like a ContentPane inside of a borderContainer. Will expand/collapse on
	command, and supports having Layout Children as direct descendants</description>
    <methods>
      <method name="toggle" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="newSize" type="Object" usage="optional">
            <description>The size object to resize to</description>
          </parameter>
        </parameters>
      </method>
      <method name="preview" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_trap" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_startupSizes" scope="instance"/>
      <method name="_showEnd" scope="instance"/>
      <method name="_setupAnims" scope="instance"/>
      <method name="_hideWrapper" scope="instance"/>
      <method name="_hideEnd" scope="instance"/>
      <method name="_afterResize" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.FloatingPane" superclass="dojox.layout.ContentPane">
    <description>Makes a `dojox.layout.ContentPane` float and draggable by it's title [similar to TitlePane]
	and over-rides onClick to onDblClick for wipeIn/Out of containerNode
	provides minimize(dock) / show() and hide() methods, and resize [almost]</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="minimize" scope="instance"/>
      <method name="maximize" scope="instance"/>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="close" scope="instance"/>
      <method name="bringToTop" scope="instance"/>
      <method name="_restore" scope="instance"/>
      <method name="_dock" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.dockNode.style"/>
  <class type="dojox.layout.FloatingPane.closeNode.style"/>
  <class type="dojox.layout.FloatingPane.maxNode.style"/>
  <class type="dojox.layout.FloatingPane.restoreNode.style"/>
  <class type="dojox.layout.FloatingPane.resizeHandle.style"/>
  <class type="dojox.layout.FloatingPane.domNode.style"/>
  <class type="dojox.layout.FloatingPane.canvas.style"/>
  <class type="dojox.layout.FloatingPane.containerNode.style"/>
  <class type="dojox.layout.FloatingPane.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.Dock" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="addNode" scope="instance">
        <parameters>
          <parameter name="refNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_positionDock" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout._DockNode" superclass="dijit._Widget">
    <methods>
      <method name="restore" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.GridContainer" superclass="dojox.layout.GridContainerLite">
    <description>This component inherits of all features of gridContainerLite plus :
	- Resize colums
	- Add / remove columns
	- Fix columns at left or at right.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setColumns" scope="instance">
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required">
            <description>Number of columns</description>
          </parameter>
        </parameters>
      </method>
      <method name="resizeChildAfterDrop" scope="instance">
        <description>Allow to resize and put grips</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>domNode of dropped widget.</description>
          </parameter>
          <parameter name="targetArea" type="Object" usage="required">
            <description>AreaManager Object containing information of targetArea</description>
          </parameter>
          <parameter name="indexChild" type="Integer" usage="required">
            <description>Index where the dropped widget has been placed</description>
          </parameter>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="onShow" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_updateColumnsWidth" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required">
            <description>dojox.mdnd.AreaManager singleton</description>
          </parameter>
        </parameters>
      </method>
      <method name="_resizeColumnOn" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_resizeColumnOff" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_resizeColumnMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_placeGrips" scope="instance"/>
      <method name="_onGripMouseUp" scope="instance"/>
      <method name="_onGripDbClick" scope="instance"/>
      <method name="_deleteColumn" scope="instance">
        <parameters>
          <parameter name="indices" type="Array" usage="required">
            <description>Column index array</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createGrip" scope="instance">
        <parameters>
          <parameter name="index" type="Integer" usage="required">
            <description>index where the grip has to be created.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addColumn" scope="instance">
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required">
            <description>Number of column to added</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.layout.GridContainerLite" scope="instance"/>
    </mixins>
    <properties>
      <property name="gridContainerTable" scope="instance" type="Object"/>
      <property name="_grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer.domNode.style"/>
  <class type="dojox.layout.GridContainer._activeGrip.style"/>
  <class type="dojox.layout.GridContainer._currentColumn.style"/>
  <class type="dojox.layout.GridContainer._nextColumn.style"/>
  <class type="dojox.layout.GridContainer.gridContainerTable"/>
  <class type="dojox.layout.GridContainer._grid"/>
  <class type="dojox.layout.GridContainerLite" superclass="dijit.layout._LayoutWidget">
    <description>GridContainerLite displays the child elements by column
	(ie: the children widths are fixed by the column width of the grid but
	the children heights are free).
	Each child is movable by drag and drop inside the GridContainer.
	The position of other children is automatically calculated when a child is moved.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resizeChildAfterDrop" scope="instance">
        <description>These components are resized only if the targetArea.node is a
	child of this instance of gridContainerLite.
	To be resized, the dropped node must have also a method resize.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>domNode of dropped widget.</description>
          </parameter>
          <parameter name="targetArea" type="Object" usage="required">
            <description>AreaManager Object containing information of targetArea</description>
          </parameter>
          <parameter name="indexChild" type="Integer" usage="required">
            <description>Index where the dropped widget has been placed</description>
          </parameter>
        </parameters>
        <return-description>True if resized.</return-description>
      </method>
      <method name="resizeChildAfterDragStart" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>domNode of dragged widget.</description>
          </parameter>
          <parameter name="sourceArea" type="Object" usage="required">
            <description>AreaManager Object containing information of sourceArea</description>
          </parameter>
          <parameter name="indexChild" type="Integer" usage="required">
            <description>Index where the dragged widget has been placed</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onShow" scope="instance"/>
      <method name="onHide" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="getChildren" scope="instance">
        <return-description>An array containing all children (widgets).</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="enableDnd" scope="instance"/>
      <method name="disableDnd" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="addService" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="column" type="Integer" usage="optional"/>
          <parameter name="p" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required">
            <description>widget to insert</description>
          </parameter>
          <parameter name="column" type="Integer" usage="optional">
            <description>column number</description>
          </parameter>
          <parameter name="p" type="Integer" usage="optional">
            <description>place in the zone (first = 0)</description>
          </parameter>
        </parameters>
        <return-description>The widget inserted</return-description>
        <return-types>
          <return-type type="Widget"/>
        </return-types>
      </method>
      <method name="_updateColumnsWidth" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required">
            <description>dojox.mdnd.AreaManager singleton</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setColWidthsAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectFocus" scope="instance">
        <description>Possibility to move focus into the GridContainer (TAB, LEFT ARROW, RIGHT ARROW, UP ARROW, DOWN ARROW).
	Possibility to move GridContainer's children (Drag and Drop) with keyboard. (SHIFT +  ARROW).
	If the type of widget is not draggable, a popup is displayed.</description>
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_organizeChildrenManually" scope="instance"/>
      <method name="_organizeChildren" scope="instance"/>
      <method name="_isShown" scope="instance">
        <return-description>true if the content is currently shown</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_insertChild" scope="instance">
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
          <parameter name="column" type="Integer" usage="required">
            <description>Column number</description>
          </parameter>
          <parameter name="p" type="Integer" usage="optional">
            <description>Place in the zone (0 - first)</description>
          </parameter>
        </parameters>
        <return-description>The widget inserted</return-description>
        <return-types>
          <return-type type="Widget"/>
        </return-types>
      </method>
      <method name="_getZonesAttr" scope="instance"/>
      <method name="_createCells" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="gridNode" scope="instance" type="Object"/>
      <property name="_grid" scope="instance" type="Array"/>
      <property name="_dragManager" scope="instance" type="Object"/>
      <property name="_contentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite._dragManager"/>
  <class type="dojox.layout.GridContainerLite._contentBox"/>
  <class type="dojox.layout.GridContainerLite._grid"/>
  <class type="dojox.layout.GridContainerLite.gridNode"/>
  <class type="dojox.layout.RadioGroup" superclass="dijit.layout.StackContainer">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="required"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.RadioGroupFade" superclass="RadioGroup">
    <methods>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="RadioGroup" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.RadioGroupSlide" superclass="RadioGroup">
    <description>An extension on a stock RadioGroup widget, sliding the pane
	into view from being hidden. The entry direction is randomized
	on each view</description>
    <methods>
      <method name="easing" scope="instance-prototype"/>
      <method name="constructor" scope="instance"/>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_positionChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="RadioGroup" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout._RadioButton" superclass="dijit._Widget">
    <description>A private widget used to manipulate the StackContainer (RadioGroup*). Don't create directly.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_onMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_clearSelected" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout._ResizeHelper" superclass="dijit._Widget">
    <methods>
      <method name="show" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.ResizeHandle" superclass="dijit._Widget">
    <description>The handle on the bottom-right corner of FloatingPane or other widgets that allows
	the widget to be resized.
	Typically not used directly.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewCoords" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="box" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_endSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_checkConstraints" scope="instance">
        <parameters>
          <parameter name="newW" type="Object" usage="required"/>
          <parameter name="newH" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_changeSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_beginSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="startSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ResizeHandle.startSize"/>
  <class type="dojox.layout.RotatorContainer" superclass="dijit.layout.StackContainer">
    <description>The RotatorContainer cycles through the children with a transition.
	
	published topics:
	[widgetId]-update - Notifies pager(s) that a child has changed.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused
	/*int*/ current     - current selected child
	/*int*/ total       - total number of children</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_updatePager" scope="instance"/>
      <method name="_transitionEnd" scope="instance"/>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="next" type="dijit._Widget" usage="required"/>
          <parameter name="prev" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_styleNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMnode" usage="required"/>
          <parameter name="opacity" type="number" usage="required"/>
          <parameter name="zIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_state" scope="instance">
        <parameters>
          <parameter name="playing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setShowTabsAttr" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_resetTimer" scope="instance"/>
      <method name="_play" scope="instance">
        <parameters>
          <parameter name="skip" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pause" scope="instance"/>
      <method name="_onMouseOver" scope="instance"/>
      <method name="_onMouseOut" scope="instance"/>
      <method name="_manualChange" scope="instance"/>
      <method name="_fade" scope="instance">
        <parameters>
          <parameter name="next" type="dijit._Widget" usage="required"/>
          <parameter name="prev" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_cycle" scope="instance">
        <parameters>
          <parameter name="next" type="boolean" usage="required">
            <description>or int</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.RotatorPager" superclass="dijit._Widget">
    <description>A pager can be defined one of two ways:
	* Externally of the RotatorContainer's template and tell the
	RotatorPager the rotatorId of the RotatorContainer
	* As a direct descendant of the RotatorContainer (i.e. inside the
	RotatorContainer's template)
	
	The pager can contain the following components:
	* Previous button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "previous"
	* Next button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "next"
	* Play/Pause toggle button
	- Must be a dijit.form.ToggleButton
	- dojoAttachPoint must be named "playPause"
	- Use iconClass to specify toggled state
	* Current child #
	- dojoAttachPoint must be named "current"
	* Total # of children
	- dojoAttachPoint must be named "total"
	
	You can choose to exclude specific controls as well as add elements
	for styling.
	
	Should you need a pager, but don't want to use Dijit buttons, you can
	write your own pager widget and just wire it into the topics.  The
	topic names are prefixed with the widget ID of the RotatorContainer.
	Notifications are received from and sent to the RotatorContainer as
	well as other RotatorPagers.
	
	published topics:
	[widgetId]-cycle - Notify that the next or previous button was pressed.
	Parameters:
	/*boolean*/ next - true if next, false if previous
	[widgetId]-state - Notify that the play/pause button was toggled.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_update" scope="instance">
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
          <parameter name="current" type="int" usage="required"/>
          <parameter name="total" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_state" scope="instance">
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="total" scope="instance" type="Object"/>
      <property name="current" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager.current"/>
  <class type="dojox.layout.RotatorPager.total"/>
  <class type="dojox.layout.ScrollPane" superclass="dijit.layout.ContentPane">
    <description>A sizable container that takes it's content's natural size and creates
	a scroll effect based on the relative mouse position. It is an interesting
	way to display lists of data, or blocks of content, within a confined
	space.
	
	Horizontal scrolling is supported. Combination scrolling is not.</description>
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_leave" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_enter" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calc" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.ScrollPane.helper.style"/>
  <class type="_WidgetBase">
    <methods/>
  </class>
  <class type="dojox.layout.TableContainer" superclass="_LayoutWidget">
    <description>The TableContainer lays out child widgets in a Table layout.
	Each widget can specify a "label" or a "title" parameter.
	This label is displayed either above or to the left of
	a widget depending on whether the "orientation" attribute
	is "horiz" or "vert", for horizontal and vertical respectively.
	The number of columns is configured using the "cols" attribute.
	The width of labels can be configured using the "labelWidth" parameter.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setSpacingAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="table" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.TableContainer.table"/>
  <class type="dojox.layout.ToggleSplitter" superclass="dijit.layout._Splitter">
    <description>This is instantiated by `dijit.layout.BorderContainer. Users should not
	create it directly.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="pane" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCollapsed" scope="instance">
        <parameters>
          <parameter name="pane" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClosed" scope="instance">
        <parameters>
          <parameter name="pane" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toggle" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stopDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_startDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStateClass" scope="instance"/>
      <method name="_setStateAttr" scope="instance">
        <parameters>
          <parameter name="state" type="Strring" usage="required"/>
        </parameters>
      </method>
      <method name="_onToggleNodeMouseMove" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onToggleNodeMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="preState" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getStyleProps" scope="instance">
        <parameters>
          <parameter name="paneNode" type="Object" usage="required"/>
          <parameter name="state" type="Object" usage="required"/>
          <parameter name="paneStyle" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._Splitter" scope="instance"/>
    </mixins>
    <properties>
      <property name="child" scope="instance" type="dijit.layout._LayoutWidget">
        <description>Pointer to the pane associated with this splitter</description>
      </property>
      <property name="a11yText" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ToggleSplitter.child"/>
  <class type="dojox.layout.ToggleSplitter.a11yText"/>
  <class type="dojox.layout.dnd">
    <methods>
      <method name="_setGcDndHandle" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="withHandles" type="Object" usage="required"/>
          <parameter name="handleClasses" type="Object" usage="required"/>
          <parameter name="first" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="PlottedDnd" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DropIndicator" scope="instance">
        <parameters>
          <parameter name="cn" type="String" usage="required"/>
          <parameter name="tag" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="Avatar" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
          <parameter name="opacity" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.layout.dnd.Avatar" superclass="dojo.dnd.Avatar">
    <methods>
      <method name="update" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
          <parameter name="opacity" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="construct" scope="instance"/>
      <method name="_generateText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Avatar" scope="instance"/>
    </mixins>
    <properties>
      <property name="manager" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.Avatar.manager"/>
  <class type="dojox.layout.dnd.PlottedDnd" superclass="dojo.dnd.Source">
    <methods>
      <method name="setIndicatorPosition" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setDndItemSelectable" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="isSelectable" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onDndStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="isAccepted" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="insertNodes" scope="instance">
        <parameters>
          <parameter name="addSelected" type="Boolean" usage="required"/>
          <parameter name="data" type="Array" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="anchor" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="insertDashedZone" scope="instance">
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getDraggedWidget" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="deleteDashedZone" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_sumAncestorProperties" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="integer"/>
        </return-types>
      </method>
      <method name="_stopAutoScroll" scope="instance"/>
      <method name="_markTargetAnchor" scope="instance">
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_checkAutoScroll" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calculateCoords" scope="instance">
        <parameters>
          <parameter name="height" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollUp" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollDown" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="offsetDrag" scope="instance" type="Object"/>
      <property name="current" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd._drop.style"/>
  <class type="dojox.layout.dnd.PlottedDnd.current"/>
  <class type="dojox.layout.dnd.PlottedDnd.offsetDrag"/>
  <class type="dojox.layout.dnd.DropIndicator">
    <methods>
      <method name="isInserted" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="cn" type="String" usage="required"/>
          <parameter name="tag" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="document.body">
    <methods>
      <method name="onselectstart" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.layout.ext-dijit.layout"/>
  <class type="dojox.layout.ext-dijit">
    <properties>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math">
    <methods>
      <method name="toRadians" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="toDegrees" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="round" scope="instance">
        <description>Rounds to the nearest value with the given number of decimal places, away from zero if equal,
	similar to Number.toFixed().  Rounding can be done by fractional increments also.
	Makes minor adjustments to accommodate for precision errors due to binary floating point representation
	of Javascript Numbers.  See http://speleotrove.com/decimal/decifaq.html for more information.
	Because of this adjustment, the rounding may not be mathematically correct for full precision
	floating point values.  The calculations assume 14 significant figures, so the accuracy will
	be limited to a certain number of decimal places preserved will vary with the magnitude of
	the input.  This is not a substitute for decimal arithmetic.</description>
        <examples>
          <example>&gt;&gt;&gt; 4.8-(1.1+2.2)
	1.4999999999999996
	&gt;&gt;&gt; Math.round(4.8-(1.1+2.2))
	1
	&gt;&gt;&gt; dojox.math.round(4.8-(1.1+2.2))
	2
	&gt;&gt;&gt; ((4.8-(1.1+2.2))/100)
	0.014999999999999996
	&gt;&gt;&gt; ((4.8-(1.1+2.2))/100).toFixed(2)
	"0.01"
	&gt;&gt;&gt; dojox.math.round((4.8-(1.1+2.2))/100,2)
	0.02
	&gt;&gt;&gt; dojox.math.round(10.71, 0, 2.5)
	10.75
	&gt;&gt;&gt; dojo.number.round(162.295, 2)
	162.29
	&gt;&gt;&gt; dojox.math.round(162.295, 2)
	162.3</example>
        </examples>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The number to round</description>
          </parameter>
          <parameter name="places" type="Number" usage="optional">
            <description>The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	Must be non-negative.</description>
          </parameter>
          <parameter name="increment" type="Number" usage="optional">
            <description>Rounds next place to nearest value of increment/10.  10 by default.</description>
          </parameter>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="range" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="optional"/>
          <parameter name="step" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="radiansToDegrees" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="permutations" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="k" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="midpoint" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="gaussian" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="factorial" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="distance" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="degreesToRadians" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="combinations" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="r" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="bernstein" scope="instance">
        <parameters>
          <parameter name="t" type="Number" usage="required"/>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="i" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_gamma" scope="instance">
        <parameters>
          <parameter name="z" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="normal integer quick return"/>
          <return-type type="undefined at nonpositive integers since sin() below will return 0"/>
          <return-type type="popular gamma(1/2)"/>
          <return-type type="reflection"/>
        </return-types>
      </method>
      <method name="BigInteger" scope="instance"/>
    </methods>
    <properties>
      <property name="stats" scope="instance" type="Object"/>
      <property name="random" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="curves" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.BigInteger">
    <methods/>
    <properties>
      <property name="prototype" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.BigInteger.prototype"/>
  <class type="NullExp"/>
  <class type="Barrett"/>
  <class type="Classic.prototype"/>
  <class type="Montgomery.prototype"/>
  <class type="BigInteger.prototype"/>
  <class type="BigInteger">
    <methods/>
    <properties>
      <property name="prototype" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves">
    <methods>
      <method name="Path" scope="instance"/>
      <method name="Line" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Circle" scope="instance">
        <parameters>
          <parameter name="center" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="CenteredArc" scope="instance">
        <parameters>
          <parameter name="center" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="CatmullRom" scope="instance">
        <parameters>
          <parameter name="pnts" type="Object" usage="required"/>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Bezier" scope="instance">
        <parameters>
          <parameter name="pnts" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Arc" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="ccw" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.curves.Line">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.curves.Bezier">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.curves.CatmullRom">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.curves.CenteredArc">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.curves.Path">
    <methods>
      <method name="removeAll" scope="instance"/>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="curve" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="curve" type="Object" usage="required"/>
          <parameter name="weight" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.matrix">
    <methods>
      <method name="zeros" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="upperTriangle" scope="instance">
        <parameters>
          <parameter name="m" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="transpose" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="sum" scope="instance">
        <return-types>
          <return-type type="Number"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="factor" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="product" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="ones" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="inverse" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="identity" scope="instance">
        <parameters>
          <parameter name="size" type="Number" usage="required"/>
          <parameter name="scale" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="points" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="determinant" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
          <parameter name="value" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="copy" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="adjoint" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.math.matrix.upperTriangle">
    <methods/>
  </class>
  <class type="dojox.math.random">
    <methods>
      <method name="prng4" scope="instance"/>
      <method name="Simple" scope="instance"/>
      <method name="Secure" scope="instance">
        <parameters>
          <parameter name="prng" type="Function" usage="required">
            <description>function that returns an instance of PRNG (pseudorandom number generator)
	with two methods: init(array) and next(). It should have a property &amp;quot;size&amp;quot;
	to indicate the required pool size.</description>
          </parameter>
          <parameter name="noEvents" type="Boolean" usage="optional">
            <description>if false or absent, onclick and onkeypress event will be used to add
	&amp;quot;randomness&amp;quot;, otherwise events will not be used.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.random.Secure">
    <methods>
      <method name="seedTime" scope="instance"/>
      <method name="nextBytes" scope="instance">
        <parameters>
          <parameter name="byteArray" type="Array" usage="required">
            <description>Array: array to be filled in with random numbers, only existing
	elements will be filled.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="prng" type="Function" usage="required">
            <description>function that returns an instance of PRNG (pseudorandom number generator)
	with two methods: init(array) and next(). It should have a property &amp;quot;size&amp;quot;
	to indicate the required pool size.</description>
          </parameter>
          <parameter name="noEvents" type="Boolean" usage="optional">
            <description>if false or absent, onclick and onkeypress event will be used to add
	&amp;quot;randomness&amp;quot;, otherwise events will not be used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_seed_int" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.random.Simple">
    <methods>
      <method name="nextBytes" scope="instance">
        <parameters>
          <parameter name="byteArray" type="Array" usage="required">
            <description>Array: array to be filled in with random numbers, only existing
	elements will be filled.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
  </class>
  <class type="Arcfour">
    <methods>
      <method name="next" scope="instance"/>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="key" type="Array" usage="required">
            <description>an array of ints, each from [0..255]</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="Arcfour.init">
    <methods/>
  </class>
  <class type="Arcfour.next">
    <methods/>
  </class>
  <class type="dojox.math.stats">
    <methods>
      <method name="variance" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="summary" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required">
            <description>a numeric array to be appraised.</description>
          </parameter>
          <parameter name="alreadySorted" type="Boolean" usage="optional">
            <description>a Boolean flag to indicated that the array is already sorted.
	This is an optional flag purely to improve the performance.
	If skipped, the array will be assumed unsorted.</description>
          </parameter>
        </parameters>
        <return-description>Object</return-description>
        <return-types>
          <return-type type="sort it properly"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="sum" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="sd" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="mode" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="min" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="median" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="mean" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="max" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="forecast" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Object&gt;" usage="required">
            <description>|| Number[]</description>
          </parameter>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="xProp" type="String" usage="optional"/>
          <parameter name="yProp" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="bestFit" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Object&gt;" usage="required">
            <description>|| Number[]</description>
          </parameter>
          <parameter name="xProp" type="String" usage="optional"/>
          <parameter name="yProp" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="approxLin" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required">
            <description>a sorted numeric array to be used for the approximation.</description>
          </parameter>
          <parameter name="pos" type="Number" usage="required">
            <description>a position number from 0 to 1. If outside of this range it
	will be clamped.</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.mdnd">
    <methods>
      <method name="areaManager" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="PureSource" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>Node or node's id to build the source on.</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional">
            <description>Any property of this class may be configured via the params
	object which is mixed-in to the 'dojo.dnd.Source' instance.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Moveable" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required">
            <description>Hash of parameters</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The draggable node</description>
          </parameter>
        </parameters>
      </method>
      <method name="LazyManager" scope="instance"/>
      <method name="DropIndicator" scope="instance"/>
      <method name="AutoScroll" scope="instance"/>
      <method name="AreaManager" scope="instance"/>
    </methods>
    <properties>
      <property name="dropMode" scope="instance" type="Object"/>
      <property name="adapter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AreaManager">
    <methods>
      <method name="unregister" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A node corresponding to the D&amp;amp;D Area.</description>
          </parameter>
        </parameters>
        <return-description>True if the area is found and unregistered.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="removeDragItem" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A node corresponding to the DndArea.</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which has to be treated.</description>
          </parameter>
        </parameters>
        <return-description>the removed node</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="registerByNode" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>a DOM node corresponding to the Dnd Area</description>
          </parameter>
          <parameter name="notInitAreas" type="Boolean" usage="required">
            <description>if false or undefined, init the areas.</description>
          </parameter>
        </parameters>
      </method>
      <method name="registerByClass" scope="instance"/>
      <method name="placeDropIndicator" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
        </parameters>
        <return-description>the current drop index</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="onDropCancel" scope="instance"/>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which is about to be dropped</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which is about to be dragged</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragExit" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates of the dragged Node.</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>size of the dragged Node.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragEnter" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates of the dragged Node.</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>size of the dragged Node.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which is dragged</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordinates of mouse</description>
          </parameter>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="findCurrentIndexArea" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating the area size</description>
          </parameter>
        </parameters>
        <return-description>an index of area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="addDragItem" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>a node corresponding to the D&amp;amp;D Area</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>the node which has to be treated.</description>
          </parameter>
          <parameter name="index" type="Integer" usage="required">
            <description>the place in the area
	noCheckParent:
	if true, doesn't check if node has a parent.</description>
          </parameter>
          <parameter name="notCheckParent" type="Boolean" usage="required"/>
        </parameters>
        <return-description>True if the node has been inserted else false.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_setMarginArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>The object of a D&amp;amp;D Area.</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which contains margins</description>
          </parameter>
        </parameters>
      </method>
      <method name="_searchDragHandle" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>A child of the D&amp;amp;D Area.</description>
          </parameter>
        </parameters>
        <return-description>The drag handle node.</return-description>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="_resetAfterDrop" scope="instance"/>
      <method name="_placeDropIndicator" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isAccepted" scope="instance">
        <parameters>
          <parameter name="type" type="Array" usage="required">
            <description>containing item type</description>
          </parameter>
          <parameter name="accept" type="Array" usage="required">
            <description>containing types</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getIndexArea" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A moveable Object.</description>
          </parameter>
        </parameters>
        <return-description>area index or -1</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_getChildren" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A DnD area.</description>
          </parameter>
        </parameters>
        <return-description>The children of a DnD area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_deleteMoveableItem" scope="instance">
        <parameters>
          <parameter name="objItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addMoveableItem" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>A child of the D&amp;amp;D Area.</description>
          </parameter>
        </parameters>
        <return-description>The draggable item.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.mdnd.AreaManager._cover.style"/>
  <class type="dojox.mdnd.AreaManager._cover2.style"/>
  <class type="dojox.mdnd.AutoScroll">
    <methods>
      <method name="stopAutoScroll" scope="instance"/>
      <method name="setAutoScrollNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>node to scroll</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAutoScrollMaxPage" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="getViewport" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="checkAutoScroll" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollUp" scope="instance"/>
      <method name="_autoScrollRight" scope="instance"/>
      <method name="_autoScrollLeft" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollDown" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mdnd.AutoScroll._node.style"/>
  <class type="dojox.mdnd.DropIndicator">
    <methods>
      <method name="remove" scope="instance"/>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="area" type="Node" usage="required">
            <description>the dnd targer area node</description>
          </parameter>
          <parameter name="nodeRef" type="Node" usage="required">
            <description>node where the dropIndicator have to be placed into the area
	dragNode:
	the node which is dragged</description>
          </parameter>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
        <return-description>the node inserted or null if it crashes</return-description>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mdnd.DropIndicator.node.style"/>
  <class type="dojox.mdnd.LazyManager">
    <methods>
      <method name="startDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="draggedNode" type="DOMNode" usage="optional"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="draggedNode" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="cancelDrag" scope="instance"/>
    </methods>
    <properties>
      <property name="manager" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.LazyManager.manager"/>
  <class type="dojox.mdnd.Moveable">
    <methods>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>a DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>a DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>a DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>A DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>a DOM node</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>absolute position of the main node</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width an height values</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragEnd" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>a DOM node</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>a DOM node</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>position of the main node (equals to css left/top properties)</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordiantes of mouse</description>
          </parameter>
        </parameters>
      </method>
      <method name="isFormElement" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>a DOM event</description>
          </parameter>
        </parameters>
        <return-description>if true, the target is one of those specific nodes.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="initOffsetDrag" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>A DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required">
            <description>Hash of parameters</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The draggable node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="offsetDrag" scope="instance" type="Object"/>
      <property name="node" scope="instance-prototype" type="The">
        <description>draggable node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mdnd.Moveable.node">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.Moveable.offsetDrag"/>
  <class type="dojox.mdnd.Moveable.node.style"/>
  <class type="dojox.mdnd.PureSource" superclass="dojo.dnd.Selector">
    <methods>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required">
            <description>???</description>
          </parameter>
          <parameter name="node" type="DomNode" usage="required">
            <description>???</description>
          </parameter>
        </parameters>
        <return-description>New dojox.mdnd.PureSource instance.</return-description>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="copyState" scope="instance">
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <description>The &amp;quot;copy&amp;quot; was pressed.</description>
          </parameter>
        </parameters>
        <return-description>True, if we need to copy items, false to move.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>Node or node's id to build the source on.</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional">
            <description>Any property of this class may be configured via the params
	object which is mixed-in to the 'dojo.dnd.Source' instance.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_markDndStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Boolean" usage="required">
            <description>Copy status.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse event.</description>
          </parameter>
        </parameters>
        <return-description>True if user clicked on "approved" items.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Selector" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mdnd.adapter">
    <methods>
      <method name="dndToDojo" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="DndToDojo" scope="instance"/>
      <method name="DndFromDojo" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo">
    <methods>
      <method name="unsubscribeDnd" scope="instance"/>
      <method name="subscribeDnd" scope="instance"/>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>the DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDropCancel" scope="instance"/>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragExit" scope="instance"/>
      <method name="onDragEnter" scope="instance"/>
      <method name="onDndSource" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the dojo source/target</description>
          </parameter>
        </parameters>
      </method>
      <method name="isAccepted" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The dragged node.</description>
          </parameter>
          <parameter name="accept" type="Object" usage="required">
            <description>containing the type accepted for a target dojo.</description>
          </parameter>
        </parameters>
        <return-description>true if the dragged node is accepted in the target dojo.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_resetAvatar" scope="instance"/>
      <method name="_getHoverArea" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>containing the coordinates x and y (mouse position)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dropIndicatorSize" scope="instance" type="Object">
        <description>size by default of dropIndicator (display only into a D&amp;amp;D Area)</description>
      </property>
      <property name="_areaManager" scope="instance-prototype" type="Object">
        <description>Reference to the current DojoX Dnd Manager</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo.dropIndicatorSize"/>
  <class type="dojox.mdnd.adapter.DndFromDojo._areaManager">
    <properties>
      <property name="_dropIndicator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo._areaManager._dropIndicator.node.style"/>
  <class type="dojox.mdnd.adapter.DndFromDojo._areaManager._dropIndicator"/>
  <class type="dojox.mdnd.adapter.DndToDojo">
    <methods>
      <method name="unregisterByType" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>A String to identify dojo targets.</description>
          </parameter>
        </parameters>
      </method>
      <method name="unregisterByNode" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>The DOM node of target dojo.</description>
          </parameter>
        </parameters>
      </method>
      <method name="unregister" scope="instance"/>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>The DOM node which has to be registered.</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>A String to identify the node.
	dojoTarger:
	True if the dojo D&amp;amp;D have to be enable when mouse is hover the registered target dojo.</description>
          </parameter>
          <parameter name="dojoTarget" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="refreshByType" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>A String to identify dojo targets.</description>
          </parameter>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>Event object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>Event object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragExit" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>current javscript event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragEnter" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>The current Javascript Event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isAccepted" scope="instance">
        <parameters>
          <parameter name="draggedNode" type="DOMNode" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_initCoordinates" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A registered DOM node.</description>
          </parameter>
        </parameters>
        <return-description>An object which contains coordinates : *{x:0,y:,x1:0,y1:0}*</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getIndexDojoArea" scope="instance">
        <parameters>
          <parameter name="area" type="node" usage="required">
            <description>DOMNode A node corresponding to the target dojo.</description>
          </parameter>
        </parameters>
        <return-description>The index of area if it's registered else -1.</return-description>
      </method>
      <method name="_getHoverDojoArea" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>Coordinates of the mouse.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_draggedNode" scope="instance" type="DOMNode">
        <description>The current dragged node</description>
      </property>
      <property name="_dojoList" scope="instance-prototype" type="Array">
        <description>Array containing object references the dojo Target list</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoList"/>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem.item">
    <properties>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dropIndicator.node.style"/>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem">
    <properties>
      <property name="item" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem.item.node">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem.item.node.style"/>
  <class type="dojox.mdnd.adapter.DndToDojo._draggedNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._draggedNode.style"/>
  <class type="dojox.mdnd.dropMode">
    <methods>
      <method name="VerticalDropMode" scope="instance"/>
      <method name="OverDropMode" scope="instance"/>
      <method name="DefaultDropMode" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mdnd.dropMode.DefaultDropMode">
    <methods>
      <method name="updateAreas" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
        </parameters>
      </method>
      <method name="refreshItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>a DnD area object</description>
          </parameter>
          <parameter name="indexItem" type="Integer" usage="required">
            <description>index of a draggable item</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>dropIndicator size</description>
          </parameter>
          <parameter name="added" type="Boolean" usage="required">
            <description>boolean to know if a dropIndicator has been added or deleted</description>
          </parameter>
        </parameters>
      </method>
      <method name="initItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the DnD area</description>
          </parameter>
        </parameters>
      </method>
      <method name="getTargetArea" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of DnD areas objects</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the dragItem</description>
          </parameter>
          <parameter name="currentIndexArea" type="integer" usage="required">
            <description>an index representing the active DnD area</description>
          </parameter>
        </parameters>
        <return-description>the index of the DnD area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getDropIndex" scope="instance">
        <parameters>
          <parameter name="targetArea" type="Object" usage="required">
            <description>a DnD area object</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the draggable item</description>
          </parameter>
        </parameters>
        <return-description>a number
	or -1 if the area has no children or the drop index represents the last position in to the area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getDragPoint" scope="instance">
        <description>return for:
	- X point : the middle
	- Y point : search if the user goes up or goes down with his mouse.
	- Up : top of the draggable item
	- Down : bottom of the draggable item</description>
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordinates of mouse</description>
          </parameter>
        </parameters>
        <return-description>an object of coordinates
	example : {'x':10,'y':10}</return-description>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="areas" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
          <parameter name="object" type="Object" usage="required">
            <description>data type of a DndArea</description>
          </parameter>
        </parameters>
        <return-description>a sorted area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_updateArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the DnD area</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkInterval" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of DnD areas objects</description>
          </parameter>
          <parameter name="index" type="Integer" usage="required">
            <description>index of a DnD area (to get the interval)</description>
          </parameter>
          <parameter name="x" type="Coord" usage="required">
            <description>coordinate x, of the dragNode</description>
          </parameter>
        </parameters>
        <return-description>true if the dragNode is in intervall</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.mdnd.dropMode.OverDropMode">
    <methods>
      <method name="updateAreas" scope="instance">
        <description>the area position (and size) is equal to the postion of the domNode associated.</description>
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
        </parameters>
      </method>
      <method name="refreshItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>a D&amp;amp;D area object</description>
          </parameter>
          <parameter name="indexItem" type="Integer" usage="required">
            <description>index of a draggable item</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>dropIndicator size</description>
          </parameter>
          <parameter name="added" type="Boolean" usage="required">
            <description>boolean to know if a dropIndicator has been added or deleted</description>
          </parameter>
        </parameters>
      </method>
      <method name="initItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the D&amp;amp;D area.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getTargetArea" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of D&amp;amp;D areas objects</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the dragItem (see getDragPoint())</description>
          </parameter>
          <parameter name="currentIndexArea" type="integer" usage="required">
            <description>an index representing the active D&amp;amp;D area</description>
          </parameter>
        </parameters>
        <return-description>the index of the D&amp;D area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getDropIndex" scope="instance">
        <parameters>
          <parameter name="targetArea" type="Object" usage="required">
            <description>a D&amp;amp;D area object.</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the draggable item.</description>
          </parameter>
        </parameters>
        <return-description>a number or -1 if the area has no children or the drop index represents the last position in to the area</return-description>
        <return-types>
          <return-type type="integer"/>
        </return-types>
      </method>
      <method name="getDragPoint" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordinates of mouse</description>
          </parameter>
        </parameters>
        <return-description>an object of coordinates
	examples:{'x':10,'y':10}</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="areas" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
          <parameter name="object" type="Object" usage="required">
            <description>data type of a DndArea</description>
          </parameter>
        </parameters>
        <return-description>a sorted area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_updateArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the D&amp;amp;D area.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkInterval" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of D&amp;amp;D areas objects</description>
          </parameter>
          <parameter name="index" type="Integer" usage="required">
            <description>index of a D&amp;amp;D area (to get the interval)</description>
          </parameter>
          <parameter name="x" type="Coord" usage="required">
            <description>coordinate x, of the dragNode (see getDragPoint())</description>
          </parameter>
          <parameter name="y" type="Coord" usage="required"/>
        </parameters>
        <return-description>true if the dragNode is in intervall</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.mdnd.dropMode.VerticalDropMode">
    <methods>
      <method name="updateAreas" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
        </parameters>
      </method>
      <method name="refreshItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>a DnD area object</description>
          </parameter>
          <parameter name="indexItem" type="Integer" usage="required">
            <description>index of a draggable item</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>dropIndicator size</description>
          </parameter>
          <parameter name="added" type="Boolean" usage="required">
            <description>boolean to know if a dropIndicator has been added or deleted</description>
          </parameter>
        </parameters>
      </method>
      <method name="initItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the DnD area</description>
          </parameter>
        </parameters>
      </method>
      <method name="getTargetArea" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of DnD areas objects</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the dragItem</description>
          </parameter>
          <parameter name="currentIndexArea" type="integer" usage="required">
            <description>an index representing the active DnD area</description>
          </parameter>
        </parameters>
        <return-description>the index of the DnD area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getDropIndex" scope="instance">
        <parameters>
          <parameter name="targetArea" type="Object" usage="required">
            <description>a DnD area object</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the draggable item</description>
          </parameter>
        </parameters>
        <return-description>a number
	or -1 if the area has no children or the drop index represents the last position in to the area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getDragPoint" scope="instance">
        <description>return for:
	- X point : the middle
	- Y point : search if the user goes up or goes down with his mouse.
	- Up : top of the draggable item
	- Down : bottom of the draggable item</description>
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordinates of mouse</description>
          </parameter>
        </parameters>
        <return-description>an object of coordinates
	example : {'x':10,'y':10}</return-description>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="areas" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
          <parameter name="object" type="Object" usage="required">
            <description>data type of a DndArea</description>
          </parameter>
        </parameters>
        <return-description>a sorted area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_updateArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the DnD area</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkInterval" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of DnD areas objects</description>
          </parameter>
          <parameter name="index" type="Integer" usage="required">
            <description>index of a DnD area (to get the interval)</description>
          </parameter>
          <parameter name="x" type="Coord" usage="required">
            <description>coordinate x, of the dragNode</description>
          </parameter>
        </parameters>
        <return-description>true if the dragNode is in intervall</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.mobile">
    <methods>
      <method name="updateOrient" scope="instance"/>
      <method name="setupIcon" scope="instance">
        <parameters>
          <parameter name="iconNode" type="DomNode" usage="required"/>
          <parameter name="iconPos" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="resizeAll" scope="instance">
        <description>Find all widgets that do not have a parent or the parent does not
	have the resize() method, and call resize() for them.
	If a widget has a parent that has resize(), call of the widget's
	resize() is its parent's responsibility.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="optional">
            <description>Native event object</description>
          </parameter>
          <parameter name="root" type="Widget" usage="optional">
            <description>If specified, search the specified widget recursively for top level
	resizable widgets.
	root.resize() is always called regardless of whether root is a
	top level widget or not.
	If omitted, search the entire page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="openWindow" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadDeviceTheme" scope="instance">
        <description>This function is automatically called when this module is
	evaluated.</description>
        <parameters>
          <parameter name="userAgent" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="loadCssFile" scope="instance">
        <parameters>
          <parameter name="file" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="loadCss" scope="instance">
        <parameters>
          <parameter name="files" type="String|Array" usage="required">
            <description>The CSS files to load and register with the page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="loadCompatCssFiles" scope="instance">
        <parameters>
          <parameter name="force" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="hide_fs" scope="instance">
        <description>Resets the height of the body, performs hiding the address
	bar, and calls resizeAll().
	This is for fail-safe, in case of failure to complete the
	address bar hiding in time.</description>
      </method>
      <method name="hide_1" scope="instance">
        <parameters>
          <parameter name="force" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hideAddressBar" scope="instance">
        <description>Tries hiding of the address bar a couple of times to do it as
	quick as possible while ensuring resize is done after the hiding
	finishes.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="optional"/>
          <parameter name="doResize" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="getScreenSize" scope="instance"/>
      <method name="getCssPaths" scope="instance"/>
      <method name="detectScreenSize" scope="instance">
        <parameters>
          <parameter name="force" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="createRoundRect" scope="instance">
        <parameters>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="isList" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createIcon" scope="instance">
        <description>If node exists, updates the existing node. Otherwise, creates a new one.</description>
        <parameters>
          <parameter name="icon" type="String" usage="required">
            <description>Path for an image, or DOM button class name.</description>
          </parameter>
          <parameter name="iconPos" type="String" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="title" type="String" usage="optional"/>
          <parameter name="parent" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="createDomButton" scope="instance">
        <description>DOM button is a simple graphical object that consists of one or
	more nested DIV elements with some CSS styling. It can be used
	in place of an icon image on ListItem, IconItem, and so on.
	The kind of DOM button to create is given as a class name of
	refNode. The number of DIVs to create is searched from the style
	sheets in the page. However, if the class name has a suffix that
	starts with an underscore, like mblDomButtonGoldStar_5, then the
	suffixed number is used instead. A class name for DOM button
	must starts with 'mblDomButton'.</description>
        <parameters>
          <parameter name="refNode" type="DomNode" usage="required">
            <description>A node that has a DOM button class name.</description>
          </parameter>
          <parameter name="style" type="Object" usage="optional">
            <description>A hash object to set styles to the node.</description>
          </parameter>
          <parameter name="toNode" type="DomNode" usage="optional">
            <description>A root node to create a DOM button. If omitted, refNode is used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="applyPngFilter" scope="instance">
        <parameters>
          <parameter name="root" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ScrollableMixin" scope="instance">
        <description>Actual implementation is in scrollable.js.
	scrollable.js is not a dojo class, but just a collection
	of functions. This module makes scrollable.js a dojo class.</description>
      </method>
      <method name="_ListTouchMixin" scope="instance"/>
      <method name="_ItemBase" scope="instance">
        <description>_ItemBase is a base class for widgets that have capability to
	make a view transition when clicked.</description>
      </method>
      <method name="_DataListMixin" scope="instance">
        <description>By mixing this class into the widgets, the list item nodes are
	generated as the child nodes of the widget and automatically
	re-generated whenever the corresponding data items are modified.</description>
      </method>
      <method name="_ComboBoxMenu" scope="instance"/>
      <method name="ViewController" scope="instance">
        <description>This class listens to the "startTransition" events and performs
	view transitions. If the transition destination is an external
	view specified with the url parameter, retrieves the view
	content and parses it to create a new target view.</description>
      </method>
      <method name="View" scope="instance">
        <description>View acts as a container for any HTML and/or widgets. An entire
	HTML page can have multiple View widgets and the user can
	navigate through the views back and forth without page
	transitions.</description>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="TransitionEvent" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="transitionOptions" type="Object" usage="required"/>
          <parameter name="triggerEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Tooltip" scope="instance"/>
      <method name="ToolBarButton" scope="instance">
        <description>ToolBarButton is a button that is placed in the Heading
	widget. It is a subclass of dojox.mobile._ItemBase just like
	ListItem or IconItem. So, unlike Button, it has basically the
	same capability as ListItem or IconItem, such as icon support,
	transition, etc.</description>
      </method>
      <method name="ToggleButton" scope="instance"/>
      <method name="TextBox" scope="instance"/>
      <method name="TextArea" scope="instance">
        <description>A textarea widget that wraps an HTML TEXTAREA element.
	Takes all the parameters (name, value, etc.) that a vanilla textarea takes.</description>
        <examples>
          <example>	&lt;textarea dojoType="dojox.mobile.TextArea"&gt;...&lt;/textarea&gt;</example>
        </examples>
      </method>
      <method name="TabBarButton" scope="instance">
        <description>TabBarButton is a button that is placed in the TabBar widget. It
	is a subclass of dojox.mobile._ItemBase just like ListItem or
	IconItem. So, unlike Button, it has similar capability as
	ListItem or IconItem, such as icon support, transition, etc.</description>
      </method>
      <method name="TabBar" scope="instance">
        <description>TabBar is a container widget that has typically multiple
	TabBarButtons which controls visibility of views. It can be used
	as a tab container.</description>
      </method>
      <method name="Switch" scope="instance">
        <description>Switch is a toggle switch with a sliding knob. You can either
	tap or slide the knob to toggle the switch. The onStateChanged
	handler is called when the switch is manipulated.</description>
      </method>
      <method name="SwapView" scope="instance">
        <description>SwapView is a container widget that represents entire mobile
	device screen, and can be swiped horizontally. (In dojo-1.6, it
	was called 'FlippableView'.) SwapView is a subclass of
	dojox.mobile.View. SwapView allows the user to swipe the screen
	left or right to move between the views. When SwapView is
	swiped, it finds an adjacent SwapView to open it.</description>
      </method>
      <method name="SpinWheelYearSlot" scope="instance"/>
      <method name="SpinWheelTimePicker" scope="instance">
        <description>SpinWheelTimePicker is a time picker widget. It is a subclass of
	dojox.mobile.SpinWheel. It has the hour and minute slots.</description>
      </method>
      <method name="SpinWheelSlot" scope="instance">
        <description>SpinWheelSlot is a slot that is placed in the SpinWheel widget.</description>
      </method>
      <method name="SpinWheelMonthSlot" scope="instance"/>
      <method name="SpinWheelDaySlot" scope="instance"/>
      <method name="SpinWheelDatePicker" scope="instance">
        <description>SpinWheelDatePicker is a date picker widget. It is a subclass of
	dojox.mobile.SpinWheel. It has the year, month, and day slots.</description>
      </method>
      <method name="SpinWheel" scope="instance">
        <description>SpinWheel is a value picker component. It is a sectioned wheel
	that can be used to pick up some values from the wheel slots by
	spinning them.</description>
      </method>
      <method name="Slider" scope="instance"/>
      <method name="ScrollableView" scope="instance">
        <description>ScrollableView is a subclass of View (=dojox.mobile.View).
	Unlike the base View class, ScrollableView's domNode always stays
	at the top of the screen and its height is "100%" of the screen.
	In this fixed domNode, containerNode scrolls. Browser's default
	scrolling behavior is disabled, and the scrolling machinery is
	re-implemented with JavaScript. Thus the user does not need to use the
	two-finger operation to scroll an inner DIV (containerNode).
	The main purpose of this widget is to realize fixed-positioned header
	and/or footer bars.</description>
      </method>
      <method name="RoundRectList" scope="instance">
        <description>RoundRectList is a rounded rectangle list, which can be used to
	display a group of items. Each item must be
	dojox.mobile.ListItem.</description>
      </method>
      <method name="RoundRectDataList" scope="instance">
        <description>RoundRectDataList is an enhanced version of RoundRectList. It
	can generate ListItems according to the given dojo.data store.</description>
      </method>
      <method name="RoundRectCategory" scope="instance"/>
      <method name="RoundRect" scope="instance">
        <description>RoundRect is a simple round rectangle container for any HTML
	and/or widgets. You can achieve the same appearance by just
	applying the -webkit-border-radius style to a div tag. However,
	if you use RoundRect, you can get a round rectangle even on
	non-CSS3 browsers such as (older) IE.</description>
      </method>
      <method name="RadioButton" scope="instance"/>
      <method name="ProgressIndicator" scope="instance">
        <description>ProgressIndicator is a round spinning graphical representation
	that indicates the current task is on-going.</description>
      </method>
      <method name="PageIndicator" scope="instance">
        <description>PageIndicator displays a series of gray and white dots to
	indicate which page is currently being viewed. It can typically
	be used with dojox.mobile.SwapView. It is also internally used
	in dojox.mobile.Carousel.</description>
      </method>
      <method name="Overlay" scope="instance"/>
      <method name="Opener" scope="instance"/>
      <method name="ListItem" scope="instance">
        <description>ListItem represents an item of either RoundRectList or
	EdgeToEdgeList. There are three ways to move to a different
	view, moveTo, href, and url. You can choose only one of them.</description>
      </method>
      <method name="IconItem" scope="instance">
        <description>IconItem represents an item that has an application component
	and its icon image. You can tap the icon to open the
	corresponding application component. You can also use the icon
	to move to a different view by specifying either of the moveTo,
	href or url parameters.</description>
      </method>
      <method name="IconContainer" scope="instance">
        <description>IconContainer is a container widget that holds multiple icons
	each of which represents application component.</description>
      </method>
      <method name="Heading" scope="instance">
        <description>Heading is a widget that represents a navigation bar, which
	usually appears at the top of an application. It usually
	displays the title of the current view and can contain a
	navigational control. If you use it with
	dojox.mobile.ScrollableView, it can also be used as a fixed
	header bar or a fixed footer bar. In such cases, specify the
	fixed="top" attribute to be a fixed header bar or the
	fixed="bottom" attribute to be a fixed footer bar. Heading can
	have one or more ToolBarButton widgets as its children.</description>
      </method>
      <method name="FixedSplitterPane" scope="instance">
        <description>FixedSplitterPane is a pane widget that is used in a
	dojox.mobile.FixedSplitter. It is a widget, but can be regarded
	as a simple &lt;div&gt; element.</description>
      </method>
      <method name="FixedSplitter" scope="instance">
        <description>FixedSplitter is a very simple container widget that layouts its
	child dom nodes side by side either horizontally or
	vertically. An example usage of this widget would be to realize
	the split view on iPad. There is no visual splitter between the
	children, and there is no function to resize the child panes
	with drag-and-drop. If you need a visual splitter, you can
	specify a border of a child dom node with CSS.
	A child of the widget should be FixedSplitterPane.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.mobile.FixedSplitter" orientation="H"&gt;
			&lt;div dojoType="dojox.mobile.FixedSplitterPane"
				style="width:200px;border-right:1px solid black;"&gt;
				pane #1 (width=200px)
			&lt;/div&gt;
			&lt;div dojoType="dojox.mobile.FixedSplitterPane"&gt;
				pane #2
			&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="ExpandingTextArea" scope="instance">
        <description>A textarea that dynamically expands/contracts (changing it's height) as
	the user types, to display all the text without requiring a vertical scroll bar.
	
	Takes all the parameters (name, value, etc.) that a vanilla textarea takes.
	Rows is not supported since this widget adjusts the height.</description>
        <examples>
          <example>	&lt;textarea dojoType="dojox.mobile.ExpandingTextArea"&gt;...&lt;/textarea&gt;</example>
        </examples>
      </method>
      <method name="EdgeToEdgeList" scope="instance">
        <description>EdgeToEdgeList is an edge-to-edge layout list, which displays
	all items in equally sized rows. Each item must be
	dojox.mobile.ListItem.</description>
      </method>
      <method name="EdgeToEdgeDataList" scope="instance">
        <description>EdgeToEdgeDataList is an enhanced version of EdgeToEdgeList. It
	can generate ListItems according to the given dojo.data store.</description>
      </method>
      <method name="EdgeToEdgeCategory" scope="instance"/>
      <method name="ContentPane" scope="instance">
        <description>This widget embeds an HTML fragment and run the parser. onLoad()
	is called when parsing is done and the content is ready.
	"dojo/_base/xhr" is in the dependency list. Usually this is not
	necessary, but there is a case where dojox.mobile custom build
	does not contain xhr. Note that this widget does not inherit
	from dijit._Container.</description>
      </method>
      <method name="ComboBox" scope="instance"/>
      <method name="CheckBox" scope="instance"/>
      <method name="Carousel" scope="instance">
        <description>The carousel widget manages a list of images that can be
	displayed horizontally, and allows the user to scroll through
	the list and select a single item.</description>
      </method>
      <method name="Button" scope="instance">
        <description>Buttons can display a label, an icon, or both.
	A label should always be specified (through innerHTML) or the label
	attribute.  It can be hidden via showLabel=false.</description>
        <examples>
          <example>    &lt;button dojoType="dijit.form.Button" onClick="..."&gt;Hello world&lt;/button&gt;</example>
        </examples>
      </method>
    </methods>
    <properties>
      <property name="i18n" scope="instance" type="Object"/>
      <property name="app" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Button" superclass="dijit._WidgetBase">
    <description>Buttons can display a label, an icon, or both.
	A label should always be specified (through innerHTML) or the label
	attribute.  It can be hidden via showLabel=false.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="isFocusable" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidgetMixin.prototype" scope="instance"/>
      <mixin type="dijit.form._ButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit.form._FormWidgetMixin" scope="instance"/>
      <mixin type="dijit.form._ButtonMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Button.srcNodeRef">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Button.srcNodeRef.firstChild"/>
  <class type="dojox.mobile.Carousel" superclass="dijit._WidgetBase">
    <description>The carousel widget manages a list of images that can be
	displayed horizontally, and allows the user to scroll through
	the list and select a single item.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resizeContent" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="box" type="Object" usage="required"/>
          <parameter name="img" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="onPrevBtnClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onNextBtnClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="errText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadImages" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleViewChanged" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createHeaderText" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createFooterText" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createContent" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createBox" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setTitleAttr" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="titleNode" scope="instance" type="Object"/>
      <property name="piw" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Carousel.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Carousel.domNode.style"/>
  <class type="dojox.mobile.Carousel.piw"/>
  <class type="dojox.mobile.Carousel.titleNode"/>
  <class type="dojox.mobile.PageIndicator" superclass="dijit._WidgetBase">
    <description>PageIndicator displays a series of gray and white dots to
	indicate which page is currently being viewed. It can typically
	be used with dojox.mobile.SwapView. It is also internally used
	in dojox.mobile.Carousel.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isView" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.SwapView" superclass="dojox.mobile.View">
    <description>SwapView is a container widget that represents entire mobile
	device screen, and can be swiped horizontally. (In dojo-1.6, it
	was called 'FlippableView'.) SwapView is a subclass of
	dojox.mobile.View. SwapView allows the user to swipe the screen
	left or right to move between the views. When SwapView is
	swiped, it finds an adjacent SwapView to open it.</description>
    <methods>
      <method name="slideTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="duration" type="Number" usage="required"/>
          <parameter name="easing" type="String" usage="required"/>
          <parameter name="fake_pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scrollTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="previousView" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFlickAnimationEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextView" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isSwapView" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handlePrevPage" scope="instance">
        <parameters>
          <parameter name="w" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="handleNextPage" scope="instance">
        <parameters>
          <parameter name="w" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="goTo" scope="instance">
        <parameters>
          <parameter name="dir" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ScrollableMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.View" scope="instance"/>
      <mixin type="dojox.mobile._ScrollableMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.CheckBox" superclass="dojox.mobile.ToggleButton">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setTypeAttr" scope="instance"/>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._CheckBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.ToggleButton" scope="instance"/>
      <mixin type="dijit.form._CheckBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.ToggleButton" superclass="dojox.mobile.Button">
    <methods>
      <method name="_setCheckedAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._ToggleButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.Button" scope="instance"/>
      <mixin type="dijit.form._ToggleButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.ComboBox" superclass="dojox.mobile.TextBox">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="openDropDown" scope="instance">
        <return-description>return value of popup.open()</return-description>
      </method>
      <method name="onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeDropDown" scope="instance"/>
      <method name="_throttleOpenClose" scope="instance"/>
      <method name="_setListAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._AutoCompleterMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.TextBox" scope="instance"/>
      <mixin type="dijit.form._AutoCompleterMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="dropDown" scope="instance" type="Widget">
        <description>The widget to display as a popup.  This widget *must* be
	defined before the startup function is called.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mobile.ComboBox.dropDown"/>
  <class type="dojox.mobile.TextBox" superclass="dijit._WidgetBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueMixin.prototype" scope="instance"/>
      <mixin type="dijit.form._TextBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit.form._FormValueMixin" scope="instance"/>
      <mixin type="dijit.form._TextBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.ContentPane" superclass="dijit._WidgetBase">
    <description>This widget embeds an HTML fragment and run the parser. onLoad()
	is called when parsing is done and the content is ready.
	"dojo/_base/xhr" is in the dependency list. Usually this is not
	necessary, but there is a case where dojox.mobile custom build
	does not contain xhr. Note that this widget does not inherit
	from dijit._Container.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="onLoad" scope="instance"/>
      <method name="loadHandler" scope="instance">
        <parameters>
          <parameter name="response" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="errorHandler" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setHrefAttr" scope="instance">
        <parameters>
          <parameter name="href" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="instance">
        <parameters>
          <parameter name="data" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ContentPane.domNode"/>
  <class type="dojox.mobile.EdgeToEdgeCategory" superclass="dojox.mobile.RoundRectCategory">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.RoundRectCategory" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeCategory.domNode"/>
  <class type="dojox.mobile.RoundRectCategory" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeDataList" superclass="dojox.mobile.EdgeToEdgeList">
    <description>EdgeToEdgeDataList is an enhanced version of EdgeToEdgeList. It
	can generate ListItems according to the given dojo.data store.</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.mobile._DataListMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.EdgeToEdgeList" scope="instance"/>
      <mixin type="dojox.mobile._DataListMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList" superclass="dojox.mobile.RoundRectList">
    <description>EdgeToEdgeList is an edge-to-edge layout list, which displays
	all items in equally sized rows. Each item must be
	dojox.mobile.ListItem.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.RoundRectList" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile._DataListMixin">
    <description>By mixing this class into the widgets, the list item nodes are
	generated as the child nodes of the widget and automatically
	re-generated whenever the corresponding data items are modified.</description>
    <methods>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="Object|Array" usage="required"/>
          <parameter name="newValue" type="Object|Array" usage="required"/>
        </parameters>
      </method>
      <method name="onNew" scope="instance">
        <parameters>
          <parameter name="newItem" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="errorData" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generateList" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createListItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList.domNode"/>
  <class type="dojox.mobile.RoundRectList" superclass="dijit._WidgetBase">
    <description>RoundRectList is a rounded rectangle list, which can be used to
	display a group of items. Each item must be
	dojox.mobile.ListItem.</description>
    <methods>
      <method name="selectItem" scope="instance">
        <parameters>
          <parameter name="item" type="ListItem" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="redrawBorders" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onCheckStateChanged" scope="instance">
        <description>Called when the check state has been changed.</description>
        <parameters>
          <parameter name="listItem" type="Widget" usage="required"/>
          <parameter name="newState" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="deselectItem" scope="instance">
        <parameters>
          <parameter name="item" type="ListItem" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="_setStatefulAttr" scope="instance">
        <parameters>
          <parameter name="stateful" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ExpandingTextArea" superclass="dojox.mobile.TextArea">
    <description>A textarea that dynamically expands/contracts (changing it's height) as
	the user types, to display all the text without requiring a vertical scroll bar.
	
	Takes all the parameters (name, value, etc.) that a vanilla textarea takes.
	Rows is not supported since this widget adjusts the height.</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form._ExpandingTextAreaMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.TextArea" scope="instance"/>
      <mixin type="dijit.form._ExpandingTextAreaMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.TextArea" superclass="dojox.mobile.TextBox">
    <description>A textarea widget that wraps an HTML TEXTAREA element.
	Takes all the parameters (name, value, etc.) that a vanilla textarea takes.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.TextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.FixedSplitter" superclass="dijit._WidgetBase">
    <description>FixedSplitter is a very simple container widget that layouts its
	child dom nodes side by side either horizontally or
	vertically. An example usage of this widget would be to realize
	the split view on iPad. There is no visual splitter between the
	children, and there is no function to resize the child panes
	with drag-and-drop. If you need a visual splitter, you can
	specify a border of a child dom node with CSS.
	A child of the widget should be FixedSplitterPane.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.FixedSplitterPane" superclass="dijit._WidgetBase">
    <description>FixedSplitterPane is a pane widget that is used in a
	dojox.mobile.FixedSplitter. It is a widget, but can be regarded
	as a simple &lt;div&gt; element.</description>
    <methods>
      <method name="resize" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.Heading" superclass="dijit._WidgetBase">
    <description>Heading is a widget that represents a navigation bar, which
	usually appears at the top of an application. It usually
	displays the title of the current view and can contain a
	navigational control. If you use it with
	dojox.mobile.ScrollableView, it can also be used as a fixed
	header bar or a fixed footer bar. In such cases, specify the
	fixed="top" attribute to be a fixed header bar or the
	fixed="bottom" attribute to be a fixed footer bar. Heading can
	have one or more ToolBarButton widgets as its children.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goTo" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findCurrentView" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setBackAttr" scope="instance">
        <parameters>
          <parameter name="back" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="labelNode" scope="instance" type="Object"/>
      <property name="labelDivNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="backProp" scope="instance" type="Object">
        <description>Properties for the back button.</description>
      </property>
      <property name="_body" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading.backProp"/>
  <class type="dojox.mobile.Heading.domNode"/>
  <class type="dojox.mobile.Heading.labelNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading._btn.style"/>
  <class type="dojox.mobile.Heading.containerNode"/>
  <class type="dojox.mobile.Heading.labelNode.style"/>
  <class type="dojox.mobile.Heading._body"/>
  <class type="dojox.mobile.Heading.labelDivNode"/>
  <class type="dojox.mobile.IconContainer" superclass="dijit._WidgetBase">
    <description>IconContainer is a container widget that holds multiple icons
	each of which represents application component.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget|Number" usage="required"/>
        </parameters>
      </method>
      <method name="closeAll" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="_setupSubNodes" scope="instance">
        <parameters>
          <parameter name="ul" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconContainer.domNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconContainer.domNode.childNodes"/>
  <class type="dojox.mobile.IconItem" superclass="dojox.mobile._ItemBase">
    <description>IconItem represents an item that has an application component
	and its icon image. You can tap the icon to open the
	corresponding application component. You can also use the icon
	to move to a different view by specifying either of the moveTo,
	href or url parameters.</description>
    <methods>
      <method name="unhighlight" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="instance"/>
      <method name="onMouseDownIcon" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="isOpen" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="instantiateWidget" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iconClicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="highlight" scope="instance"/>
      <method name="createTemplate" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeIconClicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setIconAttr" scope="instance">
        <parameters>
          <parameter name="icon" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="icon may be invalid because inheritParams is not called yet"/>
        </return-types>
      </method>
      <method name="_open_1" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ItemBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="subNode" scope="instance" type="Object"/>
      <property name="labelNode2" scope="instance" type="Object"/>
      <property name="labelNode1" scope="instance" type="Object"/>
      <property name="iconNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.subNode"/>
  <class type="dojox.mobile.IconItem.srcNodeRef.childNodes"/>
  <class type="dojox.mobile.IconItem.closeNode.style"/>
  <class type="dojox.mobile.IconItem.contentNode.style"/>
  <class type="dojox.mobile.IconItem.iconNode"/>
  <class type="dojox.mobile.IconItem.containerNode.parentNode.style"/>
  <class type="dojox.mobile.IconItem.labelNode1"/>
  <class type="dojox.mobile.IconItem.labelNode2"/>
  <class type="dojox.mobile._ItemBase" superclass="dijit._WidgetBase">
    <description>_ItemBase is a base class for widgets that have capability to
	make a view transition when clicked.</description>
    <methods>
      <method name="transitionTo" scope="instance">
        <description>Given a transition destination, this method performs a view
	transition. This method is typically called when this item
	is clicked.</description>
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="scene" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTransitionPos" scope="instance">
        <description>Some of the transition animations (e.g. ScaleIn) needs the
	clicked position.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <description>Subclass must implement.</description>
      </method>
      <method name="inheritParams" scope="instance"/>
      <method name="getParent" scope="instance">
        <description>Almost equivalent to _Contained#getParent, but this method
	does not cause a script error even if this widget has no
	parent yet.</description>
      </method>
      <method name="deselect" scope="instance">
        <description>Subclass must implement.</description>
      </method>
      <method name="defaultClickAction" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.ListItem" superclass="dojox.mobile._ItemBase">
    <description>ListItem represents an item of either RoundRectList or
	EdgeToEdgeList. There are three ways to move to a different
	view, moveTo, href, and url. You can choose only one of them.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setArrow" scope="instance"/>
      <method name="select" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already selected"/>
        </return-types>
      </method>
      <method name="onAnchorLabelClicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layoutVariableHeight" scope="instance"/>
      <method name="deselect" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setRightTextAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setRightIconAttr" scope="instance">
        <parameters>
          <parameter name="icon" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setRightIcon2Attr" scope="instance">
        <parameters>
          <parameter name="icon" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setIconAttr" scope="instance">
        <parameters>
          <parameter name="icon" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="icon may be invalid because inheritParams is not called yet"/>
        </return-types>
      </method>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ItemBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="rightTextNode" scope="instance" type="Object"/>
      <property name="rightIconNode" scope="instance" type="Object"/>
      <property name="labelNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="anchorNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ListItem.domNode"/>
  <class type="dojox.mobile.ListItem.srcNodeRef.childNodes"/>
  <class type="dojox.mobile.ListItem.labelNode"/>
  <class type="dojox.mobile.ListItem.anchorNode"/>
  <class type="dojox.mobile.ListItem.rightIconNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ListItem.rightIconNode.style"/>
  <class type="dojox.mobile.ListItem.rightIconNode.childNodes.0.style"/>
  <class type="dojox.mobile.ListItem.rightIconNode.childNodes.1.style"/>
  <class type="dojox.mobile.ListItem.rightTextNode"/>
  <class type="dojox.mobile.Opener">
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="positions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onShow" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onHide" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="v" type="Anything" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="val" type="Anything" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_resizeCover" scope="instance"/>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.mobile.Tooltip" superclass="dijit._WidgetBase">
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="positions" type="Ordered" usage="required">
            <description>list of positions to try matching up.
	* before: places drop down before the aroundNode
	* after: places drop down after the aroundNode
	* above-centered: drop down goes above aroundNode
	* below-centered: drop down goes below aroundNode</description>
          </parameter>
        </parameters>
      </method>
      <method name="onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="touching outside the overlay area does call hide() by default"/>
        </return-types>
      </method>
      <method name="hide" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.Overlay" superclass="dijit._WidgetBase">
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="touching outside the overlay area does not call hide()"/>
        </return-types>
      </method>
      <method name="hide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.PageIndicator.domNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.PageIndicator._tblNode.rows"/>
  <class type="dojox.mobile.PageIndicator.domNode.parentNode"/>
  <class type="dojox.mobile.ProgressIndicator">
    <description>ProgressIndicator is a round spinning graphical representation
	that indicates the current task is on-going.</description>
    <methods>
      <method name="stop" scope="instance"/>
      <method name="start" scope="instance"/>
      <method name="setImage" scope="instance">
        <parameters>
          <parameter name="file" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Array">
        <description>An array of indicator colors.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mobile.ProgressIndicator.imageNode.style"/>
  <class type="dojox.mobile.ProgressIndicator.colors"/>
  <class type="dojox.mobile.ProgressIndicator.spinnerNode.style"/>
  <class type="dojox.mobile.ProgressIndicator.domNode"/>
  <class type="dojox.mobile.RadioButton" superclass="dojox.mobile.CheckBox">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form._RadioButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.CheckBox" scope="instance"/>
      <mixin type="dijit.form._RadioButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.RoundRect" superclass="dijit._WidgetBase">
    <description>RoundRect is a simple round rectangle container for any HTML
	and/or widgets. You can achieve the same appearance by just
	applying the -webkit-border-radius style to a div tag. However,
	if you use RoundRect, you can get a round rectangle even on
	non-CSS3 browsers such as (older) IE.</description>
    <methods>
      <method name="resize" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRect.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRect.domNode"/>
  <class type="dojox.mobile.RoundRectCategory.domNode"/>
  <class type="dojox.mobile.RoundRectDataList" superclass="dojox.mobile.RoundRectList">
    <description>RoundRectDataList is an enhanced version of RoundRectList. It
	can generate ListItems according to the given dojo.data store.</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.mobile._DataListMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.RoundRectList" scope="instance"/>
      <mixin type="dojox.mobile._DataListMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.RoundRectList.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectList.domNode"/>
  <class type="dojox.mobile.ScrollableView" superclass="dojox.mobile.View">
    <description>ScrollableView is a subclass of View (=dojox.mobile.View).
	Unlike the base View class, ScrollableView's domNode always stays
	at the top of the screen and its height is "100%" of the screen.
	In this fixed domNode, containerNode scrolls. Browser's default
	scrolling behavior is disabled, and the scrolling machinery is
	re-implemented with JavaScript. Thus the user does not need to use the
	two-finger operation to scroll an inner DIV (containerNode).
	The main purpose of this widget is to realize fixed-positioned header
	and/or footer bars.</description>
    <methods>
      <method name="resize" scope="instance"/>
      <method name="reparent" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onAfterTransitionIn" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isTopLevel" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="top level widget"/>
        </return-types>
      </method>
      <method name="getChildren" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ScrollableMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.View" scope="instance"/>
      <mixin type="dojox.mobile._ScrollableMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.ScrollableView.domNode.style"/>
  <class type="dojox.mobile.ScrollableView.containerNode.style"/>
  <class type="dojox.mobile.ScrollableView.domNode.childNodes"/>
  <class type="dojox.mobile.View" superclass="dijit._WidgetBase">
    <description>View acts as a container for any HTML and/or widgets. An entire
	HTML page can have multiple View widgets and the user can
	navigate through the views back and forth without page
	transitions.</description>
    <methods>
      <method name="wakeUp" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to forcibly redraw.</description>
          </parameter>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="performTransition" scope="instance">
        <examples>
          <example>Transition backward to a view whose id is "foo" with the slide animation.
		performTransition("foo", -1, "slide");</example>
          <example>Transition forward to a blank view, and then open another page.
		performTransition(null, 1, "slide", null, function(){location.href = href;});</example>
        </examples>
        <parameters>
          <parameter name="moveTo" type="String" usage="required">
            <description>The id of the transition destination view which resides in
	the current page.
	If the value has a hash sign ('#') before the id
	(e.g. #view1) and the dojo.hash module is loaded by the user
	application, the view transition updates the hash in the
	browser URL so that the user can bookmark the destination
	view. In this case, the user can also use the browser's
	back/forward button to navigate through the views in the
	browser history.
	If null, transitions to a blank view.
	If '#', returns immediately without transition.</description>
          </parameter>
          <parameter name="dir" type="Number" usage="required">
            <description>The transition direction. If 1, transition forward. If -1, transition backward.
	For example, the slide transition slides the view from right to left when dir == 1,
	and from left to right when dir == -1.</description>
          </parameter>
          <parameter name="transition" type="String" usage="required">
            <description>A type of animated transition effect. You can choose from
	the standard transition types, &amp;quot;slide&amp;quot;, &amp;quot;fade&amp;quot;, &amp;quot;flip&amp;quot;, or
	from the extended transition types, &amp;quot;cover&amp;quot;, &amp;quot;coverv&amp;quot;,
	&amp;quot;dissolve&amp;quot;, &amp;quot;reveal&amp;quot;, &amp;quot;revealv&amp;quot;, &amp;quot;scaleIn&amp;quot;,
	&amp;quot;scaleOut&amp;quot;, &amp;quot;slidev&amp;quot;, &amp;quot;swirl&amp;quot;, &amp;quot;zoomIn&amp;quot;, &amp;quot;zoomOut&amp;quot;. If
	&amp;quot;none&amp;quot; is specified, transition occurs immediately without
	animation.</description>
          </parameter>
          <parameter name="context" type="Object|null" usage="required">
            <description>Object The object that the callback function will receive as &amp;quot;this&amp;quot;.</description>
          </parameter>
          <parameter name="method" type="String|Function" usage="required">
            <description>A callback function that is called when the transition has been finished.
	A function reference, or name of a function in context.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onStartView" scope="instance">
        <description>Called only when this view is shown at startup time.</description>
      </method>
      <method name="onBeforeTransitionOut" scope="instance">
        <description>Called before the leaving transition occurs.</description>
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeTransitionIn" scope="instance">
        <description>Called before the arriving transition occurs.</description>
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAnimationStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAnimationEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterTransitionOut" scope="instance">
        <description>Called after the leaving transition occurs.</description>
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterTransitionIn" scope="instance">
        <description>Called after the arriving transition occurs.</description>
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invokeCallback" scope="instance"/>
      <method name="getShowingView" scope="instance">
        <description>Note that dojox.mobile.currentView is the last shown view.
	If the page consists of a splitter, there are multiple showing views.</description>
      </method>
      <method name="convertToId" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_toCls" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveState" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fixViewState" scope="instance">
        <description>Sometimes uninitialization of Views fails after making view transition,
	and that results in failure of subsequent view transitions.
	This function does the uninitialization for all the sibling views.</description>
        <parameters>
          <parameter name="toNode" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_doTransition" scope="instance">
        <parameters>
          <parameter name="fromNode" type="Object" usage="required"/>
          <parameter name="toNode" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile._ScrollableMixin">
    <description>Actual implementation is in scrollable.js.
	scrollable.js is not a dojo class, but just a collection
	of functions. This module makes scrollable.js a dojo class.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="findAppBars" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="checkFixedBar" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="local" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="scrollableParams" scope="instance-prototype" type="Object">
        <description>Parameters for dojox.mobile.scrollable.init().</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mobile.Slider" superclass="dijit._WidgetBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="don't move images until all the properties are set"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit.form._FormValueMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="valueNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Slider.valueNode"/>
  <class type="dojox.mobile.SpinWheel" superclass="dijit._WidgetBase">
    <description>SpinWheel is a value picker component. It is a sectioned wheel
	that can be used to pick up some values from the wheel slots by
	spinning them.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="getValue" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.SpinWheelYearSlot" superclass="dojox.mobile.SpinWheelSlot">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.SpinWheelSlot" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.SpinWheelMonthSlot" superclass="dojox.mobile.SpinWheelSlot">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.SpinWheelSlot" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.SpinWheelDaySlot" superclass="dojox.mobile.SpinWheelSlot">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.mobile.SpinWheelSlot" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.SpinWheelDatePicker" superclass="dojox.mobile.SpinWheel">
    <description>SpinWheelDatePicker is a date picker widget. It is a subclass of
	dojox.mobile.SpinWheel. It has the year, month, and day slots.</description>
    <methods>
      <method name="reset" scope="instance"/>
      <method name="onMonthSet" scope="instance"/>
      <method name="onDaySet" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.SpinWheel" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.SpinWheelSlot" superclass="dijit._WidgetBase">
    <description>SpinWheelSlot is a slot that is placed in the SpinWheel widget.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="slideTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="duration" type="Number" usage="required"/>
          <parameter name="easing" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setInitialValue" scope="instance"/>
      <method name="setColor" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="getSpeed" scope="instance"/>
      <method name="getKey" scope="instance"/>
      <method name="getCenterPanel" scope="instance"/>
      <method name="getCenterItem" scope="instance"/>
      <method name="disableValues" scope="instance">
        <parameters>
          <parameter name="values" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="calcSpeed" scope="instance">
        <parameters>
          <parameter name="d" type="Number" usage="required"/>
          <parameter name="t" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="adjustDestination" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjust" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dojox.mobile._ScrollableMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dojox.mobile._ScrollableMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="panelNodes" scope="instance" type="Array"/>
      <property name="items" scope="instance" type="Array">
        <description>An array of array of key-label paris.
	(e.g. [[0,&amp;quot;Jan&amp;quot;],[1,&amp;quot;Feb&amp;quot;],...] ) If key values for each label
	are not necessary, labels can be used instead.</description>
      </property>
      <property name="_time" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.SpinWheelSlot.containerNode.style"/>
  <class type="dojox.mobile.SpinWheelSlot.items"/>
  <class type="dojox.mobile.SpinWheelSlot.panelNodes.1">
    <properties>
      <property name="style" scope="instance" type="Object"/>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.SpinWheelSlot.panelNodes.1.childNodes"/>
  <class type="dojox.mobile.SpinWheelSlot.panelNodes.0">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.SpinWheelSlot.panelNodes.0.style"/>
  <class type="dojox.mobile.SpinWheelSlot.panelNodes.1.style"/>
  <class type="dojox.mobile.SpinWheelSlot.panelNodes.2.style"/>
  <class type="dojox.mobile.SpinWheelSlot.panelNodes">
    <properties>
      <property name="1" scope="instance" type="Object"/>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.SpinWheelSlot._time"/>
  <class type="dojox.mobile.SpinWheelSlot.domNode.parentNode"/>
  <class type="dojox.mobile.SpinWheelTimePicker" superclass="dojox.mobile.SpinWheel">
    <description>SpinWheelTimePicker is a time picker widget. It is a subclass of
	dojox.mobile.SpinWheel. It has the hour and minute slots.</description>
    <methods>
      <method name="reset" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.SpinWheel" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.SwapView.domNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.SwapView.domNode.parentNode"/>
  <class type="dojox.mobile.SwapView.containerNode.style"/>
  <class type="dojox.mobile.Switch" superclass="dijit._WidgetBase">
    <description>Switch is a toggle switch with a sliding knob. You can either
	tap or slide the knob to toggle the switch. The onStateChanged
	handler is called when the switch is manipulated.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onTouchStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStateChanged" scope="instance">
        <description>Called when the state has been changed.</description>
        <parameters>
          <parameter name="newState" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRoundMask" scope="instance">
        <parameters>
          <parameter name="className" type="Object" usage="required"/>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setRightLabelAttr" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setLeftLabelAttr" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_changeState" scope="instance">
        <parameters>
          <parameter name="state" type="String" usage="required">
            <description>The state to toggle, switch 'on' or 'off'</description>
          </parameter>
          <parameter name="anim" type="Boolean" usage="required">
            <description>Whether to use animation or not</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="input" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.domNode"/>
  <class type="dojox.mobile.Switch._changeState">
    <methods/>
  </class>
  <class type="dojox.mobile.Switch.left.style"/>
  <class type="dojox.mobile.Switch.right.style"/>
  <class type="dojox.mobile.Switch.inner.style"/>
  <class type="dojox.mobile.Switch.input"/>
  <class type="dojox.mobile.Switch.left.firstChild"/>
  <class type="dojox.mobile.Switch.right.firstChild"/>
  <class type="dojox.mobile.TabBar" superclass="dijit._WidgetBase">
    <description>TabBar is a container widget that has typically multiple
	TabBarButtons which controls visibility of views. It can be used
	as a tab container.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar.domNode"/>
  <class type="dojox.mobile.TabBar.containerNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar.containerNode.style"/>
  <class type="dojox.mobile.TabBarButton" superclass="dojox.mobile._ItemBase">
    <description>TabBarButton is a button that is placed in the TabBar widget. It
	is a subclass of dojox.mobile._ItemBase just like ListItem or
	IconItem. So, unlike Button, it has similar capability as
	ListItem or IconItem, such as icon support, transition, etc.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="select" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="inheritParams" scope="instance"/>
      <method name="deselect" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setIconPos2Attr" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setIconPos1Attr" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setIcon2Attr" scope="instance">
        <parameters>
          <parameter name="icon" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setIcon1Attr" scope="instance">
        <parameters>
          <parameter name="icon" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setIcon" scope="instance">
        <parameters>
          <parameter name="icon" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="num" type="Object" usage="required"/>
          <parameter name="sel" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ItemBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="box" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.srcNodeRef.childNodes"/>
  <class type="dojox.mobile.TabBarButton.srcNodeRef">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.box"/>
  <class type="dojox.mobile.TabBarButton.domNode.parentNode"/>
  <class type="dojox.mobile.TabBarButton.iconNode1.style"/>
  <class type="dojox.mobile.TabBarButton.iconNode2.style"/>
  <class type="dojox.mobile.ToolBarButton" superclass="dojox.mobile._ItemBase">
    <description>ToolBarButton is a button that is placed in the Heading
	widget. It is a subclass of dojox.mobile._ItemBase just like
	ListItem or IconItem. So, unlike Button, it has basically the
	same capability as ListItem or IconItem, such as icon support,
	transition, etc.</description>
    <methods>
      <method name="select" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setBtnClassAttr" scope="instance">
        <parameters>
          <parameter name="btnClass" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ItemBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ToolBarButton.domNode"/>
  <class type="dojox.mobile.TransitionEvent">
    <methods>
      <method name="endTransition" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatch" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="transitionOptions" type="Object" usage="required"/>
          <parameter name="triggerEvent" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.mobile.View.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.View.domNode.parentNode"/>
  <class type="dojox.mobile.View.domNode.style"/>
  <class type="dojox.mobile.View.containerNode.style"/>
  <class type="dojox.mobile.ViewController">
    <description>This class listens to the "startTransition" events and performs
	view transitions. If the transition destination is an external
	view specified with the url parameter, retrieves the view
	content and parses it to create a new target view.</description>
    <methods>
      <method name="onStartTransition" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findCurrentView" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="src" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="TODO:1.8 may not return an expected result especially when views are nested"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_parse" scope="instance">
        <description>If the content is html fragment, constructs dom tree with it
	and runs the parser. If the content is json data, passes it
	to _instantiate().</description>
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_instantiate" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="parent" type="Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.mobile._ComboBoxMenu" superclass="dijit._WidgetBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="instance"/>
      <method name="onDeselect" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance"/>
      <method name="destroyRendering" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_createMenuItem" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ListTouchMixin.prototype" scope="instance"/>
      <mixin type="dijit.form._ComboBoxMenuMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
      <mixin type="dojox.mobile._ListTouchMixin" scope="instance"/>
      <mixin type="dijit.form._ComboBoxMenuMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="scrollable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile._ComboBoxMenu.scrollable">
    <methods>
      <method name="resize" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mobile._ListTouchMixin" superclass="dijit.form._ListBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._ListBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile._ScrollableMixin.scrollableParams"/>
  <class type="dojox.mobile._ScrollableMixin.domNode.parentNode.childNodes"/>
  <class type="dojox.mobile.Switch._changeState.left.style"/>
  <class type="dojox.mobile.Switch._changeState.right.style"/>
  <class type="dojox.mobile.Switch._changeState.inner.style"/>
  <class type="dojox.mobile.RoundRect.buildRendering.domNode"/>
  <class type="dojox.mobile.RoundRectList.buildRendering.domNode"/>
  <class type="dojox.mobile.EdgeToEdgeList.buildRendering.domNode"/>
  <class type="dojox.mobile.app">
    <methods>
      <method name="resolveTemplate" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resolveAssistant" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadResourcesForScene" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadResources" scope="instance">
        <parameters>
          <parameter name="resources" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStageController" scope="instance"/>
      <method name="getActiveSceneController" scope="instance"/>
      <method name="connectFlick" scope="instance">
        <parameters>
          <parameter name="target" type="Node" usage="required">
            <description>The DOM node to connect to</description>
          </parameter>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Widget" scope="instance"/>
      <method name="_FormWidget" scope="instance">
        <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._WidgetBase.attr`.
	
	They also share some common methods.</description>
      </method>
      <method name="_FormValueWidget" scope="instance">
        <description>Each _FormValueWidget represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
      </method>
      <method name="StageController" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="SceneController" scope="instance"/>
      <method name="SceneAssistant" scope="instance"/>
      <method name="ListSelector" scope="instance"/>
      <method name="List" scope="instance"/>
      <method name="ImageView" scope="instance"/>
      <method name="ImageThumbView" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="AlertDialog" scope="instance"/>
    </methods>
    <properties>
      <property name="eventMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.AlertDialog" superclass="dijit._WidgetBase">
    <methods>
      <method name="show" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onChoose" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_doTransition" scope="instance">
        <parameters>
          <parameter name="dir" type="An" usage="required">
            <description>integer.  If positive, the dialog is shown. If negative,
	the dialog is hidden.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.app.ImageThumbView" superclass="dijit._WidgetBase">
    <methods>
      <method name="setContainerHeight" scope="instance">
        <parameters>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hideCached" scope="instance"/>
      <method name="handleImgLoad" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calcPadding" scope="instance"/>
      <method name="addThumb" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItemsAttr" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setAnimationEnabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemNodeFromEvent" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="_thumbSize" scope="instance" type="Object"/>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageThumbView._thumbSize"/>
  <class type="dojox.mobile.app.ImageThumbView._size"/>
  <class type="dojox.mobile.app.ImageView" superclass="dojox.mobile.app._Widget">
    <methods>
      <method name="zoomTo" scope="instance">
        <parameters>
          <parameter name="centerX" type="Object" usage="required"/>
          <parameter name="centerY" type="Object" usage="required"/>
          <parameter name="zoom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>The position of the image that has loaded, either
	&amp;quot;center&amp;quot;, &amp;quot;left&amp;quot; or &amp;quot;right&amp;quot;</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>The src of the image</description>
          </parameter>
          <parameter name="isSmall" type="Boolean" usage="required">
            <description>True if it is a small version of the image that has loaded,
	false otherwise.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="direction" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveTo" scope="instance">
        <parameters>
          <parameter name="direction" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isAnimating" scope="instance"/>
      <method name="handleFlick" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleDragEnd" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_switchImage" scope="instance">
        <parameters>
          <parameter name="toImg" type="Object" usage="required"/>
          <parameter name="fromImg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomCenterYAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomCenterXAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomCenterAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomAttr" scope="instance">
        <parameters>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRightUrlAttr" scope="instance">
        <parameters>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setLeftUrlAttr" scope="instance">
        <parameters>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setCenterUrlAttr" scope="instance">
        <parameters>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setAnimatedZoomAttr" scope="instance">
        <parameters>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderImg" scope="instance">
        <parameters>
          <parameter name="smallImg" type="Object" usage="required"/>
          <parameter name="largeImg" type="Object" usage="required"/>
          <parameter name="panDir" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_animPanTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="easing" type="Object" usage="required"/>
          <parameter name="duration" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvas" scope="instance" type="Object"/>
      <property name="_centerSmallImg" scope="instance" type="Object"/>
      <property name="_centerImg" scope="instance" type="Node">
        <description>The small sized image in the center</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView.canvas"/>
  <class type="dojox.mobile.app.ImageView._centerImg"/>
  <class type="dojox.mobile.app.ImageView._centerSmallImg"/>
  <class type="dojox.mobile.app.List" superclass="dijit._WidgetBase">
    <methods>
      <method name="render" scope="instance"/>
      <method name="preDelete" scope="instance">
        <parameters>
          <parameter name="currentLeftPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="data" type="The" usage="required">
            <description>data related to the row being deleted</description>
          </parameter>
          <parameter name="index" type="The" usage="required">
            <description>index of the data in the total array</description>
          </parameter>
          <parameter name="array" type="The" usage="required">
            <description>array of data used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleDragCancel" scope="instance"/>
      <method name="handleDrag" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dividerFunction" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="deleteRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createDeleteButtons" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="The" usage="required">
            <description>DOM node of the row about to be deleted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="cancelDelete" scope="instance"/>
      <method name="applyTemplate" scope="instance">
        <parameters>
          <parameter name="template" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyClass" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="array" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItemsAttr" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFormattersAttr" scope="instance">
        <parameters>
          <parameter name="formatters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDataInfo" scope="instance">
        <parameters>
          <parameter name="rowNode" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderRange" scope="instance">
        <parameters>
          <parameter name="startIdx" type="Object" usage="required"/>
          <parameter name="endIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadTemplate" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="thisAttr" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleButtonClick" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowNode" scope="instance">
        <parameters>
          <parameter name="fromNode" type="Object" usage="required"/>
          <parameter name="ignoreNoClick" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_deselectRow" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="_selectedRow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.List._selectedRow.style"/>
  <class type="dojox.mobile.app.List.deleteRow">
    <methods/>
  </class>
  <class type="dojox.mobile.app.List._selectedRow">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ListSelector" superclass="dojox.mobile.app._Widget">
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onChoose" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setDataAttr" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.app.SceneAssistant">
    <methods>
      <method name="setup" scope="instance"/>
      <method name="disconnect" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="deactivate" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="activate" scope="instance">
        <parameters>
          <parameter name="params" type="Optional" usage="required">
            <description>paramters, only passed when a subsequent scene pops itself
	off the stack and passes back data.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.mobile.app.SceneController" superclass="dojox.mobile.View">
    <methods>
      <method name="showAlertDialog" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="selector" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popupSubMenu" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWindowSize" scope="instance"/>
      <method name="_setContents" scope="instance">
        <parameters>
          <parameter name="templateHtml" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initAssistant" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.View" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="assistant" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.SceneController.domNode"/>
  <class type="dojox.mobile.app.SceneController.assistant"/>
  <class type="dojox.mobile.app.StageController">
    <methods>
      <method name="setZIndex" scope="instance">
        <parameters>
          <parameter name="controller" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pushScene" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popScenesTo" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popScene" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getActiveSceneController" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyScene" scope="instance">
        <parameters>
          <parameter name="scene" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.mobile.app._FormWidget" superclass="dijit._WidgetBase">
    <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._WidgetBase.attr`.
	
	They also share some common methods.</description>
    <methods>
      <method name="selectInputText" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="anything" usage="required"/>
          <parameter name="val2" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required">
            <description>the new value</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <description>For a slider, for example, dragging the slider is priorityChange==false,
	but on mouse up, it's priorityChange==true.  If intermediateChanges==true,
	onChange is only called form priorityChange=true events.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.app._FormValueWidget" superclass="dojox.mobile.app._FormWidget">
    <description>Each _FormValueWidget represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
    <methods>
      <method name="undo" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._FormWidget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.app._Widget" superclass="dijit._WidgetBase">
    <methods>
      <method name="getScroll" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.app.eventMap"/>
  <class type="Mojo.Event"/>
  <class type="dojox.mobile.app.ImageView.buildRendering.domNode"/>
  <class type="dojox.mobile.detectScreenSize">
    <methods/>
  </class>
  <class type="registry">
    <methods>
      <method name="getEnclosingWidget" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.mobile.i18n">
    <methods>
      <method name="registerBundle" scope="instance">
        <parameters>
          <parameter name="bundle" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.mvc">
    <methods>
      <method name="newStatefulModel" scope="instance">
        <description>Factory method that returns a client-side data model, which is a
	tree of dojo.Stateful objects matching the initial data structure
	passed as input:
	- The mixin property "data" is used to provide a plain JavaScript
	object directly representing the data structure.
	- The mixin property "store", along with an optional mixin property
	"query", is used to provide a data store to query to obtain the
	initial data.
	This function returns an immediate dojox.mvc.StatefulModel instance or
	a Promise for such an instance as follows:
	- if args.data: returns immediate
	- if args.store:
	- if store returns immediate: this function returns immediate
	- if store returns a Promise: this function returns a model
	Promise</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>The mixin properties.</description>
          </parameter>
        </parameters>
      </method>
      <method name="bindInputs" scope="instance">
        <parameters>
          <parameter name="sourceBindArray" type="Array&lt;dojo.Stateful&gt;" usage="required">
            <description>The array of dojo.Stateful objects to watch values changes on.</description>
          </parameter>
          <parameter name="func" type="Function" usage="required">
            <description>The composing function that is called when any of the source
	values changes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="bind" scope="instance">
        <parameters>
          <parameter name="source" type="dojo.Stateful" usage="required">
            <description>The source dojo.Stateful object for the bind.</description>
          </parameter>
          <parameter name="sourceProp" type="String" usage="required">
            <description>The name of the source's property whose change triggers the bind.</description>
          </parameter>
          <parameter name="target" type="dojo.Stateful" usage="required">
            <description>The target dojo.Stateful object for the bind whose
	property will be updated with the result of the function.</description>
          </parameter>
          <parameter name="targetProp" type="String" usage="required">
            <description>The name of the target's property to be updated with the
	result of the function.</description>
          </parameter>
          <parameter name="func" type="Function" usage="optional">
            <description>The optional calculation to be performed to obtain the target
	property value.</description>
          </parameter>
          <parameter name="bindOnlyIfUnequal" type="Boolean" usage="optional">
            <description>Whether the bind notification should happen only if the old and
	new values are unequal (optional, defaults to false).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_DataBindingMixin" scope="instance">
        <description>Data binding awareness enables dijits or other view layer
	components to bind to locations within a client-side data model,
	which is commonly an instance of the dojox.mvc.StatefulModel class. A
	bind is a bi-directional update mechanism which is capable of
	synchronizing value changes between the bound dijit or other view
	component and the specified location within the data model, as well
	as changes to other properties such as "valid", "required",
	"readOnly" etc.
	
	The data binding is commonly specified declaratively via the "ref"
	property in the "data-dojo-props" attribute value.
	
	Consider the following simple example:
	
		&lt;script&gt;
			var model;
			require(["dijit/StatefulModel", "dojo/parser"], function(StatefulModel, parser){
				model = new StatefulModel({ data : {
					hello : "Hello World"
				}});
				parser.parse();
			});
		&lt;/script&gt;
	
		&lt;input id="hello1" data-dojo-type="dijit.form.TextBox"
			data-dojo-props="ref: model.hello"&gt;&lt;/input&gt;
	
		&lt;input id="hello2" data-dojo-type="dijit.form.TextBox"
			data-dojo-props="ref: model.hello"&gt;&lt;/input&gt;
	
	In the above example, both dijit.form.TextBox instances (with IDs
	"hello1" and "hello2" respectively) are bound to the same reference
	location in the data model i.e. "hello" via the "ref" expression
	"model.hello". Both will have an initial value of "Hello World".
	Thereafter, a change in the value of either of the two textboxes
	will cause an update of the value in the data model at location
	"hello" which will in turn cause a matching update of the value in
	the other textbox.</description>
      </method>
      <method name="_Container" scope="instance"/>
      <method name="StatefulModel" scope="instance">
        <description>A data model is effectively instantiated with a plain JavaScript
	object which specifies the initial data structure for the model.
	
		var struct = {
			order	: "abc123",
			shipto	: {
				address	: "123 Example St, New York, NY",
				phone	: "212-000-0000"
			},
			items : [
				{ part : "x12345", num : 1 },
				{ part : "n09876", num : 3 }
			]
		};
	
		var model = dojox.mvc.newStatefulModel({ data : struct });
	
	The simple example above shows an inline plain JavaScript object
	illustrating the data structure to prime the model with, however
	the underlying data may be made available by other means, such as
	from the results of a dojo.store or dojo.data query.
	
	To deal with stores providing immediate values or Promises, a
	factory method for model instantiation is provided. This method
	will either return an immediate model or a model Promise depending
	on the nature of the store.
	
		var model = dojox.mvc.newStatefulModel({ store: someStore });
	
	The created data model has the following properties:
	
	- It enables dijits or custom components in the view to "bind" to
	data within the model. A bind creates a bi-directional update
	mechanism between the bound view and the underlying data:
	- The data model is "live" data i.e. it maintains any updates
	driven by the view on the underlying data.
	- The data model issues updates to portions of the view if the
	data they bind to is updated in the model. For example, if two
	dijits are bound to the same part of a data model, updating the
	value of one in the view will cause the data model to issue an
	update to the other containing the new value.
	
	- The data model internally creates a tree of dojo.Stateful
	objects that matches the input, which is effectively a plain
	JavaScript object i.e. "pure data". This tree allows dijits or
	other view components to bind to any node within the data model.
	Typically, dijits with simple values bind to leaf nodes of the
	datamodel, whereas containers bind to internal nodes of the
	datamodel. For example, a datamodel created using the object below
	will generate the dojo.Stateful tree as shown:
	
		var model = dojox.mvc.newStatefulModel({ data : {
			prop1	: "foo",
			prop2	: {
				leaf1	: "bar",
				leaf2	: "baz"
			}
		}});
	
		// The created dojo.Stateful tree is illustrated below (all nodes are dojo.Stateful objects)
		//
		//	                o  (root node)
		//	               / \
		//	 (prop1 node) o   o (prop2 node)
		//	                 / \
		//	   (leaf1 node)	o   o (leaf2 node)
		//
		// The root node is accessed using the expression "model" (the var name above). The prop1
		// node is accessed using the expression "model.prop1", the leaf2 node is accessed using
		// the expression "model.prop2.leaf2" and so on.
	
	- Each of the dojo.Stateful nodes in the model may store data as well
	as associated "meta-data", which includes things such as whether
	the data is required or readOnly etc. This meta-data differs from
	that maintained by, for example, an individual dijit in that this
	is maintained by the datamodel and may therefore be affected by
	datamodel-level constraints that span multiple dijits or even
	additional criteria such as server-side computations.
	
	- When the model is backed by a dojo.store or dojo.data query, the
	client-side updates can be persisted once the client is ready to
	"submit" the changes (which may include both value changes or
	structural changes - adds/deletes). The datamodel allows control
	over when the underlying data is persisted i.e. this can be more
	incremental or batched per application needs.
	
	There need not be a one-to-one association between a datamodel and
	a view or portion thereof. For example, multiple datamodels may
	back the dijits in a view. Indeed, this may be useful where the
	binding data comes from a number of data sources or queries, for
	example. Just as well, dijits from multiple portions of the view
	may be bound to a single datamodel.
	
	Finally, requiring this class also enables all dijits to become data
	binding aware. The data binding is commonly specified declaratively
	via the "ref" property in the "data-dojo-props" attribute value.
	
	To illustrate, the following is the "Hello World" of such data-bound
	widget examples:
	
		&lt;script&gt;
			dojo.require("dojox.mvc");
			dojo.require("dojo.parser");
			var model;
			dojo.addOnLoad(function(){
				model = dojox.mvc.newStatefulModel({ data : {
					hello : "Hello World"
				}});
				dojo.parser.parse();
			}
		&lt;/script&gt;
	
		&lt;input id="helloInput" dojoType="dijit.form.TextBox"
			ref="model.hello"&gt;
	
	or
	
		&lt;script&gt;
			var model;
			require(["dojox/mvc", "dojo/parser"], function(dxmvc, parser){
				model = dojox.mvc.newStatefulModel({ data : {
					hello : "Hello World"
				}});
				parser.parse();
			});
		&lt;/script&gt;
	
		&lt;input id="helloInput" data-dojo-type="dijit.form.TextBox"
			data-dojo-props="ref: 'model.hello'"&gt;
	
	Such data binding awareness for dijits is added by extending the
	dijit._WidgetBase class to include data binding capabilities
	provided by dojox.mvc._DataBindingMixin, and this class declares a
	dependency on dojox.mvc._DataBindingMixin.
	
	The presence of a data model and the data-binding capabilities
	outlined above support the flexible development of a number of MVC
	patterns on the client. As an example, CRUD operations can be
	supported with minimal application code.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>The mixin properties.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Repeat" scope="instance">
        <description>A repeat is bound to an intermediate dojo.Stateful node corresponding
	to an array in the data model. Child dijits or custom view components
	inside it inherit their parent data binding context from it.</description>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="srcNodeRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Output" scope="instance">
        <description>Simple output example:
	
		&lt;span dojoType="dojox.mvc.Output" ref="model.balance"&gt;
			Your balance is: ${this.value}
		&lt;/span&gt;
	
	The output widget being data-bound, if the balance changes in the
	dojox.mvc.StatefulModel, the content within the &lt;span&gt; will be
	updated accordingly.</description>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="srcNodeRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Group" scope="instance">
        <description>A group is usually bound to an intermediate dojo.Stateful node in the data model.
	Child dijits or custom view components inside a group inherit their parent
	data binding context from it.</description>
      </method>
      <method name="Generate" scope="instance">
        <description>A generate introspects its data binding and creates a view contained in
	it that allows displaying the bound data. Child dijits or custom view
	components inside it inherit their parent data binding context from it.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.mvc.Generate" superclass="dojox.mvc._Container">
    <description>A generate introspects its data binding and creates a view contained in
	it that allows displaying the bound data. Child dijits or custom view
	components inside it inherit their parent data binding context from it.</description>
    <methods>
      <method name="_updateBinding" scope="instance"/>
      <method name="_generateTextBox" scope="instance">
        <parameters>
          <parameter name="prop" type="The" usage="required">
            <description>data model property name.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_generateRepeat" scope="instance">
        <parameters>
          <parameter name="binding" type="The" usage="required">
            <description>bound node (a collection/array node) to generate a
	repeating UI/view for.</description>
          </parameter>
          <parameter name="repeatHeading" type="The" usage="required">
            <description>heading to be used for this portion.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_generateGroup" scope="instance">
        <parameters>
          <parameter name="binding" type="The" usage="required">
            <description>bound (intermediate) node to generate a hierarchical
	view portion for.</description>
          </parameter>
          <parameter name="groupHeading" type="The" usage="required">
            <description>heading to be used for this portion.</description>
          </parameter>
          <parameter name="hideHeading" type="Whether" usage="required">
            <description>the heading should be hidden for this portion.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_generateBody" scope="instance">
        <parameters>
          <parameter name="binding" type="The" usage="required">
            <description>associated data binding to generate a view for.</description>
          </parameter>
          <parameter name="hideHeading" type="Whether" usage="required">
            <description>the property name should be displayed as a heading.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_buildContained" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mvc._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="_defaultWidgetMapping" scope="instance" type="Object"/>
      <property name="_defaultIdNameMapping" scope="instance" type="Object"/>
      <property name="_defaultClassMapping" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mvc.Generate._defaultWidgetMapping"/>
  <class type="dojox.mvc.Generate._defaultClassMapping"/>
  <class type="dojox.mvc.Generate._defaultIdNameMapping"/>
  <class type="dojox.mvc.Generate.srcNodeRef"/>
  <class type="dojox.mvc._Container" superclass="dijit._WidgetBase">
    <methods>
      <method name="_exprRepl" scope="instance">
        <parameters>
          <parameter name="tmpl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyBody" scope="instance"/>
      <method name="_createBody" scope="instance">
        <description>The bodies of MVC containers may be model-bound views generated dynamically.
	Parse the body, start an contained widgets and attach template nodes for
	contained widgets as necessary.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mvc.Group" superclass="dijit._WidgetBase">
    <description>A group is usually bound to an intermediate dojo.Stateful node in the data model.
	Child dijits or custom view components inside a group inherit their parent
	data binding context from it.</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mvc.Output" superclass="dijit._WidgetBase">
    <description>Simple output example:
	
		&lt;span dojoType="dojox.mvc.Output" ref="model.balance"&gt;
			Your balance is: ${this.value}
		&lt;/span&gt;
	
	The output widget being data-bound, if the balance changes in the
	dojox.mvc.StatefulModel, the content within the &lt;span&gt; will be
	updated accordingly.</description>
    <methods>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateBinding" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="old" type="Object" usage="required"/>
          <parameter name="current" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_output" scope="instance"/>
      <method name="_exprRepl" scope="instance">
        <parameters>
          <parameter name="tmpl" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="srcNodeRef" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mvc.Output.srcNodeRef"/>
  <class type="dojox.mvc.Repeat" superclass="dojox.mvc._Container">
    <description>A repeat is bound to an intermediate dojo.Stateful node corresponding
	to an array in the data model. Child dijits or custom view components
	inside it inherit their parent data binding context from it.</description>
    <methods>
      <method name="_updateBinding" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="old" type="Object" usage="required"/>
          <parameter name="current" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateAddRemoveWatch" scope="instance"/>
      <method name="_buildContained" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mvc._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="srcNodeRef" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mvc.Repeat.srcNodeRef"/>
  <class type="dojox.mvc.StatefulModel" superclass="dojo.Stateful">
    <description>A data model is effectively instantiated with a plain JavaScript
	object which specifies the initial data structure for the model.
	
		var struct = {
			order	: "abc123",
			shipto	: {
				address	: "123 Example St, New York, NY",
				phone	: "212-000-0000"
			},
			items : [
				{ part : "x12345", num : 1 },
				{ part : "n09876", num : 3 }
			]
		};
	
		var model = dojox.mvc.newStatefulModel({ data : struct });
	
	The simple example above shows an inline plain JavaScript object
	illustrating the data structure to prime the model with, however
	the underlying data may be made available by other means, such as
	from the results of a dojo.store or dojo.data query.
	
	To deal with stores providing immediate values or Promises, a
	factory method for model instantiation is provided. This method
	will either return an immediate model or a model Promise depending
	on the nature of the store.
	
		var model = dojox.mvc.newStatefulModel({ store: someStore });
	
	The created data model has the following properties:
	
	- It enables dijits or custom components in the view to "bind" to
	data within the model. A bind creates a bi-directional update
	mechanism between the bound view and the underlying data:
	- The data model is "live" data i.e. it maintains any updates
	driven by the view on the underlying data.
	- The data model issues updates to portions of the view if the
	data they bind to is updated in the model. For example, if two
	dijits are bound to the same part of a data model, updating the
	value of one in the view will cause the data model to issue an
	update to the other containing the new value.
	
	- The data model internally creates a tree of dojo.Stateful
	objects that matches the input, which is effectively a plain
	JavaScript object i.e. "pure data". This tree allows dijits or
	other view components to bind to any node within the data model.
	Typically, dijits with simple values bind to leaf nodes of the
	datamodel, whereas containers bind to internal nodes of the
	datamodel. For example, a datamodel created using the object below
	will generate the dojo.Stateful tree as shown:
	
		var model = dojox.mvc.newStatefulModel({ data : {
			prop1	: "foo",
			prop2	: {
				leaf1	: "bar",
				leaf2	: "baz"
			}
		}});
	
		// The created dojo.Stateful tree is illustrated below (all nodes are dojo.Stateful objects)
		//
		//	                o  (root node)
		//	               / \
		//	 (prop1 node) o   o (prop2 node)
		//	                 / \
		//	   (leaf1 node)	o   o (leaf2 node)
		//
		// The root node is accessed using the expression "model" (the var name above). The prop1
		// node is accessed using the expression "model.prop1", the leaf2 node is accessed using
		// the expression "model.prop2.leaf2" and so on.
	
	- Each of the dojo.Stateful nodes in the model may store data as well
	as associated "meta-data", which includes things such as whether
	the data is required or readOnly etc. This meta-data differs from
	that maintained by, for example, an individual dijit in that this
	is maintained by the datamodel and may therefore be affected by
	datamodel-level constraints that span multiple dijits or even
	additional criteria such as server-side computations.
	
	- When the model is backed by a dojo.store or dojo.data query, the
	client-side updates can be persisted once the client is ready to
	"submit" the changes (which may include both value changes or
	structural changes - adds/deletes). The datamodel allows control
	over when the underlying data is persisted i.e. this can be more
	incremental or batched per application needs.
	
	There need not be a one-to-one association between a datamodel and
	a view or portion thereof. For example, multiple datamodels may
	back the dijits in a view. Indeed, this may be useful where the
	binding data comes from a number of data sources or queries, for
	example. Just as well, dijits from multiple portions of the view
	may be bound to a single datamodel.
	
	Finally, requiring this class also enables all dijits to become data
	binding aware. The data binding is commonly specified declaratively
	via the "ref" property in the "data-dojo-props" attribute value.
	
	To illustrate, the following is the "Hello World" of such data-bound
	widget examples:
	
		&lt;script&gt;
			dojo.require("dojox.mvc");
			dojo.require("dojo.parser");
			var model;
			dojo.addOnLoad(function(){
				model = dojox.mvc.newStatefulModel({ data : {
					hello : "Hello World"
				}});
				dojo.parser.parse();
			}
		&lt;/script&gt;
	
		&lt;input id="helloInput" dojoType="dijit.form.TextBox"
			ref="model.hello"&gt;
	
	or
	
		&lt;script&gt;
			var model;
			require(["dojox/mvc", "dojo/parser"], function(dxmvc, parser){
				model = dojox.mvc.newStatefulModel({ data : {
					hello : "Hello World"
				}});
				parser.parse();
			});
		&lt;/script&gt;
	
		&lt;input id="helloInput" data-dojo-type="dijit.form.TextBox"
			data-dojo-props="ref: 'model.hello'"&gt;
	
	Such data binding awareness for dijits is added by extending the
	dijit._WidgetBase class to include data binding capabilities
	provided by dojox.mvc._DataBindingMixin, and this class declares a
	dependency on dojox.mvc._DataBindingMixin.
	
	The presence of a data model and the data-binding capabilities
	outlined above support the flexible development of a number of MVC
	patterns on the client. As an example, CRUD operations can be
	supported with minimal application code.</description>
    <methods>
      <method name="valueOf" scope="instance">
        <return-description>Object
	The object representation of the data in this model.</return-description>
      </method>
      <method name="toString" scope="instance">
        <return-description>String
	The object representation of the data in this model.</return-description>
      </method>
      <method name="toPlainObject" scope="instance">
        <return-description>Object
	The plain JavaScript object representation of the data in this
	model.</return-description>
      </method>
      <method name="reset" scope="instance"/>
      <method name="remove" scope="instance">
        <description>In case of arrays, the property names are indices passed
	as Strings. A removal of such a dojo.Stateful node
	results in left-shifting any trailing sibling nodes.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The property name from where the tree will be removed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <description>Creates a tree of dojo.Stateful objects matching the initial
	data structure passed as input. The mixin property "data" is
	used to provide a plain JavaScript object directly representing
	the data structure.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>The mixin properties.</description>
          </parameter>
        </parameters>
      </method>
      <method name="commit" scope="instance">
        <parameters>
          <parameter name="store" type="&quot;dojo.store.DataStore" usage="optional">
            <description>dojo.store.DataStore Optional dojo.store.DataStore to use for this commit, if none
	provided but one was provided at instantiation time, that store
	will be used instead.</description>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <description>In case of arrays, the property names are indices passed
	as Strings. An addition of such a dojo.Stateful node
	results in right-shifting any trailing sibling nodes.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The property name to use whose value will become the given
	dijit.Stateful tree.</description>
          </parameter>
          <parameter name="stateful" type="dojo.Stateful" usage="required">
            <description>The dojox.mvc.StatefulModel to insert.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_saveToStore" scope="instance">
        <parameters>
          <parameter name="store" type="&quot;dojo.store.DataStore" usage="required">
            <description>dojo.store.DataStore to use for this commit.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createModel" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>The input for the model, as a plain JavaScript object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_copyStatefulProperties" scope="instance">
        <parameters>
          <parameter name="src" type="dojo.Stateful" usage="required">
            <description>The source object for the copy.</description>
          </parameter>
          <parameter name="dest" type="dojo.Stateful" usage="required">
            <description>The target object of the copy.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_commit" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.Stateful" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mvc._DataBindingMixin">
    <description>Data binding awareness enables dijits or other view layer
	components to bind to locations within a client-side data model,
	which is commonly an instance of the dojox.mvc.StatefulModel class. A
	bind is a bi-directional update mechanism which is capable of
	synchronizing value changes between the bound dijit or other view
	component and the specified location within the data model, as well
	as changes to other properties such as "valid", "required",
	"readOnly" etc.
	
	The data binding is commonly specified declaratively via the "ref"
	property in the "data-dojo-props" attribute value.
	
	Consider the following simple example:
	
		&lt;script&gt;
			var model;
			require(["dijit/StatefulModel", "dojo/parser"], function(StatefulModel, parser){
				model = new StatefulModel({ data : {
					hello : "Hello World"
				}});
				parser.parse();
			});
		&lt;/script&gt;
	
		&lt;input id="hello1" data-dojo-type="dijit.form.TextBox"
			data-dojo-props="ref: model.hello"&gt;&lt;/input&gt;
	
		&lt;input id="hello2" data-dojo-type="dijit.form.TextBox"
			data-dojo-props="ref: model.hello"&gt;&lt;/input&gt;
	
	In the above example, both dijit.form.TextBox instances (with IDs
	"hello1" and "hello2" respectively) are bound to the same reference
	location in the data model i.e. "hello" via the "ref" expression
	"model.hello". Both will have an initial value of "Hello World".
	Thereafter, a change in the value of either of the two textboxes
	will cause an update of the value in the data model at location
	"hello" which will in turn cause a matching update of the value in
	the other textbox.</description>
    <methods>
      <method name="isValid" scope="instance">
        <description>This function is meant to provide an API bridge to the dijit API.
	Validity of data-bound dijits is a function of multiple concerns:
	- The validity of the value as ascertained by the data binding
	and constraints specified in the data model (usually semantic).
	- The validity of the value as ascertained by the widget itself
	based on widget constraints (usually syntactic).
	In order for dijits to function correctly in data-bound
	environments, it is imperative that their isValid() functions
	assess the model validity of the data binding via the
	this.inherited(arguments) hierarchy and declare any values
	failing the test as invalid.</description>
        <return-description>Boolean
	The validity associated with the data binding.</return-description>
      </method>
      <method name="_updateProperty" scope="instance">
        <parameters>
          <parameter name="name" type="The" usage="required">
            <description>binding property name.</description>
          </parameter>
          <parameter name="old" type="The" usage="required">
            <description>old value of the binding property.</description>
          </parameter>
          <parameter name="current" type="The" usage="required">
            <description>new or current value of the binding property.</description>
          </parameter>
          <parameter name="defaultValue" type="The" usage="required">
            <description>optional value to be applied as the current value of the
	binding property if the current value is null.</description>
          </parameter>
          <parameter name="setPropName" type="The" usage="required">
            <description>optional name of a stateful property to set on the bound
	widget.</description>
          </parameter>
          <parameter name="setPropValue" type="The" usage="required">
            <description>value, if an optional name is provided, for the stateful
	property of the bound widget.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateChildBindings" scope="instance">
        <parameters>
          <parameter name="parentBind" type="The" usage="required">
            <description>binding on the parent of a widget whose children may have bindings
	which need to be updated.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateBinding" scope="instance">
        <description>Applies the specified data binding to the attached widget.
	Loses any prior watch registrations on the previously active
	bind, registers the new one, updates data binds of any contained
	widgets and also refreshes all associated properties (valid,
	required etc.)</description>
        <parameters>
          <parameter name="name" type="The" usage="required">
            <description>name of the binding property (always &amp;quot;binding&amp;quot;).</description>
          </parameter>
          <parameter name="old" type="The" usage="required">
            <description>old dojo.Stateful binding node of the data model.</description>
          </parameter>
          <parameter name="current" type="The" usage="required">
            <description>new dojo.Stateful binding node of the data model.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_unwatchArray" scope="instance">
        <parameters>
          <parameter name="watchHandles" type="The" usage="required">
            <description>array of watch handles.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setupBinding" scope="instance">
        <description>The declarative data binding reference may be specified in two
	ways via markup:
	- For older style documents (non validating), controls may use
	the "ref" attribute to specify the data binding reference
	(String).
	- For validating documents using the new Dojo parser, controls
	may specify the data binding reference (String) as the "ref"
	property specified in the data-dojo-props attribute.
	Once the ref value is obtained using either of the above means,
	the binding is set up for this control and its required, readOnly
	etc. properties are refreshed.
	The data binding may be specified as a direct reference to the
	dojo.Stateful model node or as a string relative to its DOM
	parent or another widget.
	There are three ways in which the data binding node reference is
	calculated when specified as a string:
	- If an explicit parent widget is specified, the binding is
	calculated relative to the parent widget's data binding.
	- For any dijits that specify a data binding reference,
	we walk up their DOM hierarchy to obtain the first container
	dijit that has a data binding set up and use the reference String
	as a property name relative to the parent's data binding context.
	- If no such parent is found i.e. for the outermost container
	dijits that specify a data binding reference, the binding is
	calculated by treating the reference String as an expression and
	evaluating it to obtain the dojo.Stateful node in the datamodel.
	This method throws an Error in these two conditions:
	- The ref is an expression i.e. outermost bound dijit, but the
	expression evaluation fails.
	- The calculated binding turns out to not be an instance of a
	dojo.Stateful node.</description>
        <parameters>
          <parameter name="parentBinding" type="The" usage="required">
            <description>binding of this widget/view component's data-bound parent,
	if available.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="nothing to do here"/>
        </return-types>
      </method>
      <method name="_isEqual" scope="instance">
        <parameters>
          <parameter name="one" type="Object" usage="required"/>
          <parameter name="other" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getParentBindingFromDOM" scope="instance">
        <return-description>The parent binding, if one exists along the DOM parent axis.</return-description>
      </method>
      <method name="_dbstartup" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.rails">
    <methods>
      <method name="live" scope="instance">
        <parameters>
          <parameter name="selector" type="Object" usage="required"/>
          <parameter name="evtName" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.validate">
    <methods>
      <method name="isValidLuhn" scope="instance">
        <description>Validate a String value against the Luhn algorithm to verify
	its integrity.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidIsbn" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>An ISBN to validate</description>
          </parameter>
        </parameters>
        <return-description>Boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidCvv" scope="instance">
        <parameters>
          <parameter name="value" type="String|Int" usage="required"/>
          <parameter name="ccType" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidCreditCardNumber" scope="instance">
        <parameters>
          <parameter name="value" type="String|Int" usage="required">
            <description>CC #, white spaces and dashes are ignored</description>
          </parameter>
          <parameter name="ccType" type="String" usage="optional">
            <description>One of the abbreviation values in `dojox.validate._cardInfo` --
	if Omitted, function returns a `|` delimited string of matching card types,
	or false if no matches found.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isValidCreditCard" scope="instance">
        <description>Checks if a credit card type matches the # scheme in a passed value, and if
	the Luhn checksum is accurate (unless its an Enroute card, in which case
	the checkSum is skipped), returning a Boolean to check against.</description>
        <examples>
          <example>	if(dojox.validate.isValidCreditCard("12345", "mc")){
			console.log('inconceivable');
		}</example>
        </examples>
        <parameters>
          <parameter name="value" type="String|Int" usage="required">
            <description>A Value (credit card number) to validate</description>
          </parameter>
          <parameter name="ccType" type="String" usage="required">
            <description>A credit-card abbreviation.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isUrl" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.scheme  Can be true, false, or [true, false].
	This means: required, not allowed, or either.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isText" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>length: Number, minlength: Number, maxlength: Number}
	flags.length  If set, checks if there are exactly flags.length number of characters.
	flags.minlength  If set, checks if there are at least flags.minlength number of characters.
	flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isNumberFormat" scope="instance">
        <description>Validates any sort of number based format. Use it for phone numbers,
	social security numbers, zip-codes, etc. The value can be validated
	against one format or one of multiple formats.
	
	Format Definition
		 #        Stands for a digit, 0-9.
		 ?        Stands for an optional digit, 0-9 or nothing.
	All other characters must appear literally in the expression.</description>
        <examples>
          <example>  "(###) ###-####"       -&gt;   (510) 542-9742
		"(###) ###-#### x#???" -&gt;   (510) 542-9742 x153
		"###-##-####"          -&gt;   506-82-1089       i.e. social security number
		"#####-####"           -&gt;   98225-1649        i.e. zip code</example>
          <example> // returns true:
	 dojox.validate.isNumberFormat("123-45", { format:"###-##" });</example>
          <example>Check Multiple formats:
		dojox.validate.isNumberFormat("123-45", {
			format:["### ##","###-##","## ###"]
		});</example>
        </examples>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>FIXME: make pseudo-object for this
	format: String
	
	flags.format  A string or an Array of strings for multiple formats.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isIpAddress" scope="instance">
        <description>Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	Supports 2 formats for Ipv6.
	
	value  A string.
	flags  An object.  All flags are boolean with default = true.
	flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	Case insensitive.  Zero padding allowed.
	flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isInRange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>max:Number, min:Number, decimal:String}
	flags.max  A number, which the value must be less than or equal to for the validation to be true.
	flags.min  A number, which the value must be greater than or equal to for the validation to be true.
	flags.decimal  The character used for the decimal point.  Default is &amp;quot;.&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isEmailAddress" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.allowCruft  Allow address like &amp;lt;mailto:foo@yahoo.com&amp;gt;.  Default is false.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getEmailAddressList" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object (same as dojo.validate.isEmailAddressList)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="evaluateConstraint" scope="instance">
        <description>The arrays are expected to be in the format of:
	constraints:{</description>
        <parameters>
          <parameter name="profile" type="The" usage="required">
            <description>dojo.validate.check() profile that this evaluation is against.</description>
          </parameter>
          <parameter name="constraint" type="Array" usage="required">
            <description>The single [] array of function and arguments for the function.</description>
          </parameter>
          <parameter name="fieldName" type="The" usage="required">
            <description>form dom name of the field being validated.</description>
          </parameter>
          <parameter name="elem" type="The" usage="required">
            <description>form element field.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="check" scope="instance">
        <description>returns an object that contains several methods summarizing the results of the validation</description>
        <parameters>
          <parameter name="form" type="HTMLFormElement" usage="required">
            <description>form to be validated</description>
          </parameter>
          <parameter name="profile" type="Object" usage="required">
            <description>specifies how the form fields are to be validated
	{trim:Array, uppercase:Array, lowercase:Array, ucfirst:Array, digit:Array,
	required:Array, dependencies:Object, constraints:Object, confirm:Object}</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="regexp" scope="instance" type="Object"/>
      <property name="_cardInfo" scope="instance" type="Object">
        <description>A dictionary list of credit card abbreviations</description>
      </property>
    </properties>
  </class>
  <class type="dojox.robot"/>
  <class type="dojox.rpc.Client"/>
  <class type="dojox.rpc.JsonRest">
    <methods>
      <method name="sendToServer" scope="instance">
        <parameters>
          <parameter name="actions" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerService" scope="instance">
        <parameters>
          <parameter name="service" type="Function" usage="required">
            <description>This is the service to register</description>
          </parameter>
          <parameter name="servicePath" type="String" usage="required">
            <description>This is the path that is used for all the ids for the objects returned by service</description>
          </parameter>
          <parameter name="schema" type="Object" usage="optional">
            <description>This is a JSON Schema object to associate with objects returned by this service</description>
          </parameter>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getServiceAndId" scope="instance">
        <parameters>
          <parameter name="absoluteId" type="String" usage="required">
            <description>This is the absolute id of the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="getIdAttribute" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDirtyObjects" scope="instance"/>
      <method name="getConstructor" scope="instance">
        <parameters>
          <parameter name="service" type="Function|String" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="absoluteId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteObject" scope="instance">
        <parameters>
          <parameter name="object" type="object" usage="required">
            <description>to delete</description>
          </parameter>
        </parameters>
      </method>
      <method name="commit" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changing" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loader" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.rpc.JsonRest.sendToServer">
    <methods/>
  </class>
  <class type="dojox.rpc.OfflineRest">
    <methods>
      <method name="turnOffAutoSync" scope="instance"/>
      <method name="downloadChanges" scope="instance"/>
      <method name="addStore" scope="instance">
        <parameters>
          <parameter name="store" type="data-store" usage="required">
            <description>Store to add</description>
          </parameter>
          <parameter name="baseQuery" type="query" usage="optional">
            <description>This is the base query to should be used to load the items for
	the store. Generally you want to load all the items that should be
	available when offline.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.rpc.Service">
    <description>dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
	dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
	a "No match found" error.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
	dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
	a "No match found" error.</description>
        <parameters>
          <parameter name="smd" type="object" usage="required">
            <description>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRequest" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_generateService" scope="instance">
        <parameters>
          <parameter name="serviceName" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_executeMethod" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.secure">
    <methods>
      <method name="unwrap" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sandbox" scope="instance">
        <description>This function will create and return a sandbox object (see dojox.secure.__Sandbox)
	for the provided element.</description>
        <parameters>
          <parameter name="element" type="The" usage="required">
            <description>DOM element to use as the container for the sandbox</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.secure.__Sandbox"/>
        </return-types>
      </method>
      <method name="_safeDojoFunctions" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
          <parameter name="wrap" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="wrap the NodeList"/>
        </return-types>
      </method>
      <method name="DOM" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="capability" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="wrap"/>
  <class type="dojox.secure.capability">
    <methods>
      <method name="validate" scope="instance">
        <parameters>
          <parameter name="script" type="string" usage="required">
            <description>the script to execute</description>
          </parameter>
          <parameter name="safeLibraries" type="Array" usage="required">
            <description>The safe libraries that can be called (the functions can not be access/modified by the untrusted code, only called)</description>
          </parameter>
          <parameter name="safeGlobals" type="Object" usage="required">
            <description>These globals can be freely interacted with by the untrusted code</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="comments are replaced with a space, strings and regex are replaced with a single safe token (0)"/>
          <return-type type="replace literal keys with 0: and replace properties with the innocuous ~"/>
          <return-type type="turn into a known safe call"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.secure.capability.validate">
    <methods/>
  </class>
  <class type="dojo.NodeList.addContent">
    <methods>
      <method name="safetyCheck" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.NodeList.style">
    <methods>
      <method name="safetyCheck" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.NodeList.attr">
    <methods>
      <method name="safetyCheck" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sketch">
    <methods>
      <method name="registerTool" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeToolbar" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="figure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_Plugin" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="UndoStack" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="UnderlineAnnotationTool" scope="instance"/>
      <method name="UnderlineAnnotation" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Toolbar" scope="instance"/>
      <method name="Slider" scope="instance"/>
      <method name="SingleArrowAnnotation" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="PreexistingAnnotation" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="LeadAnnotation" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Figure" scope="instance">
        <parameters>
          <parameter name="mixin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DoubleArrowAnnotation" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ButtonGroup" scope="instance"/>
      <method name="AnnotationTool" scope="instance"/>
      <method name="Annotation" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Anchor" scope="instance">
        <parameters>
          <parameter name="an" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="isControl" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="CommandTypes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Anchor">
    <methods>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="instance"/>
      <method name="setUndo" scope="instance"/>
      <method name="setBinding" scope="instance">
        <parameters>
          <parameter name="pt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endEdit" scope="instance"/>
      <method name="enable" scope="instance"/>
      <method name="disable" scope="instance"/>
      <method name="beginEdit" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.sketch.AnnotationTool" superclass="dojox.sketch._Plugin">
    <methods>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="rect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_create" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sketch._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.sketch.Annotation">
    <methods>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="writeCommonAttrs" scope="instance"/>
      <method name="type" scope="instance"/>
      <method name="setMode" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setBinding" scope="instance">
        <parameters>
          <parameter name="pt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="toolclass" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="readCommonAttrs" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="property" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRemove" scope="instance">
        <parameters>
          <parameter name="noundo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPropertyChange" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="oldvalue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCreate" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="getTextBox" scope="instance">
        <parameters>
          <parameter name="zoomfactor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getBBox" scope="instance"/>
      <method name="endEdit" scope="instance"/>
      <method name="drawBBox" scope="instance"/>
      <method name="draw" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="beginEdit" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="calculate" scope="instance" type="Object"/>
      <property name="Modes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.beginEdit">
    <methods/>
  </class>
  <class type="dojox.sketch.Annotation.endEdit">
    <methods/>
  </class>
  <class type="dojox.sketch.Annotation.calculate">
    <methods>
      <method name="slope" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dy" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
          <parameter name="dx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dx" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
          <parameter name="dy" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sketch.Annotation.drawBBox">
    <methods/>
  </class>
  <class type="dojox.sketch.Annotation.setMode">
    <methods/>
  </class>
  <class type="dojox.sketch.Annotation.readCommonAttrs">
    <methods/>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.readCommonAttrs.transform"/>
  <class type="dojox.sketch.Annotation.Modes"/>
  <class type="dojox.sketch.DoubleArrowAnnotation">
    <methods>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="instance"/>
      <method name="serialize" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_rot" scope="instance"/>
      <method name="_pos" scope="instance"/>
    </methods>
    <properties>
      <property name="anchors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.anchors"/>
  <class type="dojox.sketch.DoubleArrowAnnotation._rot">
    <methods/>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation._pos">
    <methods/>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply">
    <methods/>
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply.start"/>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply.control"/>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply.end"/>
  <class type="dojox.sketch.DoubleArrowAnnotation.initialize">
    <methods/>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.destroy">
    <methods/>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.draw">
    <methods/>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.zoom">
    <methods/>
    <properties>
      <property name="figure" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.zoom.figure"/>
  <class type="dojox.sketch.Figure">
    <methods>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unzoom" scope="instance"/>
      <method name="undo" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTool" scope="instance">
        <parameters>
          <parameter name="t" type="dojox.sketch._Plugin" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="replaceSelection" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="annotation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="redo" scope="instance"/>
      <method name="onUndo" scope="instance"/>
      <method name="onRedo" scope="instance"/>
      <method name="onLoad" scope="instance"/>
      <method name="onDblClickShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCreateShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance"/>
      <method name="onBeforeUndo" scope="instance"/>
      <method name="onBeforeRedo" scope="instance"/>
      <method name="onBeforeCreateShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="instance"/>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initUndoStack" scope="instance"/>
      <method name="hasSelections" scope="instance"/>
      <method name="getFit" scope="instance"/>
      <method name="getAnnotator" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance"/>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="isLoading" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="convert" scope="instance">
        <parameters>
          <parameter name="ann" type="Object" usage="required"/>
          <parameter name="t" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearSelections" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="annotation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mm" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_md" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadAnnotation" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_keydown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_keyFromEvt" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fromEvt" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_delete" scope="instance">
        <parameters>
          <parameter name="arr" type="Object" usage="required"/>
          <parameter name="noundo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calCol" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sketch.Figure.initUndoStack">
    <methods/>
  </class>
  <class type="dojox.sketch.Figure.setTool">
    <methods/>
  </class>
  <class type="dojox.sketch.Figure.initialize">
    <methods/>
  </class>
  <class type="dojox.sketch.Figure.destroy">
    <methods/>
  </class>
  <class type="dojox.sketch.Figure.zoom">
    <methods/>
  </class>
  <class type="dojox.sketch.Figure.unzoom">
    <methods/>
  </class>
  <class type="dojox.sketch.Figure.setValue">
    <methods/>
  </class>
  <class type="dojox.sketch.Figure.load">
    <methods/>
  </class>
  <class type="dojox.sketch.LeadAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="serialize" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pos" scope="instance"/>
    </methods>
    <properties>
      <property name="anchors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.anchors"/>
  <class type="dojox.sketch.LeadAnnotation._pos">
    <methods/>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply">
    <methods/>
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply.start"/>
  <class type="dojox.sketch.LeadAnnotation.apply.control"/>
  <class type="dojox.sketch.LeadAnnotation.apply.end"/>
  <class type="dojox.sketch.LeadAnnotation.initialize">
    <methods/>
  </class>
  <class type="dojox.sketch.LeadAnnotation.destroy">
    <methods/>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation">
    <methods>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="instance"/>
      <method name="serialize" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pos" scope="instance"/>
    </methods>
    <properties>
      <property name="anchors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.anchors"/>
  <class type="dojox.sketch.PreexistingAnnotation._pos">
    <methods/>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.apply">
    <methods/>
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.apply.start"/>
  <class type="dojox.sketch.PreexistingAnnotation.apply.end"/>
  <class type="dojox.sketch.PreexistingAnnotation.initialize">
    <methods/>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.destroy">
    <methods/>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation">
    <methods>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="instance"/>
      <method name="serialize" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_rot" scope="instance"/>
      <method name="_pos" scope="instance"/>
    </methods>
    <properties>
      <property name="anchors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.anchors"/>
  <class type="dojox.sketch.SingleArrowAnnotation._rot">
    <methods/>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation._pos">
    <methods/>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply">
    <methods/>
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply.start"/>
  <class type="dojox.sketch.SingleArrowAnnotation.apply.control"/>
  <class type="dojox.sketch.SingleArrowAnnotation.apply.end"/>
  <class type="dojox.sketch.SingleArrowAnnotation.initialize">
    <methods/>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.destroy">
    <methods/>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.draw">
    <methods/>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.zoom">
    <methods/>
    <properties>
      <property name="figure" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.zoom.figure"/>
  <class type="dojox.sketch.Slider" superclass="dojox.sketch._Plugin">
    <methods>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="t" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_zoomToFit" scope="instance"/>
      <method name="_setZoom" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sketch._Plugin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.sketch.Slider.slider._movable.node"/>
  <class type="dojox.sketch.ButtonGroup">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="plugin" type="_Plugin" usage="required"/>
        </parameters>
      </method>
      <method name="_resetGroup" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sketch.Toolbar" superclass="dijit.Toolbar">
    <methods>
      <method name="setFigure" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="addGroupItem" scope="instance">
        <parameters>
          <parameter name="item" type="_Plugin" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setShape" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Toolbar" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.sketch.UnderlineAnnotationTool" superclass="dojox.sketch.AnnotationTool">
    <methods>
      <method name="onMouseUp" scope="instance"/>
      <method name="onMouseMove" scope="instance"/>
      <method name="onMouseDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sketch.AnnotationTool" scope="instance"/>
    </mixins>
    <properties>
      <property name="figure" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotationTool.figure"/>
  <class type="dojox.sketch.UnderlineAnnotation">
    <methods>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="instance"/>
      <method name="serialize" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.initialize">
    <methods/>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.destroy">
    <methods/>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.getBBox">
    <methods/>
    <properties>
      <property name="figure" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.getBBox.figure"/>
  <class type="dojox.sketch.UndoStack">
    <methods>
      <method name="undo" scope="instance"/>
      <method name="redo" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
          <parameter name="ann" type="ta.Annotation" usage="optional"/>
          <parameter name="before" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sketch.CommandTypes"/>
  <class type="dojox.sketch._Plugin">
    <methods>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="setFigure" scope="instance">
        <parameters>
          <parameter name="figure" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onActivate" scope="instance"/>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="tf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="activate" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.socket">
    <methods>
      <method name="Reconnect" scope="instance">
        <examples>
          <example>You can use the Reconnect module:
	 dojo.require("dojox.socket");
	 dojo.require("dojox.socket.Reconnect");
	 var socket = dojox.socket({url:"/comet"});
	 // add auto-reconnect support
	 socket = dojox.socket.Reconnect(socket);</example>
        </examples>
        <parameters>
          <parameter name="socket" type="Socket" usage="required">
            <description>to add reconnection support to.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
        <return-description>An object that implements the WebSocket API</return-description>
      </method>
    </methods>
  </class>
  <class type="Socket">
    <methods>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="socket" type="Object" usage="required"/>
          <parameter name="newSocket" type="Object" usage="required"/>
          <parameter name="listenForOpen" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="WebSocket" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="fallback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="LongPoll" scope="instance">
        <examples>
          <example> dojo.require("dojox.socket.LongPoll");
	 var socket = dojox.socket.LongPoll({url:"/comet"});
	or:
	 dojo.require("dojox.socket.LongPoll");
	 dojox.socket.LongPoll.add();
	 var socket = dojox.socket({url:"/comet"});</example>
        </examples>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required">
            <description>This uses the same arguments as the other I/O functions in Dojo, with this addition:
	args.interval:
	Indicates the amount of time (in milliseconds) after a response was received
	before another request is made. By default, a request is made immediately
	after getting a response. The interval can be increased to reduce load on the
	server or to do simple time-based polling where the server always responds
	immediately.
	args.transport:
	Provide an alternate transport like dojo.io.script.get</description>
          </parameter>
        </parameters>
        <return-description>An object that implements the WebSocket API</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.sql">
    <description>There are four ways to call this:
	1) Straight SQL: dojox.sql("SELECT * FROM FOOBAR");
	2) SQL with parameters: dojox.sql("INSERT INTO FOOBAR VALUES (?)", someParam)
	3) Encrypting particular values:
	dojox.sql("INSERT INTO FOOBAR VALUES (ENCRYPT(?))", someParam, "somePassword", callback)
	4) Decrypting particular values:
	dojox.sql("SELECT DECRYPT(SOMECOL1), DECRYPT(SOMECOL2) FROM
	FOOBAR WHERE SOMECOL3 = ?", someParam,
	"somePassword", callback)
	
	For encryption and decryption the last two values should be the the password for
	encryption/decryption, and the callback function that gets the result set.
	
	Note: We only support ENCRYPT(?) statements, and
	and DECRYPT(*) statements for now -- you can not have a literal string
	inside of these, such as ENCRYPT('foobar')
	
	Note: If you have multiple columns to encrypt and decrypt, you can use the following
	convenience form to not have to type ENCRYPT(?)/DECRYPT(*) many times:
	
	dojox.sql("INSERT INTO FOOBAR VALUES (ENCRYPT(?, ?, ?))",
	someParam1, someParam2, someParam3,
	"somePassword", callback)
	
	dojox.sql("SELECT DECRYPT(SOMECOL1, SOMECOL2) FROM
	FOOBAR WHERE SOMECOL3 = ?", someParam,
	"somePassword", callback)</description>
    <methods>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="dbName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="dbName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_printDebugSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeResults" scope="instance">
        <parameters>
          <parameter name="rs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needsEncrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needsDecrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initDb" scope="instance"/>
      <method name="_exec" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="encrypted results will arrive asynchronously"/>
          <return-type type="decrypted results will arrive asynchronously"/>
        </return-types>
      </method>
      <method name="_SQLCrypto" scope="instance">
        <parameters>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sql" scope="instance"/>
    </mixins>
    <properties>
      <property name="_crypto" scope="instance" type="Object">
        <description>dojox.sql cryptography code</description>
      </property>
    </properties>
  </class>
  <class type="dojox.sql.open">
    <methods/>
  </class>
  <class type="dojox.sql.close">
    <methods/>
  </class>
  <class type="dojox.sql._exec">
    <methods/>
  </class>
  <class type="dojox.sql._initDb">
    <methods/>
  </class>
  <class type="dojox.sql._SQLCrypto">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stripCryptoSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_flagEncryptedArgs" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execEncryptSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execDecryptSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="encryptColumns" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_determineDecryptedColumns" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decryptSingleColumn" scope="instance">
        <parameters>
          <parameter name="columnName" type="Object" usage="required"/>
          <parameter name="columnValue" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="currentRowIndex" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decrypt" scope="instance">
        <parameters>
          <parameter name="resultSet" type="Object" usage="required"/>
          <parameter name="needsDecrypt" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sql._crypto">
    <description>Taken from http://www.movable-type.co.uk/scripts/aes.html by
	Chris Veness (CLA signed); adapted for Dojo and Google Gears Worker Pool
	by Brad Neuberg, bkn3@columbia.edu</description>
    <methods>
      <method name="encrypt" scope="instance">
        <parameters>
          <parameter name="plaintext" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decrypt" scope="instance">
        <parameters>
          <parameter name="ciphertext" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_workerHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initWorkerPool" scope="instance"/>
      <method name="_assignWork" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sql._crypto._initWorkerPool">
    <methods/>
    <properties>
      <property name="_manager" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._crypto._initWorkerPool._manager">
    <methods>
      <method name="onmessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sql._crypto._assignWork">
    <methods/>
  </class>
  <class type="dojox.storage">
    <methods>
      <method name="manager" scope="instance">
        <description>Initializes the storage systems and figures out the best available
	storage options on this platform.</description>
      </method>
      <method name="WhatWGStorageProvider" scope="instance">
        <description>The WHAT WG storage API is documented at
	http://www.whatwg.org/specs/web-apps/current-work/#scs-client-side
	
	You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableWhatWGStorage: true };
	
	Authors of this storage provider-
	JB Boisseau, jb.boisseau@eutech-ssii.com
	Brad Neuberg, bkn3@columbia.edu</description>
      </method>
      <method name="Provider" scope="instance">
        <description>dojox.storage exposes the current available storage provider on this
	platform. It gives you methods such as dojox.storage.put(),
	dojox.storage.get(), etc.
	
	For more details on dojox.storage, see the primary documentation
	page at
	http://manual.dojotoolkit.org/storage.html
	
	Note for storage provider developers who are creating subclasses-
	This is the base class for all storage providers Specific kinds of
	Storage Providers should subclass this and implement these methods.
	You should avoid initialization in storage provider subclass's
	constructor; instead, perform initialization in your initialize()
	method.</description>
      </method>
      <method name="LocalStorageProvider" scope="instance"/>
      <method name="GearsStorageProvider" scope="instance">
        <description>You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableGearsStorage: true };
	
	Authors of this storage provider-
	Brad Neuberg, bkn3@columbia.edu
	
	
	instance methods and properties</description>
      </method>
      <method name="FlashStorageProvider" scope="instance"/>
      <method name="CookieStorageProvider" scope="instance"/>
      <method name="BehaviorStorageProvider" scope="instance"/>
      <method name="AirFileStorageProvider" scope="instance"/>
      <method name="AirEncryptedLocalStorageProvider" scope="instance"/>
      <method name="AirDBStorageProvider" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.storage.AirDBStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="showSettingsUI" scope="instance"/>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMaximumSize" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sql" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_commitTransaction" scope="instance"/>
      <method name="_beginTransaction" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.storage.AirEncryptedLocalStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="showSettingsUI" scope="instance"/>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMaximumSize" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItem" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeItem" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItem" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.storage.AirFileStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="showSettingsUI" scope="instance"/>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMaximumSize" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.storage.BehaviorStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isValidNamespace" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="_removeKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createStore" scope="instance"/>
      <method name="_beginsWith" scope="instance">
        <parameters>
          <parameter name="haystack" type="string" usage="required"/>
          <parameter name="needle" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidNamespace" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_addKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.storage.CookieStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isValidNamespace" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="_save" scope="instance"/>
      <method name="_beginsWith" scope="instance">
        <parameters>
          <parameter name="haystack" type="string" usage="required"/>
          <parameter name="needle" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidNamespace" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.storage.FlashStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="showSettingsUI" scope="instance"/>
      <method name="setFlushDelay" scope="instance">
        <parameters>
          <parameter name="newDelay" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="getResourceList" scope="instance"/>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getMaximumSize" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFlushDelay" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flush" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onStatus" scope="instance">
        <parameters>
          <parameter name="statusResult" type="Object" usage="required"/>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loaded" scope="instance"/>
      <method name="_destringify" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.storage.GearsStorageProvider" superclass="dojox.storage.Provider">
    <description>You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableGearsStorage: true };
	
	Authors of this storage provider-
	Brad Neuberg, bkn3@columbia.edu
	
	
	instance methods and properties</description>
    <methods>
      <method name="showSettingsUI" scope="instance"/>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMaximumSize" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initStorage" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.storage.LocalStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isValidNamespace" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="_beginsWith" scope="instance">
        <parameters>
          <parameter name="haystack" type="string" usage="required"/>
          <parameter name="needle" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidNamespace" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.storage.Provider">
    <description>dojox.storage exposes the current available storage provider on this
	platform. It gives you methods such as dojox.storage.put(),
	dojox.storage.get(), etc.
	
	For more details on dojox.storage, see the primary documentation
	page at
	http://manual.dojotoolkit.org/storage.html
	
	Note for storage provider developers who are creating subclasses-
	This is the base class for all storage providers Specific kinds of
	Storage Providers should subclass this and implement these methods.
	You should avoid initialization in storage provider subclass's
	constructor; instead, perform initialization in your initialize()
	method.</description>
    <methods>
      <method name="showSettingsUI" scope="instance"/>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <description>Example-
	var resultsHandler = function(status, key, message){
	alert("status="+status+", key="+key+", message="+message);
	};
	dojox.storage.put(["test"], ["hello world"], resultsHandler);
	
	Important note: if you are using Dojo Storage in conjunction with
	Dojo Offline, then you don't need to provide
	a resultsHandler; this is because for Dojo Offline we
	use Google Gears to persist data, which has unlimited data
	once the user has given permission. If you are using Dojo
	Storage apart from Dojo Offline, then under the covers hidden
	Flash might be used, which is both asychronous and which might
	get denied; in this case you must provide a resultsHandler.</description>
        <parameters>
          <parameter name="keys" type="array" usage="required">
            <description>An array of string keys to use when retrieving this value in the future,
	one per value to be stored</description>
          </parameter>
          <parameter name="values" type="array" usage="required">
            <description>An array of values to store; this can be any JavaScript type, though the
	performance of plain strings is considerably better</description>
          </parameter>
          <parameter name="resultsHandler" type="function" usage="required">
            <description>A callback function that will receive three arguments. The
	first argument is one of three values: dojox.storage.SUCCESS,
	dojox.storage.FAILED, or dojox.storage.PENDING; these values
	determine how the put request went. In some storage systems
	users can deny a storage request, resulting in a
	dojox.storage.FAILED, while in other storage systems a storage
	request must wait for user approval, resulting in a
	dojox.storage.PENDING status until the request is either
	approved or denied, resulting in another call back with
	dojox.storage.SUCCESS.
	The second argument in the call back is the key name that was being stored.
	The third argument in the call back is an optional message that
	details possible error messages that might have occurred during
	the storage process.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be placed into;
	if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE</description>
          </parameter>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <description>Example-
	var resultsHandler = function(status, key, message, namespace){
	alert("status="+status+", key="+key+", message="+message);
	};
	dojox.storage.put("test", "hello world", resultsHandler);
	
	Arguments:
	
	status - The status of the put operation, given by
	dojox.storage.FAILED, dojox.storage.SUCCEEDED, or
	dojox.storage.PENDING
	key - The key that was used for the put
	message - An optional message if there was an error or things failed.
	namespace - The namespace of the key. This comes at the end since
	it was added later.
	
	Important note: if you are using Dojo Storage in conjunction with
	Dojo Offline, then you don't need to provide
	a resultsHandler; this is because for Dojo Offline we
	use Google Gears to persist data, which has unlimited data
	once the user has given permission. If you are using Dojo
	Storage apart from Dojo Offline, then under the covers hidden
	Flash might be used, which is both asychronous and which might
	get denied; in this case you must provide a resultsHandler.</description>
        <parameters>
          <parameter name="key" type="string" usage="required">
            <description>A string key to use when retrieving this value in the future.</description>
          </parameter>
          <parameter name="value" type="object" usage="required">
            <description>A value to store; this can be any JavaScript type.</description>
          </parameter>
          <parameter name="resultsHandler" type="function" usage="required">
            <description>A callback function that will receive three arguments. The
	first argument is one of three values: dojox.storage.SUCCESS,
	dojox.storage.FAILED, or dojox.storage.PENDING; these values
	determine how the put request went. In some storage systems
	users can deny a storage request, resulting in a
	dojox.storage.FAILED, while in other storage systems a storage
	request must wait for user approval, resulting in a
	dojox.storage.PENDING status until the request is either
	approved or denied, resulting in another call back with
	dojox.storage.SUCCESS.
	The second argument in the call back is the key name that was being stored.
	The third argument in the call back is an optional message that
	details possible error messages that might have occurred during
	the storage process.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be placed into;
	if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHideSettingsUI" scope="instance"/>
      <method name="isValidKeyArray" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="hasKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getResourceList" scope="instance">
        <description>This method returns a list of URLs that this
	storage provider depends on to do its work.
	This list is used by the Dojo Offline Toolkit
	to cache these resources to ensure the machinery
	used by this storage provider is available offline.
	What is returned is an array of URLs.
	Note that Dojo Offline uses Gears as its native
	storage provider, and does not support using other
	kinds of storage providers while offline anymore.</description>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required">
            <description>An array of string keys to get the value of.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be retrieved from;
	if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
	return: Returns any JavaScript object type; null if the key is not present</description>
          </parameter>
        </parameters>
      </method>
      <method name="getMaximumSize" scope="instance">
        <return-description>Returns the maximum storage size
	supported by this provider, in
	thousands of bytes (i.e., if it
	returns 60 then this means that 60K
	of storage is supported).
	
	If this provider can not determine
	it's maximum size, then
	dojox.storage.SIZE_NOT_AVAILABLE is
	returned; if there is no theoretical
	limit on the amount of storage
	this provider can return, then
	dojox.storage.SIZE_NO_LIMIT is
	returned</return-description>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required">
            <description>A string key to get the value of.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be retrieved from;
	if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
	return: Returns any JavaScript object type; null if the key is not present</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.storage.WhatWGStorageProvider" superclass="dojox.storage.Provider">
    <description>The WHAT WG storage API is documented at
	http://www.whatwg.org/specs/web-apps/current-work/#scs-client-side
	
	You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableWhatWGStorage: true };
	
	Authors of this storage provider-
	JB Boisseau, jb.boisseau@eutech-ssii.com
	Brad Neuberg, bkn3@columbia.edu</description>
    <methods>
      <method name="showSettingsUI" scope="instance"/>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="getNamespaces" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.storage.manager">
    <description>Initializes the storage systems and figures out the best available
	storage options on this platform.</description>
    <methods>
      <method name="supportsProvider" scope="instance">
        <description>Example-
	dojox.storage.manager.supportsProvider(
	"dojox.storage.InternetExplorerStorageProvider");</description>
        <parameters>
          <parameter name="storageClass" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="setProvider" scope="instance">
        <description>Example-
	dojox.storage.setProvider(
	dojox.storage.IEStorageProvider)</description>
        <parameters>
          <parameter name="storageClass" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeOnLoad" scope="instance">
        <parameters>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="string" usage="required">
            <description>The full class name of this provider, such as
	&amp;quot;dojox.storage.FlashStorageProvider&amp;quot;.</description>
          </parameter>
          <parameter name="instance" type="Object" usage="required">
            <description>An instance of this provider, which we will use to call
	isAvailable() on.</description>
          </parameter>
        </parameters>
      </method>
      <method name="loaded" scope="instance">
        <description>Example 1-
	if(dojox.storage.manager.isInitialized() == false){
	dojo.connect(dojox.storage.manager, "loaded", TestStorage, "initialize");
	}else{
	dojo.connect(dojo, "loaded", TestStorage, "initialize");
	}
	Example 2-
	dojox.storage.manager.addOnLoad(someFunction);</description>
      </method>
      <method name="isInitialized" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="getResourceList" scope="instance">
        <description>This will return all files needed by all storage providers for
	this particular environment type. For example, if we are in the
	browser environment, then this will return the hidden SWF files
	needed by the FlashStorageProvider, even if we don't need them
	for the particular browser we are working within. This is meant
	to faciliate Dojo Offline, which must retrieve all resources we
	need offline into the offline cache -- we retrieve everything
	needed, in case another browser that requires different storage
	mechanisms hits the local offline cache. For example, if we
	were to sync against Dojo Offline on Firefox 2, then we would
	not grab the FlashStorageProvider resources needed for Safari.</description>
      </method>
      <method name="getProvider" scope="instance"/>
      <method name="autodetect" scope="instance"/>
      <method name="addOnLoad" scope="instance">
        <description>Adds a listener to know when Dojo Offline can be used. This
	ensures that the Dojo Offline framework is loaded and that the
	local dojox.storage system is ready to be used. This method is
	useful if you don't want to have a dependency on Dojo Events
	when using dojox.storage.</description>
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <description>A function to call when Dojo Offline is ready to go</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fireLoaded" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.store">
    <methods>
      <method name="LightstreamerStore" scope="instance">
        <parameters>
          <parameter name="pushPage" type="pushPage" usage="required">
            <description>This is the pushPage created by using the typical Lightstreamer web client</description>
          </parameter>
          <parameter name="group" type="Array&lt;String&gt;" usage="required">
            <description>An array of the item names you wish to get back from Lightstreamer.</description>
          </parameter>
          <parameter name="schema" type="Array&lt;String&gt;" usage="required">
            <description>The list of fields for each item you wish to get back from Lightstreamer.</description>
          </parameter>
          <parameter name="dataAdapter" type="String" usage="required">
            <description>This is the data adapter to connect to (defined with the Lightstreamer server)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.store.LightstreamerStore">
    <methods>
      <method name="query" scope="instance">
        <description>The main method of the LightstreamerStore, query opens up a data stream
	from a Lightstreamer server (based on the pushPage definition used in the
	constructor) and sets up a way to observe the returned results from said
	stream.  It is based on Lightstreamer's NonVisualTable object, and by
	default will run the return from the Lightstreamer server through a
	private "translate" function, which takes the updateInfo object normally
	returned by Lightstreamer's web client and converts it into a straight
	JSON-like object that can be used for data consumption.</description>
        <examples>
          <example>Query a server:
		var results = myLSStore.query("MERGE", { dataAdapter: "QUOTE_ADAPTER", snapshotRequired: true });
		results.observe(function(obj){
			//	do something with obj
		});</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <description>The name of the mode to use for the resulting stream. (RAW, MERGE, COMMAND or DISTINCT)</description>
          </parameter>
          <parameter name="options" type="LightstreamerStore.__QueryOptionsArgs" usage="required">
            <description>Additional options to consume. See http://www.lightstreamer.com/docs/client_web_jsdoc/NonVisualTable.html
	for more information on these properties. All properties are optional.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A query results object that can be used to observe data being returned,
	as well as stop the stream of data.  Note that this results object is
	customized with an "observe" method and a "close" method; observe is the
	main hook into the constant data stream returned by Lightstreamer, and
	the close method will stop the query/stream.</return-description>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required">
            <description>The identity of the object to retrieve.</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="pushPage" type="pushPage" usage="required">
            <description>This is the pushPage created by using the typical Lightstreamer web client</description>
          </parameter>
          <parameter name="group" type="Array&lt;String&gt;" usage="required">
            <description>An array of the item names you wish to get back from Lightstreamer.</description>
          </parameter>
          <parameter name="schema" type="Array&lt;String&gt;" usage="required">
            <description>The list of fields for each item you wish to get back from Lightstreamer.</description>
          </parameter>
          <parameter name="dataAdapter" type="String" usage="required">
            <description>This is the data adapter to connect to (defined with the Lightstreamer server)</description>
          </parameter>
        </parameters>
      </method>
      <method name="__queryOptionsArgs" scope="instance">
        <parameters>
          <parameter name="dataAdapter" type="String" usage="optional">
            <description>The data adapter to be used for a query.</description>
          </parameter>
          <parameter name="itemsRange" type="Array" usage="optional">
            <description>The range of items in the form of [ start, end ] to receive back from Lightstreamer.</description>
          </parameter>
          <parameter name="requestedBufferSize" type="Number" usage="optional">
            <description>The length of the internal queuing buffers to be used by the server.</description>
          </parameter>
          <parameter name="requestedMaxFrequency" type="Number" usage="optional">
            <description>The maximum update frequency (updates per second) to be used by Lightstreamer.</description>
          </parameter>
          <parameter name="selector" type="String" usage="optional">
            <description>The name of a selector, to be recognized by the Metadata Adapter in Lightstreamer.</description>
          </parameter>
          <parameter name="snapshotRequired" type="Boolean" usage="optional">
            <description>Whether or not to request snapshot delivery.</description>
          </parameter>
          <parameter name="commandLogic" type="Array" usage="optional">
            <description>An array of arguments in the following form: [ flag, commandPos, keyPos, underSchema, underDataAdapter ]</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.store.LightstreamerStore.__queryOptionsArgs">
    <methods/>
  </class>
  <class type="dojox.string.BidiEngine">
    <description>Bidi stands for support for languages with a bidirectional script.
	
	Usually Unicode Bidi Algorithm used by OS platform (and web browsers) is capable of properly transforming
	Bidi text and as a result it is adequately displayed on the screen. However, in some situations,
	Unicode Bidi Algorithm is not invoked or is not properly applied. This may occur in situation in which software
	responsible for rendering the text is not leveraging Unicode Bidi Algorithm implemented by OS (e.g. dojox.GFX renderers).
	
	Bidi engine provided in this class implements Unicode Bidi Algorithm as specified at:
	http://www.unicode.org/reports/tr9/.
	
	For more information on basic Bidi concepts please read following article:
	"Bidirectional script support - A primer" available from:
	http://www.ibm.com/developerworks/websphere/library/techarticles/bidi/bidigen.html
	
	As of February 2011, Bidi engine has following limitations:
	1. No support for following numeric shaping options:
	H - Hindi,
	C - Contextual,
	N - Nominal.
	2. No support for following shaping options:
	I - Initial shaping,
	M - Middle shaping,
	F - Final shaping,
	B - Isolated shaping.
	3. No support for source-to-target or/and target-to-source maps.
	4. No support for LRE/RLE/LRO/RLO/PDF (they are handled like neutrals).
	5. No support for Windows compatibility.
	6. No support for  insert/remove marks.
	7. No support for code pages (currently only UTF-8 is supported. Ideally we should convert from any code page to UTF-8).</description>
    <methods>
      <method name="hasBidiChar" scope="instance">
        <description>Iterates over the text string, letter by letter starting from its beginning,
	searching for RTL directed character.
	Return true if found else false. Needed for vml transformation.</description>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>The source string.</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true - if text has a RTL directed character.
	false - otherwise.</return-description>
      </method>
      <method name="checkContextual" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>The text to check.</description>
          </parameter>
        </parameters>
        <return-description>String
	"ltr" or "rtl" according to the first strong character.
	If there is no strong character, returns the value of the
	document dir property.</return-description>
      </method>
      <method name="bidiTransform" scope="instance">
        <description>Both formatIn and formatOut parameters are 5 letters long strings.
	For example - "ILYNN". Each letter is associated with specific attribute of Bidi layout.
	Possible and default values for each one of the letters are provided below:
	
	First letter:
	Letter position/index:
	1
	Letter meaning:
	Ordering Schema.
	Possible values:
	I - Implicit (Logical).
	V - Visual.
	Default value:
	I
	
	Second letter:
	Letter position/index:
	2
	Letter meaning:
	Orientation.
	Possible values:
	L - Left To Right.
	R - Right To Left.
	C - Contextual Left to Right.
	D - Contextual Right to Left.
	Default value:
	L
	
	Third letter:
	Letter position/index:
	3
	Letter meaning:
	Symmetric Swapping.
	Possible values:
	Y - Symmetric swapping is on.
	N - Symmetric swapping is off.
	Default value:
	Y
	
	Fourth letter:
	Letter position/index:
	4
	Letter meaning:
	Shaping.
	Possible values:
	S - Text is shaped.
	N - Text is not shaped.
	Default value:
	N
	
	Fifth letter:
	Letter position/index:
	5
	Letter meaning:
	Numeric Shaping.
	Possible values:
	N - Nominal.
	Default value:
	N
	
	The output of this function is original text (passed via first argument) transformed from input Bidi layout (second argument)
	to output Bidi layout (last argument).
	
	Sample call:
		mytext = bidiTransform("HELLO WORLD", "ILYNN", "VLYNN");
	In this case, "HELLO WORLD" text is transformed from Logical - LTR to Visual - LTR Bidi layout with
	default values for symmetric swapping (Yes), shaping (Not shaped) and numeric shaping (Nominal).</description>
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="formatIn" type="String" usage="required">
            <description>Input Bidi layout in which inputText is passed to the function.</description>
          </parameter>
          <parameter name="formatOut" type="String" usage="required">
            <description>Output Bidi layout to which inputText should be transformed.</description>
          </parameter>
        </parameters>
        <return-description>String*/ or throws an exception.
	Original text transformed from input Bidi layout (second argument)
	to output Bidi layout (last argument).
	Throws an exception if the bidi layout strings are not valid.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.testing">
    <methods>
      <method name="DocTest" scope="instance">
        <description>DocTests are tests that are defined inside the comment.
	A doctest looks as if it was copied from the shell (which it mostly is).
	A doctest is executed when the following conditions match:
	1) all lines are comments
	2) the line always starts with spaces/tabs followed by "//"
	and at least one space
	3) the line(s) of the test to execute starts with "&gt;&gt;&gt;"
	preceeded by what is described in 2)
	4) the first line after 3) starting without "&gt;&gt;&gt;" is the exptected result.
	preceeded by what is described in 2)
	5) the test sequence is terminated by an empty line, or the next
	test in the following line, or a new line that does not start as described in 2)
	(simple said: is not a comment)
	preceeded by what is described in 2)
	
	I.e. the following is a simple doctest, that will actually also be run
	if you run this class against this file here:
	&gt;&gt;&gt; 1+1 // A simple test case. Terminated by an empty line
	2
	
	&gt;&gt;&gt; 1==2
	false
	&gt;&gt;&gt; "a"+"b" // Also without the empty line before, this is a new test.
	"ab"
	
	&gt;&gt;&gt; var anything = "anything" // Multiple commands for one test.
	&gt;&gt;&gt; "something"==anything
	false
	
	DocTests are great for inline documenting a class or method, they also
	are very helpful in understanding what the class/method actually does.
	They don't make sense everywhere, but sometimes they are really handy.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.testing.DocTest">
    <description>DocTests are tests that are defined inside the comment.
	A doctest looks as if it was copied from the shell (which it mostly is).
	A doctest is executed when the following conditions match:
	1) all lines are comments
	2) the line always starts with spaces/tabs followed by "//"
	and at least one space
	3) the line(s) of the test to execute starts with "&gt;&gt;&gt;"
	preceeded by what is described in 2)
	4) the first line after 3) starting without "&gt;&gt;&gt;" is the exptected result.
	preceeded by what is described in 2)
	5) the test sequence is terminated by an empty line, or the next
	test in the following line, or a new line that does not start as described in 2)
	(simple said: is not a comment)
	preceeded by what is described in 2)
	
	I.e. the following is a simple doctest, that will actually also be run
	if you run this class against this file here:
	&gt;&gt;&gt; 1+1 // A simple test case. Terminated by an empty line
	2
	
	&gt;&gt;&gt; 1==2
	false
	&gt;&gt;&gt; "a"+"b" // Also without the empty line before, this is a new test.
	"ab"
	
	&gt;&gt;&gt; var anything = "anything" // Multiple commands for one test.
	&gt;&gt;&gt; "something"==anything
	false
	
	DocTests are great for inline documenting a class or method, they also
	are very helpful in understanding what the class/method actually does.
	They don't make sense everywhere, but sometimes they are really handy.</description>
    <methods>
      <method name="runTest" scope="instance">
        <parameters>
          <parameter name="commands" type="Object" usage="required"/>
          <parameter name="expected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="run" scope="instance">
        <examples>
          <example>doctest = new dojox.testing.DocTest();
	doctest.run("dojox.testing.DocTest");
	doctest.errors should finally be an empty array.
	// The above is not a doctest, because it just would
	//	execute itself in a never ending loop.
	
	&gt;&gt;&gt; true==true // Test a new line terminating the test.
	true
	
	&gt;&gt;&gt; true==true // Test a new test terminating the test.
	true
	&gt;&gt;&gt; true==true // Test a "not a comment"-line, especially an empty line terminating the test.
	true</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTestsFromString" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getTests" scope="instance">
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_run" scope="instance">
        <parameters>
          <parameter name="tests" type="Array" usage="required">
            <description>Make sure that the types are compared properly. There used to be
	the bug that a return value false was compared to &amp;quot;false&amp;quot; which
	made the test fail. This is fixed and should be verified by the
	following tests.
	&amp;gt;&amp;gt;&amp;gt; false
	false
	
	&amp;gt;&amp;gt;&amp;gt; &amp;quot;false&amp;quot;
	&amp;quot;false&amp;quot;
	
	&amp;gt;&amp;gt;&amp;gt; true
	true
	
	&amp;gt;&amp;gt;&amp;gt; 1
	1
	
	&amp;gt;&amp;gt;&amp;gt; &amp;quot;s&amp;quot;
	&amp;quot;s&amp;quot;
	
	&amp;gt;&amp;gt;&amp;gt; dojo.toJson({one:1})
	&amp;quot;{&amp;quot;one&amp;quot;:1}&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getTestsFromString" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
          <parameter name="insideComments" type="Boolean" usage="required">
            <description>Boolean, if false &amp;quot;data&amp;quot; contains only the pure tests, comments already stripped.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.timing">
    <methods>
      <method name="doLater" scope="instance">
        <description>dojox.timing.doLater(conditional) is testing if the call
	should be done later. So it returns
	true if the param is false.
	arguments:</description>
        <examples>
          <example> setTimeout(function(){
	 		if(dojox.timing.doLater(app.ready)){return;}
	 		console.log("Code is ready! anonymous.function SUCCESS")
	 	},700);</example>
        </examples>
        <parameters>
          <parameter name="conditional" type="anything" usage="required">
            <description>Can be a property that eventually gets set, or
	an expression, method... anything that can be
	evaluated.</description>
          </parameter>
          <parameter name="context" type="Object" usage="required">
            <description>The namespace where the call originated.
	Defaults to global and anonymous functions</description>
          </parameter>
          <parameter name="interval" type="Number" usage="required">
            <description>Poll time to check conditional in Milliseconds</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="Timer" scope="instance">
        <parameters>
          <parameter name="interval" type="int" usage="required">
            <description>Interval between function calls, in milliseconds.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Thread" scope="instance">
        <parameters>
          <parameter name="fn" type="Function" usage="required"/>
          <parameter name="priority" type="dojox.timing.threadPriorities" usage="optional"/>
        </parameters>
      </method>
      <method name="Streamer" scope="instance">
        <parameters>
          <parameter name="input" type="function" usage="required">
            <description>the function executed when the internal queue reaches minimumSize</description>
          </parameter>
          <parameter name="output" type="function" usage="required">
            <description>the function executed on internal tick</description>
          </parameter>
          <parameter name="interval" type="int" usage="required">
            <description>the interval in ms at which the output function is fired.</description>
          </parameter>
          <parameter name="minimum" type="int" usage="required">
            <description>the minimum number of elements in the internal queue.</description>
          </parameter>
          <parameter name="initialData" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="Sequence" scope="instance">
        <description>This array will contain the sequence defines resolved, so that
	ie. repeat:10 will result in 10 elements in the sequence, so
	the repeat handling is easier and we don't need to handle that
	many extra cases. Also the doneFunction, if given is added at the
	end of the resolved-sequences.</description>
      </method>
    </methods>
    <properties>
      <property name="threadStates" scope="instance" type="Object"/>
      <property name="threadPriorities" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Sequence">
    <description>This array will contain the sequence defines resolved, so that
	ie. repeat:10 will result in 10 elements in the sequence, so
	the repeat handling is easier and we don't need to handle that
	many extra cases. Also the doneFunction, if given is added at the
	end of the resolved-sequences.</description>
    <methods>
      <method name="stop" scope="instance">
        <description>This can only interrupt the sequence not the last function that
	had been started. If the last function was i.e. a slideshow
	that is handled inside a function that you have given as
	one sequence item it cant be stopped, since it is not controlled
	by this object here. In this case it would be smarter to
	run the slideshow using a sequence object so you can also stop
	it using this method.</description>
      </method>
      <method name="goOn" scope="instance"/>
      <method name="go" scope="instance">
        <parameters>
          <parameter name="defs" type="Array" usage="required">
            <description>The sequence of actions</description>
          </parameter>
          <parameter name="doneFunction" type="Function|Array" usage="optional">
            <description>The function to call when done</description>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="_go" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.timing.Streamer">
    <methods>
      <method name="stop" scope="instance"/>
      <method name="start" scope="instance"/>
      <method name="setInterval" scope="instance">
        <parameters>
          <parameter name="ms" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="outputFunction" scope="instance"/>
      <method name="onTick" scope="instance">
        <parameters>
          <parameter name="obj" type="dojox.timing.Streamer" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="instance"/>
      <method name="onStart" scope="instance"/>
      <method name="inputFunction" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.timing.threadStates"/>
  <class type="dojox.timing.threadPriorities"/>
  <class type="dojox.timing.Thread">
    <methods>
      <method name="invoke" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.timing.Timer">
    <methods>
      <method name="stop" scope="instance">
        <description>Calls the "onStop()" handler, if defined.</description>
      </method>
      <method name="start" scope="instance">
        <description>Calls the "onStart()" handler, if defined.
	Note that the onTick() function is not called right away,
	only after first interval passes.</description>
      </method>
      <method name="setInterval" scope="instance">
        <parameters>
          <parameter name="interval" type="New" usage="required">
            <description>interval, in milliseconds.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onTick" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.timing.Timer.setInterval">
    <methods/>
  </class>
  <class type="dojox.timing.Timer.start">
    <description>Calls the "onStart()" handler, if defined.
	Note that the onTick() function is not called right away,
	only after first interval passes.</description>
    <methods/>
  </class>
  <class type="dojox.timing.Timer.stop">
    <description>Calls the "onStop()" handler, if defined.</description>
    <methods/>
  </class>
  <class type="dojox.uuid">
    <methods>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="getVersion" scope="instance">
        <examples>
          <example>var version = dojox.uuid.getVersion("b4308fb0-86cd-11da-a72b-0800200c9a66");
	dojox.uuid.assert(version == dojox.uuid.version.TIME_BASED);</example>
        </examples>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.version"/>
        </return-types>
      </method>
      <method name="getVariant" scope="instance">
        <examples>
          <example>var variant = dojox.uuid.getVariant("3b12f1df-5232-4804-897e-917bf397618a");
	dojox.uuid.assert(variant == dojox.uuid.variant.DCE);</example>
          <example>"3b12f1df-5232-4804-897e-917bf397618a"
	^
	
	(variant "10__" == DCE)</example>
        </examples>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.variant"/>
        </return-types>
      </method>
      <method name="getTimestamp" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
          <parameter name="returnType" type="String" usage="optional">
            <description>Any of these five values: &amp;quot;string&amp;quot;, String, &amp;quot;hex&amp;quot;, &amp;quot;date&amp;quot;, Date</description>
          </parameter>
        </parameters>
        <return-description>Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
	examples:
	var uuidString = "b4308fb0-86cd-11da-a72b-0800200c9a66";
	var date, string, hexString;
	date   = dojox.uuid.getTimestamp(uuidString);         // returns a JavaScript Date
	date   = dojox.uuid.getTimestamp(uuidString, Date);     //
	string = dojox.uuid.getTimestamp(uuidString, String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
	hexString = dojox.uuid.getTimestamp(uuidString, "hex"); // "1da86cdb4308fb0"</return-description>
        <return-types>
          <return-type type="String"/>
          <return-type type="String"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="generateTimeBasedUuid" scope="instance">
        <description>For more info, see
	http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt
	http://www.infonuovo.com/dma/csdocs/sketch/instidid.htm
	http://kruithof.xs4all.nl/uuid/uuidgen
	http://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20
	http://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html</description>
        <parameters>
          <parameter name="node" type="String" usage="optional">
            <description>A 12-character hex string representing either a pseudo-node or
	hardware-node (an IEEE 802.3 network node).  A hardware-node
	will be something like &amp;quot;017bf397618a&amp;quot;, always with the first bit
	being 0.  A pseudo-node will be something like &amp;quot;f17bf397618a&amp;quot;,
	always with the first bit being 1.
	examples:
	string = dojox.uuid.generateTimeBasedUuid();
	string = dojox.uuid.generateTimeBasedUuid(&amp;quot;017bf397618a&amp;quot;);
	dojox.uuid.generateTimeBasedUuid.setNode(&amp;quot;017bf397618a&amp;quot;);
	string = dojox.uuid.generateTimeBasedUuid(); // the generated UUID has node == &amp;quot;017bf397618a&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="generateRandomUuid" scope="instance">
        <description>A typical generated value would be something like this:
	"3b12f1df-5232-4804-897e-917bf397618a"
	
	For more information about random UUIDs, see sections 4.4 and
	4.5 of RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.4
	
	This generator function is designed to be small and fast,
	but not necessarily good.
	
	Small: This generator has a small footprint. Once comments are
	stripped, it's only about 25 lines of code, and it doesn't
	dojo.require() any other modules.
	
	Fast: This generator can generate lots of new UUIDs fairly quickly
	(at least, more quickly than the other dojo UUID generators).
	
	Not necessarily good: We use Math.random() as our source
	of randomness, which may or may not provide much randomness.
	examples:
	var string = dojox.uuid.generateRandomUuid();</description>
        <return-types>
          <return-type type="for example: &quot;3B12F1DF"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="generateNilUuid" scope="instance">
        <description>The Nil UUID is described in section 4.1.7 of
	RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.1.7
	examples:
	var string = dojox.uuid.generateNilUuid();</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="assert" scope="instance">
        <description>If the asserted condition is true, this method does nothing. If the
	condition is false, we throw an error with a error message.</description>
        <parameters>
          <parameter name="booleanValue" type="Boolean" usage="required">
            <description>Must be true for the assertion to succeed.</description>
          </parameter>
          <parameter name="message" type="String" usage="optional">
            <description>A string describing the assertion.
	throws: Throws an Error if 'booleanValue' is false.</description>
          </parameter>
        </parameters>
      </method>
      <method name="Uuid" scope="instance">
        <parameters>
          <parameter name="input" type="String" usage="optional">
            <description>A 36-character string that conforms to the UUID spec.
	examples:
	var uuid;
	uuid = new dojox.uuid.Uuid(&amp;quot;3b12f1df-5232-4804-897e-917bf397618a&amp;quot;);
	uuid = new dojox.uuid.Uuid(); // &amp;quot;00000000-0000-0000-0000-000000000000&amp;quot;
	uuid = new dojox.uuid.Uuid(dojox.uuid.generateRandomUuid());
	uuid = new dojox.uuid.Uuid(dojox.uuid.generateTimeBasedUuid());
	dojox.uuid.Uuid.setGenerator(dojox.uuid.generateRandomUuid);
	uuid = new dojox.uuid.Uuid();
	dojox.uuid.assert(!uuid.isEqual(dojox.uuid.NIL_UUID));</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="version" scope="instance" type="Object"/>
      <property name="variant" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid">
    <methods>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="setGenerator" scope="instance">
        <parameters>
          <parameter name="generator" type="Function" usage="optional">
            <description>A UUID generator function, such as dojox.uuid.generateTimeBasedUuid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isValid" scope="instance"/>
      <method name="isEqual" scope="instance">
        <parameters>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="getVersion" scope="instance">
        <examples>
          <example>var uuid = new dojox.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
	var version = uuid.getVersion();
	dojox.uuid.assert(version == dojox.uuid.version.TIME_BASED);</example>
        </examples>
        <return-types>
          <return-type type="dojox.uuid.version"/>
        </return-types>
      </method>
      <method name="getVariant" scope="instance">
        <examples>
          <example>var uuid = new dojox.uuid.Uuid("3b12f1df-5232-4804-897e-917bf397618a");
	var variant = uuid.getVariant();
	dojox.uuid.assert(variant == dojox.uuid.variant.DCE);</example>
          <example>"3b12f1df-5232-4804-897e-917bf397618a"
	^
	
	(variant "10__" == DCE)</example>
        </examples>
      </method>
      <method name="getTimestamp" scope="instance">
        <parameters>
          <parameter name="returnType" type="String" usage="optional">
            <description>Any of these five values: &amp;quot;string&amp;quot;, String, &amp;quot;hex&amp;quot;, &amp;quot;date&amp;quot;, Date</description>
          </parameter>
        </parameters>
        <return-description>Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
	examples:
	var uuid = new dojox.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
	var date, string, hexString;
	date   = uuid.getTimestamp();         // returns a JavaScript Date
	date   = uuid.getTimestamp(Date);     //
	string = uuid.getTimestamp(String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
	hexString = uuid.getTimestamp("hex"); // "1da86cdb4308fb0"</return-description>
        <return-types>
          <return-type type="String"/>
          <return-type type="String"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getNode" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getGenerator" scope="instance">
        <return-types>
          <return-type type="generator (A UUID generator, such as dojox.uuid.TimeBasedGenerator)"/>
        </return-types>
      </method>
      <method name="compare" scope="instance">
        <description>This implementation is intended to match the sample implementation
	in IETF RFC 4122: http://www.ietf.org/rfc/rfc4122.txt</description>
        <parameters>
          <parameter name="uuidOne" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
          <parameter name="uuidTwo" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="integer"/>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.uuid.Uuid.getVersion">
    <methods/>
  </class>
  <class type="dojox.uuid.Uuid.getNode">
    <methods/>
  </class>
  <class type="dojox.uuid.Uuid.getTimestamp">
    <methods/>
  </class>
  <class type="dojox.uuid.version"/>
  <class type="dojox.uuid.variant"/>
  <class type="dojox.uuid.generateTimeBasedUuid">
    <description>For more info, see
	http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt
	http://www.infonuovo.com/dma/csdocs/sketch/instidid.htm
	http://kruithof.xs4all.nl/uuid/uuidgen
	http://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20
	http://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html</description>
    <methods>
      <method name="setNode" scope="instance">
        <parameters>
          <parameter name="node" type="String" usage="optional">
            <description>A 12-character hex string representing a pseudoNode or hardwareNode.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isValidNode" scope="instance">
        <parameters>
          <parameter name="node" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getNode" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.uuid.generateTimeBasedUuid.setNode">
    <methods/>
  </class>
  <class type="dojox.validate._cardInfo">
    <description>A hash of valid CC abbreviations and regular expressions</description>
  </class>
  <class type="dojox.validate.regexp">
    <methods>
      <method name="url" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.scheme  Can be true, false, or [true, false].
	This means: required, not allowed, or match either one.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="&quot;; } return &quot;&quot;; }"/>
        </return-types>
      </method>
      <method name="numberFormat" scope="instance">
        <description>Use this method for phone numbers, social security numbers, zip-codes, etc.
	The RE can match one format or one of multiple formats.
	
	Format
	#        Stands for a digit, 0-9.
	?        Stands for an optional digit, 0-9 or nothing.
	All other characters must appear literally in the expression.
	
	Example
	"(###) ###-####"       -&gt;   (510) 542-9742
	"(###) ###-#### x#???" -&gt;   (510) 542-9742 x153
	"###-##-####"          -&gt;   506-82-1089       i.e. social security number
	"#####-####"           -&gt;   98225-1649        i.e. zip code</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.format  A string or an Array of strings for multiple formats.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="ipAddress" scope="instance">
        <description>Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	Supports 2 formats for Ipv6.
	
	flags  An object.  All flags are boolean with default = true.
	flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	Case insensitive.  Zero padding allowed.
	flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	FIXME: ipv6 can be written multiple ways IIRC
	flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="host" scope="instance">
        <description>A host is a named host (A-z0-9_- but not starting with -), a domain name or an IP address, possibly followed by a port number.</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object.
	flags.allowNamed Allow a named host for local networks. Default is false.
	flags.allowIP  Allow an IP address for hostname.  Default is true.
	flags.allowLocal  Allow the host to be &amp;quot;localhost&amp;quot;.  Default is false.
	flags.allowPort  Allow a port number to be present.  Default is true.
	flags in regexp.ipAddress can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="emailAddress" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.allowCruft  Allow address like &amp;lt;mailto:foo@yahoo.com&amp;gt;.  Default is false.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="us" scope="instance" type="Object"/>
      <property name="ca" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.validate.regexp.ca">
    <methods>
      <method name="province" scope="instance"/>
      <method name="postalCode" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.validate.regexp.us">
    <methods>
      <method name="state" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.widget">
    <description>These are standalone widgets with varying levels of stability. Some are useful,
	some were created for demonstration purposes, and learning tools. The each maintain
	their own .css file (typically dojox/widget/WidgetName/WidgetName.css)</description>
    <methods>
      <method name="_RollingListPane" scope="instance"/>
      <method name="_RollingListGroupPane" scope="instance"/>
      <method name="_RollerHover" scope="instance">
        <description>A mixin class used to provide a way to automate a "stop on hover" behavior,
	while still allowing for ambigious subclassing for custom animations.
	Simply mix this class into a `dojox.widget.Roller` variant, and instantiate
	as you would. The hover connection is done automatically.
	
	The "hover" functionality is as such: Stop rotation while the mouse is over the
	instance, and resume again once leaving. Even if autoStart is disabled, the widget
	will start if a mouse enters and leaves the node in this case.</description>
        <examples>
          <example> dojo.declare("my.Roller", [dojox.widget.RollerSlide, dojox.widget._RollerHover], {});
	 new my.Roller({}, "myList");</example>
        </examples>
      </method>
      <method name="_PagerItem" scope="instance"/>
      <method name="_MonthDropDown" scope="instance"/>
      <method name="_FisheyeFX" scope="instance"/>
      <method name="_FileInfoPane" scope="instance"/>
      <method name="_CalendarYearView" scope="instance"/>
      <method name="_CalendarYear" scope="instance"/>
      <method name="_CalendarView" scope="instance"/>
      <method name="_CalendarMonthYearView" scope="instance"/>
      <method name="_CalendarMonthYear" scope="instance"/>
      <method name="_CalendarMonthView" scope="instance"/>
      <method name="_CalendarMonth" scope="instance"/>
      <method name="_CalendarDayView" scope="instance"/>
      <method name="_CalendarDay" scope="instance"/>
      <method name="_CalendarBase" scope="instance"/>
      <method name="YearlyCalendar" scope="instance"/>
      <method name="WizardPane" scope="instance">
        <description>An extended ContentPane with additional hooks for passing named
	functions to prevent the pane from going either forward or
	backwards.</description>
      </method>
      <method name="Wizard" scope="instance"/>
      <method name="UpgradeBar" scope="instance">
        <description>You can insert custom validations to trigger the UpgradeBar
	to display. An evaluation of 'true' shows the bar (as this
	version *is* less than it should be). Multiple validations
	may be checked, although only the first in the list will be
	displayed.
	Markup and programmatic are supported. Markup is a little
	cleaner, since a majority of the parameters are the HTML
	snippets to be displayed. In markup, the validate code should
	be an expression that will evaluate to true or false. This
	expression is wrapped in a try/catch, so if it blows up, it
	is assumed to be true and trigger the bar.
	In programmtic, a function should be used that returns true
	or false. You would need to use your own try/catch in that.</description>
        <examples>
          <example>See tests for examples.</example>
        </examples>
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Toaster" scope="instance"/>
      <method name="TitleGroup" scope="instance">
        <description>A container which controls a series of `dijit.TitlePane`s,
	allowing one to be visible and hiding siblings. Behaves similarly
	to a `dijit.layout.AccordionContainer` in that the children
	are all stacked, though merges the TitlePane behavior of
	variable height</description>
        <examples>
          <example>	var group = new dojox.widget.TitleGroup().placeAt(dojo.body());
		new dijit.TitlePane({ title:"One" }, "fromsource").placeAt(group);
		new dijit.TitlePane({ title:"Remote", href:"foo.html" }).placeAt(group);</example>
        </examples>
      </method>
      <method name="Standby" scope="instance"/>
      <method name="SortList" scope="instance"/>
      <method name="Rotator" scope="instance">
        <description>A small, fast, extensible, awesome rotator that cycles, with transitions,
	through panes (child nodes) displaying only one at a time and ties into
	controllers used to change state.
	
	The Rotator does not rely on dijit.  It is designed to be as lightweight
	as possible.  Controllers and transitions have been externalized
	so builds can be as optimized with only the components you want to use.
	
	For best results, each rotator pane should be the same height and width as
	the Rotator container node and consider setting overflow to hidden.
	While the Rotator will accept any DOM node for a rotator pane, a block
	element or element with display:block is recommended.
	
	Note: When the Rotator begins, it does not transition the first pane.
	
	subscribed topics:
	[id]/rotator/control - Controls the Rotator
	Parameters:
	/*string*/ action        - The name of a method of the Rotator to run
	/*anything?*/ args       - One or more arguments to pass to the action
	
	published topics:
	[id]/rotator/update - Notifies controllers that a pane or state has changed.
	Parameters:
	/*string*/ type          - the type of notification
	/*dojox.widget.Rotator*/ rotator
	- the rotator instance
	/*object?*/ params		 - params
	
	declarative dojo/method events (per pane):
	onBeforeIn  - Fired before the transition in starts.
	onAfterIn   - Fired after the transition in ends.
	onBeforeOut - Fired before the transition out starts.
	onAfterOut  - Fired after the transition out ends.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.widget.Rotator"&gt;
			&lt;div&gt;Pane 1!&lt;/div&gt;
			&lt;div&gt;Pane 2!&lt;/div&gt;
		&lt;/div&gt;</example>
          <example>	&lt;script type="text/javascript"&gt;
			dojo.require("dojox.widget.rotator.Fade");
		&lt;/script&gt;
		&lt;div dojoType="dojox.widget.Rotator" transition="dojox.widget.rotator.crossFade"&gt;
			&lt;div&gt;Pane 1!&lt;/div&gt;
			&lt;div&gt;Pane 2!&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="RollingList" scope="instance"/>
      <method name="RollerSlide" scope="instance"/>
      <method name="Roller" scope="instance">
        <description>The Roller widget takes an unordered-list of items, and converts
	them to a single-area (the size of one list-item, however you so choose
	to style it) and loops continually, fading between items.
	
	In it's current state, it requires it be created from an unordered (or ordered)
	list, though can contain complex markup.
	
	You can manipulate the `items` array at any point during the cycle with
	standard array manipulation techniques.
	
	The class "dojoxRoller" is added to the UL element for styling purposes.</description>
        <examples>
          <example>	// create a scroller from a unordered list with id="lister"
		var thinger = new dojox.widget.Roller.Roller({},"lister");</example>
          <example>	// create a scroller from a fixed array, and place in the DOM:
		new dojox.widget.Roller({ items:["one","two","three"] }).placeAt(dojo.body());</example>
          <example>	// add an item:
		dijit.byId("roller").items.push("I am a new Label");</example>
          <example>	// stop a roller from rolling:
		dijit.byId("roller").stop();</example>
        </examples>
      </method>
      <method name="PortletSettings" scope="instance">
        <description>This widget should be placed inside a dojox.widget.Portlet widget.
	It is used to set some preferences for that Portlet.	It is essentially
	a ContentPane, and should contain other widgets and DOM nodes that
	do the real work of setting preferences for the portlet.</description>
      </method>
      <method name="PortletFeedSettings" scope="instance">
        <description>It provides form items that the user can use to change the URL
	for a feed to load into the FeedPortlet.
	There are two forms that it can take.	&lt;br&gt;
	The first is to display a text field, with Load and Cancel buttons,
	which is prepopulated with the enclosing FeedPortlet's URL.
	If a &lt;select&gt; DOM node is used as the source node for this widget,
	it displays a list of predefined URLs that the user can select from
	to load into the enclosing FeedPortlet.</description>
        <examples>
          <example>&lt;div dojoType="dojox.widget.PortletFeedSettings"&gt;&lt;/div&gt;</example>
          <example>&lt;select dojoType="dojox.widget.PortletFeedSettings"&gt;
	&lt;option&gt;http://www.dojotoolkit.org/aggregator/rss&lt;/option&gt;
	&lt;option&gt;http://dojocampus.org/content/category/podcast/feed/&lt;/option&gt;
	&lt;/select&gt;</example>
        </examples>
      </method>
      <method name="PortletDialogSettings" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Portlet" scope="instance"/>
      <method name="PlaceholderMenuItem" scope="instance"/>
      <method name="Pager" scope="instance"/>
      <method name="MultiSelectCalendar" scope="instance">
        <description>A simple GUI for choosing several dates in the context of a monthly calendar.
	This widget serialises its selected dates to ISO dates or ISO ranges of dates,
	depending on developer selection
	Note that it accepts an Array of ISO dates as its input</description>
        <examples>
          <example>	var calendar = new dojox.widget.MultiSelectCalendar({value: ['2011-05-07,'2011-05-08',2011-05-09','2011-05-23']}, dojo.byId("calendarNode"));</example>
          <example>	&lt;div dojoType="dojox.widget.MultiSelectCalendar"&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="MonthlyCalendar" scope="instance"/>
      <method name="MonthAndYearlyCalendar" scope="instance"/>
      <method name="Loader" scope="instance"/>
      <method name="Iterator" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="FisheyeLite" scope="instance">
        <description>A Simple FisheyeList-like widget which (in the interest of
	performance) relies on well-styled content for positioning,
	and natural page layout for rendering.
	
	use position:absolute/relative nodes to prevent layout
	changes, and use caution when seleting properties to
	scale. Negative scaling works, but some properties
	react poorly to being set to negative values, IE being
	particularly annoying in that regard.
	
	quirk: uses the domNode as the target of the animation
	unless it finds a node class="fisheyeTarget" in the container
	being turned into a FisheyeLite instance</description>
        <examples>
          <example>	// make all the LI's in a node Fisheye's:
		 dojo.query("#node li").forEach(function(n){
			new dojox.widget.FisheyeLite({},n);
		});</example>
          <example>	new dojox.widget.FisheyeLite({
			properties:{
				// height is literal, width is multiplied
				height:{ end: 200 }, width:2.3
			}
		}, "someNode");
	
	duationIn: Integer
	The time (in ms) the run the show animation</example>
        </examples>
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="FisheyeListItem" scope="instance"/>
      <method name="FisheyeList" scope="instance">
        <examples>
          <example>	&lt;div dojoType="FisheyeList"
			itemWidth="40" itemHeight="40"
			itemMaxWidth="150" itemMaxHeight="150"
			orientation="horizontal"
			effectUnits="2"
			itemPadding="10"
			attachEdge="center"
			labelEdge="bottom"&gt;
	
			&lt;div dojoType="FisheyeListItem"
				id="item1"
				onclick="alert('click on' + this.label + '(from widget id ' + this.widgetId + ')!');"
				label="Item 1"
				iconSrc="images/fisheye_1.png"&gt;
			&lt;/div&gt;
			...
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="FilePicker" scope="instance"/>
      <method name="FeedPortlet" scope="instance">
        <description>The feed is displayed as
	an unordered list of links.	When a link is hovered over
	by the mouse, it displays a summary in a tooltip.</description>
      </method>
      <method name="ExpandableFeedPortlet" scope="instance"/>
      <method name="DynamicTooltip" scope="instance"/>
      <method name="DocTester" scope="instance"/>
      <method name="DialogSimple" scope="instance"/>
      <method name="Dialog" scope="instance">
        <description>An HTML-capable Dialog widget with advanced sizing
	options, animated show/hide and other useful options.
	
	This Dialog is also very easy to apply custom styles to.
	
	It works identically to a `dijit.Dialog` with several
	additional parameters.</description>
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DataPresentation" scope="instance">
        <examples>
          <example>var pres = new dojox.data.DataPresentation("myChartNode", {</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to attach the data presentation to.
	kwArgs:	Object (see above)</description>
          </parameter>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="DailyCalendar" scope="instance"/>
      <method name="ColorPicker" scope="instance">
        <description>Provides an interactive HSV ColorPicker similar to
	PhotoShop's color selction tool. This is an enhanced
	version of the default dijit.ColorPalette, though provides
	no accessibility.</description>
        <examples>
          <example>	var picker = new dojox.widget.ColorPicker({
			// a couple of example toggles:
			animatePoint:false,
			showHsv: false,
			webSafe: false,
			showRgb: false
		});</example>
          <example>	&lt;!-- markup: --&gt;
		&lt;div dojoType="dojox.widget.ColorPicker"&gt;&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="CalendarFisheye" scope="instance"/>
      <method name="Calendar3Pane" scope="instance"/>
      <method name="Calendar2Pane" scope="instance"/>
      <method name="Calendar" scope="instance"/>
      <method name="AutoRotator" scope="instance">
        <description>Adds automatic rotating to the dojox.widget.Rotator.  The
	AutoRotator has parameters that control how user input can
	affect the rotator including a suspend when hovering over the
	rotator and pausing when the user manually advances to another
	pane.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.widget.AutoRotator" duration="3000"&gt;
			&lt;div&gt;
				Pane 1!
			&lt;/div&gt;
			&lt;div duration="5000"&gt;
				Pane 2 with an overrided duration!
			&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
    </methods>
    <properties>
      <property name="rotator" scope="instance" type="Object"/>
      <property name="gauge" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge"/>
  <class type="dojox.widget.AutoRotator" superclass="dojox.widget.Rotator">
    <description>Adds automatic rotating to the dojox.widget.Rotator.  The
	AutoRotator has parameters that control how user input can
	affect the rotator including a suspend when hovering over the
	rotator and pausing when the user manually advances to another
	pane.</description>
    <methods>
      <method name="play" scope="instance">
        <parameters>
          <parameter name="skipCycleDecrement" type="boolean" usage="optional"/>
          <parameter name="skipDuration" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="pause" scope="instance"/>
      <method name="onManualChange" scope="instance">
        <parameters>
          <parameter name="action" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_resetTimer" scope="instance"/>
      <method name="_now" scope="instance"/>
      <method name="_cycle" scope="instance">
        <parameters>
          <parameter name="manual" type="boolean|int" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.Rotator" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._CalendarBase" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="parseInitialValue" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="goToToday" scope="instance"/>
      <method name="getClassForDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance"/>
      <method name="addFx" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateTitleStyle" scope="instance"/>
      <method name="_transitionVert" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_slideTable" scope="instance">
        <parameters>
          <parameter name="widget" type="String" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_onDateSelected" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
          <parameter name="force" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="_isInvalidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustDisplay" scope="instance">
        <parameters>
          <parameter name="part" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
          <parameter name="noSlide" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addView" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="footer" scope="instance" type="Object"/>
      <property name="constraints" scope="instance" type="Object"/>
      <property name="_children" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase.constraints"/>
  <class type="dojox.widget._CalendarBase.footer"/>
  <class type="dojox.widget._CalendarBase._children"/>
  <class type="dojox.widget._CalendarView" superclass="dijit._Widget">
    <methods>
      <method name="onValueSelected" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDisplay" scope="instance"/>
      <method name="onBeforeUnDisplay" scope="instance"/>
      <method name="onBeforeDisplay" scope="instance"/>
      <method name="getHeader" scope="instance"/>
      <method name="cloneClass" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._CalendarDay">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._CalendarDayView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onDisplay" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateDays" scope="instance"/>
      <method name="_onDayClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._CalendarMonthYear">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._CalendarMonthYearView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onOk" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeader" scope="instance"/>
      <method name="_updateSelectedYear" scope="instance"/>
      <method name="_updateSelectedNode" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="filter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelectedMonth" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateYears" scope="instance">
        <parameters>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateMonths" scope="instance"/>
      <method name="_getMonthNames" scope="instance">
        <parameters>
          <parameter name="format" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.Calendar2Pane" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.Calendar" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.DailyCalendar" superclass="dojox.widget._CalendarBase">
    <methods>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.MonthAndYearlyCalendar" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarMonthYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._FisheyeFX">
    <methods>
      <method name="addFx" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.widget.CalendarFisheye" superclass="dojox.widget.Calendar">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._FisheyeFX.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget.Calendar" scope="instance"/>
      <mixin type="dojox.widget._FisheyeFX" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._CalendarMonth">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._CalendarMonthView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="header" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarMonthView.header"/>
  <class type="dojox.widget._CalendarYear">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._CalendarYearView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.Calendar3Pane" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.MonthlyCalendar" superclass="dojox.widget._CalendarBase">
    <methods>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarMonth.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.YearlyCalendar" superclass="dojox.widget._CalendarBase">
    <methods>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.ColorPicker" superclass="dijit.form._FormWidget">
    <description>Provides an interactive HSV ColorPicker similar to
	PhotoShop's color selction tool. This is an enhanced
	version of the default dijit.ColorPalette, though provides
	no accessibility.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setColor" scope="instance">
        <parameters>
          <parameter name="col" type="String" usage="required"/>
          <parameter name="force" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_updateValue" scope="instance">
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
          <parameter name="fireChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePickerLocations" scope="instance">
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
        </parameters>
      </method>
      <method name="_updateHueCursorNode" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required">
            <description>means stop, anything else is just how many times it was called.</description>
          </parameter>
          <parameter name="node" type="The" usage="required">
            <description>node generating the event.</description>
          </parameter>
          <parameter name="e" type="The" usage="required">
            <description>event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateCursorNode" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required">
            <description>means stop, anything else is just how many times it was called.</description>
          </parameter>
          <parameter name="node" type="The" usage="required">
            <description>node generating the event.</description>
          </parameter>
          <parameter name="e" type="The" usage="required">
            <description>event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateColorInputs" scope="instance">
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColor" scope="instance"/>
      <method name="_stopDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setTimer" scope="instance">
        <parameters>
          <parameter name="mover" type="d.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="_setPoint" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setHuePoint" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setHue" scope="instance">
        <parameters>
          <parameter name="h" type="Decimal" usage="required">
            <description>0..360</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_colorInputChange" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clearTimer" scope="instance">
        <parameters>
          <parameter name="mover" type="d.dnd.Mover" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="valueNode" scope="instance" type="Object"/>
      <property name="hexCode" scope="instance" type="Object"/>
      <property name="colorUnderlay" scope="instance" type="Object"/>
      <property name="Vval" scope="instance" type="Object"/>
      <property name="Sval" scope="instance" type="Object"/>
      <property name="Rval" scope="instance" type="Object"/>
      <property name="Hval" scope="instance" type="Object"/>
      <property name="Gval" scope="instance" type="Object"/>
      <property name="Bval" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.colorUnderlay.style"/>
  <class type="dojox.widget.ColorPicker.colorUnderlay">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.rgbNode.style"/>
  <class type="dojox.widget.ColorPicker.hsvNode.style"/>
  <class type="dojox.widget.ColorPicker.hexNode.style"/>
  <class type="dojox.widget.ColorPicker.safePreviewNode.style"/>
  <class type="dojox.widget.ColorPicker.valueNode"/>
  <class type="dojox.widget.ColorPicker.Rval"/>
  <class type="dojox.widget.ColorPicker.Gval"/>
  <class type="dojox.widget.ColorPicker.Bval"/>
  <class type="dojox.widget.ColorPicker.Hval"/>
  <class type="dojox.widget.ColorPicker.Sval"/>
  <class type="dojox.widget.ColorPicker.Vval"/>
  <class type="dojox.widget.ColorPicker.hexCode"/>
  <class type="dojox.widget.ColorPicker.previewNode.style"/>
  <class type="dojox.widget.DataPresentation">
    <methods>
      <method name="setURL" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="optional"/>
          <parameter name="urlContent" type="Object" usage="optional"/>
          <parameter name="refreshInterval" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="optional"/>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="queryOptions" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setPreparedStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="optional"/>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="queryOptions" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="optional"/>
          <parameter name="refreshInterval" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="renderGridWidget" scope="instance"/>
      <method name="renderChartWidget" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="getGridWidget" scope="instance"/>
      <method name="getChartWidget" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to attach the data presentation to.
	kwArgs:	Object (see above)</description>
          </parameter>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelRefresh" scope="instance"/>
    </methods>
    <properties>
      <property name="titleNode" scope="instance" type="Object"/>
      <property name="legendNode" scope="instance" type="Object"/>
      <property name="gridNode" scope="instance" type="Object"/>
      <property name="footerNode" scope="instance" type="Object"/>
      <property name="chartNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.chartNode"/>
  <class type="dojox.widget.DataPresentation.legendNode"/>
  <class type="dojox.widget.DataPresentation.gridNode"/>
  <class type="dojox.widget.DataPresentation.titleNode"/>
  <class type="dojox.widget.DataPresentation.footerNode"/>
  <class type="dojox.widget.Dialog" superclass="dojox.widget.DialogSimple">
    <description>An HTML-capable Dialog widget with advanced sizing
	options, animated show/hide and other useful options.
	
	This Dialog is also very easy to apply custom styles to.
	
	It works identically to a `dijit.Dialog` with several
	additional parameters.</description>
    <methods>
      <method name="show" scope="instance"/>
      <method name="layout" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showContent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setup" scope="instance"/>
      <method name="_setSize" scope="instance"/>
      <method name="_position" scope="instance">
        <return-types>
          <return-type type="prevent content: from firing this anim #8914"/>
        </return-types>
      </method>
      <method name="_handleNav" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.DialogSimple" scope="instance"/>
    </mixins>
    <properties>
      <property name="_displaysize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Dialog._displaysize"/>
  <class type="dojox.widget.DialogSimple" superclass="dojox.layout.ContentPane">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._DialogBase.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._DialogBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.DocTester" superclass="dijit._Widget">
    <methods>
      <method name="runTests" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_unescapeHtml" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="numTestsOkNode" scope="instance" type="Object"/>
      <property name="numTestsNokNode" scope="instance" type="Object"/>
      <property name="numTestsNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester.containerNode"/>
  <class type="dojox.widget.DocTester.numTestsNode"/>
  <class type="dojox.widget.DocTester.numTestsNokNode"/>
  <class type="dojox.widget.DocTester.numTestsOkNode"/>
  <class type="dojox.widget.DynamicTooltip" superclass="dijit.Tooltip">
    <methods>
      <method name="refresh" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="loadContent" scope="instance">
        <description>1. checks if content already loaded
	2. if not, sends XHR to download new data</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setLoadingLabel" scope="instance"/>
      <method name="_setHrefAttr" scope="instance">
        <description>resets so next show loads new href</description>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required">
            <description>url to the content you want to show, must be within the same domain as your mainpage</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Tooltip" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.FeedPortlet" superclass="dojox.widget.Portlet">
    <description>The feed is displayed as
	an unordered list of links.	When a link is hovered over
	by the mouse, it displays a summary in a tooltip.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onFeedError" scope="instance"/>
      <method name="load" scope="instance"/>
      <method name="generateResults" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setUrlAttr" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getTitle" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLink" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getContent" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.Portlet" scope="instance"/>
    </mixins>
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FeedPortlet.containerNode"/>
  <class type="dojox.widget.ExpandableFeedPortlet" superclass="dojox.widget.FeedPortlet">
    <methods>
      <method name="generateResults" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.FeedPortlet" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.PortletFeedSettings" superclass="dojox.widget.PortletSettings">
    <description>It provides form items that the user can use to change the URL
	for a feed to load into the FeedPortlet.
	There are two forms that it can take.	&lt;br&gt;
	The first is to display a text field, with Load and Cancel buttons,
	which is prepopulated with the enclosing FeedPortlet's URL.
	If a &lt;select&gt; DOM node is used as the source node for this widget,
	it displays a list of predefined URLs that the user can select from
	to load into the enclosing FeedPortlet.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setContentAttr" scope="instance"/>
      <method name="_getFeedPortletUrlAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.PortletSettings" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._FileInfoPane" superclass="dojox.widget._RollingListPane">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onItems" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._RollingListPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="sizeNode" scope="instance" type="Object"/>
      <property name="pathNode" scope="instance" type="Object"/>
      <property name="nameNode" scope="instance" type="Object"/>
      <property name="items" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.items"/>
  <class type="dojox.widget._FileInfoPane.nameNode"/>
  <class type="dojox.widget._FileInfoPane.pathNode"/>
  <class type="dojox.widget._FileInfoPane.sizeNode"/>
  <class type="dojox.widget.FilePicker" superclass="dojox.widget.RollingList">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="getPaneForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="getChildItems" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setPathValueAttr" scope="instance">
        <parameters>
          <parameter name="path" type="string" usage="required"/>
          <parameter name="resetLastExec" type="boolean" usage="optional"/>
          <parameter name="onSet" type="function" usage="optional"/>
        </parameters>
      </method>
      <method name="_itemsMatch" scope="instance">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_getPathValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="item" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.RollingList" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.FisheyeList" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onResized" scope="instance"/>
      <method name="destroyRecursive" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_weighAt" scope="instance">
        <parameters>
          <parameter name="cen" type="Integer" usage="required"/>
          <parameter name="i" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_toEdge" scope="instance">
        <parameters>
          <parameter name="inp" type="Object" usage="required"/>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItemSize" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="scale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDormant" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already dormant?"/>
        </return-types>
      </method>
      <method name="_setActive" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already activated?"/>
        </return-types>
      </method>
      <method name="_positionLabel" scope="instance">
        <parameters>
          <parameter name="itm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_positionElementsFrom" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_paint" scope="instance"/>
      <method name="_overElement" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onScroll" scope="instance"/>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onGridMouseMove" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBodyOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_initializePositioning" scope="instance"/>
      <method name="_expandSlowly" scope="instance"/>
      <method name="_calcHitGrid" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="pos" scope="instance-prototype" type="Object"/>
      <property name="EDGE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList.EDGE"/>
  <class type="dojox.widget.FisheyeList.domNode.style"/>
  <class type="dojox.widget.FisheyeList.pos"/>
  <class type="dojox.widget.FisheyeListItem" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_isNode" scope="instance">
        <parameters>
          <parameter name="wh" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_hasParent" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="imgNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem.imgNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem.imgNode.style"/>
  <class type="dojox.widget.FisheyeLite" superclass="dijit._Widget">
    <description>A Simple FisheyeList-like widget which (in the interest of
	performance) relies on well-styled content for positioning,
	and natural page layout for rendering.
	
	use position:absolute/relative nodes to prevent layout
	changes, and use caution when seleting properties to
	scale. Negative scaling works, but some properties
	react poorly to being set to negative values, IE being
	particularly annoying in that regard.
	
	quirk: uses the domNode as the target of the animation
	unless it finds a node class="fisheyeTarget" in the container
	being turned into a FisheyeLite instance</description>
    <methods>
      <method name="show" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="easeOut" scope="instance"/>
      <method name="easeIn" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeAnims" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.Iterator" superclass="dijit.Declaration">
    <methods>
      <method name="update" scope="instance"/>
      <method name="onDataAvailable" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttrValuesObj" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="_setSrcIndex" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Declaration" scope="instance"/>
    </mixins>
    <properties>
      <property name="query" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Iterator.query"/>
  <class type="dojox.widget.Loader" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_show" scope="instance"/>
      <method name="_setMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_putLoader" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_hide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="loadMessageNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader.loadNode.style"/>
  <class type="dojox.widget.Loader.loadMessageNode"/>
  <class type="dojox.widget.MultiSelectCalendar" superclass="dijit._Widget">
    <description>A simple GUI for choosing several dates in the context of a monthly calendar.
	This widget serialises its selected dates to ISO dates or ISO ranges of dates,
	depending on developer selection
	Note that it accepts an Array of ISO dates as its input</description>
    <methods>
      <method name="unselectDate" scope="instance">
        <parameters>
          <parameter name="dateToUnselect" type="date" usage="required"/>
          <parameter name="unselectedDates" type="array" usage="required">
            <description>of dates</description>
          </parameter>
        </parameters>
      </method>
      <method name="toggleDate" scope="instance">
        <parameters>
          <parameter name="dateToToggle" type="date" usage="required"/>
          <parameter name="selectedDates" type="array" usage="required">
            <description>of dates</description>
          </parameter>
          <parameter name="unselectedDates" type="array" usage="required">
            <description>of dates</description>
          </parameter>
        </parameters>
      </method>
      <method name="selectDate" scope="instance">
        <parameters>
          <parameter name="dateToSelect" type="date" usage="required"/>
          <parameter name="selectedDates" type="array" usage="required">
            <description>of dates</description>
          </parameter>
        </parameters>
      </method>
      <method name="onValueUnselected" scope="instance">
        <description>Passes on the list of ISO dates that are unselected</description>
        <parameters>
          <parameter name="dates" type="array" usage="required">
            <description>of ISO dates</description>
          </parameter>
        </parameters>
      </method>
      <method name="onValueSelected" scope="instance">
        <description>Passes on the list of ISO dates that are selected</description>
        <parameters>
          <parameter name="dates" type="array" usage="required">
            <description>of ISO dates</description>
          </parameter>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="handleKey" scope="instance">
        <description>Called from _onKeyPress() to handle keypress on a stand alone Calendar,
	and also from `dijit.form._DateTimeTextBox` to pass a keypress event
	from the `dijit.form.DateTextBox` to be handled in this widget</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-description>False if the key was recognized as a navigation key,
	to indicate that the event was handled by Calendar and shouldn't be propogated</return-description>
      </method>
      <method name="goToToday" scope="instance"/>
      <method name="getClassForDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="focusOnLastDate" scope="instance">
        <parameters>
          <parameter name="lastElement" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_sort" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Set the passed dates to the selected date and updates the value of this widget
	to reflect that</description>
        <parameters>
          <parameter name="value" type="Date|Number|array" usage="required">
            <description>Can be a Date, the number of milliseconds since 1970 or an array of ISO dates (['2011-07-01', '2001-06-01']).</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setEndRangeAttr" scope="instance">
        <description>records the end of a date range</description>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setCurrentFocusAttr" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="forceFocus" type="Boolean" usage="required">
            <description>If true, will focus() the cell even if calendar itself doesn't have focus</description>
          </parameter>
        </parameters>
      </method>
      <method name="_selectRange" scope="instance"/>
      <method name="_returnDatesWithIsoRanges" scope="instance">
        <parameters>
          <parameter name="selectedDates" type="Array" usage="required">
            <description>of sorted ISO dates</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeFromRangeRTL" scope="instance">
        <parameters>
          <parameter name="beginning" type="date" usage="required"/>
          <parameter name="end" type="date" usage="required"/>
          <parameter name="selectedDates" type="array" usage="required"/>
          <parameter name="unselectedDates" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="_removeFromRangeLTR" scope="instance">
        <parameters>
          <parameter name="beginning" type="date" usage="required"/>
          <parameter name="end" type="date" usage="required"/>
          <parameter name="selectedDates" type="array" usage="required"/>
          <parameter name="unselectedDates" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="_populateGrid" scope="instance"/>
      <method name="_onMonthSelect" scope="instance">
        <parameters>
          <parameter name="newMonth" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOver" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOut" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_isValidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_isSelectedDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_getNodeByDate" scope="instance">
        <parameters>
          <parameter name="dateNode" type="ISO" usage="required">
            <description>date</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getEndRangeAttr" scope="instance"/>
      <method name="_areValidDates" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustDisplay" scope="instance">
        <parameters>
          <parameter name="part" type="String" usage="required">
            <description>&amp;quot;month&amp;quot; or &amp;quot;year&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>Number of months or years</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addToRangeRTL" scope="instance">
        <parameters>
          <parameter name="beginning" type="date" usage="required"/>
          <parameter name="end" type="date" usage="required"/>
          <parameter name="selectedDates" type="array" usage="required"/>
          <parameter name="unselectedDates" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="_addToRangeLTR" scope="instance">
        <parameters>
          <parameter name="beginning" type="date" usage="required"/>
          <parameter name="end" type="date" usage="required"/>
          <parameter name="selectedDates" type="array" usage="required"/>
          <parameter name="unselectedDates" type="array" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="monthDropDownButton" scope="instance" type="Object"/>
      <property name="cssStateNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.MultiSelectCalendar.cssStateNodes"/>
  <class type="dojox.widget.MultiSelectCalendar.monthDropDownButton.containerNode"/>
  <class type="dojox.widget.MultiSelectCalendar.monthDropDownButton">
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._MonthDropDown" superclass="dijit._Widget">
    <methods>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setMonthsAttr" scope="instance">
        <parameters>
          <parameter name="months" type="Array&lt;String&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="_onMenuHover" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._TemplatedMixin.prototype" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._TemplatedMixin" scope="instance"/>
      <mixin type="dijit._WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._MonthDropDown.domNode"/>
  <class type="dojox.widget.Pager" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onScrollEnd" scope="instance"/>
      <method name="_renderStatus" scope="instance"/>
      <method name="_renderPages" scope="instance"/>
      <method name="_renderPager" scope="instance"/>
      <method name="_pagerSkip" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pagerPrevious" scope="instance"/>
      <method name="_pagerNext" scope="instance"/>
      <method name="_init" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_a11yStyle" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="pagerIconNext" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Pager.pagerIconNext"/>
  <class type="dojox.widget._PagerItem" superclass="dijit._Widget">
    <methods>
      <method name="resizeChildren" scope="instance"/>
      <method name="parseChildren" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.PlaceholderMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="unReplace" scope="instance">
        <parameters>
          <parameter name="destroy" type="Boolean" usage="optional">
            <description>Also call destroy on any removed items.</description>
          </parameter>
        </parameters>
        <return-description>The array of items that were actually removed</return-description>
        <return-types>
          <return-type type="Array&lt;dijit.MenuItem&gt;"/>
        </return-types>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="menuItems" type="Array&lt;dijit.MenuItem&gt;" usage="required"/>
        </parameters>
        <return-description>true if the replace happened, false if not</return-description>
      </method>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.PlaceholderMenuItem.domNode.style"/>
  <class type="dojox.widget.Portlet" superclass="dijit.TitlePane">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onUpdateSize" scope="instance"/>
      <method name="onSizeChange" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSize" scope="instance"/>
      <method name="_setCss" scope="instance"/>
      <method name="_publish" scope="instance"/>
      <method name="_placeSettingsWidgets" scope="instance"/>
      <method name="_onTitleClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createIcon" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
          <parameter name="hoverClazz" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.TitlePane" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.PortletSettings" superclass="dijit._Container">
    <description>This widget should be placed inside a dojox.widget.Portlet widget.
	It is used to set some preferences for that Portlet.	It is essentially
	a ContentPane, and should contain other widgets and DOM nodes that
	do the real work of setting preferences for the portlet.</description>
    <methods>
      <method name="toggle" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setPortletAttr" scope="instance">
        <parameters>
          <parameter name="portlet" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.PortletDialogSettings" superclass="dojox.widget.PortletSettings">
    <methods>
      <method name="toggle" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.PortletSettings" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.Roller" superclass="dijit._Widget">
    <description>The Roller widget takes an unordered-list of items, and converts
	them to a single-area (the size of one list-item, however you so choose
	to style it) and loops continually, fading between items.
	
	In it's current state, it requires it be created from an unordered (or ordered)
	list, though can contain complex markup.
	
	You can manipulate the `items` array at any point during the cycle with
	standard array manipulation techniques.
	
	The class "dojoxRoller" is added to the UL element for styling purposes.</description>
    <methods>
      <method name="stop" scope="instance"/>
      <method name="start" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="makeAnims" scope="instance"/>
      <method name="_setupConnects" scope="instance"/>
      <method name="_setIndex" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_run" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="_roller" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Roller._roller"/>
  <class type="dojox.widget.RollerSlide" superclass="dojox.widget.Roller">
    <methods>
      <method name="makeAnims" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.Roller" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._RollerHover">
    <description>A mixin class used to provide a way to automate a "stop on hover" behavior,
	while still allowing for ambigious subclassing for custom animations.
	Simply mix this class into a `dojox.widget.Roller` variant, and instantiate
	as you would. The hover connection is done automatically.
	
	The "hover" functionality is as such: Stop rotation while the mouse is over the
	instance, and resume again once leaving. Even if autoStart is disabled, the widget
	will start if a mouse enters and leaves the node in this case.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._RollingListPane" superclass="dijit.layout.ContentPane">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="onLoadStart" scope="instance"/>
      <method name="onLoadError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onItems" scope="instance"/>
      <method name="onFetchStart" scope="instance"/>
      <method name="onFetchError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_updateNodeWidth" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="min" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinWidthAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setContentAndScroll" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
          <parameter name="isFakeContent" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_onShow" scope="instance"/>
      <method name="_onSetItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onNewItem" scope="instance">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_onMinWidthChange" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_load" scope="instance"/>
      <method name="_hasItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_focusKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="instance"/>
      <method name="_doLoadItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array&lt;item&gt;" usage="required"/>
          <parameter name="callback" type="function" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="parentWidget" scope="instance" type="dojox.widget.RollingList">
        <description>Our rolling list widget</description>
      </property>
    </properties>
  </class>
  <class type="dojox.widget._RollingListPane.parentWidget"/>
  <class type="dojox.widget._RollingListGroupPane" superclass="dojox.widget._RollingListPane">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="onItems" scope="instance"/>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelected" scope="instance">
        <parameters>
          <parameter name="item" type="dijit.MenuItem" usage="optional"/>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="_onScrollPane" scope="instance"/>
      <method name="_onMinWidthChange" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadVisibleItems" scope="instance"/>
      <method name="_getSelected" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
      <method name="_getMenu" scope="instance"/>
      <method name="_checkScrollConnection" scope="instance">
        <parameters>
          <parameter name="doLoad" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._RollingListPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListGroupPane.containerNode"/>
  <class type="dojox.widget.RollingList" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="childWidget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="onExecute" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="getPaneForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="getChildItems" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_updateClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional">
            <description>an object with key-value-pairs.  The values are boolean, if true,
	the key is added as a class, if false, it is removed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateChildClasses" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="instance">
        <parameters>
          <parameter name="store" type="dojo.data.api.Read" usage="required"/>
        </parameters>
      </method>
      <method name="_setShowButtonsAttr" scope="instance">
        <parameters>
          <parameter name="doShow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinPaneWidthAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resetValue" scope="instance"/>
      <method name="_removeAfter" scope="instance">
        <parameters>
          <parameter name="idx" type="Widget" usage="required">
            <description>or int</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="_onExecute" scope="instance"/>
      <method name="_onChange" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onCancel" scope="instance"/>
      <method name="_itemsMatch" scope="instance">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_getPaneForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="_getMenuItemForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.RollingList.domNode"/>
  <class type="dojox.widget.Rotator">
    <description>A small, fast, extensible, awesome rotator that cycles, with transitions,
	through panes (child nodes) displaying only one at a time and ties into
	controllers used to change state.
	
	The Rotator does not rely on dijit.  It is designed to be as lightweight
	as possible.  Controllers and transitions have been externalized
	so builds can be as optimized with only the components you want to use.
	
	For best results, each rotator pane should be the same height and width as
	the Rotator container node and consider setting overflow to hidden.
	While the Rotator will accept any DOM node for a rotator pane, a block
	element or element with display:block is recommended.
	
	Note: When the Rotator begins, it does not transition the first pane.
	
	subscribed topics:
	[id]/rotator/control - Controls the Rotator
	Parameters:
	/*string*/ action        - The name of a method of the Rotator to run
	/*anything?*/ args       - One or more arguments to pass to the action
	
	published topics:
	[id]/rotator/update - Notifies controllers that a pane or state has changed.
	Parameters:
	/*string*/ type          - the type of notification
	/*dojox.widget.Rotator*/ rotator
	- the rotator instance
	/*object?*/ params		 - params
	
	declarative dojo/method events (per pane):
	onBeforeIn  - Fired before the transition in starts.
	onAfterIn   - Fired after the transition in ends.
	onBeforeOut - Fired before the transition out starts.
	onAfterOut  - Fired after the transition out ends.</description>
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="width" type="int" usage="required"/>
          <parameter name="height" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="prev" scope="instance"/>
      <method name="onUpdate" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
          <parameter name="params" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onManualChange" scope="instance"/>
      <method name="next" scope="instance"/>
      <method name="go" scope="instance">
        <parameters>
          <parameter name="p" type="int|string" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="control" scope="instance">
        <parameters>
          <parameter name="action" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="_resetWaitForEvent" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget.SortList" superclass="dijit.layout._LayoutWidget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onSort" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onChanged" scope="instance"/>
      <method name="_updateValues" scope="instance"/>
      <method name="_unset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_sorter" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="focusNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList.bodyWrapper.style"/>
  <class type="dojox.widget.SortList.focusNode"/>
  <class type="dojox.widget.Standby" superclass="_Widget">
    <methods>
      <method name="uninitialize" scope="instance"/>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="onShow" scope="instance"/>
      <method name="onHide" scope="instance"/>
      <method name="isVisible" scope="instance">
        <return-description>boolean indicating if the widget is in 'show' state or not.</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="hide" scope="instance"/>
      <method name="_size" scope="instance"/>
      <method name="_setTextAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>The text to set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setImageTextAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>The text to set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setImageAttr" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setColorAttr" scope="instance">
        <parameters>
          <parameter name="c" type="String" usage="required">
            <description>The color to set the background underlay to in #XXXXXX format..</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setCenterIndicatorAttr" scope="instance">
        <parameters>
          <parameter name="indicator" type="String" usage="required">
            <description>The indicator to use, either 'image' or 'text'.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_scrollerWidths" scope="instance">
        <return-description>Object of form: {v: Number, h: Number} where v is vertical scrollbar width
	and h is horizontal scrollbar width.</return-description>
      </method>
      <method name="_ignore" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fadeOut" scope="instance"/>
      <method name="_fadeIn" scope="instance"/>
      <method name="_enableOverflow" scope="instance"/>
      <method name="_disableOverflow" scope="instance"/>
      <method name="_cloneStyles" scope="instance">
        <parameters>
          <parameter name="list" type="Array" usage="required">
            <description>An array of style names to clone.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="_Widget" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="target" scope="instance" type="DOMNode|DOMID(String)|WidgetID(String)">
        <description>The target to overlay when active.  Can be a widget id, a
	dom id, or a direct node reference.</description>
      </property>
      <property name="_textNode" scope="instance" type="DOMNode">
        <description>The div to attach text/HTML in the overlay center item.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.widget.Standby._textNode"/>
  <class type="dojox.widget.Standby.target"/>
  <class type="dojox.widget.TitleGroup" superclass="dijit._Widget">
    <description>A container which controls a series of `dijit.TitlePane`s,
	allowing one to be visible and hiding siblings. Behaves similarly
	to a `dijit.layout.AccordionContainer` in that the children
	are all stacked, though merges the TitlePane behavior of
	variable height</description>
    <methods>
      <method name="selectChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.TitlePane"/>
        </return-types>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit.TitlePane" usage="required">
            <description>A widget reference to add</description>
          </parameter>
          <parameter name="position" type="String|Int" usage="optional">
            <description>An optional index or position to pass. defaults to &amp;quot;last&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.TitlePane"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="titlepane">
    <methods>
      <method name="_dxfindParent" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget.Toaster" superclass="WidgetBase">
    <methods>
      <method name="show" scope="instance"/>
      <method name="setContent" scope="instance">
        <parameters>
          <parameter name="message" type="String|Function" usage="required">
            <description>the message. If this is a function, it will be called with this toaster widget as the only argument.</description>
          </parameter>
          <parameter name="messageType" type="String" usage="required">
            <description>type of message; possible values in messageTypes enumeration (&amp;quot;message&amp;quot;, &amp;quot;warning&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;fatal&amp;quot;)</description>
          </parameter>
          <parameter name="duration" type="int" usage="optional">
            <description>duration in milliseconds to display message before removing it. Widget has default value.</description>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="_setHideTimer" scope="instance">
        <parameters>
          <parameter name="duration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeClip" scope="instance"/>
      <method name="_handleMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cancelHideTimer" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="WidgetBase" scope="instance"/>
      <mixin type="Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="messageTypes" scope="instance" type="Enumeration">
        <description>Possible message types.</description>
      </property>
      <property name="contentNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="clipNode" scope="instance" type="Object"/>
      <property name="bgIframe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.messageTypes"/>
  <class type="dojox.widget.Toaster.containerNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.containerNode.style"/>
  <class type="dojox.widget.Toaster.contentNode"/>
  <class type="dojox.widget.Toaster.clipNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.clipNode.style"/>
  <class type="dojox.widget.Toaster.bgIframe"/>
  <class type="dojox.widget.Toaster.bgIframe.iframe.style"/>
  <class type="dojox.widget.UpgradeBar" superclass="dijit._Widget">
    <description>You can insert custom validations to trigger the UpgradeBar
	to display. An evaluation of 'true' shows the bar (as this
	version *is* less than it should be). Multiple validations
	may be checked, although only the first in the list will be
	displayed.
	Markup and programmatic are supported. Markup is a little
	cleaner, since a majority of the parameters are the HTML
	snippets to be displayed. In markup, the validate code should
	be an expression that will evaluate to true or false. This
	expression is wrapped in a try/catch, so if it blows up, it
	is assumed to be true and trigger the bar.
	In programmtic, a function should be used that returns true
	or false. You would need to use your own try/catch in that.</description>
    <methods>
      <method name="show" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="notify" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkNotifications" scope="instance"/>
      <method name="_onDontRemindClick" scope="instance"/>
      <method name="_onCloseLeave" scope="instance"/>
      <method name="_onCloseEnter" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.Wizard" superclass="StackContainer">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="done" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setButtonClass" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_forward" scope="instance"/>
      <method name="_checkButtons" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="_TemplatedMixin.prototype" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="StackContainer" scope="instance"/>
      <mixin type="_TemplatedMixin" scope="instance"/>
      <mixin type="_WidgetsInTemplateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="selectedChildWidget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.cancelButton.domNode.style"/>
  <class type="dojox.widget.Wizard.selectedChildWidget"/>
  <class type="dojox.widget.Wizard.doneButton.domNode.style"/>
  <class type="dojox.widget.Wizard.nextButton.domNode.style"/>
  <class type="dojox.widget.WizardPane" superclass="ContentPane">
    <description>An extended ContentPane with additional hooks for passing named
	functions to prevent the pane from going either forward or
	backwards.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="done" scope="instance"/>
      <method name="_onShow" scope="instance"/>
      <method name="_checkPass" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="ContentPane" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.rotator">
    <methods>
      <method name="wipeUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="continuous gets a linear easing by default"/>
        </return-types>
      </method>
      <method name="panDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pan" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="continuous gets a linear easing by default"/>
        </return-types>
      </method>
      <method name="fade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="crossFade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ThumbnailController" scope="instance">
        <description>The ThumbnailController will look at each of the rotator's panes and
	only if the node is an &lt;img&gt; tag, then it will create an thumbnail of
	the pane's image using the &lt;img&gt; tag's "thumbsrc" or "src" attribute.
	
	The size of the thumbnails and the style of the selected thumbnail is
	controlled using CSS.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.widget.Rotator" jsId="myRotator"&gt;
			&lt;img src="/path/to/image1.jpg" thumbsrc="/path/to/thumb1.jpg" alt="Image 1"/&gt;
			&lt;img src="/path/to/image2.jpg" thumbsrc="/path/to/thumb2.jpg" alt="Image 2"/&gt;
		&lt;/div&gt;
		&lt;div dojoType="dojox.widget.rotator.ThumbnailController" rotator="myRotator"&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="Controller" scope="instance">
        <description>Displays a series of controls that send actions to a Rotator or
	AutoRotator.  The Controller supports the following controls:
	
	* Next pane
	* Previous pane
	* Play/Pause toggler
	* Numbered tabs
	* Titled tabs
	* Information
	
	You may specify any of these controls in any order.  You may also
	have multiple Controllers tied to a single Rotator instance.
	
	The Controller's DOM node may also be styled for positioning or
	other styled preferences.</description>
        <examples>
          <example>	&lt;div dojoType="dojox.widget.rotator.Controller"
			rotator="myRotator"
		&gt;&lt;/div&gt;</example>
          <example>	&lt;div dojoType="dojox.widget.rotator.Controller"
			rotator="myRotator"
			controls="prev,#,next"
			class="myCtrl"
		&gt;&lt;/div&gt;</example>
          <example>	&lt;div dojoType="dojox.widget.rotator.Controller"
			rotator="myRotator"
			controls="titles"
			class="myCtrl"
		&gt;&lt;/div&gt;s</example>
        </examples>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.widget.rotator.Controller">
    <description>Displays a series of controls that send actions to a Rotator or
	AutoRotator.  The Controller supports the following controls:
	
	* Next pane
	* Previous pane
	* Play/Pause toggler
	* Numbered tabs
	* Titled tabs
	* Information
	
	You may specify any of these controls in any order.  You may also
	have multiple Controllers tied to a single Rotator instance.
	
	The Controller's DOM node may also be styled for positioning or
	other styled preferences.</description>
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="_togglePlay" scope="instance">
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpdate" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_buildInfo" scope="instance">
        <parameters>
          <parameter name="r" type="dojox.widget.Rotator" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rotator" scope="instance-prototype" type="dojox.widget.Rotator">
        <description>An instance of a Rotator widget.</description>
      </property>
      <property name="_info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator.Controller.rotator"/>
  <class type="dojox.widget.rotator.Controller._info"/>
  <class type="dojox.widget.rotator.ThumbnailController">
    <description>The ThumbnailController will look at each of the rotator's panes and
	only if the node is an &lt;img&gt; tag, then it will create an thumbnail of
	the pane's image using the &lt;img&gt; tag's "thumbsrc" or "src" attribute.
	
	The size of the thumbnails and the style of the selected thumbnail is
	controlled using CSS.</description>
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpdate" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.wire">
    <methods>
      <method name="transfer" scope="instance">
        <description>If 'source' and/or 'target' are not Wires, Wires are created with
	them as arguments.
	A value is got through the source Wire and set through the target
	Wire.
	'defaultObject' is passed to Wires as a default root object.
	If 'defaultTargetObject' is specified, it is passed to the target
	Wire as a default root object, instead of 'defaultObject'.</description>
        <parameters>
          <parameter name="source" type="Wire|Object" usage="required">
            <description>A Wire or arguments to create a Wire for a source value</description>
          </parameter>
          <parameter name="target" type="Wire|Object" usage="required">
            <description>A Wire or arguments to create a Wire for a target value</description>
          </parameter>
          <parameter name="defaultObject" type="Object" usage="optional">
            <description>defaultTargetObject; Optional default root objects passed to Wires</description>
          </parameter>
          <parameter name="defaultTargetObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="wireClass" type="Function|String" usage="required">
            <description>A class or full qualified class name</description>
          </parameter>
          <parameter name="key" type="String" usage="required">
            <description>A key property of arguments to create a Wire</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="isWire" scope="instance">
        <description>If the specified object is a Wire, true is returned.
	Otherwise, false is returned.</description>
        <parameters>
          <parameter name="wire" type="Object" usage="required">
            <description>An object to check</description>
          </parameter>
        </parameters>
        <return-description>True if the object is a Wire, otherwise false</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>If 'handle' has 'topic', the topic is unsubscribed.
	Otherwise, the listener to an event is removed.</description>
        <parameters>
          <parameter name="connection" type="Object" usage="required">
            <description>A connection handle returned by connect()</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <description>If 'args' specifies 'wireClass', it is used as a class or full
	qualified class name to create a Wire with 'args' as arguments.
	Otherwise, a Wire class is determined by other proeprties of 'args'
	checking if 'args' specifies a key property for a Wire class.
	If no key property found, the default Wire class is used.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to create a Wire</description>
          </parameter>
        </parameters>
        <return-description>A Wire</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <description>If 'trigger' specifies 'topic', the topic is subscribed to transer
	a value on the topic.
	Otherwise, the event specified to 'event' of 'trigger' is listened
	to transfer a value.
	On the specified event or topic, transfer() is called with
	'source', 'target' and the arguments of the event or topic (as
	default root objects).</description>
        <parameters>
          <parameter name="trigger" type="Object" usage="required">
            <description>An event or topic to trigger a transfer</description>
          </parameter>
          <parameter name="source" type="Wire|Object" usage="required">
            <description>A Wire or arguments to create a Wire for a source value</description>
          </parameter>
          <parameter name="target" type="Wire|Object" usage="required">
            <description>A Wire or arguments to create a Wire for a target value</description>
          </parameter>
        </parameters>
        <return-description>A connection handle for disconnect()</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getClass" scope="instance">
        <description>The class is loaded by dojo.require() and returned
	by dojo.getObject().</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>A class name</description>
          </parameter>
        </parameters>
        <return-description>A class</return-description>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="XmlWire" scope="instance">
        <description>This class accesses XML nodes or value with a simplified XPath
	specified to 'path' property.
	The root object for this class must be an DOM document or element
	node.
	"@name" accesses to an attribute value of an element and "text()"
	accesses to a text value of an element.
	The hierarchy of the elements from the root node can be specified
	with slash-separated list, such as "a/b/@c", which specifies
	the value of an attribute named "c" of an element named "b" as
	a child of another element named "a" of a child of the root node.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	path:
	A simplified XPath to an attribute, a text or elements</description>
          </parameter>
        </parameters>
      </method>
      <method name="Wire" scope="instance">
        <description>This class accesses a property of an object with a dotted notation
	specified to 'property' property, such as "a.b.c", which identifies
	a descendant property, "object.a.b.c".
	Property names in the dotted notation may have an array index, such
	as "a[0]", to identify an array element, literally, "object.a[0]".
	When a notation start with an array index, such as "[0].a", it
	specifies an array element of the root object (array),
	"object[0].a".
	This class also serves as a base class for other Wire classes,
	preparing a root object and converting a return value, so that
	sub-classes just can implement _getValue() and _setValue() called
	from getValue() and setValue() implemented by this calss.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	object:
	A root object (or another Wire to access a root object)
	property:
	A dotted notation to a descendant property
	type:
	A type of the return value (for the source Wire)</description>
          </parameter>
        </parameters>
      </method>
      <method name="TreeAdapter" scope="instance">
        <description>This class has multiple child Wires for tree nodes, their title and
	child nodes.
	The root object for this class must be an array.
	'node' Wires in 'nodes' property is used to identify an object
	representing a node.
	'title' Wires in 'nodes' property is used to get the title string
	of a node.
	'children' Wires in 'nodes' property is used to iterate over child
	node objects.
	The node values are returned in an array as follows:
	[
	{title: title1,
	children: [
	{title: title2,
	child: ...},
	{title: title3,
	child: ...},
	...
	]},
	...
	]
	This class only supports getValue(), but not setValue().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	nodes:
	An array containing objects for child Wires for node values</description>
          </parameter>
        </parameters>
      </method>
      <method name="TextAdapter" scope="instance">
        <description>This class has multiple child Wires for text segment values.
	Wires in 'segments' property are used to get text segments and
	values are concatenated with an optional delimiter string specified
	to 'delimiter' property.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	segments:
	An array containing child Wires for text segment values</description>
          </parameter>
        </parameters>
      </method>
      <method name="TableAdapter" scope="instance">
        <description>This class has multiple child Wires for object properties or array
	elements of a table row.
	The root object for this class must be an array.
	When an object with Wires is specified to 'columns' property, they
	are used to get a row object with property values.
	When an array of Wires is specified to 'columns' property, they
	are used to get a row array with element values.
	The row values are returned in an array.
	This class only supports getValue(), but not setValue().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	columns:
	An object or array containing child Wires for column values</description>
          </parameter>
        </parameters>
      </method>
      <method name="DataWire" scope="instance">
        <description>This class accesses item attributes of data stores with a dotted
	notation of attribute names specified to 'attribute' property,
	using data APIs of a data store specified to 'dataStore' property.
	The root object for this class must be an item of the data store.
	Intermediate attribute names in the dotted notation specify
	attributes for child items, which are used for repeated calls to
	data APIs until reached to a descendant attribute.
	Attribute names may have an array index, such as "a[0]", to
	identify an array element of the attribute value.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties</description>
          </parameter>
        </parameters>
      </method>
      <method name="CompositeWire" scope="instance">
        <description>This class has multiple child Wires for object properties or array
	elements.
	When an object with Wires is specified to 'children' property, they
	are used to get or set an object with property values.
	When an array of Wiares is specified to 'children' property, they
	are used to get or set an array with element values.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	children:
	An object or array containing child Wires</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="ml" scope="instance" type="Object"/>
      <property name="_wireClasses" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.CompositeWire" superclass="dojox.wire.Wire">
    <description>This class has multiple child Wires for object properties or array
	elements.
	When an object with Wires is specified to 'children' property, they
	are used to get or set an object with property values.
	When an array of Wiares is specified to 'children' property, they
	are used to get or set an array with element values.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If object properties or array elements specified in 'children'
	property are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	children:
	An object or array containing child Wires</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Object|Array" usage="required">
            <description>A root object</description>
          </parameter>
          <parameter name="value" type="Object|Array" usage="required">
            <description>An object or array with values to set</description>
          </parameter>
        </parameters>
        <return-description>'object'</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_initializeChildren" scope="instance">
        <description>If object properties or array elements specified in 'children'
	argument are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="children" type="Object|Array" usage="required">
            <description>An object or array containing child Wires</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method calls getValue() method of the child Wires with
	'object' argument and returns an object with the values as
	properties or an arary of the values as elements.</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required">
            <description>A root object</description>
          </parameter>
        </parameters>
        <return-description>An object or array with values</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.Wire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.DataWire" superclass="dojox.wire.Wire">
    <description>This class accesses item attributes of data stores with a dotted
	notation of attribute names specified to 'attribute' property,
	using data APIs of a data store specified to 'dataStore' property.
	The root object for this class must be an item of the data store.
	Intermediate attribute names in the dotted notation specify
	attributes for child items, which are used for repeated calls to
	data APIs until reached to a descendant attribute.
	Attribute names may have an array index, such as "a[0]", to
	identify an array element of the attribute value.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If 'dataStore' property is not specified, but 'parent' property
	is specified, 'dataStore' property is copied from the parent.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <description>This method uses a root item passed in 'object' argument and
	'attribute' property to identify an item.
	Then, setValue() method of 'dataStore' is called with a leaf
	attribute name and 'value' argument.
	If an attribute name have an array suffix ("[]"), setValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is set to 'value', instead of the array itself.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>A root item</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
        <return-description>'object', or 'undefined' for invalid attribute</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_setAttributeValue" scope="instance">
        <description>This method uses an item passed in 'item' argument and
	'attribute' argument to call setValue() method of 'dataStore'
	with 'value' argument.
	If an attribute name have an array suffix ("[]"), setValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is set to 'value', instead of the array itself.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>An item</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>An attribute name</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method uses a root item passed in 'object' argument and
	'attribute' property to call getValue() method of
	'dataStore'.
	If an attribute name have an array suffix ("[]"), getValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is returned, instead of the array itself.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>A root item</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_getAttributeValue" scope="instance">
        <description>This method uses an item passed in 'item' argument and
	'attribute' argument to call getValue() method of 'dataStore'.
	If an attribute name have an array suffix ("[]"), getValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is returned, instead of the array itself.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>An item
	attribute
	An attribute name</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.Wire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.TableAdapter" superclass="dojox.wire.CompositeWire">
    <description>This class has multiple child Wires for object properties or array
	elements of a table row.
	The root object for this class must be an array.
	When an object with Wires is specified to 'columns' property, they
	are used to get a row object with property values.
	When an array of Wires is specified to 'columns' property, they
	are used to get a row array with element values.
	The row values are returned in an array.
	This class only supports getValue(), but not setValue().</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If object properties or array elements specified in 'columns'
	property are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	columns:
	An object or array containing child Wires for column values</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method iterates over an array specified to 'object'
	argument and calls getValue() method of the child Wires with
	each element of the array to get a row object or array.
	Finally, an array with the row objects or arrays are retuned.</description>
        <parameters>
          <parameter name="object" type="Array" usage="required">
            <description>A root array</description>
          </parameter>
        </parameters>
        <return-description>An array of table row value</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_getRow" scope="instance">
        <description>This method calls getValue() method of the child Wires to
	create a row object or array.</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required"/>
        </parameters>
        <return-description>An array or object for a table row</return-description>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.CompositeWire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.TextAdapter" superclass="dojox.wire.CompositeWire">
    <description>This class has multiple child Wires for text segment values.
	Wires in 'segments' property are used to get text segments and
	values are concatenated with an optional delimiter string specified
	to 'delimiter' property.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If array elements specified in 'segments' are not Wires, Wires
	are created from them as arguments, with 'parent' property set
	to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	segments:
	An array containing child Wires for text segment values</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Object|Array" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method calls getValue() method of the child Wires wuth
	'object' argument and concatenate the values with 'delimiter'
	property to return.
	arg:
	A root object</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required"/>
        </parameters>
        <return-description>A concatinated text</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_addSegment" scope="instance">
        <description>This method add a text segment specified to 'segment' argument
	to a base text specified to 'text', with 'delimiter' property.</description>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>A base text</description>
          </parameter>
          <parameter name="segment" type="String" usage="required">
            <description>A text segment to add</description>
          </parameter>
        </parameters>
        <return-description>A concatinated text</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.CompositeWire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.TreeAdapter" superclass="dojox.wire.CompositeWire">
    <description>This class has multiple child Wires for tree nodes, their title and
	child nodes.
	The root object for this class must be an array.
	'node' Wires in 'nodes' property is used to identify an object
	representing a node.
	'title' Wires in 'nodes' property is used to get the title string
	of a node.
	'children' Wires in 'nodes' property is used to iterate over child
	node objects.
	The node values are returned in an array as follows:
	[
	{title: title1,
	children: [
	{title: title2,
	child: ...},
	{title: title3,
	child: ...},
	...
	]},
	...
	]
	This class only supports getValue(), but not setValue().</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If object properties ('node', 'title' and 'children') of array
	elements specified in 'nodes' property are not Wires, Wires are
	created from them as arguments, with 'parent' property set to
	this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	nodes:
	An array containing objects for child Wires for node values</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_initializeChildren" scope="instance">
        <description>If 'node' or 'title' properties of array elements specified in
	'children' argument are not Wires, Wires are created from them
	as arguments, with 'parent' property set to this Wire instance.
	If an array element has 'children' property, this method is
	called recursively with it.</description>
        <parameters>
          <parameter name="children" type="Array" usage="required">
            <description>An array of objects containing child Wires</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method iterates over an array specified to 'object'
	argument and calls getValue() method of 'node' Wires with each
	element of the array to get object(s) that represetns nodes.
	(If 'node' Wires are omitted, the array element is used for
	further processing.)
	Then, getValue() method of 'title' Wires are called to get
	title strings for nodes.
	(If 'title' Wires are omitted, the objects representing nodes
	are used as title strings.)
	And if an array of objects with 'node' and 'title' Wires is
	specified to 'children', it is used to gather child nodes and
	their title strings in the same way recursively.
	Finally, an array of the top-level node objects are retuned.</description>
        <parameters>
          <parameter name="object" type="Array" usage="required">
            <description>A root array</description>
          </parameter>
        </parameters>
        <return-description>An array of tree node values</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_getNodes" scope="instance">
        <description>This method calls getValue() method of 'node' Wires with
	'object' argument to get object(s) that represents nodes.
	(If 'node' Wires are omitted, 'object' is used for further
	processing.)
	Then, getValue() method of 'title' Wires are called to get
	title strings for nodes.
	(If 'title' Wires are omitted, the objects representing nodes
	are used as title strings.)
	And if an array of objects with 'node' and 'title' Wires is
	specified to 'children', it is used to gather child nodes and
	their title strings in the same way recursively.
	Finally, an array of node objects are returned.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>An object</description>
          </parameter>
          <parameter name="child" type="Object" usage="required">
            <description>An object with child Wires</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.CompositeWire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.Wire">
    <description>This class accesses a property of an object with a dotted notation
	specified to 'property' property, such as "a.b.c", which identifies
	a descendant property, "object.a.b.c".
	Property names in the dotted notation may have an array index, such
	as "a[0]", to identify an array element, literally, "object.a[0]".
	When a notation start with an array index, such as "[0].a", it
	specifies an array element of the root object (array),
	"object[0].a".
	This class also serves as a base class for other Wire classes,
	preparing a root object and converting a return value, so that
	sub-classes just can implement _getValue() and _setValue() called
	from getValue() and setValue() implemented by this calss.</description>
    <methods>
      <method name="setValue" scope="instance">
        <description>This method first determins a root object as follows:
	1. If 'object' property specified,
	1.1 If 'object' is a Wire, its getValue() method is called to
	obtain a root object.
	1.2 Otherwise, use 'object' as a root object.
	2. Otherwise, use 'defaultObject' argument.
	3. If 'property' is specified, it is used to get a property
	value.
	Then, if a sub-class implements _setValue() method, it is
	called with the root object and 'value' argument to set
	the value.
	Otherwise, 'value' is set to a property specified with
	'property' property.
	If the root object is undefined and 'object' property is a Wire
	and a new object is created and returned by _setValue() it is
	set through 'object' (setValue() method).</description>
        <parameters>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
          <parameter name="defaultObject" type="Object|Array" usage="required">
            <description>A default root object</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <description>This method first determins a root object as follows:
	1. If 'object' property specified,
	1.1 If 'object' is a Wire, its getValue() method is called to
	obtain a root object.
	1.2 Otherwise, use 'object' as a root object.
	2. Otherwise, use 'defaultObject' argument.
	3. If 'property' is specified, it is used to get a property
	value.
	Then, if a sub-class implements _getValue() method, it is
	called with the root object to get the return value.
	Otherwise, the root object (typically, a property valye) is
	used for the return value.
	Finally, if 'type' property is specified, the return value is
	converted to the specified primitive type ("string", "number",
	"boolean" and "array").
	If 'converter' property is specified, its convert() method is
	called to convert the value.</description>
        <parameters>
          <parameter name="defaultObject" type="Object|Array" usage="required">
            <description>A default root object</description>
          </parameter>
        </parameters>
        <return-description>A value found</return-description>
        <return-types>
          <return-type type="anything (null, undefined, etc)"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <description>If 'converter' property is specified and is a string for
	a converter class, an instanceof the converter class is
	created.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	object:
	A root object (or another Wire to access a root object)
	property:
	A dotted notation to a descendant property
	type:
	A type of the return value (for the source Wire)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_useSet" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required">
            <description>target object to set the property of.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_useGet" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required">
            <description>target object to set the property of.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_useAttr" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required">
            <description>target object to set the property of.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setPropertyValue" scope="instance">
        <description>'value' is set to 'property' of 'object'.
	If 'property' ends with an array index, it is used to indentify
	an element of an array property to set the value.
	If 'object' implements setPropertyValue(), it is called with
	'property' and 'value' to set the property value.
	If 'object' implements a setter for the property, it is called
	with 'value' to set the property value.</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required">
            <description>An object</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getPropertyValue" scope="instance">
        <description>A value for 'property' of 'object' is returned.
	If 'property' ends with an array index, it is used to indentify
	an element of an array property.
	If 'object' implements getPropertyValue(), it is called with
	'property' to obtain the property value.
	If 'object' implements a getter for the property, it is called
	to obtain the property value.</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required">
            <description>A default root object</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.wire.XmlWire" superclass="dojox.wire.Wire">
    <description>This class accesses XML nodes or value with a simplified XPath
	specified to 'path' property.
	The root object for this class must be an DOM document or element
	node.
	"@name" accesses to an attribute value of an element and "text()"
	accesses to a text value of an element.
	The hierarchy of the elements from the root node can be specified
	with slash-separated list, such as "a/b/@c", which specifies
	the value of an attribute named "c" of an element named "b" as
	a child of another element named "a" of a child of the root node.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>'args' is just mixed in with no further processing.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	path:
	A simplified XPath to an attribute, a text or elements</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <description>This method first uses a root node passed in 'object' argument
	and 'path' property to identify an attribute, a text or
	elements.
	If an intermediate element does not exist, it creates
	an element of the tag name in the 'path' segment as a child
	node of the current node.
	Finally, 'value' argument is set to an attribute or a text
	(a child node) of the leaf element.</description>
        <parameters>
          <parameter name="object" type="Node" usage="required">
            <description>A root node</description>
          </parameter>
          <parameter name="value" type="String" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_setNodeValue" scope="instance">
        <description>If 'exp' starts with '@', 'value' is set to the specified
	attribute.
	If 'exp' is "text()", 'value' is set to a child text.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="exp" type="String" usage="required">
            <description>An expression for attribute or text</description>
          </parameter>
          <parameter name="value" type="String" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method first uses a root node passed in 'object' argument
	and 'path' property to identify an attribute, a text or
	elements.
	If 'path' starts with a slash (absolute), the first path
	segment is ignored assuming it point to the root node.
	(That is, "/a/b/@c" and "b/@c" against a root node access
	the same attribute value, assuming the root node is an element
	with a tag name, "a".)</description>
        <parameters>
          <parameter name="object" type="Node" usage="required">
            <description>A root node</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="Node"/>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_getNodeValue" scope="instance">
        <description>If 'exp' starts with '@', an attribute value of the specified
	attribute is returned.
	If 'exp' is "text()", a child text value is returned.
	Otherwise, an array of child elements, the tag name of which
	match 'exp', is returned.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="exp" type="String" usage="required">
            <description>An expression for attribute, text or elements</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_getDocument" scope="instance">
        <description>If 'node' is specified, a DOM document of the node is returned.
	Otherwise, a DOM document is created.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-description>A DOM document</return-description>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
      <method name="_getChildNode" scope="instance">
        <description>A child element of the tag name specified with 'name' is
	returned.
	If 'name' ends with an array index, it is used to pick up
	the corresponding element from multiple child elements.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A parent node</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>A tag name</description>
          </parameter>
        </parameters>
        <return-description>A child node</return-description>
        <return-types>
          <return-type type="Node"/>
          <return-type type="null"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.Wire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire._wireClasses"/>
  <class type="dojox.wire.ml">
    <methods>
      <method name="_setValue" scope="instance">
        <description>This method stores a value by an ID of a widget or an DOM
	element with a dotted notation to its property, using a Wire.</description>
        <parameters>
          <parameter name="target" type="String" usage="required">
            <description>A string to specify an object and its property</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method obtains an object by an ID of a widget or an DOM
	element.
	If 'source' specifies a dotted notation to its property, a Wire is
	used to get the object property.
	If 'source' starts with "arguments", 'args' is used as a root
	object for the Wire.</description>
        <parameters>
          <parameter name="source" type="String" usage="required">
            <description>A string to specify an object and its property</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>An optional arguments array</description>
          </parameter>
        </parameters>
        <return-description>A value</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="XmlHandler" scope="instance">
        <description>This class provides XML handling for a REST service.</description>
      </method>
      <method name="XmlElement" scope="instance">
        <description>This class represents an XML element.</description>
        <parameters>
          <parameter name="element" type="Element|String" usage="required">
            <description>An XML element or a tag name</description>
          </parameter>
        </parameters>
      </method>
      <method name="Transfer" scope="instance">
        <description>This widget represents a controller task to transfer a value from
	a source to a target, through a source and a target Wires, when
	an event (a function) or a topic is issued.
	If this widget has child ChildWire widgets, their _addWire()
	methods are called to add Wire arguments to a source or a target
	Wire.</description>
      </method>
      <method name="Service" scope="instance">
        <description>This widget represents a service defined by a service description
	specified with 'url' attribute.
	If 'serviceType' and 'serviceUrl' attributes are specified, 'url'
	attribute can be omitted.</description>
      </method>
      <method name="SegmentWire" scope="instance">
        <description>Attributes of this widget are used to add a segment Wire to
	a TextAdapter of the parent Transfer widget.</description>
      </method>
      <method name="RestHandler" scope="instance">
        <description>This class serves as a base REST service.
	Sub-classes may override _getContent() and _getResult() to handle
	specific content types.</description>
      </method>
      <method name="NodeWire" scope="instance">
        <description>Attributes of this widget are used to add node Wires to
	a TreeAdapter of the parent Transfer widget.</description>
      </method>
      <method name="JsonHandler" scope="instance">
        <description>This class provides JSON handling for a REST service.</description>
      </method>
      <method name="Invocation" scope="instance">
        <description>This widget represents a controller task to invoke a method or
	publish a topic when an event (a function) or a topic is issued.</description>
      </method>
      <method name="DataStore" scope="instance">
        <description>This widget represents a data store of 'storeClass' attribute.</description>
      </method>
      <method name="DataProperty" scope="instance">
        <description>Attributes of this widget are used to add a property to the parent
	Data widget.
	'type' attribute specifies one of "string", "number", "boolean",
	"array", "object" and "element" (DOM Element)
	(default to "string").
	If 'type' is "array" or "object", child DataProperty widgets are
	used to initialize the array elements or the object properties.</description>
      </method>
      <method name="Data" scope="instance">
        <description>This widget represents an object with '_properties' property.
	If child 'DataProperty' widgets exist, they are used to initialize
	propertiy values of '_properties' object.</description>
      </method>
      <method name="ColumnWire" scope="instance">
        <description>Attributes of this widget are used to add a column Wire to
	a TableAdapter of the parent Transfer widget.</description>
      </method>
      <method name="ChildWire" scope="instance">
        <description>Attributes of this widget are used to add a child Wire to
	a composite Wire of the parent Transfer widget.</description>
      </method>
      <method name="ActionFilter" scope="instance">
        <description>This base class checks a required property specified with
	'required' attribute.
	If 'message' is specified, the message is set to a property
	specified with 'error'.
	Subclasses may implement their own filter() method.</description>
      </method>
      <method name="Action" scope="instance">
        <description>This widget represents a controller task to be run when an event
	(a function) or a topic is issued.
	Sub-classes must implement _run() method to implement their tasks.
	'trigger' specifies an event scope, an ID of a widget or an DOM
	element, or its property with the optional dotted notation.
	If this widget has child ActionFilter widgets, their filter()
	methods are called with the arguments to the event or the topic.
	If one of filter() methods returns false, run() won't be invoked.
	This widget also can serve as a composite task to run child
	Actions on an event or a topic specified to this widget.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.wire.ml.Action" superclass="dijit._Widget">
    <description>This widget represents a controller task to be run when an event
	(a function) or a topic is issued.
	Sub-classes must implement _run() method to implement their tasks.
	'trigger' specifies an event scope, an ID of a widget or an DOM
	element, or its property with the optional dotted notation.
	If this widget has child ActionFilter widgets, their filter()
	methods are called with the arguments to the event or the topic.
	If one of filter() methods returns false, run() won't be invoked.
	This widget also can serve as a composite task to run child
	Actions on an event or a topic specified to this widget.</description>
    <methods>
      <method name="uninitialize" scope="instance"/>
      <method name="run" scope="instance">
        <description>This method calls filter() method of child ActionFilter
	widgets.
	If one of them returns false, this method returns.
	Otherwise, _run() method is called.</description>
      </method>
      <method name="postCreate" scope="instance">
        <description>See _connect().</description>
      </method>
      <method name="_run" scope="instance">
        <description>If this widget has child Action widgets, their run() methods
	are called.</description>
      </method>
      <method name="_disconnect" scope="instance">
        <description>If 'triggerEvent' and 'trigger' are specified, disconnect() is
	used to set up run() not to be called on the event.
	If 'triggerTopic' is specified, unsubscribe() is used to set up
	run() not to be called on the topic.</description>
      </method>
      <method name="_connect" scope="instance">
        <description>If 'triggerEvent' and 'trigger' are specified, connect() is
	used to set up run() to be called on the event.
	If 'triggerTopic' is specified, subscribe() is used to set up
	run() to be called on the topic.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.ActionFilter" superclass="dijit._Widget">
    <description>This base class checks a required property specified with
	'required' attribute.
	If 'message' is specified, the message is set to a property
	specified with 'error'.
	Subclasses may implement their own filter() method.</description>
    <methods>
      <method name="filter" scope="instance">
        <description>If a value is undefined for a property, specified with
	'required', this method returns false.
	If the value for a property is defined, but there isn't a requiredValue for it
	then any non-false value will cause the method to return true.
	if requiredValue is set, then filter compares that value with the value from
	the required property and returns true if and only if they match.
	The type option just allows for a way to convert the required property values
	into a proper form for comparison (boolean, number, etc).
	If 'message' is specified, it is set to a proeprty specified
	with 'error' or shown with alert().
	If 'required' starts with "arguments", a property of
	the method arguments are checked.</description>
        <return-description>True if a required property is specified (and if requiredValue is specified,
	that they match), otherwise false</return-description>
        <return-types>
          <return-type type="Boolean"/>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.Data" superclass="dijit._Widget">
    <description>This widget represents an object with '_properties' property.
	If child 'DataProperty' widgets exist, they are used to initialize
	propertiy values of '_properties' object.</description>
    <methods>
      <method name="startup" scope="instance">
        <description>See _initializeProperties().</description>
      </method>
      <method name="setPropertyValue" scope="instance">
        <description>This method stores 'value' as a property, specified with
	'property' argument, in '_properties' object.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A property value</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPropertyValue" scope="instance">
        <description>This method returns the value of a property, specified with
	'property' argument, in '_properties' object.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
        </parameters>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_initializeProperties" scope="instance">
        <description>If this widget has child DataProperty widgets, their getValue()
	methods are called and set the return value to a property
	specified by 'name' attribute of the child widgets.</description>
        <parameters>
          <parameter name="reset" type="Boolean" usage="required">
            <description>A boolean to reset current properties</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.DataProperty" superclass="dijit._Widget">
    <description>Attributes of this widget are used to add a property to the parent
	Data widget.
	'type' attribute specifies one of "string", "number", "boolean",
	"array", "object" and "element" (DOM Element)
	(default to "string").
	If 'type' is "array" or "object", child DataProperty widgets are
	used to initialize the array elements or the object properties.</description>
    <methods>
      <method name="getValue" scope="instance">
        <description>If 'type' is specified, 'value' attribute is converted to
	the specified type and returned.
	Otherwise, 'value' attribute is returned as is.</description>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_getValueAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.DataStore" superclass="dijit._Widget">
    <description>This widget represents a data store of 'storeClass' attribute.</description>
    <methods>
      <method name="save" scope="instance">
        <description>See dojo.data.api.Write.save().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A save arguments object</description>
          </parameter>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <description>See dojo.data.api.Write.revert().</description>
        <return-description>A boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="postCreate" scope="instance">
        <description>See _createStore().</description>
      </method>
      <method name="newItem" scope="instance">
        <description>See dojo.data.api.Write.newItem().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A new item arguments object</description>
          </parameter>
        </parameters>
        <return-description>A new item</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance">
        <description>See dojo.data.api.Read.getFeatures().</description>
        <return-description>A features object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="fetch" scope="instance">
        <description>See dojo.data.api.Read.fetch().</description>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>A request object</description>
          </parameter>
        </parameters>
        <return-description>A request object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <description>See dojo.data.api.Write.deleteItem().</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-description>A boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_createStore" scope="instance">
        <return-description>A data store</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.DataStore.domNode"/>
  <class type="dojox.wire.ml.Invocation" superclass="dojox.wire.ml.Action">
    <description>This widget represents a controller task to invoke a method or
	publish a topic when an event (a function) or a topic is issued.</description>
    <methods>
      <method name="onError" scope="instance">
        <description>If 'error' attribute is specified, the error object also set to
	the specified property.</description>
        <parameters>
          <parameter name="error" type="anything" usage="required">
            <description>The exception or error occurred</description>
          </parameter>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <description>If 'result' attribute is specified, the result object also set
	to the specified property.</description>
        <parameters>
          <parameter name="result" type="anything" usage="required">
            <description>The return value of a method or undefined for a topic</description>
          </parameter>
        </parameters>
      </method>
      <method name="_run" scope="instance">
        <description>If 'topic' is specified, the topic is published with arguments
	specified to 'parameters'.
	If 'method' and 'object' are specified, the method is invoked
	with arguments specified to 'parameters' and set the return
	value to a property specified to 'result'.
	'object', 'parameters' and 'result' can specify properties of
	a widget or an DOM element with the dotted notation.
	If 'parameters' are omitted, the arguments to this method are
	passed as is.</description>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getParameters" scope="instance">
        <description>This method retunrs an array of arguments specified by
	'parameters' attribute, a comma-separated list of IDs and
	their properties in a dotted notation.
	If 'parameters' are omitted, the original arguments are
	used.</description>
        <parameters>
          <parameter name="args" type="Array" usage="required">
            <description>Arguments to a trigger event or topic</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.Action" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.JsonHandler" superclass="dojox.wire.ml.RestHandler">
    <description>This class provides JSON handling for a REST service.</description>
    <methods>
      <method name="_getContent" scope="instance">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameter' is used to generate a JSON content.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
        </parameters>
        <return-description>A request content</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.RestHandler" scope="instance"/>
    </mixins>
    <properties>
      <property name="headers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.JsonHandler.headers"/>
  <class type="dojox.wire.ml.RestHandler">
    <description>This class serves as a base REST service.
	Sub-classes may override _getContent() and _getResult() to handle
	specific content types.</description>
    <methods>
      <method name="bind" scope="instance">
        <description>A service is called with a URL generated by _getUrl() and
	an HTTP method specified with 'method'.
	For "POST" and "PUT", a content is generated by _getContent().
	When data is loaded, _getResult() is used to pass the result to
	Deferred.callback().</description>
        <parameters>
          <parameter name="method" type="A" usage="required">
            <description>method name</description>
          </parameter>
          <parameter name="parameters" type="An" usage="required">
            <description>array of parameters</description>
          </parameter>
          <parameter name="deferred" type="'Deferred'" usage="required"/>
          <parameter name="url" type="A" usage="required">
            <description>URL for the method</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getUrl" scope="instance">
        <description>If 'method' is "GET" or "DELETE", a query string is generated
	from a query object specified to the first parameter in
	'parameters' and appended to 'url'.
	If 'url' contains variable seguments ("{parameter_name}"),
	they are replaced with corresponding parameter values, instead.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>A base URL</description>
          </parameter>
        </parameters>
        <return-description>A URL</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getResult" scope="instance">
        <description>A response data is returned as is.</description>
        <parameters>
          <parameter name="data" type="anything" usage="required">
            <description>A response data returned by a service</description>
          </parameter>
        </parameters>
        <return-description>A result object</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_getContent" scope="instance">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameters' is returned.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
        </parameters>
        <return-description>A request content</return-description>
        <return-types>
          <return-type type="anything"/>
          <return-type type="null"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.wire.ml.Service" superclass="dijit._Widget">
    <description>This widget represents a service defined by a service description
	specified with 'url' attribute.
	If 'serviceType' and 'serviceUrl' attributes are specified, 'url'
	attribute can be omitted.</description>
    <methods>
      <method name="postCreate" scope="instance">
        <description>See _createHandler().</description>
      </method>
      <method name="callMethod" scope="instance">
        <parameters>
          <parameter name="method" type="A" usage="required">
            <description>method name</description>
          </parameter>
          <parameter name="parameters" type="An" usage="required">
            <description>array parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createHandler" scope="instance">
        <return-description>A service handler</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="_handlerClasses" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Service._handlerClasses"/>
  <class type="dojox.wire.ml.Transfer" superclass="dojox.wire.ml.Action">
    <description>This widget represents a controller task to transfer a value from
	a source to a target, through a source and a target Wires, when
	an event (a function) or a topic is issued.
	If this widget has child ChildWire widgets, their _addWire()
	methods are called to add Wire arguments to a source or a target
	Wire.</description>
    <methods>
      <method name="_run" scope="instance">
        <description>First, Wires for a source and a target are created from attributes.
	Then, a value is obtained by getValue() of the source Wire is set
	by setValue() of the target Wire.
	The arguments to this method is passed to getValue() and setValue()
	of Wires, so that they can be used to identify the root objects off
	the arguments.</description>
      </method>
      <method name="_getWire" scope="instance">
        <description>Arguments object for a source or a target Wire, specified by
	'which' argument, are build from corresponding attributes,
	including '*Store' (for 'dataStore'), '*Attribute'
	(for 'attribute), '*Path' (for 'path'), 'type' and 'converter'.
	'source' or 'target' attribute is parsed as:
	"object_id.property_name[.sub_property_name...]"
	If 'source' or 'target' starts with "arguments", 'object'
	argument for a Wire is set to null, so that the root object is
	given as an event or topic arguments.
	If this widget has child ChildWire widgets with a corresponding
	'which' attribute, their _addWire() methods are called to add
	additional Wire arguments and nested Wire is created,
	specifying the Wire defined by this widget to 'object' argument.</description>
        <parameters>
          <parameter name="which" type="String" usage="required">
            <description>Which Wire arguments to build, &amp;quot;source&amp;quot; or &amp;quot;target&amp;quot;</description>
          </parameter>
        </parameters>
        <return-description>Wire arguments object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.Action" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.ChildWire" superclass="dijit._Widget">
    <description>Attributes of this widget are used to add a child Wire to
	a composite Wire of the parent Transfer widget.</description>
    <methods>
      <method name="_getWire" scope="instance">
        <description>Arguments object for a child Wire are build from attributes,
	including 'object', 'property', 'type', 'converter',
	'attribute' and 'path'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
        </parameters>
        <return-description>Wire arguments object</return-description>
      </method>
      <method name="_addWire" scope="instance">
        <description>If 'name' attribute is specified, a child Wire is added as
	the named property of 'children' object of 'args'.
	Otherwise, a child Wire is added to 'children' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.ColumnWire" superclass="dojox.wire.ml.ChildWire">
    <description>Attributes of this widget are used to add a column Wire to
	a TableAdapter of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>If 'column' attribute is specified, a column Wire is added as
	the named property of 'columns' object of 'args'.
	Otherwise, a column Wire is added to 'columns' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.ChildWire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.NodeWire" superclass="dojox.wire.ml.ChildWire">
    <description>Attributes of this widget are used to add node Wires to
	a TreeAdapter of the parent Transfer widget.</description>
    <methods>
      <method name="_getWires" scope="instance">
        <description>Arguments object for 'node' Wire are build from attributes,
	including 'object', 'property', 'type', 'converter',
	'attribute' and 'path'.
	Arguments object for 'title' Wire are build from another set of
	attributes, 'titleProperty', 'titleAttribute' and 'titlePath'.
	If this widget has child NodeWire widgets, their _getWires()
	methods are called recursively to build 'children' array of
	'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
        </parameters>
        <return-description>Wire arguments object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_addWire" scope="instance">
        <description>Node Wires are added to 'nodes' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.ChildWire" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.SegmentWire" superclass="dojox.wire.ml.ChildWire">
    <description>Attributes of this widget are used to add a segment Wire to
	a TextAdapter of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>A segment Wire is added to 'segments' array of 'args'.
	If 'parent' has 'delimiter' attribute, it is used for
	'delimiter' property of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.ChildWire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.XmlHandler" superclass="dojox.wire.ml.RestHandler">
    <description>This class provides XML handling for a REST service.</description>
    <methods>
      <method name="_getResult" scope="instance">
        <description>A response data (XML Document) is returned wrapped with
	XmlElement.</description>
        <parameters>
          <parameter name="data" type="Document" usage="required">
            <description>A response data returned by a service</description>
          </parameter>
        </parameters>
        <return-description>A result object</return-description>
      </method>
      <method name="_getContent" scope="instance">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameters' is used to generate an XML content.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
        </parameters>
        <return-description>A request content</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.RestHandler" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.XmlElement">
    <description>This class represents an XML element.</description>
    <methods>
      <method name="toString" scope="instance">
        <description>A value of the first text child of the element is returned.</description>
        <return-description>A value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toObject" scope="instance">
        <description>An object with properties for child elements, attributes and
	text is returned.</description>
        <return-description>An object representation of the element</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setPropertyValue" scope="instance">
        <description>If 'property' starts with '@', 'value' is set to the attribute.
	If 'property' specifies "text()", 'value' is set as the first
	child text.
	If 'value' is a string, a child element of the tag name
	specified with 'property' is created and 'value' is set as
	the first child text of the child element.
	Otherwise, 'value' is set to as child elements.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
          <parameter name="value" type="String|Array|XmlElement" usage="required">
            <description>A property value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getPropertyValue" scope="instance">
        <description>If 'property' starts with '@', the attribute value is returned.
	If 'property' specifies "text()", the value of the first child
	text is returned.
	Otherwise, child elements of the tag name specified with
	'property' are returned.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
        </parameters>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
          <return-type type="XmlElement"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="element" type="Element|String" usage="required">
            <description>An XML element or a tag name</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getDocument" scope="instance">
        <description>If 'element' is specified, a DOM document of the element is
	returned.
	Otherwise, a DOM document is created.</description>
        <return-description>A DOM document</return-description>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="element" scope="instance" type="An">
        <description>XML element or a tag name</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.XmlElement.element">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
      <property name="attributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.XmlElement.element.firstChild"/>
  <class type="dojox.wire.ml.XmlElement.element.attributes"/>
  <class type="dojox.xml">
    <methods>
      <method name="Script" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="parser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xml.Script">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xml.parser">
    <methods>
      <method name="textContent" scope="instance">
        <description>Implementation of the DOM Level 3 attribute; scan node for text
	This function can also update the text of a node by replacing all child
	content of the node.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node to get the text off of or set the text on.</description>
          </parameter>
          <parameter name="text" type="String" usage="optional">
            <description>Optional argument of the text to apply to the node.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="replaceChildren" scope="instance">
        <description>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</description>
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <description>The node to modify the children on</description>
          </parameter>
          <parameter name="newChildren" type="Node" usage="required">
            <description>The children to add to the node.  It can either be a single Node or an
	array of Nodes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeChildren" scope="instance">
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <description>The node to remove all the children from.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="optional">
            <description>Optional text to create the document from.  If not provided, an empty XML document will be created.
	If str is empty string &amp;quot;&amp;quot;, then a new empty document will be created.</description>
          </parameter>
          <parameter name="mimetype" type="String" usage="optional">
            <description>Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="innerXML" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node from which to generate the XML text representation.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="xXml"/>
  <class type="dojox.xmpp">
    <methods>
      <method name="xmppSession" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="UserService" scope="instance">
        <parameters>
          <parameter name="xmppService" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="TransportSession" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="RosterService" scope="instance">
        <parameters>
          <parameter name="xmppSession" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="PresenceService" scope="instance">
        <parameters>
          <parameter name="xmppService" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ChatService" scope="instance"/>
    </methods>
    <properties>
      <property name="xmpp" scope="instance" type="Object"/>
      <property name="widget" scope="instance" type="Object"/>
      <property name="util" scope="instance" type="Object"/>
      <property name="sasl" scope="instance" type="Object"/>
      <property name="roster" scope="instance" type="Object"/>
      <property name="presence" scope="instance" type="Object"/>
      <property name="chat" scope="instance" type="Object"/>
      <property name="bosh" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.ChatService">
    <methods>
      <method name="setState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSession" scope="instance">
        <parameters>
          <parameter name="session" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendChatState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="recieveMessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="initial" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onNewMessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onInvite" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invite" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.xmpp.chat"/>
  <class type="dojox.xmpp.PresenceService">
    <methods>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleContactInvisiblity" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleBlockContact" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendAvatarHash" scope="instance">
        <parameters>
          <parameter name="avatarHash" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="publish" scope="instance">
        <parameters>
          <parameter name="presence" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="declineSubscription" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="xmppService" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelSubscription" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="approveSubscription" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateRestricted" scope="instance"/>
      <method name="_setVisible" scope="instance"/>
      <method name="_setPresence" scope="instance"/>
      <method name="_setInvisible" scope="instance"/>
      <method name="_manageSubscriptions" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRestrictedJid" scope="instance"/>
    </methods>
    <properties>
      <property name="presence" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.PresenceService.presence"/>
  <class type="dojox.xmpp.presence"/>
  <class type="dojox.xmpp.RosterService">
    <methods>
      <method name="verifyRoster" scope="instance">
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="groups" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rosterItemRenameGroup" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="oldGroup" type="Object" usage="required"/>
          <parameter name="newGroup" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="newName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterGroup" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
          <parameter name="newGroup" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItemFromGroup" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterGroup" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="publishAvatar" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="binval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRosterFailed" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRoster" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAvatar" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="xmppSession" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRosterItemToGroup" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="groups" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="session" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.RosterService.session"/>
  <class type="dojox.xmpp.roster"/>
  <class type="dojox.xmpp.TransportSession">
    <methods>
      <method name="setState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendXml" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeFromOutboundQueue" scope="instance">
        <parameters>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="redispatchPacket" scope="instance">
        <parameters>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processScriptSrc" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processResponse" scope="instance">
        <parameters>
          <parameter name="body" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processProtocolResponse" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processProtocolPacketQueue" scope="instance"/>
      <method name="processInboundQueue" scope="instance"/>
      <method name="processError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="httpStatusCode" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processDocument" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance"/>
      <method name="onTerminate" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onProcessProtocolResponse" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isTerminated" scope="instance"/>
      <method name="dispatchPacket" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="protocolMatchType" type="Object" usage="required"/>
          <parameter name="matchId" type="Object" usage="required"/>
          <parameter name="matchProperty" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="protocolMsg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToOutboundQueue" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToInboundQueue" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sendRestart" scope="instance"/>
      <method name="_sendLogin" scope="instance"/>
      <method name="_keepAlive" scope="instance"/>
      <method name="_dispatchPacket" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.xmpp.TransportSession.open">
    <methods/>
  </class>
  <class type="dojox.xmpp.TransportSession._keepAlive">
    <methods/>
  </class>
  <class type="dojox.xmpp.TransportSession.dispatchPacket">
    <methods/>
  </class>
  <class type="dojox.xmpp.TransportSession._dispatchPacket">
    <methods/>
  </class>
  <class type="dojox.xmpp.TransportSession.processProtocolPacketQueue">
    <methods/>
  </class>
  <class type="dojox.xmpp.TransportSession.sendXml">
    <methods/>
  </class>
  <class type="dojox.xmpp.TransportSession.processDocument">
    <methods/>
  </class>
  <class type="dojox.xmpp.TransportSession.processDocument.outboundQueue.0"/>
  <class type="dojox.xmpp.TransportSession.processResponse">
    <methods/>
  </class>
  <class type="dojox.xmpp.TransportSession.setState">
    <methods/>
  </class>
  <class type="dojox.xmpp.TransportSession.processError">
    <methods/>
  </class>
  <class type="dojox.xmpp.UserService">
    <methods>
      <method name="setPersonalProfile" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfileFailure" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfileFailure" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="profile" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPersonalProfile" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="xmppService" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="response" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onGetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="profile" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.bosh">
    <methods>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.xmpp.bosh.__initArgs" usage="required"/>
        </parameters>
      </method>
      <method name="handle" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.xmpp.bosh.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="findOpenIframe" scope="instance"/>
      <method name="_validCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_resHandle" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_makeScriptDeferred" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_ioCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeOnload" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredOk" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredCancel" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_addDeadScript" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__ioArgs" scope="instance"/>
      <method name="__initArgs" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.xmpp.bosh.__initArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.xmpp.bosh.__ioArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.xmpp.bosh.initialize">
    <methods/>
  </class>
  <class type="dojox.xmpp.sasl">
    <methods>
      <method name="_Base" scope="instance">
        <parameters>
          <parameter name="session" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="SunWebClientAuth" scope="instance"/>
      <method name="Plain" scope="instance"/>
      <method name="DigestMD5" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.xmpp.sasl._Base">
    <methods>
      <method name="startAuth" scope="instance"/>
      <method name="onSuccess" scope="instance"/>
      <method name="onSecondChallenge" scope="instance"/>
      <method name="onFirstChallenge" scope="instance"/>
      <method name="onChallenge" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="session" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="appendToAuth" scope="instance">
        <parameters>
          <parameter name="auth" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.sasl.SunWebClientAuth" superclass="dojox.xmpp.sasl._Base">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.xmpp.sasl._Base" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.xmpp.sasl.Plain" superclass="dojox.xmpp.sasl._Base">
    <methods>
      <method name="appendToAuth" scope="instance">
        <parameters>
          <parameter name="auth" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.xmpp.sasl._Base" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.xmpp.sasl.DigestMD5" superclass="dojox.xmpp.sasl._Base">
    <methods>
      <method name="onSecondChallenge" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstChallenge" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.xmpp.sasl._Base" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.xmpp.util">
    <methods>
      <method name="xmlEncode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stripHtml" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="htmlToPlain" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encodeJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeHtmlEntities" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createElement" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
          <parameter name="attributes" type="Object" usage="required"/>
          <parameter name="terminal" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="Base64" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.util.Base64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.widget">
    <methods>
      <method name="ChatSession" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.xmpp.widget.ChatSession" superclass="dijit.layout.LayoutContainer">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goToLastMessage" scope="instance"/>
      <method name="displayMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.LayoutContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="chatInput" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.widget.ChatSession.messages.domNode"/>
  <class type="dojox.xmpp.widget.ChatSession.chatInput"/>
  <class type="dojox.xmpp.xmppSession">
    <methods>
      <method name="simpleMessageHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendStanzaError" scope="instance">
        <parameters>
          <parameter name="stanzaType" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="errorType" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRestart" scope="instance"/>
      <method name="sendIqResult" scope="instance">
        <parameters>
          <parameter name="iqId" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="search" scope="instance">
        <parameters>
          <parameter name="searchString" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="searchAttribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saslHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rosterSetHandler" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="retrieveRoster" scope="instance"/>
      <method name="registerChatInstance" scope="instance">
        <parameters>
          <parameter name="chatInstance" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processXmppError" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processProtocolResponse" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="presenceUpdate" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="presenceSubscriptionRequest" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="presenceHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="user" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="resource" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTransportTerminate" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTransportReady" scope="instance"/>
      <method name="onTerminate" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSubscriptionRequest" scope="instance">
        <parameters>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSearchResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterUpdated" scope="instance"/>
      <method name="onRosterRemoved" scope="instance">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterChanged" scope="instance">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
          <parameter name="previousCopy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterAdded" scope="instance">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRetrieveRoster" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRegisterChatInstance" scope="instance">
        <parameters>
          <parameter name="chatInstance" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPresenceUpdate" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoginFailure" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLogin" scope="instance"/>
      <method name="onConnected" scope="instance"/>
      <method name="onBindSession" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBindResource" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="hasSession" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onActive" scope="instance"/>
      <method name="messageHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iqSetHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iqHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRosterIndex" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getResourceFromJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNextIqId" scope="instance"/>
      <method name="getBareJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="featuresHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchPacket" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="matchId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRosterEntry" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="chatHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bindResource" scope="instance">
        <parameters>
          <parameter name="hasSession" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSearchResults" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.xmppSession.open">
    <methods/>
  </class>
  <class type="dojox.xmpp.xmppSession.close">
    <methods/>
  </class>
  <class type="dojox.xmpp.xmppSession.featuresHandler">
    <methods/>
  </class>
  <class type="dojox.xmpp.xmppSession.chatHandler">
    <methods/>
  </class>
  <class type="dojox.xmpp.xmppSession.setState">
    <methods/>
  </class>
  <class type="dojox.xmpp.xmppSession.onBindResource">
    <methods/>
  </class>
  <class type="dojox.xmpp.xmppSession.onTransportReady">
    <methods/>
  </class>
  <class type="dojox.xmpp.xmpp">
    <properties>
      <property name="error" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmpp.error"/>
</javascript>
